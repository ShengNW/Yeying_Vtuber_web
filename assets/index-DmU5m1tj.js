function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a && a.defaultProps) for (d2 in g2 = a.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$2, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a, b2) {
  return { $$typeof: l$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$2;
}
function escape$1(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$2 = /\/+/g;
function Q$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape$1("" + a.key) : b2.toString(36);
}
function R$1(a, b2, e2, d2, c2) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2) a = null;
  var h2 = false;
  if (null === a) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a.$$typeof) {
        case l$2:
        case n$2:
          h2 = true;
      }
  }
  if (h2) return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$2, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
    return a2;
  })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a)) for (var g2 = 0; g2 < a.length; g2++) {
    k2 = a[g2];
    var f2 = d2 + Q$1(k2, g2);
    h2 += R$1(k2, b2, e2, f2, c2);
  }
  else if (f2 = A$2(a), "function" === typeof f2) for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2) throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b2, e2) {
  if (null == a) return a;
  var d2 = [], c2 = 0;
  R$1(a, d2, "", "", function(a2) {
    return b2.call(e2, a2, c2++);
  });
  return d2;
}
function T$1(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$2() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r$1;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$2;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a.type && a.type.defaultProps) var g2 = a.type.defaultProps;
    for (f2 in b2) J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$2, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$1, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$2, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = X$2;
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$1.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$1.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$1.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a) m$2.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
  if (c2 && c2.defaultProps) for (b2 in a = c2.defaultProps, a) void 0 === d2[b2] && (d2[b2] = a[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports2) {
  function f2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a: for (; 0 < c2; ) {
      var d2 = c2 - 1 >>> 1, e2 = a[d2];
      if (0 < g2(e2, b2)) a[d2] = b2, a[c2] = e2, c2 = d2;
      else break a;
    }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length) return null;
    var b2 = a[0], c2 = a.pop();
    if (c2 !== b2) {
      a[0] = c2;
      a: for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
        var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
        if (0 > g2(C2, c2)) n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
        else if (n2 < e2 && 0 > g2(x2, c2)) a[d2] = x2, a[n2] = c2, d2 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports2.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b2 = h2(t2);
      null !== b2 && K2(H2, b2.startTime - a);
    }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports2.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports2.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports2.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports2.unstable_now());
    }, b2);
  }
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports2.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports2.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c2;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = function() {
  };
  exports2.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports2.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports2.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports2.unstable_shouldYield = M2;
  exports2.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++) da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a)) return true;
  if (ja.call(la, a)) return false;
  if (ka.test(a)) return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2)) return true;
  if (d2) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$1(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new v$1(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$1[b2] = new v$1(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new v$1(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new v$1(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new v$1(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new v$1(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z$1[b2] = new v$1(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
}
var ua$1 = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$1 = Object.assign, La;
function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d2 = l2;
      }
      Reflect.construct(a, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d2 = l2;
      }
      a.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";
    case Ba:
      return (a._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a.render;
      a = a.displayName;
      a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga:
      return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
    case Ha:
      b2 = a._payload;
      a = a._init;
      try {
        return Qa(a(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a) return false;
  var b2 = a._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2) if ("number" === d2) {
    if (0 === c2 && "" === a.value || a.value != c2) a.value = "" + c2;
  } else a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
function cb(a, b2, c2) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a) null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++) e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$1(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = { initialValue: Sa(c2) };
}
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
    for (; b2.firstChild; ) a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
    "float" === c2 && (c2 = "cssFloat");
    d2 ? a.setProperty(c2, e2) : a[c2] = e2;
  }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$1(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$1(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-")) return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p$1(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2) for (a = 0; a < b2.length; a++) Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c2) {
  if (Ib) return a(b2, c2);
  Ib = true;
  try {
    return Gb(a, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c2 = a.stateNode;
  if (null === c2) return null;
  var d2 = Db(c2);
  if (null === d2) return null;
  c2 = d2[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d2;
      break a;
    default:
      a = false;
  }
  if (a) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$1(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = false;
}
function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c2 = a;
  if (a.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a) throw Error(p$1(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2) throw Error(p$1(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2) return Xb(e2), a;
        if (f2 === d2) return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return) c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2) throw Error(p$1(190));
  }
  if (3 !== c2.tag) throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2) return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c2 = a.pendingLanes;
  if (0 === c2) return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2) return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a.entangledLanes;
  if (0 !== b2) for (a = a.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
    } else k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a);
  return b2;
}
function Ac(a, b2, c2) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c2;
}
function Bc(a, b2) {
  var c2 = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a, b2) {
  var c2 = a.entangledLanes |= b2;
  for (a = a.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c2, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2) return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn) return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c2) {
      c2 = a.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c2) {
  Xc(a) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua$1.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a, b2, c2, d2);
    if (null === e2) hd(a, b2, d2, id, c2), Sc(a, d2);
    else if (Uc(e2, a, b2, c2, d2)) d2.stopPropagation();
    else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c2, d2);
        null === f2 && hd(a, b2, d2, id, c2);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else hd(a, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a, b2, c2, d2) {
  id = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a) if (b2 = Vb(a), null === b2) a = null;
  else if (c2 = b2.tag, 13 === c2) {
    a = Wb(b2);
    if (null !== a) return a;
    a = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a = null;
  } else b2 !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++) ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a) a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a) return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id$5 = A$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id$5), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b2) {
  if (ie) return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
}
function ne(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b2 = ue(a);
  if (Wa(b2)) return a;
}
function ve(a, b2) {
  if ("change" === a) return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    Jb(re, b2);
  }
}
function Ce(a, b2, c2) {
  "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b2) {
  if ("click" === a) return te(b2);
}
function Fe(a, b2) {
  if ("input" === a || "change" === a) return te(b2);
}
function Ge(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b2) {
  if (He(a, b2)) return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length) return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a[e2], b2[e2])) return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; ) a = a.firstChild;
  return a;
}
function Ke(a, b2) {
  var c2 = Je(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2) return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2) a = b2.contentWindow;
    else break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe(a) {
  var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; ) 1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b2 = We[a], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a] = b2[c2];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Ub(d2, b2, void 0, a);
  a.currentTarget = null;
}
function se(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
        var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d2.length; g2++) {
        h2 = d2[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
}
function qf(a, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
}
function hd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
    if (null === d2) return;
    var g2 = d2.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d2.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d2.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d2 = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d2 = d2.return;
  }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
        else if (me(h3)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c2) : ke(a, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a, b2, c2) {
  return { instance: a, listener: b2, currentTarget: c2 };
}
function oe(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function vf(a) {
  if (null === a) return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c2) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c2) throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d2) {
        a.removeChild(e2);
        bd(b2);
        return;
      }
      d2--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c2 = a.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2) return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a = Mf(a); null !== a; ) {
        if (c2 = a[Of]) return c2;
        a = Mf(a);
      }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p$1(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2) return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2) e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b2, c2) {
  if (H.current !== Vf) throw Error(p$1(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a, b2, c2) {
  var d2 = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext) return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2) if (!(e2 in b2)) throw Error(p$1(108, Ra(a) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2) throw Error(p$1(169));
  c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a < c2.length; a++) {
        var d2 = c2[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a;
  } else rg = 1 << f2 | c2 << e2 | d2, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a, b2)) {
        if (Dg(a)) throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p$1(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return false;
  if (!I) return Fg(a), I = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a)) throw Hg(), Error(p$1(418));
    for (; b2; ) Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p$1(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; ) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua$1.ReactCurrentBatchConfig;
function Lg(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2) throw Error(p$1(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a) throw Error(p$1(284));
    if (!c2._owner) throw Error(p$1(290, a));
  }
  return a;
}
function Mg(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function Ng(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function Og(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a) return null;
    for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = Pg(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a) return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya) return m2(a2, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = Lg(a2, b3, c3), d3.return = a2, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = Lg(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Lg(a2, null, b3), c3.return = a2, c3;
        case wa:
          return b3 = Sg(b3, a2.mode, c3), b3.return = a2, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a2, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a2.mode, c3, null), b3.return = a2, b3;
      Mg(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a2,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      Mg(a2, c3);
    }
    return null;
  }
  function y2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3)) return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3) throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c2(
      e3,
      m3
    ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c2(a2, l3);
                break;
              } else b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                c2(a2, d3.sibling);
                d3 = e2(d3, f3.children || []);
                d3.return = a2;
                a2 = d3;
                break a;
              } else {
                c2(a2, d3);
                break;
              }
              else b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3)) return n2(a2, d3, f3, h3);
      if (Ka(f3)) return t2(a2, d3, f3, h3);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = Qg(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a) {
  var b2 = Wg.current;
  E(Wg);
  a._currentValue = b2;
}
function bh(a, b2, c2) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a === c2) break;
    a = a.return;
  }
}
function ch(a, b2) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (dh = true), a.firstContext = null);
}
function eh(a) {
  var b2 = a._currentValue;
  if (Zg !== a) if (a = { context: a, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$1(308));
    Yg = a;
    Xg.dependencies = { lanes: 0, firstContext: a };
  } else Yg = Yg.next = a;
  return b2;
}
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
function hh(a, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a, d2);
}
function ih(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; null !== a; ) a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function mh(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a, b2, c2) {
  var d2 = a.updateQueue;
  if (null === d2) return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a, c2);
}
function oh(a, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
function ph(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function sh(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a) for (b2 = 0; b2 < a.length; b2++) {
    var d2 = a[b2], e2 = d2.callback;
    if (null !== e2) {
      d2.callback = null;
      d2 = c2;
      if ("function" !== typeof e2) throw Error(p$1(191, e2));
      e2.call(d2);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th) throw Error(p$1(174));
  return a;
}
function yh(a, b2) {
  G(wh, b2);
  G(vh, a);
  G(uh, th);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E(uh);
  G(uh, b2);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a.type);
  b2 !== c2 && (G(vh, a), G(uh, c2));
}
function Bh(a) {
  vh.current === a && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua$1.ReactCurrentDispatcher, Gh = ua$1.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P$1() {
  throw Error(p$1(321));
}
function Mh(a, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++) if (!He(a[c2], b2[c2])) return false;
  return true;
}
function Nh(a, b2, c2, d2, e2, f2) {
  Hh = f2;
  M = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$1(301));
      f2 += 1;
      O = N = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N && null !== N.next;
  Hh = 0;
  O = N = M = null;
  Ih = false;
  if (b2) throw Error(p$1(300));
  return a;
}
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a : O = O.next = a;
  return O;
}
function Uh() {
  if (null === N) {
    var a = M.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = N.next;
  var b2 = null === O ? M.memoizedState : O.next;
  if (null !== b2) O = b2, N = a;
  else {
    if (null === a) throw Error(p$1(310));
    N = a;
    a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
  }
  return O;
}
function Vh(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function Wh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = N, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a = c2.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a, b2) {
  var c2 = M, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a), [a]);
  if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q) throw Error(p$1(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a, b2, c2) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c2 };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
}
function ci(a, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a);
}
function ai(a, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a);
  });
}
function ei(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c2 = b2();
    return !He(a, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a) {
  var b2 = ih(a, 1);
  null !== b2 && gi(b2, a, 1, -1);
}
function hi(a) {
  var b2 = Th();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ii.bind(null, M, a);
  return [b2.memoizedState, a];
}
function bi(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a, b2, c2, d2) {
  var e2 = Th();
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N) {
    var g2 = N.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M.flags |= a;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function mi(a, b2) {
  return ki(8390656, 8, a, b2);
}
function $h(a, b2) {
  return li(2048, 8, a, b2);
}
function ni(a, b2) {
  return li(4, 2, a, b2);
}
function oi(a, b2) {
  return li(4, 4, a, b2);
}
function pi(a, b2) {
  if ("function" === typeof b2) return a = a(), b2(a), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a = a(), b2.current = a, function() {
    b2.current = null;
  };
}
function qi(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return li(4, 4, pi.bind(null, b2, a), c2);
}
function ri() {
}
function si(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
function ti(a, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
function ui(a, b2, c2) {
  if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M.lanes |= c2, rh |= c2, a.baseState = true);
  return b2;
}
function vi(a, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c2, Gh.transition = d2;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a, b2, c2) {
  var d2 = yi(a);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b2, c2);
  else if (c2 = hh(a, b2, c2, d2), null !== c2) {
    var e2 = R();
    gi(c2, a, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii(a, b2, c2) {
  var d2 = yi(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He(h2, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c2 = hh(a, b2, e2, d2);
    null !== c2 && (e2 = R(), gi(c2, a, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a) {
  var b2 = a.alternate;
  return a === M || null !== b2 && b2 === M;
}
function Ai(a, b2) {
  Jh = Ih = true;
  var c2 = a.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a.pending = b2;
}
function Bi(a, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
var Rh = { readContext: eh, useCallback: P$1, useContext: P$1, useEffect: P$1, useImperativeHandle: P$1, useInsertionEffect: P$1, useLayoutEffect: P$1, useMemo: P$1, useReducer: P$1, useRef: P$1, useState: P$1, useDebugValue: P$1, useDeferredValue: P$1, useTransition: P$1, useMutableSource: P$1, useSyncExternalStore: P$1, useId: P$1, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b2) {
  Th().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a),
    c2
  );
}, useLayoutEffect: function(a, b2) {
  return ki(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ki(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d2.queue = a;
  a = a.dispatch = xi.bind(null, M, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b2 = Th();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi(false), b2 = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c2) {
  var d2 = M, e2 = Th();
  if (I) {
    if (void 0 === c2) throw Error(p$1(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q) throw Error(p$1(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b2 = Uh();
    return ui(b2, N.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b2 = Uh();
  return null === N ? b2.memoizedState = a : ui(b2, N.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$1({}, b2);
    a = a.defaultProps;
    for (var c2 in a) void 0 === b2[c2] && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
function Di(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a.memoizedState = c2;
  0 === a.lanes && (a.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = R(), e2 = yi(a), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a, f2, e2);
  null !== b2 && (gi(b2, a, e2, d2), oh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = R(), d2 = yi(a), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a, e2, d2);
  null !== b2 && (gi(b2, a, d2, c2), oh(b2, a, d2));
} };
function Fi(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function Gi(a, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = {};
  kh(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a, c2, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function Ji(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Ki(a, b2, c2) {
  return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi = d2);
    Li(a, b2);
  };
  return c2;
}
function Qi(a, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si(a, b2, c2) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a = Ti.bind(null, a, b2, c2), b2.then(a, a));
}
function Ui(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag) b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Vi(a, b2, c2, d2, e2) {
  if (0 === (a.mode & 1)) return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Wi = ua$1.ReactCurrentOwner, dh = false;
function Xi(a, b2, c2, d2) {
  b2.child = null === a ? Vg(b2, null, c2, d2) : Ug(b2, a.child, c2, d2);
}
function Yi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a && !dh) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, d2, e2);
  return b2.child;
}
function $i(a, b2, c2, d2, e2) {
  if (null === a) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a, b2, f2, d2, e2);
    a = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a.ref === b2.ref) return Zi(a, b2, e2);
  }
  b2.flags |= 1;
  a = Pg(f2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function bj(a, b2, c2, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d2) && a.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2)) 0 !== (a.flags & 131072) && (dh = true);
    else return b2.lanes = a.lanes, Zi(a, b2, e2);
  }
  return cj(a, b2, c2, d2, e2);
}
function dj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d2 = null !== f2 ? f2.baseLanes : c2;
    G(ej, fj);
    fj |= d2;
  }
  else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a, b2, e2, c2);
  return b2.child;
}
function gj(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a && !dh) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, Zi(a, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a, b2, c2, e2);
  return b2.child;
}
function hj(a, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode) ij(a, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a, b2, c2, d2, f2, e2);
}
function jj(a, b2, c2, d2, e2, f2) {
  gj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2) return e2 && dg(b2, c2, false), Zi(a, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Ug(b2, a.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  yh(a, b2.containerInfo);
}
function lj(a, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function oj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState) e2 |= 1;
  G(L, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a = Tg(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a) : qj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function sj(a, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a.child, null, c2);
  a = qj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function rj(a, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$1(422))), sj(a, b2, g2, d2);
    if (null !== b2.memoizedState) return b2.child = a.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return sj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2) var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$1(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a, e2), gi(d2, a, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$1(421)));
    return sj(a, b2, g2, d2);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a.child, b2 = uj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a, b2, c2) {
  a.lanes |= b2;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a.return, b2, c2);
}
function wj(a, b2, c2, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a, b2, d2.children, c2);
  d2 = L.current;
  if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b2.child; null !== a; ) {
      if (13 === a.tag) null !== a.memoizedState && vj(a, c2, b2);
      else if (19 === a.tag) vj(a, c2, b2);
      else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b2) break a;
      for (; null === a.sibling; ) {
        if (null === a.return || a.return === b2) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d2 &= 1;
  }
  G(L, d2);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a = c2.alternate, null !== a && null === Ch(a) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      wj(b2, false, e2, c2, f2);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a = e2.alternate;
        if (null !== a && null === Ch(a)) {
          b2.child = e2;
          break;
        }
        a = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a;
      }
      wj(b2, true, c2, null, f2);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a, b2, c2) {
  null !== a && (b2.dependencies = a.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a && b2.child !== a.child) throw Error(p$1(153));
  if (null !== b2.child) {
    a = b2.child;
    c2 = Pg(a, a.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; ) a = a.sibling, c2 = c2.sibling = Pg(a, a.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated) return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return oj(a, b2, c2);
        G(L, L.current & 1);
        a = Zi(a, b2, c2);
        return null !== a ? a.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2) return xj(a, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L, L.current);
      if (d2) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a, b2, c2);
  }
  return Zi(a, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f2 || (f2 = []), f2.push(
        l2,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Cj = function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a, b2) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b2 = a.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a.tail;
      for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
      null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
  }
}
function S(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
  if (b2) for (var e2 = a.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else for (e2 = a.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c2;
  return b2;
}
function Ej(a, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child) Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b2);
      S(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a && null != b2.stateNode) Bj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode) throw Error(p$1(166));
          S(b2);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d2.textContent,
              h2,
              a
            ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
          }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[Of] = b2;
          a[Pf] = d2;
          zj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d2;
                break;
              case "details":
                D("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode) Cj(a, b2, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$1(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a = xg, null !== a) switch (a.tag) {
              case 3:
                Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                break;
              case 5:
                true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(L);
      d2 = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2) throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$1(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return zh(), Aj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return ah(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2) return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d2) Dj(f2, false);
      else {
        if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b2.child; null !== a; ) {
          g2 = Ch(a);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f2, false);
            d2 = g2.updateQueue;
            null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d2 = c2;
            for (c2 = b2.child; null !== c2; ) f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
            G(L, L.current & 1 | 2);
            return b2.child;
          }
          a = a.sibling;
        }
        null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d2) if (a = Ch(g2), null !== a) {
          if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S(b2), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Ij(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate) throw Error(p$1(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a, b2) {
  var c2 = a.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d2) {
    W(a, b2, d2);
  }
  else c2.current = null;
}
function Mj(a, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a, b2, d2);
  }
}
var Nj = false;
function Oj(a, b2) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c2 = { start: a.selectionStart, end: a.selectionEnd };
    else a: {
      c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
      var d2 = c2.getSelection && c2.getSelection();
      if (d2 && 0 !== d2.rangeCount) {
        c2 = d2.anchorNode;
        var e2 = d2.anchorOffset, f2 = d2.focusNode;
        d2 = d2.focusOffset;
        try {
          c2.nodeType, f2.nodeType;
        } catch (F2) {
          c2 = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
            q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a) break b;
            r2 === c2 && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d2 && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; ) if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a) a.return = b2, V = a;
  else for (; null !== V; ) {
    b2 = V;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b2.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$1(163));
      }
    } catch (F2) {
      W(b2, b2.return, F2);
    }
    a = b2.sibling;
    if (null !== a) {
      a.return = b2.return;
      V = a;
      break;
    }
    V = b2.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a) === a) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c2 = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c2;
        break;
      default:
        a = c2;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Sj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Sj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Uj(a) {
  a: for (; ; ) {
    for (; null === a.sibling; ) {
      if (null === a.return || Tj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;
      else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Vj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a)) for (Vj(a, b2, c2), a = a.sibling; null !== a; ) Vj(a, b2, c2), a = a.sibling;
}
function Wj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a)) for (Wj(a, b2, c2), a = a.sibling; null !== a; ) Wj(a, b2, c2), a = a.sibling;
}
var X$1 = null, Xj = false;
function Yj(a, b2, c2) {
  for (c2 = c2.child; null !== c2; ) Zj(a, b2, c2), c2 = c2.sibling;
}
function Zj(a, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h2) {
  }
  switch (c2.tag) {
    case 5:
      U || Lj(c2, b2);
    case 6:
      var d2 = X$1, e2 = Xj;
      X$1 = null;
      Yj(a, b2, c2);
      X$1 = d2;
      Xj = e2;
      null !== X$1 && (Xj ? (a = X$1, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Xj ? (a = X$1, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Xj;
      X$1 = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a, b2, c2);
      X$1 = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a, b2, c2);
      break;
    case 1:
      if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
        d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
      } catch (h2) {
        W(c2, b2, h2);
      }
      Yj(a, b2, c2);
      break;
    case 21:
      Yj(a, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a, b2, c2), U = d2) : Yj(a, b2, c2);
      break;
    default:
      Yj(a, b2, c2);
  }
}
function ak(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    null === c2 && (c2 = a.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    try {
      var f2 = a, g2 = b2, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X$1 = h2.stateNode;
            Xj = false;
            break a;
          case 3:
            X$1 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X$1 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X$1) throw Error(p$1(160));
      Zj(f2, g2, e2);
      X$1 = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W(e2, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a), b2 = b2.sibling;
}
function dk(a, b2) {
  var c2 = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a);
      ek(a);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
          vb(h2, g2);
          var l2 = vb(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q2 = k2[g2 + 1];
            "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
          }
          switch (h2) {
            case "input":
              bb(e2, f2);
              break;
            case "textarea":
              ib(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 6:
      ck(b2, a);
      ek(a);
      if (d2 & 4) {
        if (null === a.stateNode) throw Error(p$1(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a);
      ek(a);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W(a, a.return, t2);
      }
      break;
    case 4:
      ck(b2, a);
      ek(a);
      break;
    case 13:
      ck(b2, a);
      ek(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a), U = l2) : ck(b2, a);
      ek(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
          for (q2 = V = m2; null !== V; ) {
            r2 = V;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d2 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d2, c2, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
              } catch (t2) {
                W(a, a.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a, a.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a);
      ek(a);
      d2 & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a
      ), ek(a);
  }
}
function ek(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a);
          Vj(a, h2, g2);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function hk(a, b2, c2) {
  V = a;
  ik(a);
}
function ik(a, b2, c2) {
  for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Jj;
        var l2 = U;
        Jj = g2;
        if ((U = k2) && !l2) for (V = e2; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
        for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
        V = e2;
        Jj = h2;
        U = l2;
      }
      kk(a);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a);
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U || Qj(5, b2);
            break;
          case 1:
            var d2 = b2.stateNode;
            if (b2.flags & 4 && !U) if (null === c2) d2.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
              d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && sh(b2, f2, d2);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              sh(b2, g2, c2);
            }
            break;
          case 5:
            var h2 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h2;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$1(163));
        }
        U || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function gk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function jk(a) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var lk = Math.ceil, mk = ua$1.ReactCurrentDispatcher, nk = ua$1.ReactCurrentOwner, ok = ua$1.ReactCurrentBatchConfig, K = 0, Q = null, Y$1 = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function gi(a, b2, c2, d2) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$1(185));
  Ac(a, c2, d2);
  if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a, Z)), Dk(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a, b2) {
  var c2 = a.callbackNode;
  wc(a, b2);
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2) null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
      0 === (K & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
function Gk(a, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p$1(327));
  var c2 = a.callbackNode;
  if (Hk() && a.callbackNode !== c2) return null;
  var d2 = uc(a, a === Q ? Z : 0);
  if (0 === d2) return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2) b2 = Ik(a, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a || Z !== b2) uk = null, Gj = B() + 500, Kk(a, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y$1 ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Nk(a, e2)));
    if (1 === b2) throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
    if (6 === b2) Ck(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Nk(a, f2))), 1 === b2)) throw c2 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c2;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a, 0)) break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d2);
          if ((d2 & 4194240) === d2) break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d2);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Dk(a, B());
  return a.callbackNode === c2 ? Gk.bind(null, a) : null;
}
function Nk(a, b2) {
  var c2 = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b2).flags |= 256);
  a = Ik(a, b2);
  2 !== a && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a;
}
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
function Ok(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a) {
  if (0 !== (K & 6)) throw Error(p$1(327));
  Hk();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1)) return Dk(a, B()), null;
  var c2 = Ik(a, b2);
  if (0 !== a.tag && 2 === c2) {
    var d2 = xc(a);
    0 !== d2 && (b2 = d2, c2 = Nk(a, d2));
  }
  if (1 === c2) throw c2 = pk, Kk(a, 0), Ck(a, b2), Dk(a, B()), c2;
  if (6 === c2) throw Error(p$1(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Pk(a, tk, uk);
  Dk(a, B());
  return null;
}
function Qk(a, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a(b2);
  } finally {
    K = c2, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c2 = ok.transition, d2 = C;
  try {
    if (ok.transition = null, C = 1, a) return a();
  } finally {
    C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1) for (c2 = Y$1.return; null !== c2; ) {
    var d2 = c2;
    wg(d2);
    switch (d2.tag) {
      case 1:
        d2 = d2.type.childContextTypes;
        null !== d2 && void 0 !== d2 && $f();
        break;
      case 3:
        zh();
        E(Wf);
        E(H);
        Eh();
        break;
      case 5:
        Bh(d2);
        break;
      case 4:
        zh();
        break;
      case 13:
        E(L);
        break;
      case 19:
        E(L);
        break;
      case 10:
        ah(d2.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c2 = c2.return;
  }
  Q = a;
  Y$1 = a = Pg(a.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
      c2.interleaved = null;
      var e2 = d2.next, f2 = c2.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d2.next = g2;
      }
      c2.pending = d2;
    }
    fh = null;
  }
  return a;
}
function Mk(a, b2) {
  do {
    var c2 = Y$1;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        pk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Jk();
  if (Q !== a || Z !== b2) uk = null, Kk(a, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a, e2);
    }
  while (1);
  $g();
  K = c2;
  mk.current = d2;
  if (null !== Y$1) throw Error(p$1(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y$1; ) Uk(Y$1);
}
function Lk() {
  for (; null !== Y$1 && !cc(); ) Uk(Y$1);
}
function Uk(a) {
  var b2 = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Sk(a) : Y$1 = b2;
  nk.current = null;
}
function Sk(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a, b2, c2) {
  var d2 = C, e2 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a, b2, c2, d2);
  } finally {
    ok.transition = e2, C = d2;
  }
  return null;
}
function Wk(a, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p$1(327));
  c2 = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c2) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current) throw Error(p$1(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a, f2);
  a === Q && (Y$1 = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a, c2);
    dk(c2, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c2;
    hk(c2);
    dc();
    K = h2;
    C = g2;
    ok.transition = f2;
  } else a.current = c2;
  vk && (vk = false, wk = a, xk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a, B());
  if (null !== b2) for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi) throw Oi = false, a = Pi, Pi = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a = Dc(xk), b2 = ok.transition, c2 = C;
    try {
      ok.transition = null;
      C = 16 > a ? 16 : a;
      if (null === wk) var d2 = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p$1(331));
        var e2 = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V = q2;
                  else for (; null !== V; ) {
                    m2 = V;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V = r2;
                      break;
                    }
                    V = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V = x2;
              break b;
            }
            V = f2.return;
          }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
          else b: for (g2 = w2; null !== V; ) {
            h2 = V;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h2);
              }
            } catch (na) {
              W(h2, h2.return, na);
            }
            if (h2 === g2) {
              V = null;
              break b;
            }
            var F2 = h2.sibling;
            if (null !== F2) {
              F2.return = h2.return;
              V = F2;
              break b;
            }
            V = h2.return;
          }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {
        }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a, b2, 1);
  a = nh(a, b2, 1);
  b2 = R();
  null !== a && (Ac(a, 1, b2), Dk(a, b2));
}
function W(a, b2, c2) {
  if (3 === a.tag) Xk(a, a, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a, c2);
      break;
    } else if (1 === b2.tag) {
      var d2 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
        a = Ji(c2, a);
        a = Qi(b2, a, 1);
        b2 = nh(b2, a, 1);
        a = R();
        null !== b2 && (Ac(b2, 1, a), Dk(b2, a));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R();
  a.pingedLanes |= a.suspendedLanes & c2;
  Q === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c2);
  Dk(a, b2);
}
function Yk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R();
  a = ih(a, b2);
  null !== a && (Ac(a, b2, c2), Dk(a, c2));
}
function uj(a) {
  var b2 = a.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a, c2);
}
function bk(a, b2) {
  var c2 = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a, c2);
}
var Vk;
Vk = function(a, b2, c2) {
  if (null !== a) if (a.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a, b2, c2);
    dh = 0 !== (a.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a, b2);
        a = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a = Ci(d2, a);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a), c2);
            break a;
        }
        throw Error(p$1(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a) throw Error(p$1(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e2 = Ji(Error(p$1(423)), b2);
          b2 = lj(a, b2, d2, c2, e2);
          break a;
        } else if (d2 !== e2) {
          e2 = Ji(Error(p$1(424)), b2);
          b2 = lj(a, b2, d2, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a, b2, c2);
            break a;
          }
          Xi(a, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a, b2), Xi(a, b2, g2, c2), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return oj(a, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Ug(b2, null, d2, c2) : Xi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a, b2, d2, e2, c2);
    case 7:
      return Xi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b2 = Zi(a, b2, c2);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d2) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c2 & -c2);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c2;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c2);
                bh(
                  f2.return,
                  c2,
                  b2
                );
                h2.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$1(341));
            g2.lanes |= c2;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c2);
            bh(g2, c2, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a, b2, d2, e2, c2);
    case 15:
      return bj(a, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a, c2);
    case 19:
      return xj(a, b2, c2);
    case 22:
      return dj(a, b2, c2);
  }
  throw Error(p$1(156, b2.tag));
};
function Fk(a, b2) {
  return ac(a, b2);
}
function $k(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c2, d2) {
  return new $k(a, b2, c2, d2);
}
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Zk(a) {
  if ("function" === typeof a) return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }
  return 2;
}
function Pg(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a.flags & 14680064;
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function Rg(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a) aj(a) && (g2 = 1);
  else if ("string" === typeof a) g2 = 5;
  else a: switch (a) {
    case ya:
      return Tg(c2.children, e2, f2, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
    case Ea:
      return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
    case Fa:
      return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
    case Ia:
      return pj(c2, e2, f2, b2);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d2 = null;
          break a;
      }
      throw Error(p$1(130, null == a ? a : typeof a, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a, b2, c2, d2) {
  a = Bg(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
function pj(a, b2, c2, d2) {
  a = Bg(22, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  a.stateNode = { isHidden: false };
  return a;
}
function Qg(a, b2, c2) {
  a = Bg(6, a, null, b2);
  a.lanes = c2;
  return a;
}
function Sg(a, b2, c2) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function al(a, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = new al(a, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
function cl(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
function dl(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p$1(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a.tag) {
    var c2 = a.type;
    if (Zf(c2)) return bg(a, c2, b2);
  }
  return b2;
}
function el(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = bl(c2, d2, true, a, e2, f2, g2, h2, k2);
  a.context = dl(null);
  c2 = a.current;
  d2 = R();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Dk(a, d2);
  return a;
}
function fl(a, b2, c2, d2) {
  var e2 = b2.current, f2 = R(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a = nh(e2, b2, g2);
  null !== a && (gi(a, e2, g2, f2), oh(a, e2, g2));
  return g2;
}
function gl$1(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function hl(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c2 = a.retryLane;
    a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a, b2) {
  hl(a, b2);
  (a = a.alternate) && hl(a, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
ml.prototype.render = ll.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$1(409));
  fl(a, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Rk(function() {
      fl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a);
    0 === c2 && Vc(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function pl() {
}
function ql(a, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a2 = gl$1(g2);
        f2.call(a2);
      };
    }
    var g2 = el(b2, d2, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g2;
  }
  for (; e2 = a.lastChild; ) a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a2 = gl$1(k2);
      h2.call(a2);
    };
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = gl$1(g2);
        h2.call(a2);
      };
    }
    fl(b2, g2, a, e2);
  } else g2 = ql(c2, b2, a, e2, d2);
  return gl$1(g2);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a, 1);
        if (null !== b3) {
          var c3 = R();
          gi(b3, a, 1, c3);
        }
      }), il(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = ih(a, 134217728);
    if (null !== b2) {
      var c2 = R();
      gi(b2, a, 134217728, c2);
    }
    il(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = yi(a), c2 = ih(a, b2);
    if (null !== c2) {
      var d2 = R();
      gi(c2, a, b2, d2);
    }
    il(a, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b2) {
  var c2 = C;
  try {
    return C = a, b2();
  } finally {
    C = c2;
  }
};
yb = function(a, b2, c2) {
  switch (b2) {
    case "input":
      bb(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2) throw Error(p$1(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua$1.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$1(200));
  return cl(a, b2, null, c2);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!nl(a)) throw Error(p$1(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a, 1, false, null, null, c2, false, d2, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render) throw Error(p$1(188));
    a = Object.keys(a).join(",");
    throw Error(p$1(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b2, c2) {
  if (!ol(b2)) throw Error(p$1(200));
  return rl(null, a, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a, b2, c2) {
  if (!nl(a)) throw Error(p$1(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d2) for (a = 0; a < d2.length; a++) c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a, b2, c2) {
  if (!ol(b2)) throw Error(p$1(200));
  return rl(null, a, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a)) throw Error(p$1(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!ol(c2)) throw Error(p$1(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p$1(38));
  return rl(a, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var createRoot;
var m$1 = reactDomExports;
{
  createRoot = m$1.createRoot;
  m$1.hydrateRoot;
}
const cx = (...classNames2) => classNames2.filter(Boolean).map((r2) => r2.trim()).join(" ");
function getErrorMessage$1(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext$1(options2 = {}) {
  const {
    name: name2,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options2;
  const Context = reactExports.createContext(defaultValue);
  Context.displayName = name2;
  function useContext$1() {
    const context = reactExports.useContext(Context);
    if (!context && strict) {
      const error2 = new Error(
        errorMessage ?? getErrorMessage$1(hookName, providerName)
      );
      error2.name = "ContextError";
      Error.captureStackTrace?.(error2, useContext$1);
      throw error2;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}
function callAll$1(...fns) {
  return function mergedFn(...args) {
    fns.forEach((fn) => fn?.(...args));
  };
}
const clsx$1 = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
const eventRegex = /^on[A-Z]/;
function mergeProps$1(...args) {
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (eventRegex.test(key) && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = callAll$1(result[key], props[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx$1(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = Object.assign({}, result[key] ?? {}, props[key] ?? {});
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}
const EMPTY_STYLES = Object.freeze({});
const EMPTY_SLOT_STYLES = Object.freeze(
  {}
);
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0) cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid$1 = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? true : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert2(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match$3(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy$1(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev$1() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next$1() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice$1(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice$1(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next$1();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next$1())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice$1(index, caret() + (count < 6 && peek() == 32 && next$1() == 32));
}
function delimiter(type) {
  while (next$1())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next$1();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next$1())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice$1(index, position - 1) + "*" + from(type === 47 ? type : next$1());
}
function identifier(index) {
  while (!token(peek()))
    next$1();
  return slice$1(index, position);
}
function compile(value) {
  return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$1(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next$1()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next$1(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$1(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next$1());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i = 0, j = 0, k2 = 0; i < index; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$1(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify$2(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection2) {
  var length2 = sizeof(collection2);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection2[i](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next$1();
  }
  return slice$1(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next$1());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix$1(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix$1(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix$1(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize$1([copy$1(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match$3(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize$1([copy$1(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize$1([copy$1(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy$1(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy$1(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$1(compile(styles2), serializer);
    };
    _insert = function insert2(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w$1 = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a) {
  return z(a) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a) {
  return A(a) || z(a) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a) {
  return z(a) === k;
};
reactIs_production_min.isContextProvider = function(a) {
  return z(a) === h;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a) {
  return z(a) === n;
};
reactIs_production_min.isFragment = function(a) {
  return z(a) === e;
};
reactIs_production_min.isLazy = function(a) {
  return z(a) === t;
};
reactIs_production_min.isMemo = function(a) {
  return z(a) === r;
};
reactIs_production_min.isPortal = function(a) {
  return z(a) === d;
};
reactIs_production_min.isProfiler = function(a) {
  return z(a) === g;
};
reactIs_production_min.isStrictMode = function(a) {
  return z(a) === f;
};
reactIs_production_min.isSuspense = function(a) {
  return z(a) === p;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w$1 || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor$1 = {
            name: p1,
            styles: p2,
            next: cursor$1
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor$1 = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor$1
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor$1 = {
              name: next2.name,
              styles: next2.styles,
              next: cursor$1
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor$1;
        var result = interpolation(mergedProps);
        cursor$1 = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor$1;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor$1 = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  return {
    name: name2,
    styles: styles2,
    next: cursor$1
  };
}
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$1 = function Insertion2(_ref2) {
  var cache2 = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache2, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion$1, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function assignRef(ref, value) {
  if (ref == null) return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error2) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return (node2) => {
    refs.forEach((ref) => {
      assignRef(ref, node2);
    });
  };
}
function compact$1(object) {
  const clone2 = Object.assign({}, object);
  for (let key in clone2) {
    if (clone2[key] === void 0) delete clone2[key];
  }
  return clone2;
}
function interopDefault(mod2) {
  return mod2.default || mod2;
}
const isObject$4 = (v2) => v2 != null && typeof v2 === "object" && !Array.isArray(v2);
const isString$3 = (v2) => typeof v2 === "string";
const isFunction$2 = (v2) => typeof v2 === "function";
function getElementRef(el2) {
  const version = reactExports.version;
  if (!isString$3(version)) return el2?.ref;
  if (version.startsWith("18.")) return el2?.ref;
  return el2?.props?.ref;
}
const [ChakraContextProvider, useChakraContext] = createContext$1({
  name: "ChakraContext",
  strict: true,
  providerName: "<ChakraProvider />"
});
function ChakraProvider(props) {
  const { value: sys, children } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChakraContextProvider, { value: sys, children: [
    !sys._config.disableLayers && /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: sys.layers.atRule }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: sys._global }),
    children
  ] });
}
const splitPropFn = (props, predicate) => {
  const rest = {};
  const result = {};
  const allKeys = Object.keys(props);
  for (const key of allKeys) {
    if (predicate(key)) {
      result[key] = props[key];
    } else {
      rest[key] = props[key];
    }
  }
  return [result, rest];
};
const splitProps = (props, keys) => {
  const predicate = isFunction$2(keys) ? keys : (key) => keys.includes(key);
  return splitPropFn(props, predicate);
};
const htmlProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function isHtmlProp(prop) {
  return typeof prop === "string" && htmlProps.has(prop);
}
function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
  const { css: css2, isValidProperty } = useChakraContext();
  const { children, ...props } = inProps;
  const result = reactExports.useMemo(() => {
    const [forwardedProps, restProps_B] = splitProps(
      props,
      (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
    );
    const [variantProps, restProps_C] = splitProps(
      restProps_B,
      cvaRecipe.variantKeys
    );
    const [styleProps, elementProps] = splitProps(restProps_C, isValidProperty);
    return {
      forwardedProps,
      variantProps,
      styleProps,
      elementProps
    };
  }, [cvaRecipe.variantKeys, shouldForwardProps, props, isValidProperty]);
  const { css: cssStyles, ...propStyles } = result.styleProps;
  const cvaStyles = reactExports.useMemo(() => {
    const variantProps = { ...result.variantProps };
    if (!cvaRecipe.variantKeys.includes("colorPalette")) {
      variantProps.colorPalette = props.colorPalette;
    }
    if (!cvaRecipe.variantKeys.includes("orientation")) {
      variantProps.orientation = props.orientation;
    }
    return cvaRecipe(variantProps);
  }, [cvaRecipe, result.variantProps, props.colorPalette, props.orientation]);
  const styles2 = reactExports.useMemo(() => {
    return css2(cvaStyles, ...toArray$1(cssStyles), propStyles);
  }, [css2, cvaStyles, cssStyles, propStyles]);
  return {
    styles: styles2,
    props: {
      ...result.forwardedProps,
      ...result.elementProps,
      children
    }
  };
}
const toArray$1 = (val) => {
  const res = Array.isArray(val) ? val : [val];
  return res.filter(Boolean).flat();
};
const isPropValid = interopDefault(isPropValid$1);
const testOmitPropsOnStringTag = isPropValid;
const testOmitPropsOnComponent = (key) => key !== "theme";
const composeShouldForwardProps = (tag, options2, isReal) => {
  let shouldForwardProp;
  if (options2) {
    const optionsShouldForwardProp = options2.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
let isBrowser = typeof document !== "undefined";
const Insertion = ({ cache: cache2, serialized, isStringTag }) => {
  registerStyles(cache2, serialized, isStringTag);
  const rules = useInsertionEffectAlwaysWithSyncFallback(
    () => insertStyles(cache2, serialized, isStringTag)
  );
  if (!isBrowser && rules !== void 0) {
    let serializedNames = serialized.name;
    let next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames = cx(serializedNames, next2.name);
      next2 = next2.next;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "style",
      {
        ...{
          [`data-emotion`]: cx(cache2.key, serializedNames),
          dangerouslySetInnerHTML: { __html: rules },
          nonce: cache2.sheet.nonce
        }
      }
    );
  }
  return null;
};
const createStyled = (tag, configOrCva = {}, options2 = {}) => {
  const isReal = tag.__emotion_real === tag;
  const baseTag = isReal && tag.__emotion_base || tag;
  let identifierName;
  let targetClassName;
  if (options2 !== void 0) {
    identifierName = options2.label;
    targetClassName = options2.target;
  }
  let styles2 = [];
  const Styled = withEmotionCache((inProps, cache2, ref) => {
    const { cva, isValidProperty } = useChakraContext();
    const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
    const cvaRecipe = mergeCva$1(tag.__emotion_cva, cvaFn);
    const createShouldForwardProps = (props2) => {
      return (prop, variantKeys) => {
        if (props2.includes(prop)) return true;
        return !variantKeys?.includes(prop) && !isValidProperty(prop);
      };
    };
    if (!options2.shouldForwardProp && options2.forwardProps) {
      options2.shouldForwardProp = createShouldForwardProps(options2.forwardProps);
    }
    const fallbackShouldForwardProp = (prop, variantKeys) => {
      const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      const chakraSfp = !variantKeys?.includes(prop) && !isValidProperty(prop);
      return emotionSfp(prop) && chakraSfp;
    };
    const shouldForwardProp = composeShouldForwardProps(tag, options2, isReal) || fallbackShouldForwardProp;
    const propsWithDefault = reactExports.useMemo(
      () => Object.assign({}, options2.defaultProps, compact$1(inProps)),
      [inProps]
    );
    const { props, styles: styleProps } = useResolvedProps(
      propsWithDefault,
      cvaRecipe,
      shouldForwardProp
    );
    let className = "";
    let classInterpolations = [styleProps];
    let mergedProps = props;
    if (props.theme == null) {
      mergedProps = {};
      for (let key in props) {
        mergedProps[key] = props[key];
      }
      mergedProps.theme = reactExports.useContext(ThemeContext);
    }
    if (typeof props.className === "string") {
      className = getRegisteredStyles(
        cache2.registered,
        classInterpolations,
        props.className
      );
    } else if (props.className != null) {
      className = cx(className, props.className);
    }
    const serialized = serializeStyles(
      styles2.concat(classInterpolations),
      cache2.registered,
      mergedProps
    );
    className = cx(className, `${cache2.key}-${serialized.name}`);
    if (targetClassName !== void 0) {
      className = cx(className, targetClassName);
    }
    const shouldUseAs = !shouldForwardProp("as");
    let FinalTag = shouldUseAs && props.as || baseTag;
    let finalProps = {};
    for (let prop in props) {
      if (shouldUseAs && prop === "as") continue;
      if (isHtmlProp(prop)) {
        const nativeProp = prop.replace("html", "").toLowerCase();
        finalProps[nativeProp] = props[prop];
        continue;
      }
      if (shouldForwardProp(prop)) {
        finalProps[prop] = props[prop];
      }
    }
    finalProps.className = className.trim();
    finalProps.ref = ref;
    const forwardAsChild = options2.forwardAsChild || options2.forwardProps?.includes("asChild");
    if (props.asChild && !forwardAsChild) {
      const child = reactExports.Children.only(props.children);
      FinalTag = child.type;
      finalProps.children = null;
      Reflect.deleteProperty(finalProps, "asChild");
      finalProps = mergeProps$1(finalProps, child.props);
      finalProps.ref = mergeRefs(ref, getElementRef(child));
    }
    if (finalProps.as && forwardAsChild) {
      finalProps.as = void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Insertion,
          {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FinalTag, { asChild: true, ...finalProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(props.as, { children: finalProps.children }) })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Insertion,
        {
          cache: cache2,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FinalTag, { ...finalProps })
    ] });
  });
  Styled.displayName = identifierName !== void 0 ? identifierName : `chakra(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
  Styled.__emotion_real = Styled;
  Styled.__emotion_base = baseTag;
  Styled.__emotion_forwardProp = options2.shouldForwardProp;
  Styled.__emotion_cva = configOrCva;
  Object.defineProperty(Styled, "toString", {
    value() {
      return `.${targetClassName}`;
    }
  });
  return Styled;
};
const styledFn = createStyled.bind();
const cache = /* @__PURE__ */ new Map();
const chakraImpl = new Proxy(styledFn, {
  apply(_, __, args) {
    return styledFn(...args);
  },
  get(_, el2) {
    if (!cache.has(el2)) {
      cache.set(el2, styledFn(el2));
    }
    return cache.get(el2);
  }
});
const chakra = chakraImpl;
const mergeCva$1 = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  return cvaA.merge(cvaB);
};
function useRecipe(options2) {
  const { key, recipe: recipeProp } = options2;
  const sys = useChakraContext();
  return reactExports.useMemo(() => {
    const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
    return sys.cva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}
const upperFirst$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options2) {
  const { key: recipeKey, recipe: recipeConfig } = options2;
  const contextName = upperFirst$1(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider, usePropsContext2] = createContext$1({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  function useRecipeResult2(props) {
    const { unstyled, ...restProps } = props;
    const recipe = useRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = reactExports.useMemo(
      () => recipe.splitVariantProps(restProps),
      [recipe, restProps]
    );
    const styles2 = unstyled ? EMPTY_STYLES : recipe(variantProps);
    return {
      styles: styles2,
      className: recipe.className,
      props: otherProps
    };
  }
  const withContext2 = (Component, options22) => {
    const SuperComponent = chakra(Component, {}, options22);
    const StyledComponent = reactExports.forwardRef((inProps, ref) => {
      const propsContext = usePropsContext2();
      const props = reactExports.useMemo(
        () => mergeProps$1(propsContext, inProps),
        [inProps, propsContext]
      );
      const { styles: styles2, className, props: localProps } = useRecipeResult2(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ...localProps,
          ref,
          css: [styles2, props.css],
          className: cx(className, props.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  function withPropsProvider() {
    return PropsProvider;
  }
  return {
    withContext: withContext2,
    PropsProvider,
    withPropsProvider,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult2
  };
}
var wrap$3 = (v2, idx) => {
  return v2.map((_, index) => v2[(Math.max(idx, 0) + index) % v2.length]);
};
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop$5 = () => void 0;
var isObject$3 = (v2) => typeof v2 === "object" && v2 !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr$1 = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement$1 = (el2) => isObject$3(el2) && el2.nodeType === ELEMENT_NODE && typeof el2.nodeName === "string";
var isDocument = (el2) => isObject$3(el2) && el2.nodeType === DOCUMENT_NODE;
var isWindow = (el2) => isObject$3(el2) && el2 === el2.window;
var getNodeName$1 = (node2) => {
  if (isHTMLElement$1(node2)) return node2.localName || "";
  return "#document";
};
function isRootElement(node2) {
  return ["html", "body", "#document"].includes(getNodeName$1(node2));
}
var isNode$2 = (el2) => isObject$3(el2) && el2.nodeType !== void 0;
var isShadowRoot$1 = (el2) => isNode$2(el2) && el2.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el2;
var isInputElement = (el2) => isHTMLElement$1(el2) && el2.localName === "input";
var isAnchorElement = (el2) => !!el2?.matches("a[href]");
var isElementVisible = (el2) => {
  if (!isHTMLElement$1(el2)) return false;
  return el2.offsetWidth > 0 || el2.offsetHeight > 0 || el2.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el2) {
  if (el2 == null || !isHTMLElement$1(el2)) return false;
  try {
    return isInputElement(el2) && el2.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el2.localName) || el2.isContentEditable || el2.getAttribute("contenteditable") === "true" || el2.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent, child) {
  if (!parent || !child) return false;
  if (!isHTMLElement$1(parent) || !isHTMLElement$1(child)) return false;
  const rootNode = child.getRootNode?.();
  if (parent === child) return true;
  if (parent.contains(child)) return true;
  if (rootNode && isShadowRoot$1(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) return true;
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getDocument(el2) {
  if (isDocument(el2)) return el2;
  if (isWindow(el2)) return el2.document;
  return el2?.ownerDocument ?? document;
}
function getDocumentElement$1(el2) {
  return getDocument(el2).documentElement;
}
function getWindow$1(el2) {
  if (isShadowRoot$1(el2)) return getWindow$1(el2.host);
  if (isDocument(el2)) return el2.defaultView ?? window;
  if (isHTMLElement$1(el2)) return el2.ownerDocument?.defaultView ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement?.shadowRoot) {
    const el2 = activeElement.shadowRoot.activeElement;
    if (el2 === activeElement) break;
    else activeElement = el2;
  }
  return activeElement;
}
function getParentNode$2(node2) {
  if (getNodeName$1(node2) === "html") return node2;
  const result = node2.assignedSlot || node2.parentNode || isShadowRoot$1(node2) && node2.host || getDocumentElement$1(node2);
  return isShadowRoot$1(result) ? result.host : result;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle$2(el2) {
  if (!styleCache.has(el2)) {
    styleCache.set(el2, getWindow$1(el2).getComputedStyle(el2));
  }
  return styleCache.get(el2);
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v2) => isDom() && v2.test(getPlatform());
var ua = (v2) => isDom() && v2.test(getUserAgent());
var vn = (v2) => isDom() && v2.test(navigator.vendor);
var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
var isIPhone = () => pt(/^iPhone/i);
var isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;
var isIos = () => isIPhone() || isIPad();
var isApple = () => isMac() || isIos();
var isMac = () => pt(/^Mac/i);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/Firefox/i);
var isAndroid = () => ua(/Android/i);
function getComposedPath(event) {
  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return composedPath?.[0] ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const isAppleDevice = isApple();
  if (isAppleDevice && !event.metaKey) return false;
  if (!isAppleDevice && !event.ctrlKey) return false;
  const localName = element.localName;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const localName = element.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing || event.keyCode === 229;
}
function isPrintableKey(e2) {
  return e2.key.length === 1 && !e2.ctrlKey && !e2.metaKey;
}
function isVirtualClick(e2) {
  if (e2.mozInputSource === 0 && e2.isTrusted) return true;
  if (isAndroid() && e2.pointerType) {
    return e2.type === "click" && e2.buttons === 1;
  }
  return e2.detail === 0 && !e2.pointerType;
}
var isLeftClick = (e2) => e2.button === 0;
var isContextMenuEvent = (e2) => {
  return e2.button === 2 || isMac() && e2.ctrlKey && e2.button === 0;
};
var isModifierKey = (e2) => e2.ctrlKey || e2.altKey || e2.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options2 = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options2;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options2) => {
  const node2 = typeof target === "function" ? target() : target;
  node2?.addEventListener(eventName, handler, options2);
  return () => {
    node2?.removeEventListener(eventName, handler, options2);
  };
};
function getDescriptor(el2, options2) {
  const { type = "HTMLInputElement", property = "value" } = options2;
  const proto = getWindow$1(el2)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el2) {
  if (el2.localName === "input") return "HTMLInputElement";
  if (el2.localName === "textarea") return "HTMLTextAreaElement";
  if (el2.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el2, value, property = "value") {
  if (!el2) return;
  const type = getElementType(el2);
  if (type) {
    const descriptor = getDescriptor(el2, { type, property });
    descriptor.set?.call(el2, value);
  }
  el2.setAttribute(property, value);
}
function setElementChecked(el2, checked) {
  if (!el2) return;
  const descriptor = getDescriptor(el2, { type: "HTMLInputElement", property: "checked" });
  descriptor.set?.call(el2, checked);
  if (checked) el2.setAttribute("checked", "");
  else el2.removeAttribute("checked");
}
function dispatchInputCheckedEvent(el2, options2) {
  const { checked, bubbles = true } = options2;
  if (!el2) return;
  const win = getWindow$1(el2);
  if (!(el2 instanceof win.HTMLInputElement)) return;
  setElementChecked(el2, checked);
  el2.dispatchEvent(new win.Event("click", { bubbles }));
}
function getClosestForm(el2) {
  return isFormElement(el2) ? el2.form : el2.closest("form");
}
function isFormElement(el2) {
  return el2.matches("textarea, input, select, button");
}
function trackFormReset(el2, callback) {
  if (!el2) return;
  const form = getClosestForm(el2);
  const onReset = (e2) => {
    if (e2.defaultPrevented) return;
    callback();
  };
  form?.addEventListener("reset", onReset, { passive: true });
  return () => form?.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el2, callback) {
  const fieldset = el2?.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow$1(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el2, options2) {
  if (!el2) return;
  const { onFieldsetDisabledChange, onFormReset } = options2;
  const cleanups = [trackFormReset(el2, onFormReset), trackFieldsetDisabled(el2, onFieldsetDisabledChange)];
  return () => cleanups.forEach((cleanup) => cleanup?.());
}
var isFrame = (el2) => isHTMLElement$1(el2) && el2.tagName === "IFRAME";
var hasTabIndex = (el2) => !Number.isNaN(parseInt(el2.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el2) => parseInt(el2.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement$1(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) ;
  return tabbableElements;
}
function isTabbable(el2) {
  if (el2 != null && el2.tabIndex > 0) return true;
  return isFocusable(el2) && !hasNegativeTabIndex(el2);
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first2 = elements[0] || null;
  const last2 = elements[elements.length - 1] || null;
  return [first2, last2];
}
function getTabIndex(node2) {
  if (node2.tabIndex < 0) {
    if ((/^(audio|video|details)$/.test(node2.localName) || isEditableElement(node2)) && !hasTabIndex(node2)) {
      return 0;
    }
  }
  return node2.tabIndex;
}
function getInitialFocus(options2) {
  const { root, getInitialEl, filter, enabled = true } = options2;
  if (!enabled) return;
  let node2 = null;
  node2 || (node2 = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node2 || (node2 = root?.querySelector("[data-autofocus],[autofocus]"));
  if (!node2) {
    const tabbables = getTabbables(root);
    node2 = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node2 || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
function nextTick(fn) {
  const set2 = /* @__PURE__ */ new Set();
  function raf2(fn2) {
    const id2 = globalThis.requestAnimationFrame(fn2);
    set2.add(() => globalThis.cancelAnimationFrame(id2));
  }
  raf2(() => raf2(fn));
  return function cleanup() {
    set2.forEach((fn2) => fn2());
  };
}
function raf$1(fn) {
  let cleanup;
  const id2 = globalThis.requestAnimationFrame(() => {
    cleanup = fn();
  });
  return () => {
    globalThis.cancelAnimationFrame(id2);
    cleanup?.();
  };
}
function queueBeforeEvent(el2, type, cb2) {
  const cancelTimer = raf$1(() => {
    el2.removeEventListener(type, exec, true);
    cb2();
  });
  const exec = () => {
    cancelTimer();
    cb2();
  };
  el2.addEventListener(type, exec, { once: true, capture: true });
  return cancelTimer;
}
function observeAttributesImpl(node2, options2) {
  if (!node2) return;
  const { attributes, callback: fn } = options2;
  const win = node2.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node2, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options2) {
  const { defer: defer2 } = options2;
  const func = defer2 ? raf$1 : (v2) => v2();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(observeAttributesImpl(node2, options2));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function clickIfLink(el2) {
  const click = () => el2.click();
  if (isFirefox()) {
    queueBeforeEvent(el2, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function getNearestOverflowAncestor$1(el2) {
  const parentNode = getParentNode$2(el2);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement$1(parentNode) && isOverflowElement$1(parentNode)) return parentNode;
  return getNearestOverflowAncestor$1(parentNode);
}
function getOverflowAncestors$1(el2, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor$1(el2);
  const isBody = scrollableAncestor === el2.ownerDocument.body;
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement$1(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors$1(scrollableAncestor, []));
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement$1(el2) {
  const win = getWindow$1(el2);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el2);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isScrollable(el2) {
  return el2.scrollHeight > el2.clientHeight || el2.scrollWidth > el2.clientWidth;
}
function scrollIntoView(el2, options2) {
  const { rootEl, ...scrollOptions } = options2 || {};
  if (!el2 || !rootEl) return;
  if (!isOverflowElement$1(rootEl) || !isScrollable(rootEl)) return;
  el2.scrollIntoView(scrollOptions);
}
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
  }
  function onPointerError(event) {
    if (isLocked()) ;
    console.error("PointerLock error occurred:", event);
    doc.exitPointerLock();
  }
  if (!supported) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
function trackPress(options2) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e2) => e2.key === "Enter"
  } = options2;
  if (!pointerNode) return noop$5;
  const win = getWindow$1(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop$5;
  let removeEndListeners = noop$5;
  let removeAccessibleListeners = noop$5;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart?.(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd?.(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress?.(getInfo(endEvent));
      } else {
        onPressEnd?.(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress, once: true });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, {
      passive: !onPressEnd,
      once: true
    });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent)) return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent)) return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress?.(info);
        onPressEnd?.(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return () => {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}
function queryAll(root, selector) {
  return Array.from(root?.querySelectorAll(selector) ?? []);
}
var defaultItemToId = (v2) => v2.id;
function itemById(v2, id2, itemToId = defaultItemToId) {
  return v2.find((item) => itemToId(item) === id2);
}
function indexOfId(v2, id2, itemToId = defaultItemToId) {
  const item = itemById(v2, id2, itemToId);
  return item ? v2.indexOf(item) : -1;
}
function nextById(v2, id2, loop = true) {
  let idx = indexOfId(v2, id2);
  idx = loop ? (idx + 1) % v2.length : Math.min(idx + 1, v2.length - 1);
  return v2[idx];
}
function prevById(v2, id2, loop = true) {
  let idx = indexOfId(v2, id2);
  if (idx === -1) return loop ? v2[v2.length - 1] : null;
  idx = loop ? (idx - 1 + v2.length) % v2.length : Math.max(0, idx - 1);
  return v2[idx];
}
function trackElementRect(elements, options2) {
  const { onEntry, measure, box = "border-box" } = options2;
  const elems = (Array.isArray(elements) ? elements : [elements]).filter(isHTMLElement$1);
  const win = getWindow$1(elems[0]);
  const trigger = (entries) => {
    const rects = elems.map((el2) => measure(el2));
    onEntry({ rects, entries });
  };
  trigger([]);
  const obs = new win.ResizeObserver(trigger);
  elems.forEach((el2) => obs.observe(el2, { box }));
  return () => obs.disconnect();
}
var sanitize = (str) => str.split("").map((char2) => {
  const code = char2.charCodeAt(0);
  if (code > 0 && code < 128) return char2;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el2) => {
  return sanitize(el2.dataset?.valuetext ?? el2.textContent ?? "");
};
var match$2 = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v2, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v2, currentId, itemToId) : -1;
  let items = currentId ? wrap$3(v2, index) : v2;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match$2(getValueText(item), text));
}
function setStyle(el2, style) {
  if (!el2) return noop$5;
  const prev2 = Object.keys(style).reduce((acc, key) => {
    acc[key] = el2.style.getPropertyValue(key);
    return acc;
  }, {});
  Object.assign(el2.style, style);
  return () => {
    Object.assign(el2.style, prev2);
    if (el2.style.length === 0) {
      el2.removeAttribute("style");
    }
  };
}
function setStyleProperty(el2, prop, value) {
  if (!el2) return noop$5;
  const prev2 = el2.style.getPropertyValue(prop);
  el2.style.setProperty(prop, value);
  return () => {
    el2.style.setProperty(prop, prev2);
    if (el2.style.length === 0) {
      el2.removeAttribute("style");
    }
  };
}
function getByTypeaheadImpl(baseItems, options2) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options2;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next2 = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update2(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update2("");
        cleanup();
      }, timeout);
    }
  }
  update2(search);
  return next2;
}
var getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
var fps = 1e3 / 60;
function waitForElement(query2, cb2) {
  const el2 = query2();
  if (isHTMLElement$1(el2) && el2.isConnected) {
    cb2(el2);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el22 = query2();
      if (isHTMLElement$1(el22) && el22.isConnected) {
        cb2(el22);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb2) {
  const cleanups = [];
  queries?.forEach((query2) => {
    const clean = waitForElement(query2, cb2);
    cleanups.push(clean);
  });
  return () => {
    cleanups.forEach((fn) => fn());
  };
}
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options2 = {}) {
  const {
    name: name2,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options2;
  const Context = reactExports.createContext(defaultValue);
  Context.displayName = name2;
  function useContext$1() {
    const context = reactExports.useContext(Context);
    if (!context && strict) {
      const error2 = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error2.name = "ContextError";
      Error.captureStackTrace?.(error2, useContext$1);
      throw error2;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}
const [LocaleContextProvider, useLocaleContext] = createContext({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});
function composeRefs(...refs) {
  return (node2) => {
    const cleanUps = [];
    for (const ref of refs) {
      if (typeof ref === "function") {
        const cb2 = ref(node2);
        if (typeof cb2 === "function") {
          cleanUps.push(cb2);
        }
      } else if (ref) {
        ref.current = node2;
      }
    }
    if (cleanUps.length) {
      return () => {
        for (const cleanUp of cleanUps) {
          cleanUp();
        }
      };
    }
  };
}
function toArray(v2) {
  if (!v2) return [];
  return Array.isArray(v2) ? v2 : [v2];
}
var first = (v2) => v2[0];
var last = (v2) => v2[v2.length - 1];
var has = (v2, t2) => v2.indexOf(t2) !== -1;
var add$1 = (v2, ...items) => v2.concat(items);
var remove$1 = (v2, ...items) => v2.filter((t2) => !items.includes(t2));
var addOrRemove = (v2, item) => {
  if (has(v2, item)) return remove$1(v2, item);
  return add$1(v2, item);
};
function nextIndex(v2, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v2.length;
  const last2 = len - 1;
  if (idx === -1) return step > 0 ? 0 : last2;
  if (next2 < 0) return loop ? last2 : 0;
  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function next(v2, idx, opts = {}) {
  return v2[nextIndex(v2, idx, opts)];
}
function prevIndex(v2, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v2, idx, { step: -step, loop });
}
function prev(v2, index, opts = {}) {
  return v2[prevIndex(v2, index, opts)];
}
var isArrayLike = (value) => value?.constructor.name === "Array";
var isArrayEqual = (a, b2) => {
  if (a.length !== b2.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual(a[i], b2[i])) return false;
  }
  return true;
};
var isEqual = (a, b2) => {
  if (Object.is(a, b2)) return true;
  if (a == null && b2 != null || a != null && b2 == null) return false;
  if (typeof a?.isEqual === "function" && typeof b2?.isEqual === "function") {
    return a.isEqual(b2);
  }
  if (typeof a === "function" && typeof b2 === "function") {
    return a.toString() === b2.toString();
  }
  if (isArrayLike(a) && isArrayLike(b2)) {
    return isArrayEqual(Array.from(a), Array.from(b2));
  }
  if (!(typeof a === "object") || !(typeof b2 === "object")) return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length2 = keys.length;
  for (let i = 0; i < length2; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length2; i++) {
    const key = keys[i];
    if (!isEqual(a[key], b2[key])) return false;
  }
  return true;
};
var isArray = (v2) => Array.isArray(v2);
var isObjectLike = (v2) => v2 != null && typeof v2 === "object";
var isObject$2 = (v2) => isObjectLike(v2) && !isArray(v2);
var isString$2 = (v2) => typeof v2 === "string";
var isFunction$1 = (v2) => typeof v2 === "function";
var isNull = (v2) => v2 == null;
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
var fnToString = Function.prototype.toString;
fnToString.call(Object);
var runIfFn = (v2, ...a) => {
  const res = typeof v2 === "function" ? v2(...a) : v2;
  return res ?? void 0;
};
var identity$2 = (v2) => v2();
var noop$4 = () => {
};
var callAll = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn?.(...a);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id2 = 0;
  return () => {
    id2++;
    return id2.toString(36);
  };
})();
var { floor: floor$1, round: round$1, min: min$1, max: max$1 } = Math;
var isNaN$1 = (v2) => Number.isNaN(v2);
var nan = (v2) => isNaN$1(v2) ? 0 : v2;
var wrap$2 = (v2, vmax) => (v2 % vmax + vmax) % vmax;
var isValueAtMax = (v2, vmax) => nan(v2) >= vmax;
var isValueAtMin = (v2, vmin) => nan(v2) <= vmin;
var isValueWithinRange = (v2, vmin, vmax) => nan(v2) >= vmin && nan(v2) <= vmax;
var clampValue = (v2, vmin, vmax) => min$1(max$1(nan(v2), vmin), vmax);
var roundToDpr = (v2, dpr) => typeof dpr === "number" ? floor$1(v2 * dpr + 0.5) / dpr : round$1(v2);
var countDecimals = (value) => {
  if (!Number.isFinite(value)) return 0;
  let e2 = 1, p2 = 0;
  while (Math.round(value * e2) / e2 !== value) {
    e2 *= 10;
    p2 += 1;
  }
  return p2;
};
var decimalOp = (a, op, b2) => {
  let result = op === "+" ? a + b2 : a - b2;
  if (a % 1 !== 0 || b2 % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b2));
    a = Math.round(a * multiplier);
    b2 = Math.round(b2 * multiplier);
    result = op === "+" ? a + b2 : a - b2;
    result /= multiplier;
  }
  return result;
};
var incrementValue = (v2, s) => decimalOp(nan(v2), "+", s);
var decrementValue = (v2, s) => decimalOp(nan(v2), "-", s);
function compact(obj) {
  if (!isPlainObject2(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (v2) => {
  return v2 && typeof v2 === "object" && v2.constructor === Object;
};
function setRafTimeout(callback, delay2) {
  const start = performance.now();
  let handle;
  function loop(now) {
    handle = requestAnimationFrame(loop);
    const delta = now - start;
    if (delta >= delay2) {
      callback();
    }
  }
  handle = requestAnimationFrame(loop);
  return () => cancelAnimationFrame(handle);
}
function warn$1(...a) {
  a.length === 1 ? a[0] : a[1];
  a.length === 2 ? a[0] : true;
}
function ensure(c2, m2) {
  if (c2 == null) throw new Error(m2());
}
function ensureProps(props, keys, scope) {
  let missingKeys = [];
  for (const key of keys) {
    if (props[key] == null) missingKeys.push(key);
  }
  if (missingKeys.length > 0)
    throw new Error(`[zag-js${` > ${scope}`}] missing required props: ${missingKeys.join(", ")}`);
}
var clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style) => {
  const res = {};
  let match2;
  while (match2 = CSS_REGEX.exec(style)) {
    res[match2[1]] = match2[2];
  }
  return res;
};
var css$1 = (a, b2) => {
  if (isString$2(a)) {
    if (isString$2(b2)) return `${a};${b2}`;
    a = serialize(a);
  } else if (isString$2(b2)) {
    b2 = serialize(b2);
  }
  return Object.assign({}, a ?? {}, b2 ?? {});
};
function mergeProps(...args) {
  let result = {};
  for (let props of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props[key] === "function") {
        result[key] = callAll(props[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css$1(result[key], props[key]);
        continue;
      }
      result[key] = props[key] !== void 0 ? props[key] : result[key];
    }
    for (let key in props) {
      if (result[key] === void 0) {
        result[key] = props[key];
      }
    }
  }
  return result;
}
function memo$2(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => !isEqual(deps[index], dep));
    if (!depsChanged) return result;
    deps = newDeps;
    result = fn(...newDeps);
    return result;
  };
}
function createGuards() {
  return {
    and: (...guards2) => {
      return function andGuard(params) {
        return guards2.every((str) => params.guard(str));
      };
    },
    or: (...guards2) => {
      return function orGuard(params) {
        return guards2.some((str) => params.guard(str));
      };
    },
    not: (guard) => {
      return function notGuard(params) {
        return !params.guard(guard);
      };
    }
  };
}
function createMachine$1(config2) {
  return config2;
}
function setup() {
  return {
    guards: createGuards(),
    createMachine: (config2) => {
      return createMachine$1(config2);
    },
    choose: (transitions) => {
      return function chooseFn({ choose: choose2 }) {
        return choose2(transitions)?.actions;
      };
    }
  };
}
var MachineStatus = /* @__PURE__ */ ((MachineStatus2) => {
  MachineStatus2["NotStarted"] = "Not Started";
  MachineStatus2["Started"] = "Started";
  MachineStatus2["Stopped"] = "Stopped";
  return MachineStatus2;
})(MachineStatus || {});
var INIT_STATE = "__init__";
function createScope(props) {
  const getRootNode = () => props.getRootNode?.() ?? document;
  const getDoc = () => getDocument(getRootNode());
  const getWin = () => getDoc().defaultView ?? window;
  const getActiveElementFn = () => getActiveElement(getRootNode());
  const isActiveElement = (elem) => elem === getActiveElementFn();
  const getById = (id2) => getRootNode().getElementById(id2);
  return {
    ...props,
    getRootNode,
    getDoc,
    getWin,
    getActiveElement: getActiveElementFn,
    isActiveElement,
    getById
  };
}
function getRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
const withAsChild = (Component) => {
  const Comp = reactExports.memo(
    reactExports.forwardRef((props, ref) => {
      const { asChild, children, ...restProps } = props;
      if (!asChild) {
        return reactExports.createElement(Component, { ...restProps, ref }, children);
      }
      const onlyChild = reactExports.Children.only(children);
      if (!reactExports.isValidElement(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return reactExports.cloneElement(onlyChild, {
        ...mergeProps(restProps, onlyChild.props),
        ref: ref ? composeRefs(ref, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
const jsxFactory = () => {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache2.has(asElement)) {
        cache2.set(asElement, withAsChild(asElement));
      }
      return cache2.get(asElement);
    }
  });
};
const ark = jsxFactory();
const createSplitProps = () => (props, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props }]
);
const splitPresenceProps = (props) => createSplitProps()(props, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "skipAnimationOnMount",
  "unmountOnExit"
]);
function createNormalizer(fn) {
  return new Proxy({}, {
    get(_target, key) {
      if (key === "style")
        return (props) => {
          return fn({ style: props }).style;
        };
      return fn;
    }
  });
}
var createProps$1 = () => (props) => Array.from(new Set(props));
function connect$9(service, _normalize) {
  const { state, send, context } = service;
  const present = state.matches("mounted", "unmountSuspended");
  return {
    skip: !context.get("initial"),
    present,
    setNode(node2) {
      if (!node2) return;
      send({ type: "NODE.SET", node: node2 });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
var machine$9 = createMachine$1({
  props({ props: props2 }) {
    return { ...props2, present: !!props2.present };
  },
  initialState({ prop }) {
    return prop("present") ? "mounted" : "unmounted";
  },
  refs() {
    return {
      node: null,
      styles: null
    };
  },
  context({ bindable }) {
    return {
      unmountAnimationName: bindable(() => ({ defaultValue: null })),
      prevAnimationName: bindable(() => ({ defaultValue: null })),
      present: bindable(() => ({ defaultValue: false })),
      initial: bindable(() => ({
        sync: true,
        defaultValue: false
      }))
    };
  },
  exit: ["clearInitial", "cleanupNode"],
  watch({ track, action, prop }) {
    track([() => prop("present")], () => {
      action(["setInitial", "syncPresence"]);
    });
  },
  on: {
    "NODE.SET": {
      actions: ["setNode", "setStyles"]
    }
  },
  states: {
    mounted: {
      on: {
        UNMOUNT: {
          target: "unmounted",
          actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
        },
        "UNMOUNT.SUSPEND": {
          target: "unmountSuspended"
        }
      }
    },
    unmountSuspended: {
      effects: ["trackAnimationEvents"],
      on: {
        MOUNT: {
          target: "mounted",
          actions: ["setPrevAnimationName"]
        },
        UNMOUNT: {
          target: "unmounted",
          actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
        }
      }
    },
    unmounted: {
      on: {
        MOUNT: {
          target: "mounted",
          actions: ["setPrevAnimationName"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setInitial: ({ context }) => {
        if (context.get("initial")) return;
        queueMicrotask(() => {
          context.set("initial", true);
        });
      },
      clearInitial: ({ context }) => {
        context.set("initial", false);
      },
      cleanupNode: ({ refs }) => {
        refs.set("node", null);
        refs.set("styles", null);
      },
      invokeOnExitComplete: ({ prop }) => {
        prop("onExitComplete")?.();
      },
      setNode: ({ refs, event }) => {
        refs.set("node", event.node);
      },
      setStyles: ({ refs, event }) => {
        refs.set("styles", getComputedStyle$2(event.node));
      },
      syncPresence: ({ context, refs, send, prop }) => {
        const presentProp = prop("present");
        if (presentProp) {
          return send({ type: "MOUNT", src: "presence.changed" });
        }
        const node2 = refs.get("node");
        if (!presentProp && node2?.ownerDocument.visibilityState === "hidden") {
          return send({ type: "UNMOUNT", src: "visibilitychange" });
        }
        raf$1(() => {
          const animationName = getAnimationName(refs.get("styles"));
          context.set("unmountAnimationName", animationName);
          if (animationName === "none" || animationName === context.get("prevAnimationName") || refs.get("styles")?.display === "none" || refs.get("styles")?.animationDuration === "0s") {
            send({ type: "UNMOUNT", src: "presence.changed" });
          } else {
            send({ type: "UNMOUNT.SUSPEND" });
          }
        });
      },
      setPrevAnimationName: ({ context, refs }) => {
        raf$1(() => {
          context.set("prevAnimationName", getAnimationName(refs.get("styles")));
        });
      },
      clearPrevAnimationName: ({ context }) => {
        context.set("prevAnimationName", null);
      }
    },
    effects: {
      trackAnimationEvents: ({ context, refs, send }) => {
        const node2 = refs.get("node");
        if (!node2) return;
        const onStart = (event) => {
          const target = event.composedPath?.()?.[0] ?? event.target;
          if (target === node2) {
            context.set("prevAnimationName", getAnimationName(refs.get("styles")));
          }
        };
        const onEnd = (event) => {
          const animationName = getAnimationName(refs.get("styles"));
          const target = getEventTarget(event);
          if (target === node2 && animationName === context.get("unmountAnimationName")) {
            send({ type: "UNMOUNT", src: "animationend" });
          }
        };
        node2.addEventListener("animationstart", onStart);
        node2.addEventListener("animationcancel", onEnd);
        node2.addEventListener("animationend", onEnd);
        const cleanupStyles = setStyle(node2, { animationFillMode: "forwards" });
        return () => {
          node2.removeEventListener("animationstart", onStart);
          node2.removeEventListener("animationcancel", onEnd);
          node2.removeEventListener("animationend", onEnd);
          nextTick(() => cleanupStyles());
        };
      }
    }
  }
});
function getAnimationName(styles2) {
  return styles2?.animationName || "none";
}
createProps$1()(["onExitComplete", "present", "immediate"]);
var useSafeLayoutEffect$1 = typeof globalThis.document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useBindable(props) {
  const initial2 = props().value ?? props().defaultValue;
  const eq = props().isEqual ?? Object.is;
  const [initialValue] = reactExports.useState(initial2);
  const [value, setValue] = reactExports.useState(initialValue);
  const controlled = props().value !== void 0;
  const valueRef = reactExports.useRef(value);
  valueRef.current = controlled ? props().value : value;
  const prevValue = reactExports.useRef(valueRef.current);
  useSafeLayoutEffect$1(() => {
    prevValue.current = valueRef.current;
  }, [value, props().value]);
  const setFn = (value2) => {
    const prev2 = prevValue.current;
    const next2 = isFunction$1(value2) ? value2(prev2) : value2;
    if (props().debug) {
      console.log(`[bindable > ${props().debug}] setValue`, { next: next2, prev: prev2 });
    }
    if (!controlled) setValue(next2);
    if (!eq(next2, prev2)) {
      props().onChange?.(next2, prev2);
    }
  };
  function get2() {
    return controlled ? props().value : value;
  }
  return {
    initial: initialValue,
    ref: valueRef,
    get: get2,
    set(value2) {
      const exec = props().sync ? reactDomExports.flushSync : identity$2;
      exec(() => setFn(value2));
    },
    invoke(nextValue, prevValue2) {
      props().onChange?.(nextValue, prevValue2);
    },
    hash(value2) {
      return props().hash?.(value2) ?? String(value2);
    }
  };
}
useBindable.cleanup = (fn) => {
  reactExports.useEffect(() => fn, []);
};
useBindable.ref = (defaultValue) => {
  const value = reactExports.useRef(defaultValue);
  return {
    get: () => value.current,
    set: (next2) => {
      value.current = next2;
    }
  };
};
function useRefs(refs) {
  const ref = reactExports.useRef(refs);
  return {
    get(key) {
      return ref.current[key];
    },
    set(key, value) {
      ref.current[key] = value;
    }
  };
}
var useTrack = (deps, effect) => {
  const render = reactExports.useRef(false);
  const called = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const mounted = render.current;
    const run = mounted && called.current;
    if (run) return effect();
    called.current = true;
  }, [...(deps ?? []).map((d2) => typeof d2 === "function" ? d2() : d2)]);
  reactExports.useEffect(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
};
function useMachine(machine2, userProps = {}) {
  const scope = reactExports.useMemo(() => {
    const { id: id2, ids, getRootNode } = userProps;
    return createScope({ id: id2, ids, getRootNode });
  }, [userProps]);
  const debug = (...args) => {
    if (machine2.debug) console.log(...args);
  };
  const props = machine2.props?.({ props: compact(userProps), scope }) ?? userProps;
  const prop = useProp(props);
  const context = machine2.context?.({
    prop,
    bindable: useBindable,
    scope,
    flush,
    getContext() {
      return ctx;
    },
    getComputed() {
      return computed;
    },
    getRefs() {
      return refs;
    }
  });
  const contextRef = useLiveRef(context);
  const ctx = {
    get(key) {
      return contextRef.current?.[key].ref.current;
    },
    set(key, value) {
      contextRef.current?.[key].set(value);
    },
    initial(key) {
      return contextRef.current?.[key].initial;
    },
    hash(key) {
      const current = contextRef.current?.[key].get();
      return contextRef.current?.[key].hash(current);
    }
  };
  const effects = reactExports.useRef(/* @__PURE__ */ new Map());
  const transitionRef = reactExports.useRef(null);
  const previousEventRef = reactExports.useRef(null);
  const eventRef = reactExports.useRef({ type: "" });
  const getEvent = () => ({
    ...eventRef.current,
    current() {
      return eventRef.current;
    },
    previous() {
      return previousEventRef.current;
    }
  });
  const getState = () => ({
    ...state,
    matches(...values) {
      return values.includes(state.ref.current);
    },
    hasTag(tag) {
      return !!machine2.states[state.ref.current]?.tags?.includes(tag);
    }
  });
  const refs = useRefs(machine2.refs?.({ prop, context: ctx }) ?? {});
  const getParams = () => ({
    state: getState(),
    context: ctx,
    event: getEvent(),
    prop,
    send,
    action,
    guard,
    track: useTrack,
    refs,
    computed,
    flush,
    scope,
    choose: choose2
  });
  const action = (keys) => {
    const strs = isFunction$1(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine2.implementations?.actions?.[s];
      if (!fn) warn$1(`[zag-js] No implementation found for action "${JSON.stringify(s)}"`);
      return fn;
    });
    for (const fn of fns) {
      fn?.(getParams());
    }
  };
  const guard = (str) => {
    if (isFunction$1(str)) return str(getParams());
    return machine2.implementations?.guards?.[str](getParams());
  };
  const effect = (keys) => {
    const strs = isFunction$1(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine2.implementations?.effects?.[s];
      if (!fn) warn$1(`[zag-js] No implementation found for effect "${JSON.stringify(s)}"`);
      return fn;
    });
    const cleanups = [];
    for (const fn of fns) {
      const cleanup = fn?.(getParams());
      if (cleanup) cleanups.push(cleanup);
    }
    return () => cleanups.forEach((fn) => fn?.());
  };
  const choose2 = (transitions) => {
    return toArray(transitions).find((t2) => {
      let result = !t2.guard;
      if (isString$2(t2.guard)) result = !!guard(t2.guard);
      else if (isFunction$1(t2.guard)) result = t2.guard(getParams());
      return result;
    });
  };
  const computed = (key) => {
    ensure(machine2.computed, () => `[zag-js] No computed object found on machine`);
    const fn = machine2.computed[key];
    return fn({
      context: ctx,
      event: getEvent(),
      prop,
      refs,
      scope,
      computed
    });
  };
  const state = useBindable(() => ({
    defaultValue: machine2.initialState({ prop }),
    onChange(nextState, prevState) {
      if (prevState) {
        const exitEffects = effects.current.get(prevState);
        exitEffects?.();
        effects.current.delete(prevState);
      }
      if (prevState) {
        action(machine2.states[prevState]?.exit);
      }
      action(transitionRef.current?.actions);
      const cleanup = effect(machine2.states[nextState]?.effects);
      if (cleanup) effects.current.set(nextState, cleanup);
      if (prevState === INIT_STATE) {
        action(machine2.entry);
        const cleanup2 = effect(machine2.effects);
        if (cleanup2) effects.current.set(INIT_STATE, cleanup2);
      }
      action(machine2.states[nextState]?.entry);
    }
  }));
  const hydratedStateRef = reactExports.useRef(void 0);
  const statusRef = reactExports.useRef(MachineStatus.NotStarted);
  useSafeLayoutEffect$1(() => {
    queueMicrotask(() => {
      const started = statusRef.current === MachineStatus.Started;
      statusRef.current = MachineStatus.Started;
      debug(started ? "rehydrating..." : "initializing...");
      const initialState2 = hydratedStateRef.current ?? state.initial;
      state.invoke(initialState2, started ? state.get() : INIT_STATE);
    });
    const fns = effects.current;
    const currentState = state.ref.current;
    return () => {
      debug("unmounting...");
      hydratedStateRef.current = currentState;
      statusRef.current = MachineStatus.Stopped;
      fns.forEach((fn) => fn?.());
      effects.current = /* @__PURE__ */ new Map();
      transitionRef.current = null;
      queueMicrotask(() => {
        action(machine2.exit);
      });
    };
  }, []);
  const getCurrentState = () => {
    if ("ref" in state) return state.ref.current;
    return state.get();
  };
  const send = (event) => {
    queueMicrotask(() => {
      if (statusRef.current !== MachineStatus.Started) return;
      previousEventRef.current = eventRef.current;
      eventRef.current = event;
      debug("send", event);
      let currentState = getCurrentState();
      const transitions = (
        // @ts-ignore
        machine2.states[currentState].on?.[event.type] ?? // @ts-ignore
        machine2.on?.[event.type]
      );
      const transition = choose2(transitions);
      if (!transition) return;
      transitionRef.current = transition;
      const target = transition.target ?? currentState;
      debug("transition", transition);
      const changed = target !== currentState;
      if (changed) {
        reactDomExports.flushSync(() => state.set(target));
      } else if (transition.reenter && !changed) {
        state.invoke(currentState, currentState);
      } else {
        action(transition.actions ?? []);
      }
    });
  };
  machine2.watch?.(getParams());
  return {
    state: getState(),
    send,
    context: ctx,
    prop,
    scope,
    refs,
    computed,
    event: getEvent(),
    getStatus: () => statusRef.current
  };
}
function useLiveRef(value) {
  const ref = reactExports.useRef(value);
  ref.current = value;
  return ref;
}
function useProp(value) {
  const ref = useLiveRef(value);
  return function get2(key) {
    return ref.current[key];
  };
}
function flush(fn) {
  queueMicrotask(() => {
    reactDomExports.flushSync(() => fn());
  });
}
var normalizeProps = createNormalizer((v2) => v2);
function useEvent(callback, opts = {}) {
  const { sync = false } = opts;
  const callbackRef = useLatestRef(callback);
  return reactExports.useCallback(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      if (sync) return queueMicrotask(() => callbackRef.current?.(...args));
      return callbackRef.current?.(...args);
    },
    [sync, callbackRef]
  );
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  ref.current = value;
  return ref;
}
const usePresence = (props = {}) => {
  const { lazyMount, unmountOnExit, present, skipAnimationOnMount = false, ...rest } = props;
  const wasEverPresent = reactExports.useRef(false);
  const machineProps = {
    ...rest,
    present,
    onExitComplete: useEvent(props.onExitComplete)
  };
  const service = useMachine(machine$9, machineProps);
  const api = connect$9(service);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = () => ({
    "data-state": api.skip && skipAnimationOnMount ? void 0 : present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    ref: api.setNode,
    getPresenceProps,
    present: api.present,
    unmounted
  };
};
const [PresenceProvider, usePresenceContext] = createContext({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});
function useSlotRecipe(options2) {
  const { key, recipe: recipeProp } = options2;
  const sys = useChakraContext();
  return reactExports.useMemo(() => {
    const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
    return sys.sva(structuredClone(recipe));
  }, [key, recipeProp, sys]);
}
const upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const createSlotRecipeContext = (options2) => {
  const { key: recipeKey, recipe: recipeConfig } = options2;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [StylesProvider, useStyles] = createContext$1({
    name: `${contextName}StylesContext`,
    errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
  });
  const [ClassNamesProvider, useClassNames2] = createContext$1({
    name: `${contextName}ClassNameContext`,
    errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
    strict: false
  });
  const [PropsProvider, usePropsContext2] = createContext$1({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`,
    defaultValue: {}
  });
  function useRecipeResult2(props) {
    const { unstyled, ...restProps } = props;
    const slotRecipe = useSlotRecipe({
      key: recipeKey,
      recipe: restProps.recipe || recipeConfig
    });
    const [variantProps, otherProps] = reactExports.useMemo(
      () => slotRecipe.splitVariantProps(restProps),
      [restProps, slotRecipe]
    );
    const styles2 = reactExports.useMemo(
      () => unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps),
      [unstyled, variantProps, slotRecipe]
    );
    return {
      styles: styles2,
      classNames: slotRecipe.classNameMap,
      props: otherProps
    };
  }
  function withRootProvider2(Component, options22 = {}) {
    const { defaultProps } = options22;
    const StyledComponent = (inProps) => {
      const propsContext = usePropsContext2();
      const props = reactExports.useMemo(
        () => mergeProps$1(defaultProps, propsContext, inProps),
        [propsContext, inProps]
      );
      const { styles: styles2, classNames: classNames2, props: rootProps } = useRecipeResult2(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StylesProvider, { value: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClassNamesProvider, { value: classNames2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...rootProps }) }) });
    };
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  }
  const withProvider2 = (Component, slot, options22) => {
    const { defaultProps, ...restOptions } = options22 ?? {};
    const SuperComponent = chakra(Component, {}, restOptions);
    const StyledComponent = reactExports.forwardRef((inProps, ref) => {
      const propsContext = usePropsContext2();
      const props = reactExports.useMemo(
        () => mergeProps$1(defaultProps ?? {}, propsContext, inProps),
        [propsContext, inProps]
      );
      const { styles: styles2, props: rootProps, classNames: classNames2 } = useRecipeResult2(props);
      const className = classNames2[slot];
      const element = /* @__PURE__ */ jsxRuntimeExports.jsx(StylesProvider, { value: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClassNamesProvider, { value: classNames2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ref,
          ...rootProps,
          css: [styles2[slot], props.css],
          className: cx(props.className, className)
        }
      ) }) });
      return options22?.wrapElement?.(element, props) ?? element;
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  const withContext2 = (Component, slot, options22) => {
    const SuperComponent = chakra(Component, {}, options22);
    const StyledComponent = reactExports.forwardRef((props, ref) => {
      const styles2 = useStyles();
      const classNames2 = useClassNames2();
      const className = classNames2?.[slot];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SuperComponent,
        {
          ...props,
          css: [slot ? styles2[slot] : void 0, props.css],
          ref,
          className: cx(props.className, className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    StylesProvider,
    ClassNamesProvider,
    PropsProvider,
    usePropsContext: usePropsContext2,
    useRecipeResult: useRecipeResult2,
    withProvider: withProvider2,
    withContext: withContext2,
    withRootProvider: withRootProvider2,
    useStyles,
    useClassNames: useClassNames2
  };
};
const CheckIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 6 9 17l-5-5" })
    }
  );
};
const ChevronUpIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.svg,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m18 15-6-6-6 6" })
  }
);
const ChevronDownIcon = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.svg,
    {
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m6 9 6 6 6-6" })
    }
  );
};
const CheckCircleIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11.0026 16L6.75999 11.7574L8.17421 10.3431L11.0026 13.1716L16.6595 7.51472L18.0737 8.92893L11.0026 16Z" })
  }
);
const WarningIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 24 24",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" })
  }
);
const CloseIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) });
const CopyIcon = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  chakra.svg,
  {
    stroke: "currentColor",
    fill: "none",
    strokeWidth: "2",
    viewBox: "0 0 24 24",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" })
    ]
  }
);
function useCallbackRef(callback, deps = []) {
  const callbackRef = reactExports.useRef(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  reactExports.useInsertionEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useCallback((...args) => callbackRef.current?.(...args), deps);
}
function useDisclosure(props = {}) {
  const handleOpen = useCallbackRef(props.onOpen);
  const handleClose = useCallbackRef(props.onClose);
  const [openState, setOpen] = reactExports.useState(props.defaultOpen || false);
  const open = props.open !== void 0 ? props.open : openState;
  const controlled = props.open !== void 0;
  const onClose = reactExports.useCallback(() => {
    if (!controlled) setOpen(false);
    handleClose?.();
  }, [controlled, handleClose]);
  const onOpen = reactExports.useCallback(() => {
    if (!controlled) setOpen(true);
    handleOpen?.();
  }, [controlled, handleOpen]);
  const onToggle = reactExports.useCallback(() => {
    if (open) {
      onClose();
    } else {
      onOpen();
    }
  }, [open, onOpen, onClose]);
  return {
    open,
    onOpen,
    onClose,
    onToggle,
    setOpen
  };
}
var createAnatomy = (name2, parts2 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts2)) {
      return createAnatomy(name2, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name2, [...parts2, ...values]),
  rename: (newName) => createAnatomy(newName, parts2),
  keys: () => parts2,
  build: () => [...new Set(parts2)].reduce(
    (prev2, part) => Object.assign(prev2, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name2)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name2)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name2), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v2) => v2.length === 0;
var anatomy$n = createAnatomy("collapsible").parts("root", "trigger", "content", "indicator");
anatomy$n.build();
createProps$1()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "defaultOpen",
  "open"
]);
const [EnvironmentContextProvider, useEnvironmentContext] = createContext({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref2, placement, rtl) {
  let {
    reference,
    floating
  } = _ref2;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$1 = (options2) => ({
  name: "arrow",
  options: options2,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options2, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$12 = minPadding;
    const max2 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset2 = clamp(min$12, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length2] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$1 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options2, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$1 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "hide",
    options: options2,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options2, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(options2) {
  if (options2 === void 0) {
    options2 = 0;
  }
  return {
    name: "offset",
    options: options2,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options2);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$1 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "shift",
    options: options2,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref2) => {
            let {
              x: x3,
              y: y3
            } = _ref2;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$1 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    options: options2,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options2, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$1 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "size",
    options: options2,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode$1(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref2;
  return (_ref2 = (isNode$1(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref2.documentElement;
}
function isNode$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement$1(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode$1(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode$1(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode$1(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode$1(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css2 = getComputedStyle$1(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement$1(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$1(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref2) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref2;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement$1(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode$1(element);
  if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement$1(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode$1(element) : element;
  while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode$1(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref2) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref2;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode$1(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement$1(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode$1(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$1,
  isRTL
};
function rectsAreEqual(a, b2) {
  return a.x === b2.x && a.y === b2.y && a.width === b2.width && a.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref2) => {
      let [firstEntry] = _ref2;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset = offset$1;
const shift = shift$1;
const flip = flip$1;
const size = size$1;
const hide = hide$1;
const arrow = arrow$1;
const limitShift = limitShift$1;
const computePosition = (reference, floating, options2) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options2
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function createDOMRect(x2 = 0, y2 = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x2, y2, width, height);
  }
  const rect = {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x: x2, y: y2, width, height } = anchorRect;
  return createDOMRect(x2, y2, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement$1(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect?.(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2) => ({
  top: "bottom center",
  "top-start": arrow2 ? `${arrow2.x}px bottom` : "left bottom",
  "top-end": arrow2 ? `${arrow2.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow2 ? `${arrow2.x}px top` : "top left",
  "bottom-end": arrow2 ? `${arrow2.x}px top` : "top right",
  left: "right center",
  "left-start": arrow2 ? `right ${arrow2.y}px` : "right top",
  "left-end": arrow2 ? `right ${arrow2.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow2 ? `left ${arrow2.y}px` : "left top",
  "right-end": arrow2 ? `left ${arrow2.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow2 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow2)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x: x2, y: y2 } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x2 != null ? `${x2}px` : "",
        top: y2 != null ? `${y2}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}
var defaultOptions$3 = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset(({ placement }) => {
    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;
    const gutter = opts.offset?.mainAxis ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift2 = !hasAlign ? opts.shift : void 0;
    const crossAxis = opts.offset?.crossAxis ?? shift2;
    return compact({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift()
  });
}
function getSizeMiddleware(opts) {
  return size({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  if (!opts.hideWhenDetached) return;
  return hide({ strategy: "referenceHidden", boundary: opts.boundary?.() ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options2 = Object.assign({}, defaultOptions$3, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware2 = [
    getOffsetMiddleware(arrowEl, options2),
    getFlipMiddleware(options2),
    getShiftMiddleware(options2),
    getArrowMiddleware(arrowEl, options2),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options2),
    hideWhenDetachedMiddleware(options2),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options2;
  const updatePosition = async () => {
    if (!reference || !floating) return;
    const pos = await computePosition(reference, floating, {
      placement,
      middleware: middleware2,
      strategy
    });
    onComplete?.(pos);
    onPositioned?.({ placed: true });
    const win = getWindow$1(floating);
    const x2 = roundByDpr(win, pos.x);
    const y2 = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x2}px`);
    floating.style.setProperty("--y", `${y2}px`);
    if (options2.hideWhenDetached) {
      const isHidden = pos.middlewareData.hide?.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles2 = getComputedStyle$2(contentEl);
      floating.style.setProperty("--z-index", styles2.zIndex);
    }
  };
  const update2 = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned?.({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options2.listeners);
  const cancelAutoUpdate = options2.listeners ? autoUpdate(reference, floating, update2, autoUpdateOptions) : noop$4;
  update2();
  return () => {
    cancelAutoUpdate?.();
    onPositioned?.({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer: defer2, ...options2 } = opts;
  const func = defer2 ? raf$1 : (v2) => v2();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups.push(getPlacementImpl(reference, floating, options2));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options2 = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options2;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      pointerEvents: !placement ? "none" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}
function getWindowFrames(win) {
  const frames = {
    each(cb2) {
      for (let i = 0; i < win.frames?.length; i += 1) {
        const frame = win.frames[i];
        if (frame) cb2(frame);
      }
    },
    addEventListener(event, listener3, options2) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener3, options2);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener3, options2);
        } catch {
        }
      };
    },
    removeEventListener(event, listener3, options2) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener3, options2);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener3, options2) => {
      try {
        parent?.addEventListener(event, listener3, options2);
      } catch {
      }
      return () => {
        try {
          parent?.removeEventListener(event, listener3, options2);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener3, options2) => {
      try {
        parent?.removeEventListener(event, listener3, options2);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node2 of composedPath) {
    if (isHTMLElement$1(node2) && isFocusable(node2)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node2, event) {
  if (!isPointerEvent(event) || !node2) return false;
  const rect = node2.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node2, options2) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer: defer2 } = options2;
  if (!node2) return;
  const doc = getDocument(node2);
  const win = getWindow$1(node2);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event, target) {
    if (!isHTMLElement$1(target)) return false;
    if (!target.isConnected) return false;
    if (contains(node2, target)) return false;
    if (isEventPointWithin(node2, event)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node2.id}"]`);
    if (triggerEl) {
      const triggerAncestor = getNearestOverflowAncestor$1(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = getNearestOverflowAncestor$1(node2);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !exclude?.(target);
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  const isInShadowRoot = isShadowRoot$1(node2?.getRootNode());
  function onPointerDown(event) {
    function handler(clickEvent) {
      const func = defer2 && !isTouchDevice() ? raf$1 : (v2) => v2();
      const evt = clickEvent ?? event;
      const composedPath = evt?.composedPath?.() ?? [evt?.target];
      func(() => {
        const target = isInShadowRoot ? composedPath[0] : getEventTarget(event);
        if (!node2 || !isEventOutside(event, target)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll(onPointerDownOutside, onInteractOutside);
          node2.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node2, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: evt,
            contextmenu: isContextMenuEvent(evt),
            focusable: isComposedPathFocusable(composedPath),
            target
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer2 ? raf$1 : (v2) => v2();
    func(() => {
      const target = getEventTarget(event);
      if (!node2 || !isEventOutside(event, target)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll(onFocusOutside, onInteractOutside);
        node2.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node2, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(target),
          target
        }
      });
    });
  }
  if (!isTouchDevice()) {
    cleanups.add(addDomEvent(doc, "focusin", onFocusin, true));
    cleanups.add(parentWin.addEventListener("focusin", onFocusin, true));
    cleanups.add(frames.addEventListener("focusin", onFocusin, true));
  }
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options2) {
  const { defer: defer2 } = options2;
  const func = defer2 ? raf$1 : (v2) => v2();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackInteractOutsideImpl(node2, options2));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function fireCustomEvent(el2, type, init) {
  const win = el2.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el2.dispatchEvent(event);
}
function trackEscapeKeydown(node2, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn?.(event);
  };
  return addDomEvent(getDocument(node2), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node2) {
    const index = this.indexOf(node2);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf(this.topMostPointerBlockingLayer()?.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node2) {
    const layer = this.layers[this.count() - 1];
    return layer?.node === node2;
  },
  getNestedLayers(node2) {
    return Array.from(this.layers).slice(this.indexOf(node2) + 1);
  },
  isInNestedLayer(node2, target) {
    return this.getNestedLayers(node2).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node2) {
    this.branches.push(node2);
  },
  remove(node2) {
    const index = this.indexOf(node2);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node2);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node2.style.removeProperty("--layer-index");
  },
  removeBranch(node2) {
    const index = this.branches.indexOf(node2);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node2) {
    return this.layers.findIndex((layer) => layer.node === node2);
  },
  dismiss(node2) {
    this.layers[this.indexOf(node2)]?.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node: node2 }) => {
    node2.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node2) ? "none" : "auto";
  });
}
function clearPointerEvent(node2) {
  node2.style.pointerEvents = "";
}
function disablePointerEventsOutside(node2, persistentElements) {
  const doc = getDocument(node2);
  const cleanups = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (persistentElements) {
    const persistedCleanup = waitForElements(persistentElements, (el2) => {
      cleanups.push(setStyle(el2, { pointerEvents: "auto" }));
    });
    cleanups.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node2, options2) {
  const { warnOnMissingNode = true } = options2;
  if (warnOnMissingNode && !node2) {
    warn$1("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  if (!node2) {
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options2;
  const layer = { dismiss: onDismiss, node: node2, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node2) || layerStack.isInBranch(target)) return;
    options2.onPointerDownOutside?.(event);
    options2.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onFocusOutside(event) {
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    options2.onFocusOutside?.(event);
    options2.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onEscapeKeyDown(event) {
    if (!layerStack.isTopMost(node2)) return;
    options2.onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    if (!node2) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = options2.persistentElements?.map((fn) => fn()).filter(isHTMLElement$1);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node22) => contains(node22, target)) || layerStack.isInNestedLayer(node2, target);
  }
  const cleanups = [
    pointerBlocking ? disablePointerEventsOutside(node2, options2.persistentElements) : void 0,
    trackEscapeKeydown(node2, onEscapeKeyDown),
    trackInteractOutside(node2, { exclude, onFocusOutside, onPointerDownOutside, defer: options2.defer })
  ];
  return () => {
    layerStack.remove(node2);
    assignPointerEventToLayers();
    clearPointerEvent(node2);
    cleanups.forEach((fn) => fn?.());
  };
}
function trackDismissableElement(nodeOrFn, options2) {
  const { defer: defer2 } = options2;
  const func = defer2 ? raf$1 : (v2) => v2();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node2 = isFunction$1(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups.push(trackDismissableElementImpl(node2, options2));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
function trackDismissableBranch(nodeOrFn, options2 = {}) {
  const { defer: defer2 } = options2;
  const func = defer2 ? raf$1 : (v2) => v2();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const node2 = isFunction$1(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node2) {
        warn$1("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node2);
      cleanups.push(() => {
        layerStack.removeBranch(node2);
      });
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
var anatomy$m = createAnatomy("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "valueText",
  "areaBackground",
  "channelSlider",
  "channelSliderLabel",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelSliderValueText",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
anatomy$m.build();
createProps$1()([
  "closeOnSelect",
  "dir",
  "disabled",
  "format",
  "defaultFormat",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "name",
  "positioning",
  "onFocusOutside",
  "onFormatChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "onValueChangeEnd",
  "defaultOpen",
  "open",
  "positioning",
  "required",
  "readOnly",
  "value",
  "defaultValue",
  "invalid",
  "openAutoFocus"
]);
createProps$1()(["xChannel", "yChannel"]);
createProps$1()(["channel", "orientation"]);
createProps$1()(["value", "disabled"]);
createProps$1()(["value", "respectAlpha"]);
createProps$1()(["size"]);
const [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
const splitRenderStrategyProps = (props) => createSplitProps()(props, ["lazyMount", "unmountOnExit"]);
var anatomy$l = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
anatomy$l.build();
createProps$1()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value",
  "defaultValue"
]);
createProps$1()(["value", "disabled"]);
var anatomy$k = createAnatomy("avatar").parts("root", "image", "fallback");
anatomy$k.build();
createProps$1()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
function isValidKey(e2) {
  return !(e2.metaKey || !isMac() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e2) {
  const target = e2 ? getEventTarget(e2) : null;
  const win = getWindow$1(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target?.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e2 instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e2.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e2) {
  for (let handler of changeHandlers) {
    handler(modality, e2);
  }
}
function handleKeyboardEvent(e2) {
  hasEventBeforeFocus = true;
  if (isValidKey(e2)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e2);
  }
}
function handlePointerEvent(e2) {
  currentModality = "pointer";
  if (e2.type === "mousedown" || e2.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e2);
  }
}
function handleClickEvent(e2) {
  if (isVirtualClick(e2)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e2) {
  const target = getEventTarget(e2);
  if (target === getWindow$1(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e2);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get(getWindow$1(root))) {
    return;
  }
  const win = getWindow$1(root);
  const doc = getDocument(root);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = getWindow$1(root);
  const doc = getDocument(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props = {}) {
  const { isTextInput, autoFocus, onChange, root } = props;
  setupGlobalFocusEvents(root);
  onChange?.({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e2) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e2)) return;
    onChange?.({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}
var anatomy$j = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
anatomy$j.build();
createProps$1()([
  "defaultChecked",
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
const checkboxAnatomy = anatomy$j.extendWith("group");
const [FieldProvider, useFieldContext] = createContext({
  name: "FieldContext",
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});
const [ClipboardProvider, useClipboardContext] = createContext({
  name: "ClipboardContext",
  hookName: "useClipboardContext",
  providerName: "<ClipboardProvider />"
});
const ClipboardControl = reactExports.forwardRef((props, ref) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getControlProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
ClipboardControl.displayName = "ClipboardControl";
const ClipboardIndicator$1 = reactExports.forwardRef((props, ref) => {
  const { children, copied, ...localProps } = props;
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getIndicatorProps({ copied: clipboard.copied }), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref, children: clipboard.copied ? copied : children });
});
ClipboardIndicator$1.displayName = "ClipboardIndicator";
const ClipboardInput$1 = reactExports.forwardRef((props, ref) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getInputProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { ...mergedProps, ref });
});
ClipboardInput$1.displayName = "ClipboardInput";
const ClipboardLabel$1 = reactExports.forwardRef((props, ref) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref });
});
ClipboardLabel$1.displayName = "ClipboardLabel";
var anatomy$i = createAnatomy("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
var parts$9 = anatomy$i.build();
var getRootId$5 = (ctx) => ctx.ids?.root ?? `clip:${ctx.id}`;
var getInputId$1 = (ctx) => ctx.ids?.input ?? `clip:${ctx.id}:input`;
var getLabelId$3 = (ctx) => ctx.ids?.label ?? `clip:${ctx.id}:label`;
var getInputEl$1 = (ctx) => ctx.getById(getInputId$1(ctx));
var writeToClipboard = (ctx, value) => copyText(ctx.getDoc(), value);
function createNode(doc, text) {
  const node2 = doc.createElement("pre");
  Object.assign(node2.style, {
    width: "1px",
    height: "1px",
    position: "fixed",
    top: "5px"
  });
  node2.textContent = text;
  return node2;
}
function copyNode(node2) {
  const win = getWindow$1(node2);
  const selection = win.getSelection();
  if (selection == null) {
    return Promise.reject(new Error());
  }
  selection.removeAllRanges();
  const doc = node2.ownerDocument;
  const range = doc.createRange();
  range.selectNodeContents(node2);
  selection.addRange(range);
  doc.execCommand("copy");
  selection.removeAllRanges();
  return Promise.resolve();
}
function copyText(doc, text) {
  const win = doc.defaultView || window;
  if (win.navigator.clipboard?.writeText !== void 0) {
    return win.navigator.clipboard.writeText(text);
  }
  if (!doc.body) {
    return Promise.reject(new Error());
  }
  const node2 = createNode(doc, text);
  doc.body.appendChild(node2);
  copyNode(node2);
  doc.body.removeChild(node2);
  return Promise.resolve();
}
function connect$8(service, normalize2) {
  const { state, send, context, scope } = service;
  const copied = state.matches("copied");
  return {
    copied,
    value: context.get("value"),
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    copy() {
      send({ type: "COPY" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts$9.root.attrs,
        "data-copied": dataAttr$1(copied),
        id: getRootId$5(scope)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts$9.label.attrs,
        htmlFor: getInputId$1(scope),
        "data-copied": dataAttr$1(copied),
        id: getLabelId$3(scope)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts$9.control.attrs,
        "data-copied": dataAttr$1(copied)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts$9.input.attrs,
        defaultValue: context.get("value"),
        "data-copied": dataAttr$1(copied),
        readOnly: true,
        "data-readonly": "true",
        id: getInputId$1(scope),
        onFocus(event) {
          event.currentTarget.select();
        },
        onCopy() {
          send({ type: "INPUT.COPY" });
        }
      });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts$9.trigger.attrs,
        type: "button",
        "aria-label": copied ? "Copied to clipboard" : "Copy to clipboard",
        "data-copied": dataAttr$1(copied),
        onClick() {
          send({ type: "COPY" });
        }
      });
    },
    getIndicatorProps(props2) {
      return normalize2.element({
        ...parts$9.indicator.attrs,
        hidden: props2.copied !== copied
      });
    }
  };
}
var machine$8 = createMachine$1({
  props({ props: props2 }) {
    return {
      timeout: 3e3,
      defaultValue: "",
      ...props2
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      }))
    };
  },
  watch({ track, context, action }) {
    track([() => context.get("value")], () => {
      action(["syncInputElement"]);
    });
  },
  on: {
    "VALUE.SET": {
      actions: ["setValue"]
    },
    COPY: {
      target: "copied",
      actions: ["copyToClipboard", "invokeOnCopy"]
    }
  },
  states: {
    idle: {
      on: {
        "INPUT.COPY": {
          target: "copied",
          actions: ["invokeOnCopy"]
        }
      }
    },
    copied: {
      effects: ["waitForTimeout"],
      on: {
        "COPY.DONE": {
          target: "idle"
        },
        COPY: {
          target: "copied",
          actions: ["copyToClipboard", "invokeOnCopy"]
        },
        "INPUT.COPY": {
          actions: ["invokeOnCopy"]
        }
      }
    }
  },
  implementations: {
    effects: {
      waitForTimeout({ prop, send }) {
        return setRafTimeout(() => {
          send({ type: "COPY.DONE" });
        }, prop("timeout"));
      }
    },
    actions: {
      setValue({ context, event }) {
        context.set("value", event.value);
      },
      copyToClipboard({ context, scope }) {
        writeToClipboard(scope, context.get("value"));
      },
      invokeOnCopy({ prop }) {
        prop("onStatusChange")?.({ copied: true });
      },
      syncInputElement({ context, scope }) {
        const inputEl = getInputEl$1(scope);
        if (!inputEl) return;
        setElementValue(inputEl, context.get("value"));
      }
    }
  }
});
createProps$1()([
  "getRootNode",
  "id",
  "ids",
  "value",
  "defaultValue",
  "timeout",
  "onStatusChange",
  "onValueChange"
]);
createProps$1()(["copied"]);
const useClipboard = (props) => {
  const id2 = reactExports.useId();
  const { getRootNode } = useEnvironmentContext();
  const machineProps = {
    id: id2,
    getRootNode,
    ...props
  };
  const service = useMachine(machine$8, machineProps);
  return connect$8(service, normalizeProps);
};
const ClipboardRoot$2 = reactExports.forwardRef((props, ref) => {
  const [useClipboardProps, localProps] = createSplitProps()(props, [
    "defaultValue",
    "id",
    "ids",
    "onStatusChange",
    "onValueChange",
    "timeout",
    "value"
  ]);
  const clipboard = useClipboard(useClipboardProps);
  const mergedProps = mergeProps(clipboard.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardProvider, { value: clipboard, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ref, ...mergedProps }) });
});
ClipboardRoot$2.displayName = "ClipboardRoot";
const ClipboardRootProvider = reactExports.forwardRef((props, ref) => {
  const [{ value: clipboard }, localProps] = createSplitProps()(props, ["value"]);
  const mergedProps = mergeProps(clipboard.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardProvider, { value: clipboard, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ref, ...mergedProps }) });
});
ClipboardRootProvider.displayName = "ClipboardRootProvider";
const ClipboardTrigger$1 = reactExports.forwardRef((props, ref) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
ClipboardTrigger$1.displayName = "ClipboardTrigger";
const ClipboardValueText = reactExports.forwardRef((props, ref) => {
  const clipboard = useClipboardContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...props, ref, children: props.children || clipboard.value });
});
ClipboardValueText.displayName = "ClipboardValueText";
const colorPickerAnatomy$1 = anatomy$m.extendWith("view");
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback$1 = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject$2(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject$2(item) && hasProp(item, "label")) return item.label;
    return fallback$1.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject$2(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var ListCollection = class _ListCollection {
  constructor(options2) {
    this.options = options2;
    __publicField$1(this, "items");
    __publicField$1(this, "copy", (items) => {
      return new _ListCollection({ ...this.options, items: items ?? [...this.items] });
    });
    __publicField$1(this, "isEqual", (other) => {
      return isEqual(this.items, other.items);
    });
    __publicField$1(this, "setItems", (items) => {
      return this.copy(items);
    });
    __publicField$1(this, "getValues", (items = this.items) => {
      return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
    });
    __publicField$1(this, "find", (value) => {
      if (value == null) return null;
      const index = this.items.findIndex((item) => this.getItemValue(item) === value);
      return index != null ? this.items[index] : null;
    });
    __publicField$1(this, "findMany", (values) => {
      return Array.from(values).map((value) => this.find(value)).filter((item) => item != null);
    });
    __publicField$1(this, "at", (index) => {
      return this.items[index] ?? null;
    });
    __publicField$1(this, "sortFn", (valueA, valueB) => {
      const indexA = this.indexOf(valueA);
      const indexB = this.indexOf(valueB);
      return (indexA ?? 0) - (indexB ?? 0);
    });
    __publicField$1(this, "sort", (values) => {
      return [...values].sort(this.sortFn.bind(this));
    });
    __publicField$1(this, "getItemValue", (item) => {
      if (item == null) return null;
      return this.options.itemToValue?.(item) ?? fallback$1.itemToValue(item);
    });
    __publicField$1(this, "getItemDisabled", (item) => {
      if (item == null) return false;
      return this.options.isItemDisabled?.(item) ?? fallback$1.isItemDisabled(item);
    });
    __publicField$1(this, "stringifyItem", (item) => {
      if (item == null) return null;
      return this.options.itemToString?.(item) ?? fallback$1.itemToString(item);
    });
    __publicField$1(this, "stringify", (value) => {
      if (value == null) return null;
      return this.stringifyItem(this.find(value));
    });
    __publicField$1(this, "stringifyItems", (items, separator = ", ") => {
      return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
    });
    __publicField$1(this, "stringifyMany", (value, separator) => {
      return this.stringifyItems(this.findMany(value), separator);
    });
    __publicField$1(this, "has", (value) => {
      return this.indexOf(value) !== -1;
    });
    __publicField$1(this, "hasItem", (item) => {
      if (item == null) return false;
      return this.has(this.getItemValue(item));
    });
    __publicField$1(this, "getNextValue", (value, step = 1, clamp2 = false) => {
      let index = this.indexOf(value);
      if (index === -1) return null;
      index = clamp2 ? Math.min(index + step, this.size - 1) : index + step;
      while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
      return this.getItemValue(this.at(index));
    });
    __publicField$1(this, "getPreviousValue", (value, step = 1, clamp2 = false) => {
      let index = this.indexOf(value);
      if (index === -1) return null;
      index = clamp2 ? Math.max(index - step, 0) : index - step;
      while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
      return this.getItemValue(this.at(index));
    });
    __publicField$1(this, "indexOf", (value) => {
      if (value == null) return -1;
      return this.items.findIndex((item) => this.getItemValue(item) === value);
    });
    __publicField$1(this, "getByText", (text, current) => {
      let items = current != null ? wrap$1(this.items, this.indexOf(current)) : this.items;
      const isSingleKey = text.length === 1;
      if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
      return items.find((item) => match$1(this.stringifyItem(item), text));
    });
    __publicField$1(this, "search", (queryString, options3) => {
      const { state, currentValue, timeout = 350 } = options3;
      const search = state.keysSoFar + queryString;
      const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
      const query = isRepeated ? search[0] : search;
      const item = this.getByText(query, currentValue);
      const value = this.getItemValue(item);
      function cleanup() {
        clearTimeout(state.timer);
        state.timer = -1;
      }
      function update2(value2) {
        state.keysSoFar = value2;
        cleanup();
        if (value2 !== "") {
          state.timer = +setTimeout(() => {
            update2("");
            cleanup();
          }, timeout);
        }
      }
      update2(search);
      return value;
    });
    __publicField$1(this, "update", (value, item) => {
      let index = this.items.findIndex((item2) => this.getItemValue(item2) === value);
      if (index === -1) return this;
      return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);
    });
    __publicField$1(this, "insert", (index, ...items) => {
      return this.copy(insert(this.items, index, ...items));
    });
    __publicField$1(this, "insertBefore", (value, ...items) => {
      let toIndex = this.indexOf(value);
      if (toIndex === -1) {
        if (this.items.length === 0) toIndex = 0;
        else return this;
      }
      return this.copy(insert(this.items, toIndex, ...items));
    });
    __publicField$1(this, "insertAfter", (value, ...items) => {
      let toIndex = this.indexOf(value);
      if (toIndex === -1) {
        if (this.items.length === 0) toIndex = 0;
        else return this;
      }
      return this.copy(insert(this.items, toIndex + 1, ...items));
    });
    __publicField$1(this, "prepend", (...items) => {
      return this.copy(insert(this.items, 0, ...items));
    });
    __publicField$1(this, "append", (...items) => {
      return this.copy(insert(this.items, this.items.length, ...items));
    });
    __publicField$1(this, "remove", (...itemsOrValues) => {
      const values = itemsOrValues.map(
        (itemOrValue) => typeof itemOrValue === "string" ? itemOrValue : this.getItemValue(itemOrValue)
      );
      return this.copy(
        this.items.filter((item) => {
          const value = this.getItemValue(item);
          if (value == null) return false;
          return !values.includes(value);
        })
      );
    });
    __publicField$1(this, "move", (value, toIndex) => {
      const fromIndex = this.indexOf(value);
      if (fromIndex === -1) return this;
      return this.copy(move(this.items, [fromIndex], toIndex));
    });
    __publicField$1(this, "reorder", (fromIndex, toIndex) => {
      return this.copy(move(this.items, [fromIndex], toIndex));
    });
    __publicField$1(this, "compareValue", (a, b2) => {
      const indexA = this.indexOf(a);
      const indexB = this.indexOf(b2);
      if (indexA < indexB) return -1;
      if (indexA > indexB) return 1;
      return 0;
    });
    __publicField$1(this, "range", (from2, to) => {
      let keys = [];
      let key = from2;
      while (key != null) {
        let item = this.find(key);
        if (item) keys.push(key);
        if (key === to) return keys;
        key = this.getNextValue(key);
      }
      return [];
    });
    __publicField$1(this, "getValueRange", (from2, to) => {
      if (from2 && to) {
        if (this.compareValue(from2, to) <= 0) {
          return this.range(from2, to);
        }
        return this.range(to, from2);
      }
      return [];
    });
    __publicField$1(this, "toString", () => {
      let result = "";
      for (const item of this.items) {
        const value = this.getItemValue(item);
        const label = this.stringifyItem(item);
        const disabled = this.getItemDisabled(item);
        const itemString = [value, label, disabled].filter(Boolean).join(":");
        result += itemString + ",";
      }
      return result;
    });
    __publicField$1(this, "toJSON", () => {
      return {
        size: this.size,
        first: this.firstValue,
        last: this.lastValue
      };
    });
    this.items = [...options2.items];
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
};
var match$1 = (label, query) => {
  return !!label?.toLowerCase().startsWith(query.toLowerCase());
};
var wrap$1 = (v2, idx) => {
  return v2.map((_, index) => v2[(Math.max(idx, 0) + index) % v2.length]);
};
function insert(items, index, ...values) {
  return [...items.slice(0, index), ...values, ...items.slice(index)];
}
function move(items, indices, toIndex) {
  indices = [...indices].sort((a, b2) => a - b2);
  const itemsToMove = indices.map((i) => items[i]);
  for (let i = indices.length - 1; i >= 0; i--) {
    items = [...items.slice(0, indices[i]), ...items.slice(indices[i] + 1)];
  }
  toIndex = Math.max(0, toIndex - indices.filter((i) => i < toIndex).length);
  return [...items.slice(0, toIndex), ...itemsToMove, ...items.slice(toIndex)];
}
const createListCollection = (options2) => new ListCollection(options2);
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node2) => node2 && (node2.host || unwrapHost(node2.parentNode));
var correctTargets = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
  return null;
}).filter((x2) => Boolean(x2));
var isIgnoredNode = (node2) => {
  if (node2.localName === "next-route-announcer") return true;
  if (node2.localName === "script") return true;
  if (node2.hasAttribute("aria-live")) return true;
  return node2.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props) => {
  const { parentNode, markerName, controlAttribute } = props;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el2) => {
    if (!el2 || elementsToKeep.has(el2)) return;
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node2) => {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        try {
          if (isIgnoredNode(node2)) return;
          const attr = node2.getAttribute(controlAttribute);
          const alreadyHidden = attr === "true";
          const counterValue = (counterMap.get(node2) || 0) + 1;
          const markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenNodes.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node2, true);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node2.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node2, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node2) => {
      const counterValue = counterMap.get(node2) - 1;
      const markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var getParentNode = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode(originalTarget), markerName = "data-aria-hidden") => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden"
  });
};
var raf = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options2 = {}) {
  const { defer: defer2 = true } = options2;
  const func = defer2 ? raf : (v2) => v2();
  const cleanups = [];
  cleanups.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements = targets.filter(Boolean);
      if (elements.length === 0) return;
      cleanups.push(hideOthers(elements));
    })
  );
  return () => {
    cleanups.forEach((fn) => fn?.());
  };
}
const [DialogProvider, useDialogContext] = createContext({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});
const DialogBackdrop = reactExports.forwardRef((props, ref) => {
  const dialog = useDialogContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = mergeProps(dialog.getBackdropProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
DialogBackdrop.displayName = "DialogBackdrop";
const DialogCloseTrigger = reactExports.forwardRef((props, ref) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getCloseTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
DialogCloseTrigger.displayName = "DialogCloseTrigger";
const DialogContent = reactExports.forwardRef((props, ref) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(dialog.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
DialogContent.displayName = "DialogContent";
const DialogDescription = reactExports.forwardRef((props, ref) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getDescriptionProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
DialogDescription.displayName = "DialogDescription";
const DialogPositioner = reactExports.forwardRef((props, ref) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getPositionerProps(), props);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
DialogPositioner.displayName = "DialogPositioner";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements, options2) {
    __publicField(this, "trapStack");
    __publicField(this, "config");
    __publicField(this, "doc");
    __publicField(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField(this, "listenerCleanups", []);
    __publicField(this, "handleFocus", (event) => {
      const target = getEventTarget(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || isDocument(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node2) => node2 === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g2) => g2.tabbableNodes.some((n2) => getTabIndex(n2) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField(this, "handlePointerDown", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField(this, "handleClick", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField(this, "_mutationObserver");
    __publicField(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node2) => node2 === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
      });
    });
    __publicField(this, "updateObservedNodes", () => {
      this._mutationObserver?.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          this._mutationObserver?.observe(container, { subtree: true, childList: true });
        });
      }
    });
    __publicField(this, "getInitialFocusNode", () => {
      let node2 = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node2 === false) {
        return false;
      }
      if (node2 === void 0 || node2 && !isFocusable(node2)) {
        if (this.findContainerIndex(this.doc.activeElement) >= 0) {
          node2 = this.doc.activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node2 = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node2 === null) {
        node2 = this.getNodeForOption("fallbackFocus");
      }
      if (!node2) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node2.isConnected) {
        node2 = this.getNodeForOption("fallbackFocus");
      }
      return node2;
    });
    __publicField(this, "tryFocus", (node2) => {
      if (node2 === false) return;
      if (node2 === getActiveElement(this.doc)) return;
      if (!node2 || !node2.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node2.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node2;
      if (isSelectableInput(node2)) {
        node2.select();
      }
    });
    __publicField(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options3 = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      const onDeactivate = this.getOption(options3, "onDeactivate");
      const onPostDeactivate = this.getOption(options3, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options3, "checkCanReturnFocus");
      const returnFocus = this.getOption(options3, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate?.();
      const finishDeactivation = () => {
        delay(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate?.();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause?.();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause?.();
      return this;
    });
    __publicField(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause?.();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause?.();
      return this;
    });
    __publicField(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField(this, "getReturnFocusNode", (previousActiveElement) => {
      const node2 = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node2 ? node2 : node2 === false ? false : previousActiveElement;
    });
    __publicField(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node2 = optionValue;
      if (typeof optionValue === "string") {
        try {
          node2 = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node2) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node2;
    });
    __publicField(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || getEventTarget(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options2.trapStack || sharedTrapStack;
    const config2 = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward(e2) {
        return isTabEvent(e2) && !e2.shiftKey;
      },
      isKeyBackward(e2) {
        return isTabEvent(e2) && e2.shiftKey;
      },
      ...options2
    };
    this.doc = config2.document || getDocument(Array.isArray(elements) ? elements[0] : elements);
    this.config = config2;
    this.updateContainerElements(elements);
    this.setupMutationObserver();
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element, event) {
    const composedPath = typeof event?.composedPath === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node2) => node2 === element)
    );
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = getTabbables(container);
      const focusableNodes = getFocusables(container);
      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      const firstDomTabbableNode = focusableNodes.find((node2) => isTabbable(node2));
      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node2) => isTabbable(node2));
      const posTabIndexesFound = !!tabbableNodes.find((node2) => getTabIndex(node2) > 0);
      function nextTabbableNode(node2, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node2);
        if (nodeIdx < 0) {
          if (forward) {
            return focusableNodes.slice(focusableNodes.indexOf(node2) + 1).find((el2) => isTabbable(el2));
          }
          return focusableNodes.slice(0, focusableNodes.indexOf(node2)).reverse().find((el2) => isTabbable(el2));
        }
        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group2) => group2.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g2) => g2.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      addDomEvent(this.doc, "focusin", this.handleFocus, true),
      addDomEvent(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
    onActivate?.();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate?.();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isTabEvent = (event) => event.key === "Tab";
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node2) => node2.localName === "input" && "select" in node2 && typeof node2.select === "function";
function trapFocus(el2, options2 = {}) {
  let trap;
  const cleanup = raf$1(() => {
    const contentEl = typeof el2 === "function" ? el2() : el2;
    if (!contentEl) return;
    trap = new FocusTrap(contentEl, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: contentEl,
      ...options2,
      document: getDocument(contentEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy2() {
    trap?.deactivate();
    cleanup();
  };
}
var LOCK_CLASSNAME = "data-scroll-lock";
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setStyleProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setBodyStyle = () => setStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setBodyStyleIOS = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const restoreStyle = setStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups = [setScrollbarWidthProperty(), isIos() ? setBodyStyleIOS() : setBodyStyle()];
  return () => {
    cleanups.forEach((fn) => fn?.());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}
var anatomy$h = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts$8 = anatomy$h.build();
var getPositionerId$3 = (ctx) => ctx.ids?.positioner ?? `dialog:${ctx.id}:positioner`;
var getBackdropId = (ctx) => ctx.ids?.backdrop ?? `dialog:${ctx.id}:backdrop`;
var getContentId$4 = (ctx) => ctx.ids?.content ?? `dialog:${ctx.id}:content`;
var getTriggerId$4 = (ctx) => ctx.ids?.trigger ?? `dialog:${ctx.id}:trigger`;
var getTitleId$1 = (ctx) => ctx.ids?.title ?? `dialog:${ctx.id}:title`;
var getDescriptionId$1 = (ctx) => ctx.ids?.description ?? `dialog:${ctx.id}:description`;
var getCloseTriggerId$1 = (ctx) => ctx.ids?.closeTrigger ?? `dialog:${ctx.id}:close`;
var getContentEl$3 = (ctx) => ctx.getById(getContentId$4(ctx));
var getPositionerEl$3 = (ctx) => ctx.getById(getPositionerId$3(ctx));
var getBackdropEl = (ctx) => ctx.getById(getBackdropId(ctx));
var getTriggerEl$4 = (ctx) => ctx.getById(getTriggerId$4(ctx));
var getTitleEl = (ctx) => ctx.getById(getTitleId$1(ctx));
var getDescriptionEl = (ctx) => ctx.getById(getDescriptionId$1(ctx));
var getCloseTriggerEl = (ctx) => ctx.getById(getCloseTriggerId$1(ctx));
function connect$7(service, normalize2) {
  const { state, send, context, prop, scope } = service;
  const ariaLabel = prop("aria-label");
  const open = state.matches("open");
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state.matches("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts$8.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId$4(scope),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": getContentId$4(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TOGGLE" });
        }
      });
    },
    getBackdropProps() {
      return normalize2.element({
        ...parts$8.backdrop.attrs,
        dir: prop("dir"),
        hidden: !open,
        id: getBackdropId(scope),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts$8.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId$3(scope),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      const rendered = context.get("rendered");
      return normalize2.element({
        ...parts$8.content.attrs,
        dir: prop("dir"),
        role: prop("role"),
        hidden: !open,
        id: getContentId$4(scope),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : getTitleId$1(scope),
        "aria-describedby": rendered.description ? getDescriptionId$1(scope) : void 0
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts$8.title.attrs,
        dir: prop("dir"),
        id: getTitleId$1(scope)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts$8.description.attrs,
        dir: prop("dir"),
        id: getDescriptionId$1(scope)
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        ...parts$8.closeTrigger.attrs,
        dir: prop("dir"),
        id: getCloseTriggerId$1(scope),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send({ type: "CLOSE" });
        }
      });
    }
  };
}
var machine$7 = createMachine$1({
  props({ props: props2, scope }) {
    const alertDialog = props2.role === "alertdialog";
    const initialFocusEl = alertDialog ? () => getCloseTriggerEl(scope) : void 0;
    return {
      role: "dialog",
      modal: true,
      trapFocus: true,
      preventScroll: true,
      closeOnInteractOutside: !alertDialog,
      closeOnEscape: true,
      restoreFocus: true,
      initialFocusEl,
      ...props2
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  context({ bindable }) {
    return {
      rendered: bindable(() => ({
        defaultValue: { title: true, description: true }
      }))
    };
  },
  watch({ track, action, prop }) {
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    open: {
      entry: ["checkRenderedElements", "syncZIndex"],
      effects: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackDismissableElement({ scope, send, prop }) {
        const getContentEl2 = () => getContentEl$3(scope);
        return trackDismissableElement(getContentEl2, {
          defer: true,
          pointerBlocking: prop("modal"),
          exclude: [getTriggerEl$4(scope)],
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          persistentElements: prop("persistentElements"),
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (!prop("closeOnEscape")) {
              event.preventDefault();
            }
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside" });
          }
        });
      },
      preventScroll({ scope, prop }) {
        if (!prop("preventScroll")) return;
        return preventBodyScroll(scope.getDoc());
      },
      trapFocus({ scope, prop }) {
        if (!prop("trapFocus") || !prop("modal")) return;
        const contentEl = () => getContentEl$3(scope);
        return trapFocus(contentEl, {
          preventScroll: true,
          returnFocusOnDeactivate: !!prop("restoreFocus"),
          initialFocus: prop("initialFocusEl"),
          setReturnFocus: (el2) => prop("finalFocusEl")?.() ?? el2
        });
      },
      hideContentBelow({ scope, prop }) {
        if (!prop("modal")) return;
        const getElements2 = () => [getContentEl$3(scope)];
        return ariaHidden(getElements2, { defer: true });
      }
    },
    actions: {
      checkRenderedElements({ context, scope }) {
        raf$1(() => {
          context.set("rendered", {
            title: !!getTitleEl(scope),
            description: !!getDescriptionEl(scope)
          });
        });
      },
      syncZIndex({ scope }) {
        raf$1(() => {
          const contentEl = getContentEl$3(scope);
          if (!contentEl) return;
          const styles2 = getComputedStyle$2(contentEl);
          const elems = [getPositionerEl$3(scope), getBackdropEl(scope)];
          elems.forEach((node2) => {
            node2?.style.setProperty("--z-index", styles2.zIndex);
          });
        });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      toggleVisibility({ prop, send, event }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
createProps$1()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "defaultOpen",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
const useDialog = (props) => {
  const id2 = reactExports.useId();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id: id2,
    getRootNode,
    dir,
    ...props
  };
  const service = useMachine(machine$7, machineProps);
  return connect$7(service, normalizeProps);
};
const DialogRoot = (props) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const dialog = useDialog(localProps);
  const presence = usePresence(mergeProps({ present: dialog.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogProvider, { value: dialog, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) }) });
};
const DialogRootProvider = (props) => {
  const [presenceProps, { value: dialog, children }] = splitPresenceProps(props);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const presence = usePresence(mergeProps({ present: dialog.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogProvider, { value: dialog, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) }) });
};
const DialogTitle = reactExports.forwardRef((props, ref) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getTitleProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.h2, { ...mergedProps, ref });
});
DialogTitle.displayName = "DialogTitle";
const DialogTrigger = reactExports.forwardRef((props, ref) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
DialogTrigger.displayName = "DialogTrigger";
var anatomy$g = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
anatomy$g.build();
createProps$1()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEditChange",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "edit",
  "defaultEdit",
  "submitMode",
  "translations",
  "defaultValue",
  "value"
]);
const FieldErrorText$1 = reactExports.forwardRef((props, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field.getErrorTextProps(), props);
  if (field?.invalid) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref });
  }
  return null;
});
FieldErrorText$1.displayName = "FieldErrorText";
const FieldHelperText$1 = reactExports.forwardRef((props, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field?.getHelperTextProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref });
});
FieldHelperText$1.displayName = "FieldHelperText";
const FieldInput = reactExports.forwardRef((props, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field?.getInputProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { ...mergedProps, ref });
});
FieldInput.displayName = "FieldInput";
const FieldLabel$1 = reactExports.forwardRef((props, ref) => {
  const field = useFieldContext();
  const mergedProps = mergeProps(field?.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref });
});
FieldLabel$1.displayName = "FieldLabel";
const useSafeLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
const [FieldsetProvider, useFieldsetContext] = createContext({
  name: "FieldsetContext",
  hookName: "useFieldsetContext",
  providerName: "<FieldsetProvider />",
  strict: false
});
const fieldAnatomy$1 = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
const parts$7 = fieldAnatomy$1.build();
const useField = (props = {}) => {
  const fieldset = useFieldsetContext();
  const { ids, disabled = Boolean(fieldset?.disabled), invalid = false, readOnly = false, required = false } = props;
  const [hasErrorText, setHasErrorText] = reactExports.useState(false);
  const [hasHelperText, setHasHelperText] = reactExports.useState(false);
  const id2 = props.id ?? reactExports.useId();
  const rootRef = reactExports.useRef(null);
  const rootId = ids?.control ?? `field::${id2}`;
  const errorTextId = ids?.errorText ?? `field::${id2}::error-text`;
  const helperTextId = ids?.helperText ?? `field::${id2}::helper-text`;
  const labelId = ids?.label ?? `field::${id2}::label`;
  useSafeLayoutEffect(() => {
    const rootNode = rootRef.current;
    if (!rootNode) return;
    const win = getWindow$1(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      setHasErrorText(!!doc.getElementById(errorTextId));
      setHasHelperText(!!doc.getElementById(helperTextId));
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    return () => observer.disconnect();
  }, [errorTextId, helperTextId]);
  const labelIds = reactExports.useMemo(() => {
    const ids2 = [];
    if (hasErrorText && invalid) ids2.push(errorTextId);
    if (hasHelperText) ids2.push(helperTextId);
    return ids2.join(" ") || void 0;
  }, [invalid, errorTextId, helperTextId, hasErrorText, hasHelperText]);
  const getRootProps = reactExports.useMemo(
    () => () => ({
      ...parts$7.root.attrs,
      id: rootId,
      ref: rootRef,
      role: "group",
      "data-disabled": dataAttr$1(disabled),
      "data-invalid": dataAttr$1(invalid),
      "data-readonly": dataAttr$1(readOnly)
    }),
    [disabled, invalid, readOnly, rootId]
  );
  const getLabelProps = reactExports.useMemo(
    () => () => ({
      ...parts$7.label.attrs,
      id: labelId,
      "data-disabled": dataAttr$1(disabled),
      "data-invalid": dataAttr$1(invalid),
      "data-readonly": dataAttr$1(readOnly),
      htmlFor: id2
    }),
    [disabled, invalid, readOnly, id2, labelId]
  );
  const getControlProps = reactExports.useMemo(
    () => () => ({
      "aria-describedby": labelIds,
      "aria-invalid": ariaAttr(invalid),
      "data-invalid": dataAttr$1(invalid),
      "data-required": dataAttr$1(required),
      "data-readonly": dataAttr$1(readOnly),
      id: id2,
      required,
      disabled,
      readOnly
    }),
    [labelIds, invalid, required, readOnly, id2, disabled]
  );
  const getInputProps = reactExports.useMemo(
    () => () => ({
      ...getControlProps(),
      ...parts$7.input.attrs
    }),
    [getControlProps]
  );
  const getTextareaProps = reactExports.useMemo(
    () => () => ({
      ...getControlProps(),
      ...parts$7.textarea.attrs
    }),
    [getControlProps]
  );
  const getSelectProps = reactExports.useMemo(
    () => () => ({
      ...getControlProps(),
      ...parts$7.select.attrs
    }),
    [getControlProps]
  );
  const getHelperTextProps = reactExports.useMemo(
    () => () => ({
      id: helperTextId,
      ...parts$7.helperText.attrs,
      "data-disabled": dataAttr$1(disabled)
    }),
    [disabled, helperTextId]
  );
  const getErrorTextProps = reactExports.useMemo(
    () => () => ({
      id: errorTextId,
      ...parts$7.errorText.attrs,
      "aria-live": "polite"
    }),
    [errorTextId]
  );
  const getRequiredIndicatorProps = reactExports.useMemo(
    () => () => ({
      "aria-hidden": true,
      ...parts$7.requiredIndicator.attrs
    }),
    []
  );
  return {
    ariaDescribedby: labelIds,
    ids: {
      root: rootId,
      control: id2,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef
    },
    disabled,
    invalid,
    readOnly,
    required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps,
    getRequiredIndicatorProps
  };
};
const FieldRoot$1 = reactExports.forwardRef((props, ref) => {
  const [useFieldProps, localProps] = createSplitProps()(props, [
    "id",
    "ids",
    "disabled",
    "invalid",
    "readOnly",
    "required"
  ]);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps(field.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FieldProvider, { value: field, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(ref, field.refs.rootRef) }) });
});
FieldRoot$1.displayName = "FieldRoot";
var autoresizeTextarea = (el2) => {
  if (!el2) return;
  const style = getComputedStyle$2(el2);
  const win = getWindow$1(el2);
  const doc = getDocument(el2);
  const resize = () => {
    requestAnimationFrame(() => {
      el2.style.height = "auto";
      let newHeight;
      if (style.boxSizing === "content-box") {
        newHeight = el2.scrollHeight - (parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
      } else {
        newHeight = el2.scrollHeight + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
      }
      if (style.maxHeight !== "none" && newHeight > parseFloat(style.maxHeight)) {
        if (style.overflowY === "hidden") {
          el2.style.overflowY = "scroll";
        }
        newHeight = parseFloat(style.maxHeight);
      } else if (style.overflowY !== "hidden") {
        el2.style.overflowY = "hidden";
      }
      el2.style.height = `${newHeight}px`;
    });
  };
  el2.addEventListener("input", resize);
  el2.form?.addEventListener("reset", resize);
  const elementPrototype = Object.getPrototypeOf(el2);
  const descriptor = Object.getOwnPropertyDescriptor(elementPrototype, "value");
  Object.defineProperty(el2, "value", {
    ...descriptor,
    set() {
      descriptor?.set?.apply(this, arguments);
      resize();
    }
  });
  const resizeObserver = new win.ResizeObserver(() => {
    requestAnimationFrame(() => resize());
  });
  resizeObserver.observe(el2);
  const attrObserver = new win.MutationObserver(() => resize());
  attrObserver.observe(el2, { attributes: true, attributeFilter: ["rows", "placeholder"] });
  doc.fonts?.addEventListener("loadingdone", resize);
  return () => {
    el2.removeEventListener("input", resize);
    el2.form?.removeEventListener("reset", resize);
    doc.fonts?.removeEventListener("loadingdone", resize);
    resizeObserver.disconnect();
    attrObserver.disconnect();
  };
};
const FieldTextarea = reactExports.forwardRef((props, ref) => {
  const { autoresize, ...textareaProps } = props;
  const textareaRef = reactExports.useRef(null);
  const field = useFieldContext();
  const mergedProps = mergeProps(
    field?.getTextareaProps(),
    { style: { resize: autoresize ? "none" : void 0 } },
    textareaProps
  );
  reactExports.useEffect(() => {
    if (!autoresize) return;
    return autoresizeTextarea(textareaRef.current);
  }, [autoresize]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.textarea, { ...mergedProps, ref: composeRefs(ref, textareaRef) });
});
FieldTextarea.displayName = "FieldTextarea";
const fieldsetAnatomy$1 = createAnatomy("fieldset").parts("root", "errorText", "helperText", "legend");
fieldsetAnatomy$1.build();
var anatomy$f = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger",
  "clearTrigger"
);
anatomy$f.build();
createProps$1()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "invalid",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "preventDocumentDrop",
  "required",
  "translations",
  "validate"
]);
createProps$1()(["file"]);
var anatomy$e = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
anatomy$e.build();
createProps$1()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "defaultOpen",
  "open",
  "openDelay",
  "positioning",
  "onInteractOutside",
  "onPointerDownOutside",
  "onFocusOutside"
]);
const [MenuProvider, useMenuContext] = createContext({
  name: "MenuContext",
  hookName: "useMenuContext",
  providerName: "<MenuProvider />",
  strict: false
});
const MenuArrow = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getArrowProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
MenuArrow.displayName = "MenuArrow";
const MenuArrowTip$1 = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getArrowTipProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
MenuArrowTip$1.displayName = "MenuArrowTip";
const [MenuItemProvider, useMenuItemContext] = createContext({
  name: "MenuItemContext",
  hookName: "useMenuItemContext",
  providerName: "<MenuItemProvider />"
});
const [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext({
  name: "MenuOptionItemPropsContext",
  hookName: "useMenuOptionItemPropsContext",
  providerName: "<MenuOptionItemPropsProvider />"
});
const MenuCheckboxItem = reactExports.forwardRef((props, ref) => {
  const [partialOptionItemProps, localProps] = createSplitProps()(props, [
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "value",
    "valueText"
  ]);
  const optionItemProps = {
    ...partialOptionItemProps,
    type: "checkbox"
  };
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getOptionItemProps(optionItemProps), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuOptionItemPropsProvider, { value: optionItemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemProvider, { value: optionItemState, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
});
MenuCheckboxItem.displayName = "MenuCheckboxItem";
const MenuContent$1 = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(menu.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
MenuContent$1.displayName = "MenuContent";
const MenuContextTrigger = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getContextTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
MenuContextTrigger.displayName = "MenuContextTrigger";
const MenuIndicator = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getIndicatorProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
MenuIndicator.displayName = "MenuIndicator";
const MenuItem = reactExports.forwardRef((props, ref) => {
  const [itemProps, localProps] = createSplitProps()(props, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText",
    "onSelect"
  ]);
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getItemProps(itemProps), localProps);
  const itemState = menu.getItemState(itemProps);
  reactExports.useEffect(() => {
    return menu.addItemListener({ id: itemState.id, onSelect: itemProps.onSelect });
  }, [itemState.id, itemProps.onSelect]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemProvider, { value: itemState, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
});
MenuItem.displayName = "MenuItem";
const [MenuItemGroupProvider, useMenuItemGroupContext] = createContext({
  name: "MenuItemGroupContext",
  hookName: "useMenuItemGroupContext",
  providerName: "<MenuItemGroupProvider />"
});
const MenuItemGroup = reactExports.forwardRef((props, ref) => {
  const [optionalItemGroupProps, localProps] = createSplitProps()(props, ["id"]);
  const menu = useMenuContext();
  const id2 = reactExports.useId();
  const itemGroupProps = { id: id2, ...optionalItemGroupProps };
  const mergedProps = mergeProps(menu.getItemGroupProps(itemGroupProps), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemGroupProvider, { value: itemGroupProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
});
MenuItemGroup.displayName = "MenuItemGroup";
const MenuItemGroupLabel = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const mergedProps = mergeProps(menu.getItemGroupLabelProps({ htmlFor: itemGroup.id }), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
MenuItemGroupLabel.displayName = "MenuItemGroupLabel";
const MenuItemIndicator$1 = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const optionItemProps = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps(menu.getItemIndicatorProps(optionItemProps), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
MenuItemIndicator$1.displayName = "MenuItemIndicator";
const MenuItemText = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const optionItemProps = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps(menu.getItemTextProps(optionItemProps), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
MenuItemText.displayName = "MenuItemText";
const MenuPositioner$1 = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getPositionerProps(), props);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
MenuPositioner$1.displayName = "MenuPositioner";
const MenuRadioItem$1 = reactExports.forwardRef((props, ref) => {
  const [partialItemProps, localProps] = createSplitProps()(props, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps = {
    ...partialItemProps,
    checked: itemGroup.value === partialItemProps.value,
    type: "radio",
    onCheckedChange: () => itemGroup.onValueChange?.({ value: partialItemProps.value })
  };
  const mergedProps = mergeProps(menu.getOptionItemProps(optionItemProps), localProps);
  const optionItemState = menu.getOptionItemState(optionItemProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuOptionItemPropsProvider, { value: optionItemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemProvider, { value: optionItemState, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
});
MenuRadioItem$1.displayName = "MenuRadioItem";
const MenuRadioItemGroup$1 = reactExports.forwardRef((props, ref) => {
  const [optionalItemGroupProps, localProps] = createSplitProps()(props, [
    "id",
    "onValueChange",
    "value"
  ]);
  const menu = useMenuContext();
  const id2 = reactExports.useId();
  const itemGroupProps = { id: id2, ...optionalItemGroupProps };
  const mergedProps = mergeProps(menu.getItemGroupProps({ id: itemGroupProps.id }), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemGroupProvider, { value: itemGroupProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
});
MenuRadioItemGroup$1.displayName = "MenuRadioItemGroup";
const useEffectOnce = (cb2) => {
  const savedCallback = reactExports.useRef(cb2);
  const effectGuard = reactExports.useRef(false);
  reactExports.useEffect(() => {
    savedCallback.current = cb2;
  });
  reactExports.useEffect(() => {
    if (effectGuard.current !== true) {
      effectGuard.current = true;
      savedCallback.current();
    }
  }, []);
};
var createPoint = (x2, y2) => ({ x: x2, y: y2 });
function createRect(r2) {
  const { x: x2, y: y2, width, height } = r2;
  const midX = x2 + width / 2;
  const midY = y2 + height / 2;
  return {
    x: x2,
    y: y2,
    width,
    height,
    minX: x2,
    minY: y2,
    maxX: x2 + width,
    maxY: y2 + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v2) {
  const top = createPoint(v2.minX, v2.minY);
  const right = createPoint(v2.maxX, v2.minY);
  const bottom = createPoint(v2.maxX, v2.maxY);
  const left = createPoint(v2.minX, v2.maxY);
  return { top, right, bottom, left };
}
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x: x2, y: y2 } = point;
  let c2 = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi2 = polygon[i].x;
    const yi2 = polygon[i].y;
    const xj2 = polygon[j].x;
    const yj2 = polygon[j].y;
    if (yi2 > y2 !== yj2 > y2 && x2 < (xj2 - xi2) * (y2 - yi2) / (yj2 - yi2) + xi2) {
      c2 = !c2;
    }
  }
  return c2;
}
var anatomy$d = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts$6 = anatomy$d.build();
var getTriggerId$3 = (ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`;
var getContextTriggerId = (ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`;
var getContentId$3 = (ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`;
var getArrowId$1 = (ctx) => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`;
var getPositionerId$2 = (ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`;
var getGroupId = (ctx, id2) => ctx.ids?.group?.(id2) ?? `menu:${ctx.id}:group:${id2}`;
var getItemId$1 = (ctx, id2) => `${ctx.id}/${id2}`;
var getItemValue = (el2) => el2?.dataset.value ?? null;
var getGroupLabelId = (ctx, id2) => ctx.ids?.groupLabel?.(id2) ?? `menu:${ctx.id}:group-label:${id2}`;
var getContentEl$2 = (ctx) => ctx.getById(getContentId$3(ctx));
var getPositionerEl$2 = (ctx) => ctx.getById(getPositionerId$2(ctx));
var getTriggerEl$3 = (ctx) => ctx.getById(getTriggerId$3(ctx));
var getItemEl$1 = (ctx, value) => value ? ctx.getById(getItemId$1(ctx, value)) : null;
var getContextTriggerEl = (ctx) => ctx.getById(getContextTriggerId(ctx));
var getElements$1 = (ctx) => {
  const ownerId = CSS.escape(getContentId$3(ctx));
  const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
  return queryAll(getContentEl$2(ctx), selector);
};
var getFirstEl = (ctx) => first(getElements$1(ctx));
var getLastEl = (ctx) => last(getElements$1(ctx));
var isMatch = (el2, value) => {
  if (!value) return false;
  return el2.id === value || el2.dataset.value === value;
};
var getNextEl = (ctx, opts) => {
  const items = getElements$1(ctx);
  const index = items.findIndex((el2) => isMatch(el2, opts.value));
  return next(items, index, { loop: opts.loop ?? opts.loopFocus });
};
var getPrevEl = (ctx, opts) => {
  const items = getElements$1(ctx);
  const index = items.findIndex((el2) => isMatch(el2, opts.value));
  return prev(items, index, { loop: opts.loop ?? opts.loopFocus });
};
var getElemByKey = (ctx, opts) => {
  const items = getElements$1(ctx);
  const item = items.find((el2) => isMatch(el2, opts.value));
  return getByTypeahead(items, { state: opts.typeaheadState, key: opts.key, activeId: item?.id ?? null });
};
var isTargetDisabled = (v2) => {
  return isHTMLElement$1(v2) && (v2.dataset.disabled === "" || v2.hasAttribute("disabled"));
};
var isTriggerItem = (el2) => {
  return !!el2?.getAttribute("role")?.startsWith("menuitem") && !!el2?.hasAttribute("aria-controls");
};
var itemSelectEvent = "menu:select";
function dispatchSelectionEvent(el2, value) {
  if (!el2) return;
  const win = getWindow$1(el2);
  const event = new win.CustomEvent(itemSelectEvent, { detail: { value } });
  el2.dispatchEvent(event);
}
function connect$6(service, normalize2) {
  const { context, send, state, computed, prop, scope } = service;
  const open = state.hasTag("open");
  const isSubmenu = computed("isSubmenu");
  const isTypingAhead = computed("isTypingAhead");
  const composite = prop("composite");
  const currentPlacement = context.get("currentPlacement");
  const anchorPoint = context.get("anchorPoint");
  const highlightedValue = context.get("highlightedValue");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: anchorPoint ? "bottom" : currentPlacement
  });
  function getItemState(props2) {
    return {
      id: getItemId$1(scope, props2.value),
      disabled: !!props2.disabled,
      highlighted: highlightedValue === props2.value
    };
  }
  function getOptionItemProps(props2) {
    const valueText = props2.valueText ?? props2.value;
    return { ...props2, id: props2.value, valueText };
  }
  function getOptionItemState(props2) {
    const itemState = getItemState(getOptionItemProps(props2));
    return {
      ...itemState,
      checked: !!props2.checked
    };
  }
  function getItemProps(props2) {
    const { closeOnSelect, valueText, value } = props2;
    const itemState = getItemState(props2);
    const id2 = getItemId$1(scope, value);
    return normalize2.element({
      ...parts$6.item.attrs,
      id: id2,
      role: "menuitem",
      "aria-disabled": ariaAttr(itemState.disabled),
      "data-disabled": dataAttr$1(itemState.disabled),
      "data-ownedby": getContentId$3(scope),
      "data-highlighted": dataAttr$1(itemState.highlighted),
      "data-value": value,
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id: id2, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = service.event.previous()?.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id: id2, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id: id2, closeOnSelect });
      },
      onClick(event) {
        if (isDownloadingEvent(event)) return;
        if (isOpeningInNewTab(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id: id2, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue,
    open,
    setOpen(nextOpen) {
      const open2 = state.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.prop("id") });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.prop("id") });
    },
    reposition(options2 = {}) {
      send({ type: "POSITIONING.SET", options: options2 });
    },
    addItemListener(props2) {
      const node2 = scope.getById(props2.id);
      if (!node2) return;
      const listener3 = () => props2.onSelect?.();
      node2.addEventListener(itemSelectEvent, listener3);
      return () => node2.removeEventListener(itemSelectEvent, listener3);
    },
    getContextTriggerProps() {
      return normalize2.element({
        ...parts$6.contextTrigger.attrs,
        dir: prop("dir"),
        id: getContextTriggerId(scope),
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onContextMenu(event) {
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      const triggerProps = childApi.getTriggerProps();
      return mergeProps(getItemProps({ value: triggerProps.id }), triggerProps);
    },
    getTriggerProps() {
      return normalize2.button({
        ...isSubmenu ? parts$6.triggerItem.attrs : parts$6.trigger.attrs,
        "data-placement": context.get("currentPlacement"),
        type: "button",
        dir: prop("dir"),
        id: getTriggerId$3(scope),
        "data-uid": prop("id"),
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": getContentId$3(scope),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          const point = getEventPoint(event);
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget, point });
        },
        onPointerLeave(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = getEventPoint(event);
          send({
            type: "TRIGGER_POINTERLEAVE",
            target: event.currentTarget,
            point
          });
        },
        onPointerDown(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (isContextMenuEvent(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send({ type: "TRIGGER_BLUR" });
        },
        onFocus() {
          send({ type: "TRIGGER_FOCUS" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey(event, {
            orientation: "vertical",
            dir: prop("dir")
          });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts$6.indicator.attrs,
        dir: prop("dir"),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts$6.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId$2(scope),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: getArrowId$1(scope),
        ...parts$6.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts$6.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts$6.content.attrs,
        id: getContentId$3(scope),
        "aria-label": prop("aria-label"),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: prop("dir"),
        "aria-activedescendant": computed("highlightedId") || void 0,
        "aria-labelledby": getTriggerId$3(scope),
        "data-placement": currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send({ type: "MENU_POINTERENTER" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          const target = getEventTarget(event);
          const sameMenu = target?.closest("[role=menu]") === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = getItemEl$1(scope, highlightedValue);
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "ENTER" });
              if (isAnchorElement(item)) {
                prop("navigate")?.({ value: highlightedValue, node: item });
              }
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                keyMap2.Enter?.(event2);
              }
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!prop("typeahead")) return;
          if (!isPrintableKey(event)) return;
          if (isModifierKey(event)) return;
          if (isEditableElement(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize2.element({
        ...parts$6.separator.attrs,
        role: "separator",
        dir: prop("dir"),
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props2) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props2;
      const option = getOptionItemProps(props2);
      const itemState = getOptionItemState(props2);
      return {
        ...getItemProps(option),
        ...normalize2.element({
          "data-type": type,
          ...parts$6.item.attrs,
          dir: prop("dir"),
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if (isDownloadingEvent(event)) return;
            if (isOpeningInNewTab(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
            onCheckedChange?.(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props2) {
      const itemState = getOptionItemState(props2);
      return normalize2.element({
        ...parts$6.itemIndicator.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr$1(itemState.disabled),
        "data-highlighted": dataAttr$1(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked",
        hidden: !itemState.checked
      });
    },
    getItemTextProps(props2) {
      const itemState = getOptionItemState(props2);
      return normalize2.element({
        ...parts$6.itemText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr$1(itemState.disabled),
        "data-highlighted": dataAttr$1(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props2) {
      return normalize2.element({
        ...parts$6.itemGroupLabel.attrs,
        id: getGroupLabelId(scope, props2.htmlFor),
        dir: prop("dir")
      });
    },
    getItemGroupProps(props2) {
      return normalize2.element({
        id: getGroupId(scope, props2.id),
        ...parts$6.itemGroup.attrs,
        dir: prop("dir"),
        "aria-labelledby": getGroupLabelId(scope, props2.id),
        role: "group"
      });
    }
  };
}
var { not: not$6, and: and$3, or: or$1 } = createGuards();
var machine$6 = createMachine$1({
  props({ props: props2 }) {
    return {
      closeOnSelect: true,
      typeahead: true,
      composite: true,
      loopFocus: false,
      navigate(details) {
        clickIfLink(details.node);
      },
      ...props2,
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props2.positioning
      }
    };
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  context({ bindable, prop }) {
    return {
      suspendPointer: bindable(() => ({
        defaultValue: false
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          prop("onHighlightChange")?.({ highlightedValue: value });
        }
      })),
      lastHighlightedValue: bindable(() => ({
        defaultValue: null
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      intentPolygon: bindable(() => ({
        defaultValue: null
      })),
      anchorPoint: bindable(() => ({
        defaultValue: null,
        hash(value) {
          return `x: ${value?.x}, y: ${value?.y}`;
        }
      }))
    };
  },
  refs() {
    return {
      parent: null,
      children: {},
      typeaheadState: { ...getByTypeahead.defaultOptions },
      positioningOverride: {}
    };
  },
  computed: {
    isSubmenu: ({ refs }) => refs.get("parent") != null,
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar !== "",
    highlightedId: ({ context, scope, refs }) => resolveItemId(refs.get("children"), context.get("highlightedValue"), scope)
  },
  watch({ track, action, context, computed, prop }) {
    track([() => computed("isSubmenu")], () => {
      action(["setSubmenuPlacement"]);
    });
    track([() => context.hash("anchorPoint")], () => {
      action(["reposition"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "PARENT.SET": {
      actions: ["setParentMenu"]
    },
    "CHILD.SET": {
      actions: ["setChildMenu"]
    },
    OPEN: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        target: "open",
        actions: ["invokeOnOpen"]
      }
    ],
    OPEN_AUTOFOCUS: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        // internal: true,
        target: "open",
        actions: ["highlightFirstItem", "invokeOnOpen"]
      }
    ],
    CLOSE: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnClose"]
      },
      {
        target: "closed",
        actions: ["invokeOnClose"]
      }
    ],
    "HIGHLIGHTED.RESTORE": {
      actions: ["restoreHighlightedItem"]
    },
    "HIGHLIGHTED.SET": {
      actions: ["setHighlightedItem"]
    }
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_FOCUS: {
          guard: not$6("isSubmenu"),
          target: "closed"
        },
        TRIGGER_POINTERMOVE: {
          guard: "isSubmenu",
          target: "opening"
        }
      }
    },
    "opening:contextmenu": {
      tags: ["closed"],
      effects: ["waitForLongPress"],
      on: {
        "CONTROLLED.OPEN": { target: "open" },
        "CONTROLLED.CLOSE": { target: "closed" },
        CONTEXT_MENU_CANCEL: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "LONG_PRESS.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      tags: ["closed"],
      effects: ["waitForOpenDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        BLUR: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_POINTERLEAVE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "DELAY.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    closing: {
      tags: ["open"],
      effects: ["trackPointerMove", "trackInteractOutside", "waitForCloseDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["focusParentMenu", "restoreParentHighlightedItem"]
        },
        // don't invoke on open here since the menu is still open (we're only keeping it open)
        MENU_POINTERENTER: {
          target: "open",
          actions: ["clearIntentPolygon"]
        },
        POINTER_MOVED_AWAY_FROM_SUBMENU: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem"]
          }
        ],
        "DELAY.CLOSE": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      tags: ["closed"],
      entry: ["clearHighlightedItem", "focusTrigger", "resumePointer"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: or$1("isOpenAutoFocusEvent", "isArrowDownEvent"),
            target: "open",
            actions: ["highlightFirstItem"]
          },
          {
            guard: "isArrowUpEvent",
            target: "open",
            actions: ["highlightLastItem"]
          },
          {
            target: "open"
          }
        ],
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          target: "opening"
        },
        TRIGGER_BLUR: { target: "idle" },
        ARROW_DOWN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        ARROW_UP: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightLastItem", "invokeOnOpen"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
      entry: ["focusMenu", "resumePointer"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            target: "closed",
            guard: "isArrowLeftEvent",
            actions: ["focusParentMenu"]
          },
          {
            target: "closed"
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: and$3(not$6("isTriggerItem"), "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: not$6("isTriggerItem"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        CONTEXT_MENU: {
          actions: ["setAnchorPoint", "focusMenu"]
        },
        ARROW_UP: {
          actions: ["highlightPrevItem", "focusMenu"]
        },
        ARROW_DOWN: {
          actions: ["highlightNextItem", "focusMenu"]
        },
        ARROW_LEFT: [
          {
            guard: and$3("isSubmenu", "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: "isSubmenu",
            target: "closed",
            actions: ["focusParentMenu", "invokeOnClose"]
          }
        ],
        HOME: {
          actions: ["highlightFirstItem", "focusMenu"]
        },
        END: {
          actions: ["highlightLastItem", "focusMenu"]
        },
        ARROW_RIGHT: {
          guard: "isTriggerItemHighlighted",
          actions: ["openSubmenu"]
        },
        ENTER: [
          {
            guard: "isTriggerItemHighlighted",
            actions: ["openSubmenu"]
          },
          {
            actions: ["clickHighlightedItem"]
          }
        ],
        ITEM_POINTERMOVE: [
          {
            guard: not$6("isPointerSuspended"),
            actions: ["setHighlightedItem", "focusMenu"]
          },
          {
            actions: ["setLastHighlightedItem"]
          }
        ],
        ITEM_POINTERLEAVE: {
          guard: and$3(not$6("isPointerSuspended"), not$6("isTriggerItem")),
          actions: ["clearHighlightedItem"]
        },
        ITEM_CLICK: [
          // == grouped ==
          {
            guard: and$3(
              not$6("isTriggerItemHighlighted"),
              not$6("isHighlightedItemEditable"),
              "closeOnSelect",
              "isOpenControlled"
            ),
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          {
            guard: and$3(not$6("isTriggerItemHighlighted"), not$6("isHighlightedItemEditable"), "closeOnSelect"),
            target: "closed",
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          //
          {
            guard: and$3(not$6("isTriggerItemHighlighted"), not$6("isHighlightedItemEditable")),
            actions: ["invokeOnSelect", "setOptionState"]
          },
          { actions: ["setHighlightedItem"] }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          actions: ["setIntentPolygon"]
        },
        TRIGGER_POINTERLEAVE: {
          target: "closing"
        },
        ITEM_POINTERDOWN: {
          actions: ["setHighlightedItem"]
        },
        TYPEAHEAD: {
          actions: ["highlightMatchedItem"]
        },
        FOCUS_MENU: {
          actions: ["focusMenu"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      closeOnSelect: ({ prop, event }) => !!(event?.closeOnSelect ?? prop("closeOnSelect")),
      // whether the trigger is also a menu item
      isTriggerItem: ({ event }) => isTriggerItem(event.target),
      // whether the trigger item is the active item
      isTriggerItemHighlighted: ({ event, scope, computed }) => {
        const target = event.target ?? scope.getById(computed("highlightedId"));
        return !!target?.hasAttribute("aria-controls");
      },
      isSubmenu: ({ computed }) => computed("isSubmenu"),
      isPointerSuspended: ({ context }) => context.get("suspendPointer"),
      isHighlightedItemEditable: ({ scope, computed }) => isEditableElement(scope.getById(computed("highlightedId"))),
      // guard assertions (for controlled mode)
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      isArrowLeftEvent: ({ event }) => event.previousEvent?.type === "ARROW_LEFT",
      isArrowUpEvent: ({ event }) => event.previousEvent?.type === "ARROW_UP",
      isArrowDownEvent: ({ event }) => event.previousEvent?.type === "ARROW_DOWN",
      isOpenAutoFocusEvent: ({ event }) => event.previousEvent?.type === "OPEN_AUTOFOCUS"
    },
    effects: {
      waitForOpenDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.OPEN" });
        }, 100);
        return () => clearTimeout(timer);
      },
      waitForCloseDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.CLOSE" });
        }, 300);
        return () => clearTimeout(timer);
      },
      waitForLongPress({ send }) {
        const timer = setTimeout(() => {
          send({ type: "LONG_PRESS.OPEN" });
        }, 700);
        return () => clearTimeout(timer);
      },
      trackPositioning({ context, prop, scope, refs }) {
        if (!!getContextTriggerEl(scope)) return;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        context.set("currentPlacement", positioning.placement);
        const getPositionerEl2 = () => getPositionerEl$2(scope);
        return getPlacement(getTriggerEl$3(scope), getPositionerEl2, {
          ...positioning,
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackInteractOutside({ refs, scope, prop, computed, send }) {
        const getContentEl2 = () => getContentEl$2(scope);
        let restoreFocus = true;
        return trackDismissableElement(getContentEl2, {
          defer: true,
          exclude: [getTriggerEl$3(scope)],
          onInteractOutside: prop("onInteractOutside"),
          onFocusOutside: prop("onFocusOutside"),
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (computed("isSubmenu")) event.preventDefault();
            closeRootMenu({ parent: refs.get("parent") });
          },
          onPointerDownOutside(event) {
            const target = getEventTarget(event.detail.originalEvent);
            const isWithinContextTrigger = contains(getContextTriggerEl(scope), target);
            if (isWithinContextTrigger && event.detail.contextmenu) {
              event.preventDefault();
              return;
            }
            restoreFocus = !event.detail.focusable;
            prop("onPointerDownOutside")?.(event);
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      trackPointerMove({ context, scope, send, refs, flush: flush2 }) {
        const parent = refs.get("parent");
        flush2(() => {
          parent.context.set("suspendPointer", true);
        });
        const doc = scope.getDoc();
        return addDomEvent(doc, "pointermove", (e2) => {
          const isMovingToSubmenu = isWithinPolygon(context.get("intentPolygon"), {
            x: e2.clientX,
            y: e2.clientY
          });
          if (!isMovingToSubmenu) {
            send({ type: "POINTER_MOVED_AWAY_FROM_SUBMENU" });
            parent.context.set("suspendPointer", false);
          }
        });
      },
      scrollToHighlightedItem({ event, scope, computed }) {
        const exec = () => {
          if (event.type.startsWith("ITEM_POINTER")) return;
          const itemEl = scope.getById(computed("highlightedId"));
          const contentEl2 = getContentEl$2(scope);
          scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
        };
        raf$1(() => exec());
        const contentEl = () => getContentEl$2(scope);
        return observeAttributes(contentEl, {
          defer: true,
          attributes: ["aria-activedescendant"],
          callback: exec
        });
      }
    },
    actions: {
      setAnchorPoint({ context, event }) {
        context.set("anchorPoint", event.point);
      },
      setSubmenuPlacement({ computed, refs }) {
        if (!computed("isSubmenu")) return;
        const placement = computed("isRtl") ? "left-start" : "right-start";
        refs.set("positioningOverride", { placement, gutter: 0 });
      },
      reposition({ context, scope, prop, event, refs }) {
        const getPositionerEl2 = () => getPositionerEl$2(scope);
        const anchorPoint = context.get("anchorPoint");
        const getAnchorRect = anchorPoint ? () => ({ width: 0, height: 0, ...anchorPoint }) : void 0;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        getPlacement(getTriggerEl$3(scope), getPositionerEl2, {
          ...positioning,
          defer: true,
          getAnchorRect,
          ...event.options ?? {},
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setOptionState({ event }) {
        if (!event.option) return;
        const { checked, onCheckedChange, type } = event.option;
        if (type === "radio") {
          onCheckedChange?.(true);
        } else if (type === "checkbox") {
          onCheckedChange?.(!checked);
        }
      },
      clickHighlightedItem({ scope, computed }) {
        const itemEl = scope.getById(computed("highlightedId"));
        if (!itemEl || itemEl.dataset.disabled) return;
        queueMicrotask(() => itemEl.click());
      },
      setIntentPolygon({ context, scope, event }) {
        const menu = getContentEl$2(scope);
        const placement = context.get("currentPlacement");
        if (!menu || !placement) return;
        const rect = menu.getBoundingClientRect();
        const polygon = getElementPolygon(rect, placement);
        if (!polygon) return;
        const rightSide = getPlacementSide(placement) === "right";
        const bleed = rightSide ? -5 : 5;
        context.set("intentPolygon", [{ ...event.point, x: event.point.x + bleed }, ...polygon]);
      },
      clearIntentPolygon({ context }) {
        context.set("intentPolygon", null);
      },
      resumePointer({ refs, flush: flush2 }) {
        const parent = refs.get("parent");
        if (!parent) return;
        flush2(() => {
          parent.context.set("suspendPointer", false);
        });
      },
      setHighlightedItem({ context, event }) {
        const value = event.value || getItemValue(event.target);
        context.set("highlightedValue", value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      focusMenu({ scope }) {
        raf$1(() => {
          const contentEl = getContentEl$2(scope);
          const initialFocusEl = getInitialFocus({
            root: contentEl,
            enabled: !contains(contentEl, scope.getActiveElement()),
            filter(node2) {
              return !node2.role?.startsWith("menuitem");
            }
          });
          initialFocusEl?.focus({ preventScroll: true });
        });
      },
      highlightFirstItem({ context, scope }) {
        const fn = getContentEl$2(scope) ? queueMicrotask : raf$1;
        fn(() => {
          const first2 = getFirstEl(scope);
          if (!first2) return;
          context.set("highlightedValue", getItemValue(first2));
        });
      },
      highlightLastItem({ context, scope }) {
        const fn = getContentEl$2(scope) ? queueMicrotask : raf$1;
        fn(() => {
          const last2 = getLastEl(scope);
          if (!last2) return;
          context.set("highlightedValue", getItemValue(last2));
        });
      },
      highlightNextItem({ context, scope, event, prop }) {
        const next2 = getNextEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", getItemValue(next2));
      },
      highlightPrevItem({ context, scope, event, prop }) {
        const prev2 = getPrevEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", getItemValue(prev2));
      },
      invokeOnSelect({ context, prop, scope }) {
        const value = context.get("highlightedValue");
        if (value == null) return;
        const node2 = getItemEl$1(scope, value);
        dispatchSelectionEvent(node2, value);
        prop("onSelect")?.({ value });
      },
      focusTrigger({ scope, context, event, computed }) {
        if (computed("isSubmenu") || context.get("anchorPoint") || event.restoreFocus === false) return;
        queueMicrotask(() => getTriggerEl$3(scope)?.focus({ preventScroll: true }));
      },
      highlightMatchedItem({ scope, context, event, refs }) {
        const node2 = getElemByKey(scope, {
          key: event.key,
          value: context.get("highlightedValue"),
          typeaheadState: refs.get("typeaheadState")
        });
        if (!node2) return;
        context.set("highlightedValue", getItemValue(node2));
      },
      setParentMenu({ refs, event }) {
        refs.set("parent", event.value);
      },
      setChildMenu({ refs, event }) {
        const children = refs.get("children");
        children[event.id] = event.value;
        refs.set("children", children);
      },
      closeRootMenu({ refs }) {
        closeRootMenu({ parent: refs.get("parent") });
      },
      openSubmenu({ refs, scope, computed }) {
        const item = scope.getById(computed("highlightedId"));
        const id2 = item?.getAttribute("data-uid");
        const children = refs.get("children");
        const child = id2 ? children[id2] : null;
        child?.send({ type: "OPEN_AUTOFOCUS" });
      },
      focusParentMenu({ refs }) {
        refs.get("parent")?.send({ type: "FOCUS_MENU" });
      },
      setLastHighlightedItem({ context, event }) {
        context.set("lastHighlightedValue", getItemValue(event.target));
      },
      restoreHighlightedItem({ context }) {
        if (!context.get("lastHighlightedValue")) return;
        context.set("highlightedValue", context.get("lastHighlightedValue"));
        context.set("lastHighlightedValue", null);
      },
      restoreParentHighlightedItem({ refs }) {
        refs.get("parent")?.send({ type: "HIGHLIGHTED.RESTORE" });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      toggleVisibility({ prop, event, send }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.computed("isSubmenu")) {
    parent = parent.refs.get("parent");
  }
  parent?.send({ type: "CLOSE" });
}
function isWithinPolygon(polygon, point) {
  if (!polygon) return false;
  return isPointInPolygon(polygon, point);
}
function resolveItemId(children, value, scope) {
  const hasChildren = Object.keys(children).length > 0;
  if (!value) return null;
  if (!hasChildren) {
    return getItemId$1(scope, value);
  }
  for (const id2 in children) {
    const childMenu = children[id2];
    const childTriggerId = getTriggerId$3(childMenu.scope);
    if (childTriggerId === value) {
      return childTriggerId;
    }
  }
  return getItemId$1(scope, value);
}
createProps$1()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "defaultHighlightedValue",
  "defaultOpen",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "open",
  "positioning",
  "typeahead"
]);
createProps$1()(["closeOnSelect", "disabled", "value", "valueText"]);
createProps$1()(["htmlFor"]);
createProps$1()(["id"]);
createProps$1()([
  "checked",
  "closeOnSelect",
  "disabled",
  "onCheckedChange",
  "type",
  "value",
  "valueText"
]);
const useMenu = (props) => {
  const id2 = reactExports.useId();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id: id2,
    dir,
    getRootNode,
    ...props
  };
  const service = useMachine(machine$6, machineProps);
  const api = connect$6(service, normalizeProps);
  return { api, service };
};
const [MenuMachineProvider, useMenuMachineContext] = createContext({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});
const [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});
const MenuRoot$1 = (props) => {
  const [presenceProps, menuProps] = splitPresenceProps(props);
  const [useMenuProps, localProps] = createSplitProps()(menuProps, [
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultHighlightedValue",
    "defaultOpen",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
  ]);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const { api, service } = useMenu(useMenuProps);
  const presence = usePresence(mergeProps({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(service);
    api.setParent(parentMachine);
  });
  const triggerItemContext = reactExports.useCallback(() => parentApi?.getTriggerItemProps(api), [api, parentApi]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuTriggerItemProvider, { value: triggerItemContext, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMachineProvider, { value: service, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuProvider, { value: api, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, ...localProps }) }) }) });
};
const MenuRootProvider = (props) => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, { value: menu, children }] = splitPresenceProps(props);
  const { api, service } = menu;
  const presence = usePresence(mergeProps({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine) return;
    if (!parentApi) return;
    parentApi.setChild(service);
    api.setParent(parentMachine);
  });
  const triggerItemContext = reactExports.useCallback(() => parentApi?.getTriggerItemProps(api), [api, parentApi]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuTriggerItemProvider, { value: triggerItemContext, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMachineProvider, { value: service, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuProvider, { value: api, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) }) }) });
};
const MenuSeparator = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getSeparatorProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.hr, { ...mergedProps, ref });
});
MenuSeparator.displayName = "MenuSeparator";
const MenuTrigger$1 = reactExports.forwardRef((props, ref) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...menu.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : menu.getTriggerProps()["aria-controls"]
    },
    props
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
MenuTrigger$1.displayName = "MenuTrigger";
const MenuTriggerItem = reactExports.forwardRef((props, ref) => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps(getTriggerItemProps?.() ?? {}, props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
MenuTriggerItem.displayName = "MenuTriggerItem";
const [NumberInputProvider, useNumberInputContext] = createContext({
  name: "NumberInputContext",
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});
const NumberInputControl$1 = reactExports.forwardRef((props, ref) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getControlProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
NumberInputControl$1.displayName = "NumberInputControl";
const NumberInputDecrementTrigger$1 = reactExports.forwardRef(
  (props, ref) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getDecrementTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
  }
);
NumberInputDecrementTrigger$1.displayName = "NumberInputDecrementTrigger";
const NumberInputIncrementTrigger$1 = reactExports.forwardRef(
  (props, ref) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getIncrementTriggerProps(), props);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
  }
);
NumberInputIncrementTrigger$1.displayName = "NumberInputIncrementTrigger";
const NumberInputInput$1 = reactExports.forwardRef((props, ref) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getInputProps(), props);
  const field = useFieldContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { "aria-describedby": field?.ariaDescribedby, ...mergedProps, ref });
});
NumberInputInput$1.displayName = "NumberInputInput";
const NumberInputLabel = reactExports.forwardRef((props, ref) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref });
});
NumberInputLabel.displayName = "NumberInputLabel";
let $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
let $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "",
      "ja-JP": " ",
      "zh-TW": "",
      "sl-SI": " "
    }
  }
};
class $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)}  ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p2) => ({
        ...p2,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...endParts.map((p2) => ({
        ...p2,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options2 = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options2 = {
      ...options2,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options2 = {
      ...options2,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options2;
  }
  constructor(locale, options2 = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options2);
    this.options = options2;
  }
}
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options2 = {}) {
  let { numberingSystem } = options2;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options2.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options2;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options2 = {
      ...options2,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options2 ? Object.entries(options2).sort((a, b2) => a[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options2);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}
const $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
const $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
class $6c7bd7858deea686$export$cd11ab140839f11d {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue2);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options2 = {}) {
    this.locale = locale;
    this.options = options2;
  }
}
const $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options2, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options2);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options2);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options2) {
  let cacheKey = locale + (options2 ? Object.entries(options2).sort((a, b2) => a[0] < b2[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options2);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
class $6c7bd7858deea686$var$NumberParserImpl {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options2 = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options2).parse(new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(this.locale, options2).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR") value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue2 = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue2 > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options2 = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options2);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options2);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
const $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n2) => symbolFormatter.formatToParts(n2));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p2) => p2.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p2) => p2.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p2) => p2.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group2 = (_allParts_find1 = allParts.find((p2) => p2.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value));
  let pluralPartsLiterals = pluralParts.flatMap((p2) => p2.filter((p3) => !$6c7bd7858deea686$var$nonLiteralParts.has(p3.type)).map((p3) => $6c7bd7858deea686$var$escapeRegex(p3.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a, b2) => b2.length - a.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d2, i) => [
    d2,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d2) => String(indexes.get(d2));
  return {
    minusSign,
    plusSign,
    decimal,
    group: group2,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace2) {
  if (str.replaceAll) return str.replaceAll(find, replace2);
  return str.split(find).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var anatomy$c = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts$5 = anatomy$c.build();
var getRootId$4 = (ctx) => ctx.ids?.root ?? `number-input:${ctx.id}`;
var getInputId = (ctx) => ctx.ids?.input ?? `number-input:${ctx.id}:input`;
var getIncrementTriggerId = (ctx) => ctx.ids?.incrementTrigger ?? `number-input:${ctx.id}:inc`;
var getDecrementTriggerId = (ctx) => ctx.ids?.decrementTrigger ?? `number-input:${ctx.id}:dec`;
var getScrubberId = (ctx) => ctx.ids?.scrubber ?? `number-input:${ctx.id}:scrubber`;
var getCursorId = (ctx) => `number-input:${ctx.id}:cursor`;
var getLabelId$2 = (ctx) => ctx.ids?.label ?? `number-input:${ctx.id}:label`;
var getInputEl = (ctx) => ctx.getById(getInputId(ctx));
var getIncrementTriggerEl = (ctx) => ctx.getById(getIncrementTriggerId(ctx));
var getDecrementTriggerEl = (ctx) => ctx.getById(getDecrementTriggerId(ctx));
var getCursorEl = (ctx) => ctx.getDoc().getElementById(getCursorId(ctx));
var getPressedTriggerEl = (ctx, hint) => {
  let btnEl = null;
  if (hint === "increment") {
    btnEl = getIncrementTriggerEl(ctx);
  }
  if (hint === "decrement") {
    btnEl = getDecrementTriggerEl(ctx);
  }
  return btnEl;
};
var setupVirtualCursor = (ctx, point) => {
  if (isSafari()) return;
  createVirtualCursor(ctx, point);
  return () => {
    getCursorEl(ctx)?.remove();
  };
};
var preventTextSelection = (ctx) => {
  const doc = ctx.getDoc();
  const html = doc.documentElement;
  const body = doc.body;
  body.style.pointerEvents = "none";
  html.style.userSelect = "none";
  html.style.cursor = "ew-resize";
  return () => {
    body.style.pointerEvents = "";
    html.style.userSelect = "";
    html.style.cursor = "";
    if (!html.style.length) {
      html.removeAttribute("style");
    }
    if (!body.style.length) {
      body.removeAttribute("style");
    }
  };
};
var getMousemoveValue = (ctx, opts) => {
  const { point, isRtl, event } = opts;
  const win = ctx.getWin();
  const x2 = roundToDpr(event.movementX, win.devicePixelRatio);
  const y2 = roundToDpr(event.movementY, win.devicePixelRatio);
  let hint = x2 > 0 ? "increment" : x2 < 0 ? "decrement" : null;
  if (isRtl && hint === "increment") hint = "decrement";
  if (isRtl && hint === "decrement") hint = "increment";
  const newPoint = { x: point.x + x2, y: point.y + y2 };
  const width = win.innerWidth;
  const half = roundToDpr(7.5, win.devicePixelRatio);
  newPoint.x = wrap$2(newPoint.x + half, width) - half;
  return { hint, point: newPoint };
};
var createVirtualCursor = (ctx, point) => {
  const doc = ctx.getDoc();
  const el2 = doc.createElement("div");
  el2.className = "scrubber--cursor";
  el2.id = getCursorId(ctx);
  Object.assign(el2.style, {
    width: "15px",
    height: "15px",
    position: "fixed",
    pointerEvents: "none",
    left: "0px",
    top: "0px",
    zIndex: MAX_Z_INDEX,
    transform: point ? `translate3d(${point.x}px, ${point.y}px, 0px)` : void 0,
    willChange: "transform"
  });
  el2.innerHTML = `
      <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
        <g transform="translate(2 3)">
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
        </g>
      </svg>`;
  doc.body.appendChild(el2);
};
function connect$5(service, normalize2) {
  const { state, send, prop, scope, computed } = service;
  const focused = state.hasTag("focus");
  const disabled = computed("isDisabled");
  const readOnly = prop("readOnly");
  const empty2 = computed("isValueEmpty");
  const invalid = computed("isOutOfRange") || !!prop("invalid");
  const isIncrementDisabled = disabled || !computed("canIncrement") || readOnly;
  const isDecrementDisabled = disabled || !computed("canDecrement") || readOnly;
  const translations = prop("translations");
  return {
    focused,
    invalid,
    empty: empty2,
    value: computed("formattedValue"),
    valueAsNumber: computed("valueAsNumber"),
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    increment() {
      send({ type: "VALUE.INCREMENT" });
    },
    decrement() {
      send({ type: "VALUE.DECREMENT" });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: prop("max") });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: prop("min") });
    },
    focus() {
      getInputEl(scope)?.focus();
    },
    getRootProps() {
      return normalize2.element({
        id: getRootId$4(scope),
        ...parts$5.root.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr$1(disabled),
        "data-focus": dataAttr$1(focused),
        "data-invalid": dataAttr$1(invalid)
      });
    },
    getLabelProps() {
      return normalize2.label({
        ...parts$5.label.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr$1(disabled),
        "data-focus": dataAttr$1(focused),
        "data-invalid": dataAttr$1(invalid),
        id: getLabelId$2(scope),
        htmlFor: getInputId(scope)
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts$5.control.attrs,
        dir: prop("dir"),
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr$1(focused),
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "aria-invalid": ariaAttr(invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts$5.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-focus": dataAttr$1(focused)
      });
    },
    getInputProps() {
      return normalize2.input({
        ...parts$5.input.attrs,
        dir: prop("dir"),
        name: prop("name"),
        form: prop("form"),
        id: getInputId(scope),
        role: "spinbutton",
        defaultValue: computed("formattedValue"),
        pattern: prop("pattern"),
        inputMode: prop("inputMode"),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr$1(invalid),
        disabled,
        "data-disabled": dataAttr$1(disabled),
        readOnly,
        required: prop("required"),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": prop("min"),
        "aria-valuemax": prop("max"),
        "aria-valuenow": Number.isNaN(computed("valueAsNumber")) ? void 0 : computed("valueAsNumber"),
        "aria-valuetext": computed("valueText"),
        onFocus() {
          send({ type: "INPUT.FOCUS" });
        },
        onBlur() {
          send({ type: "INPUT.BLUR" });
        },
        onInput(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = computed("parser").isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if (isComposingEvent(event)) return;
          const step = getEventStep(event) * prop("step");
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if (isModifierKey(event)) return;
              send({ type: "INPUT.HOME" });
              event.preventDefault();
            },
            End() {
              if (isModifierKey(event)) return;
              send({ type: "INPUT.END" });
              event.preventDefault();
            },
            Enter() {
              send({ type: "INPUT.ENTER" });
            }
          };
          const exec = keyMap2[event.key];
          exec?.(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize2.button({
        ...parts$5.decrementTrigger.attrs,
        dir: prop("dir"),
        id: getDecrementTriggerId(scope),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr$1(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId(scope),
        onPointerDown(event) {
          if (isDecrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            event.currentTarget?.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize2.button({
        ...parts$5.incrementTrigger.attrs,
        dir: prop("dir"),
        id: getIncrementTriggerId(scope),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr$1(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId(scope),
        onPointerDown(event) {
          if (isIncrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            event.currentTarget?.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize2.element({
        ...parts$5.scrubber.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr$1(disabled),
        id: getScrubberId(scope),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = getEventPoint(event);
          const win = getWindow$1(event.currentTarget);
          const dpr = win.devicePixelRatio;
          point.x = point.x - roundToDpr(7.5, dpr);
          point.y = point.y - roundToDpr(7.5, dpr);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options2 = {}) => {
  return new Intl.NumberFormat(locale, options2);
};
var createParser = (locale, options2 = {}) => {
  return new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options2);
};
var parseValue = (value, params) => {
  const { prop, computed } = params;
  if (!prop("formatOptions")) return parseFloat(value);
  return computed("parser").parse(String(value));
};
var formatValue = (value, params) => {
  const { prop, computed } = params;
  if (Number.isNaN(value)) return "";
  if (!prop("formatOptions")) return value.toString();
  return computed("formatter").format(value);
};
var getDefaultStep = (step, formatOptions) => {
  let defaultStep = step !== void 0 && !Number.isNaN(step) ? step : 1;
  if (formatOptions?.style === "percent" && (step === void 0 || Number.isNaN(step))) {
    defaultStep = 0.01;
  }
  return defaultStep;
};
var { choose, guards, createMachine } = setup();
var { not: not$5, and: and$2 } = guards;
var machine$5 = createMachine({
  props({ props: props2 }) {
    const step = getDefaultStep(props2.step, props2.formatOptions);
    return {
      dir: "ltr",
      locale: "en-US",
      focusInputOnChange: true,
      clampValueOnBlur: !props2.allowOverflow,
      allowOverflow: false,
      inputMode: "decimal",
      pattern: "[0-9]*(.[0-9]+)?",
      defaultValue: "",
      step,
      min: Number.MIN_SAFE_INTEGER,
      max: Number.MAX_SAFE_INTEGER,
      spinOnPress: true,
      ...props2,
      translations: {
        incrementLabel: "increment value",
        decrementLabel: "decrease value",
        ...props2.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getComputed }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          const computed = getComputed();
          const valueAsNumber = parseValue(value, { computed, prop });
          prop("onValueChange")?.({ value, valueAsNumber });
        }
      })),
      hint: bindable(() => ({ defaultValue: null })),
      scrubberCursorPoint: bindable(() => ({
        defaultValue: null,
        hash(value) {
          return value ? `x:${value.x}, y:${value.y}` : "";
        }
      })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false }))
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    valueAsNumber: ({ context, computed, prop }) => parseValue(context.get("value"), { computed, prop }),
    formattedValue: ({ computed, prop }) => formatValue(computed("valueAsNumber"), { computed, prop }),
    isAtMin: ({ computed, prop }) => isValueAtMin(computed("valueAsNumber"), prop("min")),
    isAtMax: ({ computed, prop }) => isValueAtMax(computed("valueAsNumber"), prop("max")),
    isOutOfRange: ({ computed, prop }) => !isValueWithinRange(computed("valueAsNumber"), prop("min"), prop("max")),
    isValueEmpty: ({ context }) => context.get("value") === "",
    isDisabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    canIncrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMax"),
    canDecrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMin"),
    valueText: ({ prop, context }) => prop("translations").valueText?.(context.get("value")),
    formatter: memo$2(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => createFormatter(locale, formatOptions)
    ),
    parser: memo$2(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => createParser(locale, formatOptions)
    )
  },
  watch({ track, action, context, computed, prop }) {
    track([() => context.get("value"), () => prop("locale")], () => {
      action(["syncInputElement"]);
    });
    track([() => computed("isOutOfRange")], () => {
      action(["invokeOnInvalid"]);
    });
    track([() => context.hash("scrubberCursorPoint")], () => {
      action(["setVirtualCursorPosition"]);
    });
  },
  effects: ["trackFormControl"],
  on: {
    "VALUE.SET": {
      actions: ["setRawValue"]
    },
    "VALUE.CLEAR": {
      actions: ["clearValue"]
    },
    "VALUE.INCREMENT": {
      actions: ["increment"]
    },
    "VALUE.DECREMENT": {
      actions: ["decrement"]
    }
  },
  states: {
    idle: {
      on: {
        "TRIGGER.PRESS_DOWN": [
          { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
          {
            target: "before:spin",
            actions: ["focusInput", "invokeOnFocus", "setHint"]
          }
        ],
        "SCRUBBER.PRESS_DOWN": {
          target: "scrubbing",
          actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
        },
        "INPUT.FOCUS": {
          target: "focused",
          actions: ["focusInput", "invokeOnFocus"]
        }
      }
    },
    focused: {
      tags: ["focus"],
      effects: ["attachWheelListener"],
      on: {
        "TRIGGER.PRESS_DOWN": [
          { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
          { target: "before:spin", actions: ["focusInput", "setHint"] }
        ],
        "SCRUBBER.PRESS_DOWN": {
          target: "scrubbing",
          actions: ["focusInput", "setHint", "setCursorPoint"]
        },
        "INPUT.ARROW_UP": {
          actions: ["increment"]
        },
        "INPUT.ARROW_DOWN": {
          actions: ["decrement"]
        },
        "INPUT.HOME": {
          actions: ["decrementToMin"]
        },
        "INPUT.END": {
          actions: ["incrementToMax"]
        },
        "INPUT.CHANGE": {
          actions: ["setValue", "setHint"]
        },
        "INPUT.BLUR": [
          {
            guard: and$2("clampValueOnBlur", not$5("isInRange")),
            target: "idle",
            actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
          },
          {
            guard: not$5("isInRange"),
            target: "idle",
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur", "invokeOnInvalid"]
          },
          {
            target: "idle",
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
          }
        ],
        "INPUT.ENTER": {
          actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
        }
      }
    },
    "before:spin": {
      tags: ["focus"],
      effects: ["trackButtonDisabled", "waitForChangeDelay"],
      entry: choose([
        { guard: "isIncrementHint", actions: ["increment"] },
        { guard: "isDecrementHint", actions: ["decrement"] }
      ]),
      on: {
        CHANGE_DELAY: {
          target: "spinning",
          guard: and$2("isInRange", "spinOnPress")
        },
        "TRIGGER.PRESS_UP": [
          { guard: "isTouchPointer", target: "focused", actions: ["clearHint"] },
          { target: "focused", actions: ["focusInput", "clearHint"] }
        ]
      }
    },
    spinning: {
      tags: ["focus"],
      effects: ["trackButtonDisabled", "spinValue"],
      on: {
        SPIN: [
          {
            guard: "isIncrementHint",
            actions: ["increment"]
          },
          {
            guard: "isDecrementHint",
            actions: ["decrement"]
          }
        ],
        "TRIGGER.PRESS_UP": {
          target: "focused",
          actions: ["focusInput", "clearHint"]
        }
      }
    },
    scrubbing: {
      tags: ["focus"],
      effects: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
      on: {
        "SCRUBBER.POINTER_UP": {
          target: "focused",
          actions: ["focusInput", "clearCursorPoint"]
        },
        "SCRUBBER.POINTER_MOVE": [
          {
            guard: "isIncrementHint",
            actions: ["increment", "setCursorPoint"]
          },
          {
            guard: "isDecrementHint",
            actions: ["decrement", "setCursorPoint"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      clampValueOnBlur: ({ prop }) => prop("clampValueOnBlur"),
      spinOnPress: ({ prop }) => !!prop("spinOnPress"),
      isInRange: ({ computed }) => !computed("isOutOfRange"),
      isDecrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "decrement",
      isIncrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "increment",
      isTouchPointer: ({ event }) => event.pointerType === "touch"
    },
    effects: {
      waitForChangeDelay({ send }) {
        const id2 = setTimeout(() => {
          send({ type: "CHANGE_DELAY" });
        }, 300);
        return () => clearTimeout(id2);
      },
      spinValue({ send }) {
        const id2 = setInterval(() => {
          send({ type: "SPIN" });
        }, 50);
        return () => clearInterval(id2);
      },
      trackFormControl({ context, scope }) {
        const inputEl = getInputEl(scope);
        return trackFormControl(inputEl, {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      setupVirtualCursor({ context, scope }) {
        const point = context.get("scrubberCursorPoint");
        return setupVirtualCursor(scope, point);
      },
      preventTextSelection({ scope }) {
        return preventTextSelection(scope);
      },
      trackButtonDisabled({ context, scope, send }) {
        const hint = context.get("hint");
        const btn = getPressedTriggerEl(scope, hint);
        return observeAttributes(btn, {
          attributes: ["disabled"],
          callback() {
            send({ type: "TRIGGER.PRESS_UP", src: "attr" });
          }
        });
      },
      attachWheelListener({ scope, send, prop }) {
        const inputEl = getInputEl(scope);
        if (!inputEl || !scope.isActiveElement(inputEl) || !prop("allowMouseWheel")) return;
        function onWheel(event) {
          event.preventDefault();
          const dir = Math.sign(event.deltaY) * -1;
          if (dir === 1) {
            send({ type: "VALUE.INCREMENT" });
          } else if (dir === -1) {
            send({ type: "VALUE.DECREMENT" });
          }
        }
        return addDomEvent(inputEl, "wheel", onWheel, { passive: false });
      },
      activatePointerLock({ scope }) {
        if (isSafari()) return;
        return requestPointerLock(scope.getDoc());
      },
      trackMousemove({ scope, send, context, computed }) {
        const doc = scope.getDoc();
        function onMousemove(event) {
          const point = context.get("scrubberCursorPoint");
          const isRtl = computed("isRtl");
          const value = getMousemoveValue(scope, { point, isRtl, event });
          if (!value.hint) return;
          send({
            type: "SCRUBBER.POINTER_MOVE",
            hint: value.hint,
            point: value.point
          });
        }
        function onMouseup() {
          send({ type: "SCRUBBER.POINTER_UP" });
        }
        return callAll(addDomEvent(doc, "mousemove", onMousemove, false), addDomEvent(doc, "mouseup", onMouseup, false));
      }
    },
    actions: {
      focusInput({ scope, prop }) {
        if (!prop("focusInputOnChange")) return;
        const inputEl = getInputEl(scope);
        if (scope.isActiveElement(inputEl)) return;
        raf$1(() => inputEl?.focus({ preventScroll: true }));
      },
      increment({ context, event, prop, computed }) {
        let nextValue = incrementValue(computed("valueAsNumber"), event.step ?? prop("step"));
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      decrement({ context, event, prop, computed }) {
        let nextValue = decrementValue(computed("valueAsNumber"), event.step ?? prop("step"));
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setClampedValue({ context, prop, computed }) {
        const nextValue = clampValue(computed("valueAsNumber"), prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setRawValue({ context, event, prop, computed }) {
        let nextValue = parseValue(event.value, { computed, prop });
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setValue({ context, event }) {
        const value = event.target?.value ?? event.value;
        context.set("value", value);
      },
      clearValue({ context }) {
        context.set("value", "");
      },
      incrementToMax({ context, prop, computed }) {
        const value = formatValue(prop("max"), { computed, prop });
        context.set("value", value);
      },
      decrementToMin({ context, prop, computed }) {
        const value = formatValue(prop("min"), { computed, prop });
        context.set("value", value);
      },
      setHint({ context, event }) {
        context.set("hint", event.hint);
      },
      clearHint({ context }) {
        context.set("hint", null);
      },
      invokeOnFocus({ computed, prop }) {
        prop("onFocusChange")?.({
          focused: true,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      invokeOnBlur({ computed, prop }) {
        prop("onFocusChange")?.({
          focused: false,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      invokeOnInvalid({ computed, prop, event }) {
        if (event.type === "INPUT.CHANGE") return;
        const reason = computed("valueAsNumber") > prop("max") ? "rangeOverflow" : "rangeUnderflow";
        prop("onValueInvalid")?.({
          reason,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      syncInputElement({ context, event, computed, scope }) {
        const value = event.type.endsWith("CHANGE") ? context.get("value") : computed("formattedValue");
        const inputEl = getInputEl(scope);
        const sel = recordCursor(inputEl);
        raf$1(() => {
          setElementValue(inputEl, value);
          restoreCursor(inputEl, sel);
        });
      },
      setFormattedValue({ context, computed }) {
        context.set("value", computed("formattedValue"));
      },
      setCursorPoint({ context, event }) {
        context.set("scrubberCursorPoint", event.point);
      },
      clearCursorPoint({ context }) {
        context.set("scrubberCursorPoint", null);
      },
      setVirtualCursorPosition({ context, scope }) {
        const cursorEl = getCursorEl(scope);
        const point = context.get("scrubberCursorPoint");
        if (!cursorEl || !point) return;
        cursorEl.style.transform = `translate3d(${point.x}px, ${point.y}px, 0px)`;
      }
    }
  }
});
createProps$1()([
  "allowMouseWheel",
  "allowOverflow",
  "clampValueOnBlur",
  "dir",
  "disabled",
  "focusInputOnChange",
  "form",
  "formatOptions",
  "getRootNode",
  "id",
  "ids",
  "inputMode",
  "invalid",
  "locale",
  "max",
  "min",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueInvalid",
  "pattern",
  "required",
  "readOnly",
  "spinOnPress",
  "step",
  "translations",
  "value",
  "defaultValue"
]);
const useNumberInput = (props) => {
  const id2 = reactExports.useId();
  const { getRootNode } = useEnvironmentContext();
  const { dir, locale } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id: id2,
    ids: {
      label: field?.ids.label,
      input: field?.ids.control
    },
    disabled: field?.disabled,
    readOnly: field?.readOnly,
    required: field?.required,
    invalid: field?.invalid,
    dir,
    locale,
    getRootNode,
    ...props
  };
  const service = useMachine(machine$5, machineProps);
  return connect$5(service, normalizeProps);
};
const NumberInputRoot$1 = reactExports.forwardRef((props, ref) => {
  const [useNumberInputProps, localProps] = createSplitProps()(props, [
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "defaultValue",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "readOnly",
    "required",
    "spinOnPress",
    "step",
    "translations",
    "value"
  ]);
  const numberInput = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps(numberInput.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputProvider, { value: numberInput, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
});
NumberInputRoot$1.displayName = "NumberInputRoot";
const NumberInputRootProvider = reactExports.forwardRef((props, ref) => {
  const [{ value: numberInput }, localProps] = createSplitProps()(props, ["value"]);
  const mergedProps = mergeProps(numberInput.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputProvider, { value: numberInput, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
});
NumberInputRootProvider.displayName = "NumberInputRootProvider";
const NumberInputScrubber = reactExports.forwardRef((props, ref) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getScrubberProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
NumberInputScrubber.displayName = "NumberInputScrubber";
const NumberInputValueText = reactExports.forwardRef((props, ref) => {
  const { children, ...localProps } = props;
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getValueTextProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref, children: children || numberInput.value });
});
NumberInputValueText.displayName = "NumberInputValueText";
var anatomy$b = createAnatomy("pinInput").parts("root", "label", "input", "control");
anatomy$b.build();
createProps$1()([
  "autoFocus",
  "blurOnComplete",
  "count",
  "defaultValue",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "mask",
  "name",
  "onValueChange",
  "onValueComplete",
  "onValueInvalid",
  "otp",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "selectOnFocus",
  "translations",
  "type",
  "value"
]);
var anatomy$a = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
anatomy$a.build();
createProps$1()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "defaultOpen",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
const Portal = (props) => {
  const { children, disabled } = props;
  const [container, setContainer] = reactExports.useState(props.container?.current);
  const isServer = reactExports.useSyncExternalStore(
    subscribe$1,
    () => false,
    () => true
  );
  const { getRootNode } = useEnvironmentContext();
  reactExports.useEffect(() => {
    setContainer(() => props.container?.current);
  }, [props.container]);
  if (isServer || disabled) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  const mountNode = container ?? getPortalNode(getRootNode);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: reactExports.Children.map(children, (child) => reactDomExports.createPortal(child, mountNode)) });
};
const getPortalNode = (cb2) => {
  const node2 = cb2?.();
  const rootNode = node2.getRootNode();
  if (isShadowRoot$1(rootNode)) return rootNode;
  return getDocument(node2).body;
};
const subscribe$1 = () => () => {
};
var anatomy$9 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
anatomy$9.build();
createProps$1()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange",
  "defaultValue",
  "formatOptions",
  "locale"
]);
var anatomy$8 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay", "downloadTrigger");
anatomy$8.build();
createProps$1()([
  "ids",
  "defaultValue",
  "value",
  "id",
  "encoding",
  "dir",
  "getRootNode",
  "onValueChange",
  "pixelSize"
]);
var anatomy$7 = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
anatomy$7.build();
createProps$1()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value",
  "defaultValue"
]);
createProps$1()(["value", "disabled", "invalid"]);
var anatomy$6 = createAnatomy("rating-group").parts("root", "label", "item", "control");
anatomy$6.build();
createProps$1()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "required",
  "readOnly",
  "translations",
  "value",
  "defaultValue"
]);
createProps$1()(["index"]);
const segmentGroupAnatomy = anatomy$7.rename("segment-group");
segmentGroupAnatomy.build();
const [SelectProvider, useSelectContext] = createContext({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
});
const SelectClearTrigger$2 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getClearTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
SelectClearTrigger$2.displayName = "SelectClearTrigger";
const SelectContent$2 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(select.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
SelectContent$2.displayName = "SelectContent";
const SelectContext$1 = (props) => props.children(useSelectContext());
const SelectControl$1 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getControlProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
SelectControl$1.displayName = "SelectControl";
const SelectHiddenSelect$1 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getHiddenSelectProps(), props);
  const isValueEmpty = select.value.length === 0;
  const field = useFieldContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ark.select, { "aria-describedby": field?.ariaDescribedby, ...mergedProps, ref, children: [
    isValueEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }),
    select.collection.items.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "option",
      {
        value: select.collection.getItemValue(item) ?? "",
        disabled: select.collection.getItemDisabled(item),
        children: select.collection.stringifyItem(item)
      },
      index
    ))
  ] });
});
SelectHiddenSelect$1.displayName = "SelectHiddenSelect";
const SelectIndicator$1 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getIndicatorProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
SelectIndicator$1.displayName = "SelectIndicator";
const [SelectItemProvider, useSelectItemContext] = createContext({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
});
const [SelectItemPropsProvider, useSelectItemPropsContext] = createContext({
  name: "SelectItemPropsContext",
  hookName: "useSelectItemPropsContext",
  providerName: "<SelectItemPropsProvider />"
});
const SelectItem$2 = reactExports.forwardRef((props, ref) => {
  const [itemProps, localProps] = createSplitProps()(props, ["item", "persistFocus"]);
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getItemProps(itemProps), localProps);
  const itemState = select.getItemState(itemProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemPropsProvider, { value: itemProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemProvider, { value: itemState, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
});
SelectItem$2.displayName = "SelectItem";
const [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext({
  name: "SelectItemGroupPropsContext",
  hookName: "useSelectItemGroupPropsContext",
  providerName: "<SelectItemGroupPropsProvider />"
});
const SelectItemGroup$1 = reactExports.forwardRef((props, ref) => {
  const id2 = reactExports.useId();
  const [_itemGroupProps, localProps] = createSplitProps()(props, ["id"]);
  const itemGroupProps = { id: id2, ..._itemGroupProps };
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getItemGroupProps(itemGroupProps), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemGroupPropsProvider, { value: itemGroupProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
});
SelectItemGroup$1.displayName = "SelectItemGroup";
const SelectItemGroupLabel$1 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const itemGroupProps = useSelectItemGroupPropsContext();
  const mergedProps = mergeProps(select.getItemGroupLabelProps({ htmlFor: itemGroupProps.id }), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
SelectItemGroupLabel$1.displayName = "SelectItemGroupLabel";
const SelectItemIndicator$1 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const itemProps = useSelectItemPropsContext();
  const mergedProps = mergeProps(select.getItemIndicatorProps(itemProps), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
SelectItemIndicator$1.displayName = "SelectItemIndicator";
const SelectItemText = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const itemProps = useSelectItemPropsContext();
  const mergedProps = mergeProps(select.getItemTextProps(itemProps), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref });
});
SelectItemText.displayName = "SelectItemText";
const SelectLabel = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref });
});
SelectLabel.displayName = "SelectLabel";
const SelectPositioner$1 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getPositionerProps(), props);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
SelectPositioner$1.displayName = "SelectPositioner";
var anatomy$5 = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control",
  "valueText"
);
var parts$4 = anatomy$5.build();
var collection = (options2) => {
  return new ListCollection(options2);
};
collection.empty = () => {
  return new ListCollection({ items: [] });
};
var getRootId$3 = (ctx) => ctx.ids?.root ?? `select:${ctx.id}`;
var getContentId$2 = (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`;
var getTriggerId$2 = (ctx) => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`;
var getClearTriggerId = (ctx) => ctx.ids?.clearTrigger ?? `select:${ctx.id}:clear-trigger`;
var getLabelId$1 = (ctx) => ctx.ids?.label ?? `select:${ctx.id}:label`;
var getControlId$1 = (ctx) => ctx.ids?.control ?? `select:${ctx.id}:control`;
var getItemId = (ctx, id2) => ctx.ids?.item?.(id2) ?? `select:${ctx.id}:option:${id2}`;
var getHiddenSelectId = (ctx) => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`;
var getPositionerId$1 = (ctx) => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`;
var getItemGroupId = (ctx, id2) => ctx.ids?.itemGroup?.(id2) ?? `select:${ctx.id}:optgroup:${id2}`;
var getItemGroupLabelId = (ctx, id2) => ctx.ids?.itemGroupLabel?.(id2) ?? `select:${ctx.id}:optgroup-label:${id2}`;
var getHiddenSelectEl = (ctx) => ctx.getById(getHiddenSelectId(ctx));
var getContentEl$1 = (ctx) => ctx.getById(getContentId$2(ctx));
var getTriggerEl$2 = (ctx) => ctx.getById(getTriggerId$2(ctx));
var getClearTriggerEl = (ctx) => ctx.getById(getClearTriggerId(ctx));
var getPositionerEl$1 = (ctx) => ctx.getById(getPositionerId$1(ctx));
var getItemEl = (ctx, id2) => ctx.getById(getItemId(ctx, id2));
function connect$4(service, normalize2) {
  const { context, prop, scope, state, computed, send } = service;
  const disabled = prop("disabled") || context.get("fieldsetDisabled");
  const invalid = prop("invalid");
  const readOnly = prop("readOnly");
  const composite = prop("composite");
  const collection2 = prop("collection");
  const open = state.hasTag("open");
  const focused = state.matches("focused");
  const highlightedValue = context.get("highlightedValue");
  const highlightedItem = context.get("highlightedItem");
  const selectedItems = context.get("selectedItems");
  const currentPlacement = context.get("currentPlacement");
  const isTypingAhead = computed("isTypingAhead");
  const interactive = computed("isInteractive");
  const ariaActiveDescendant = highlightedValue ? getItemId(scope, highlightedValue) : void 0;
  function getItemState(props2) {
    const _disabled = collection2.getItemDisabled(props2.item);
    const value = collection2.getItemValue(props2.item);
    ensure(value, () => `[zag-js] No value found for item ${JSON.stringify(props2.item)}`);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: context.get("value").includes(value)
    };
  }
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: currentPlacement
  });
  return {
    open,
    focused,
    empty: context.get("value").length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: computed("hasSelectedItems"),
    value: context.get("value"),
    valueAsString: context.get("valueAsString"),
    collection: collection2,
    multiple: !!prop("multiple"),
    disabled: !!disabled,
    reposition(options2 = {}) {
      send({ type: "POSITIONING.SET", options: options2 });
    },
    focus() {
      getTriggerEl$2(scope)?.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      const open2 = state.hasTag("open");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    selectAll() {
      send({ type: "VALUE.SET", value: collection2.getValues() });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize2.element({
        ...parts$4.root.attrs,
        dir: prop("dir"),
        id: getRootId$3(scope),
        "data-invalid": dataAttr$1(invalid),
        "data-readonly": dataAttr$1(readOnly)
      });
    },
    getLabelProps() {
      return normalize2.label({
        dir: prop("dir"),
        id: getLabelId$1(scope),
        ...parts$4.label.attrs,
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-readonly": dataAttr$1(readOnly),
        htmlFor: getHiddenSelectId(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          getTriggerEl$2(scope)?.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts$4.control.attrs,
        dir: prop("dir"),
        id: getControlId$1(scope),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr$1(focused),
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid)
      });
    },
    getValueTextProps() {
      return normalize2.element({
        ...parts$4.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-focus": dataAttr$1(focused)
      });
    },
    getTriggerProps() {
      return normalize2.button({
        id: getTriggerId$2(scope),
        disabled,
        dir: prop("dir"),
        type: "button",
        role: "combobox",
        "aria-controls": getContentId$2(scope),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": getLabelId$1(scope),
        ...parts$4.trigger.attrs,
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-readonly": dataAttr$1(readOnly),
        "data-placement": currentPlacement,
        "data-placeholder-shown": dataAttr$1(!computed("hasSelectedItems")),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          send({ type: "TRIGGER.CLICK" });
        },
        onFocus() {
          send({ type: "TRIGGER.FOCUS" });
        },
        onBlur() {
          send({ type: "TRIGGER.BLUR" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!interactive) return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec = keyMap2[getEventKey(event, {
            dir: prop("dir"),
            orientation: "vertical"
          })];
          if (exec) {
            exec(event);
            event.preventDefault();
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize2.element({
        ...parts$4.indicator.attrs,
        dir: prop("dir"),
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr$1(disabled),
        "data-invalid": dataAttr$1(invalid),
        "data-readonly": dataAttr$1(readOnly)
      });
    },
    getItemProps(props2) {
      const itemState = getItemState(props2);
      return normalize2.element({
        id: getItemId(scope, itemState.value),
        role: "option",
        ...parts$4.item.attrs,
        dir: prop("dir"),
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": dataAttr$1(itemState.highlighted),
        "data-disabled": dataAttr$1(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse") return;
          if (itemState.value === highlightedValue) return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (itemState.disabled) return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          if (itemState.disabled) return;
          if (props2.persistFocus) return;
          if (event.pointerType !== "mouse") return;
          const pointerMoved = service.event.previous()?.type.includes("POINTER");
          if (!pointerMoved) return;
          send({ type: "ITEM.POINTER_LEAVE" });
        }
      });
    },
    getItemTextProps(props2) {
      const itemState = getItemState(props2);
      return normalize2.element({
        ...parts$4.itemText.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-disabled": dataAttr$1(itemState.disabled),
        "data-highlighted": dataAttr$1(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props2) {
      const itemState = getItemState(props2);
      return normalize2.element({
        "aria-hidden": true,
        ...parts$4.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props2) {
      const { htmlFor } = props2;
      return normalize2.element({
        ...parts$4.itemGroupLabel.attrs,
        id: getItemGroupLabelId(scope, htmlFor),
        dir: prop("dir"),
        role: "presentation"
      });
    },
    getItemGroupProps(props2) {
      const { id: id2 } = props2;
      return normalize2.element({
        ...parts$4.itemGroup.attrs,
        "data-disabled": dataAttr$1(disabled),
        id: getItemGroupId(scope, id2),
        "aria-labelledby": getItemGroupLabelId(scope, id2),
        role: "group",
        dir: prop("dir")
      });
    },
    getClearTriggerProps() {
      return normalize2.button({
        ...parts$4.clearTrigger.attrs,
        id: getClearTriggerId(scope),
        type: "button",
        "aria-label": "Clear value",
        "data-invalid": dataAttr$1(invalid),
        disabled,
        hidden: !computed("hasSelectedItems"),
        dir: prop("dir"),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "CLEAR.CLICK" });
        }
      });
    },
    getHiddenSelectProps() {
      const value = context.get("value");
      const defaultValue = prop("multiple") ? value : value?.[0];
      return normalize2.select({
        name: prop("name"),
        form: prop("form"),
        disabled,
        multiple: prop("multiple"),
        required: prop("required"),
        "aria-hidden": true,
        id: getHiddenSelectId(scope),
        defaultValue,
        style: visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          getTriggerEl$2(scope)?.focus({ preventScroll: true });
        },
        "aria-labelledby": getLabelId$1(scope)
      });
    },
    getPositionerProps() {
      return normalize2.element({
        ...parts$4.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId$1(scope),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        hidden: !open,
        dir: prop("dir"),
        id: getContentId$2(scope),
        role: composite ? "listbox" : "dialog",
        ...parts$4.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": prop("multiple") && composite ? true : void 0,
        "aria-labelledby": getLabelId$1(scope),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive) return;
          if (!isSelfTarget(event)) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                keyMap2.Enter?.(event2);
              }
            }
          };
          const exec = keyMap2[getEventKey(event)];
          if (exec) {
            exec(event);
            event.preventDefault();
            return;
          }
          const target = getEventTarget(event);
          if (isEditableElement(target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts$4.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": getTriggerId$2(scope),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && prop("multiple") ? true : void 0
      });
    }
  };
}
var { and: and$1, not: not$4, or } = createGuards();
var machine$4 = createMachine$1({
  props({ props: props2 }) {
    return {
      loopFocus: false,
      closeOnSelect: !props2.multiple,
      composite: true,
      defaultValue: [],
      ...props2,
      collection: props2.collection ?? collection.empty(),
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props2.positioning
      }
    };
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        isEqual,
        onChange(value) {
          const items = prop("collection").findMany(value);
          return prop("onValueChange")?.({ value, items });
        }
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          prop("onHighlightChange")?.({
            highlightedValue: value,
            highlightedItem: prop("collection").find(value),
            highlightedIndex: prop("collection").indexOf(value)
          });
        }
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      })),
      highlightedItem: bindable(() => ({
        defaultValue: null
      })),
      selectedItems: bindable(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        const items = prop("collection").findMany(value);
        return { defaultValue: items };
      }),
      valueAsString: bindable(() => {
        const value = prop("value") ?? prop("defaultValue") ?? [];
        return { defaultValue: prop("collection").stringifyMany(value) };
      })
    };
  },
  refs() {
    return {
      typeahead: { ...getByTypeahead.defaultOptions }
    };
  },
  computed: {
    hasSelectedItems: ({ context }) => context.get("value").length > 0,
    isTypingAhead: ({ refs }) => refs.get("typeahead").keysSoFar !== "",
    isDisabled: ({ prop, context }) => !!prop("disabled") || !!context.get("fieldsetDisabled"),
    isInteractive: ({ prop }) => !(prop("disabled") || prop("readOnly"))
  },
  initialState({ prop }) {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "idle";
  },
  entry: ["syncSelectElement"],
  watch({ context, prop, track, action }) {
    track([() => context.get("value").toString()], () => {
      action(["syncSelectedItems", "syncSelectElement", "dispatchChangeEvent"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
    track([() => context.get("highlightedValue")], () => {
      action(["syncHighlightedItem"]);
    });
    track([() => prop("collection").toString()], () => {
      action(["syncCollection"]);
    });
  },
  on: {
    "HIGHLIGHTED_VALUE.SET": {
      actions: ["setHighlightedItem"]
    },
    "ITEM.SELECT": {
      actions: ["selectItem"]
    },
    "ITEM.CLEAR": {
      actions: ["clearItem"]
    },
    "VALUE.SET": {
      actions: ["setSelectedItems"]
    },
    "VALUE.CLEAR": {
      actions: ["clearSelectedItems"]
    },
    "CLEAR.CLICK": {
      actions: ["clearSelectedItems", "focusTriggerEl"]
    }
  },
  effects: ["trackFormControlState"],
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: "isTriggerClickEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightFirstSelectedItem"]
          },
          {
            target: "open",
            actions: ["setInitialFocus"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
          }
        ],
        "TRIGGER.FOCUS": {
          target: "focused"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen"]
          }
        ]
      }
    },
    focused: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: "isTriggerClickEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightFirstSelectedItem"]
          },
          {
            guard: "isTriggerArrowUpEvent",
            target: "open",
            actions: ["setInitialFocus", "highlightComputedLastItem"]
          },
          {
            guard: or("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
            target: "open",
            actions: ["setInitialFocus", "highlightComputedFirstItem"]
          },
          {
            target: "open",
            actions: ["setInitialFocus"]
          }
        ],
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen"]
          }
        ],
        "TRIGGER.BLUR": {
          target: "idle"
        },
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
          }
        ],
        "TRIGGER.ENTER": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
          }
        ],
        "TRIGGER.ARROW_UP": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
          }
        ],
        "TRIGGER.ARROW_DOWN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
          }
        ],
        "TRIGGER.ARROW_LEFT": [
          {
            guard: and$1(not$4("multiple"), "hasSelectedItems"),
            actions: ["selectPreviousItem"]
          },
          {
            guard: not$4("multiple"),
            actions: ["selectLastItem"]
          }
        ],
        "TRIGGER.ARROW_RIGHT": [
          {
            guard: and$1(not$4("multiple"), "hasSelectedItems"),
            actions: ["selectNextItem"]
          },
          {
            guard: not$4("multiple"),
            actions: ["selectFirstItem"]
          }
        ],
        "TRIGGER.HOME": {
          guard: not$4("multiple"),
          actions: ["selectFirstItem"]
        },
        "TRIGGER.END": {
          guard: not$4("multiple"),
          actions: ["selectLastItem"]
        },
        "TRIGGER.TYPEAHEAD": {
          guard: not$4("multiple"),
          actions: ["selectMatchingItem"]
        }
      }
    },
    open: {
      tags: ["open"],
      exit: ["scrollContentToTop"],
      effects: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
      on: {
        "CONTROLLED.CLOSE": {
          target: "focused",
          actions: ["focusTriggerEl", "clearHighlightedItem"]
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
          }
        ],
        "TRIGGER.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["invokeOnClose", "clearHighlightedItem"]
          }
        ],
        "ITEM.CLICK": [
          {
            guard: and$1("closeOnSelect", "isOpenControlled"),
            actions: ["selectHighlightedItem", "invokeOnClose"]
          },
          {
            guard: "closeOnSelect",
            target: "focused",
            actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
          },
          {
            actions: ["selectHighlightedItem"]
          }
        ],
        "CONTENT.HOME": {
          actions: ["highlightFirstItem"]
        },
        "CONTENT.END": {
          actions: ["highlightLastItem"]
        },
        "CONTENT.ARROW_DOWN": [
          {
            guard: and$1("hasHighlightedItem", "loop", "isLastItemHighlighted"),
            actions: ["highlightFirstItem"]
          },
          {
            guard: "hasHighlightedItem",
            actions: ["highlightNextItem"]
          },
          {
            actions: ["highlightFirstItem"]
          }
        ],
        "CONTENT.ARROW_UP": [
          {
            guard: and$1("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
            actions: ["highlightLastItem"]
          },
          {
            guard: "hasHighlightedItem",
            actions: ["highlightPreviousItem"]
          },
          {
            actions: ["highlightLastItem"]
          }
        ],
        "CONTENT.TYPEAHEAD": {
          actions: ["highlightMatchingItem"]
        },
        "ITEM.POINTER_MOVE": {
          actions: ["highlightItem"]
        },
        "ITEM.POINTER_LEAVE": {
          actions: ["clearHighlightedItem"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      loop: ({ prop }) => !!prop("loopFocus"),
      multiple: ({ prop }) => !!prop("multiple"),
      hasSelectedItems: ({ computed }) => !!computed("hasSelectedItems"),
      hasHighlightedItem: ({ context }) => context.get("highlightedValue") != null,
      isFirstItemHighlighted: ({ context, prop }) => context.get("highlightedValue") === prop("collection").firstValue,
      isLastItemHighlighted: ({ context, prop }) => context.get("highlightedValue") === prop("collection").lastValue,
      closeOnSelect: ({ prop, event }) => !!(event.closeOnSelect ?? prop("closeOnSelect")),
      // guard assertions (for controlled mode)
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      isTriggerClickEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.CLICK",
      isTriggerEnterEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ENTER",
      isTriggerArrowUpEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ARROW_UP",
      isTriggerArrowDownEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ARROW_DOWN"
    },
    effects: {
      trackFormControlState({ context, scope }) {
        return trackFormControl(getHiddenSelectEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const value = context.initial("value");
            context.set("value", value);
          }
        });
      },
      trackDismissableElement({ scope, send, prop }) {
        const contentEl = () => getContentEl$1(scope);
        let restoreFocus = true;
        return trackDismissableElement(contentEl, {
          defer: true,
          exclude: [getTriggerEl$2(scope), getClearTriggerEl(scope)],
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      computePlacement({ context, prop, scope }) {
        const positioning = prop("positioning");
        context.set("currentPlacement", positioning.placement);
        const triggerEl = () => getTriggerEl$2(scope);
        const positionerEl = () => getPositionerEl$1(scope);
        return getPlacement(triggerEl, positionerEl, {
          defer: true,
          ...positioning,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      scrollToHighlightedItem({ context, prop, scope, event }) {
        const exec = (immediate) => {
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue == null) return;
          if (event.current().type.includes("POINTER")) return;
          const optionEl = getItemEl(scope, highlightedValue);
          const contentEl2 = getContentEl$1(scope);
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const highlightedIndex = prop("collection").indexOf(highlightedValue);
            scrollToIndexFn?.({ index: highlightedIndex, immediate });
            return;
          }
          scrollIntoView(optionEl, { rootEl: contentEl2, block: "nearest" });
        };
        raf$1(() => exec(true));
        const contentEl = () => getContentEl$1(scope);
        return observeAttributes(contentEl, {
          defer: true,
          attributes: ["data-activedescendant"],
          callback() {
            exec(false);
          }
        });
      }
    },
    actions: {
      reposition({ context, prop, scope, event }) {
        const positionerEl = () => getPositionerEl$1(scope);
        getPlacement(getTriggerEl$2(scope), positionerEl, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility({ send, prop, event }) {
        send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
      },
      highlightPreviousItem({ context, prop }) {
        const highlightedValue = context.get("highlightedValue");
        if (highlightedValue == null) return;
        const value = prop("collection").getPreviousValue(highlightedValue, 1, prop("loopFocus"));
        context.set("highlightedValue", value);
      },
      highlightNextItem({ context, prop }) {
        const highlightedValue = context.get("highlightedValue");
        if (highlightedValue == null) return;
        const value = prop("collection").getNextValue(highlightedValue, 1, prop("loopFocus"));
        context.set("highlightedValue", value);
      },
      highlightFirstItem({ context, prop }) {
        const value = prop("collection").firstValue;
        context.set("highlightedValue", value);
      },
      highlightLastItem({ context, prop }) {
        const value = prop("collection").lastValue;
        context.set("highlightedValue", value);
      },
      setInitialFocus({ scope }) {
        raf$1(() => {
          const element = getInitialFocus({
            root: getContentEl$1(scope)
          });
          element?.focus({ preventScroll: true });
        });
      },
      focusTriggerEl({ event, scope }) {
        const restoreFocus = event.restoreFocus ?? event.previousEvent?.restoreFocus;
        if (restoreFocus != null && !restoreFocus) return;
        raf$1(() => {
          const element = getTriggerEl$2(scope);
          element?.focus({ preventScroll: true });
        });
      },
      selectHighlightedItem({ context, prop, event }) {
        let value = event.value ?? context.get("highlightedValue");
        if (value == null) return;
        const nullable = prop("deselectable") && !prop("multiple") && context.get("value").includes(value);
        value = nullable ? null : value;
        context.set("value", (prev2) => {
          if (value == null) return [];
          if (prop("multiple")) return addOrRemove(prev2, value);
          return [value];
        });
      },
      highlightComputedFirstItem({ context, prop, computed }) {
        const collection2 = prop("collection");
        const value = computed("hasSelectedItems") ? collection2.sort(context.get("value"))[0] : collection2.firstValue;
        context.set("highlightedValue", value);
      },
      highlightComputedLastItem({ context, prop, computed }) {
        const collection2 = prop("collection");
        const value = computed("hasSelectedItems") ? collection2.sort(context.get("value"))[0] : collection2.lastValue;
        context.set("highlightedValue", value);
      },
      highlightFirstSelectedItem({ context, prop, computed }) {
        if (!computed("hasSelectedItems")) return;
        const value = prop("collection").sort(context.get("value"))[0];
        context.set("highlightedValue", value);
      },
      highlightItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      highlightMatchingItem({ context, prop, event, refs }) {
        const value = prop("collection").search(event.key, {
          state: refs.get("typeahead"),
          currentValue: context.get("highlightedValue")
        });
        if (value == null) return;
        context.set("highlightedValue", value);
      },
      setHighlightedItem({ context, event }) {
        context.set("highlightedValue", event.value);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      selectItem({ context, prop, event }) {
        const nullable = prop("deselectable") && !prop("multiple") && context.get("value").includes(event.value);
        const value = nullable ? null : event.value;
        context.set("value", (prev2) => {
          if (value == null) return [];
          if (prop("multiple")) return addOrRemove(prev2, value);
          return [value];
        });
      },
      clearItem({ context, event }) {
        context.set("value", (prev2) => prev2.filter((v2) => v2 !== event.value));
      },
      setSelectedItems({ context, event }) {
        context.set("value", event.value);
      },
      clearSelectedItems({ context }) {
        context.set("value", []);
      },
      selectPreviousItem({ context, prop }) {
        const [firstItem] = context.get("value");
        const value = prop("collection").getPreviousValue(firstItem);
        if (value) context.set("value", [value]);
      },
      selectNextItem({ context, prop }) {
        const [firstItem] = context.get("value");
        const value = prop("collection").getNextValue(firstItem);
        if (value) context.set("value", [value]);
      },
      selectFirstItem({ context, prop }) {
        const value = prop("collection").firstValue;
        if (value) context.set("value", [value]);
      },
      selectLastItem({ context, prop }) {
        const value = prop("collection").lastValue;
        if (value) context.set("value", [value]);
      },
      selectMatchingItem({ context, prop, event, refs }) {
        const value = prop("collection").search(event.key, {
          state: refs.get("typeahead"),
          currentValue: context.get("value")[0]
        });
        if (value == null) return;
        context.set("value", [value]);
      },
      scrollContentToTop({ prop, scope }) {
        if (prop("scrollToIndexFn")) {
          prop("scrollToIndexFn")?.({ index: 0, immediate: true });
        } else {
          getContentEl$1(scope)?.scrollTo(0, 0);
        }
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      syncSelectElement({ context, prop, scope }) {
        const selectEl = getHiddenSelectEl(scope);
        if (!selectEl) return;
        if (context.get("value").length === 0 && !prop("multiple")) {
          selectEl.selectedIndex = -1;
          return;
        }
        for (const option of selectEl.options) {
          option.selected = context.get("value").includes(option.value);
        }
      },
      syncCollection({ context, prop }) {
        const collection2 = prop("collection");
        const highlightedItem = collection2.find(context.get("highlightedValue"));
        if (highlightedItem) context.set("highlightedItem", highlightedItem);
        const selectedItems = collection2.findMany(context.get("value"));
        context.set("selectedItems", selectedItems);
        const valueAsString = collection2.stringifyItems(selectedItems);
        context.set("valueAsString", valueAsString);
      },
      syncSelectedItems({ context, prop }) {
        const collection2 = prop("collection");
        const prevSelectedItems = context.get("selectedItems");
        const value = context.get("value");
        const selectedItems = value.map((value2) => {
          const item = prevSelectedItems.find((item2) => collection2.getItemValue(item2) === value2);
          return item || collection2.find(value2);
        });
        context.set("selectedItems", selectedItems);
        context.set("valueAsString", collection2.stringifyItems(selectedItems));
      },
      syncHighlightedItem({ context, prop }) {
        const collection2 = prop("collection");
        const highlightedValue = context.get("highlightedValue");
        const highlightedItem = highlightedValue ? collection2.find(highlightedValue) : null;
        context.set("highlightedItem", highlightedItem);
      },
      dispatchChangeEvent({ scope }) {
        queueMicrotask(() => {
          const node2 = getHiddenSelectEl(scope);
          if (!node2) return;
          const win = scope.getWin();
          const changeEvent = new win.Event("change", { bubbles: true, composed: true });
          node2.dispatchEvent(changeEvent);
        });
      }
    }
  }
});
createProps$1()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "deselectable",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "defaultOpen",
  "open",
  "composite",
  "positioning",
  "required",
  "readOnly",
  "scrollToIndexFn",
  "value",
  "defaultValue",
  "defaultHighlightedValue"
]);
createProps$1()(["item", "persistFocus"]);
createProps$1()(["id"]);
createProps$1()(["htmlFor"]);
const useSelect = (props) => {
  const id2 = reactExports.useId();
  const { dir } = useLocaleContext();
  const { getRootNode } = useEnvironmentContext();
  const field = useFieldContext();
  const machineProps = {
    id: id2,
    ids: {
      label: field?.ids.label,
      hiddenSelect: field?.ids.control
    },
    disabled: field?.disabled,
    readOnly: field?.readOnly,
    invalid: field?.invalid,
    required: field?.required,
    dir,
    getRootNode,
    ...props
  };
  const service = useMachine(machine$4, machineProps);
  return connect$4(service, normalizeProps);
};
const SelectImpl$1 = (props, ref) => {
  const [presenceProps, selectProps] = splitPresenceProps(props);
  const [useSelectProps, localProps] = createSplitProps()(selectProps, [
    "closeOnSelect",
    "collection",
    "composite",
    "defaultHighlightedValue",
    "defaultOpen",
    "defaultValue",
    "deselectable",
    "disabled",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "value"
  ]);
  const select = useSelect(useSelectProps);
  const presence = usePresence(mergeProps({ present: select.open }, presenceProps));
  const mergedProps = mergeProps(select.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectProvider, { value: select, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
};
const SelectRoot$2 = reactExports.forwardRef(SelectImpl$1);
const SelectImpl = (props, ref) => {
  const [presenceProps, selectProps] = splitPresenceProps(props);
  const [{ value: select }, localProps] = createSplitProps()(selectProps, ["value"]);
  const presence = usePresence(mergeProps({ present: select.open }, presenceProps));
  const mergedProps = mergeProps(select.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectProvider, { value: select, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
};
const SelectRootProvider = reactExports.forwardRef(SelectImpl);
const SelectTrigger$2 = reactExports.forwardRef((props, ref) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
SelectTrigger$2.displayName = "SelectTrigger";
const SelectValueText$2 = reactExports.forwardRef((props, ref) => {
  const { children, placeholder, ...localprops } = props;
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getValueTextProps(), localprops);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref, children: children || select.valueAsString || placeholder });
});
SelectValueText$2.displayName = "SelectValueText";
var anatomy$4 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker",
  "draggingIndicator"
);
anatomy$4.build();
createProps$1()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value",
  "defaultValue"
]);
createProps$1()(["index", "name"]);
const [SwitchProvider, useSwitchContext] = createContext({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});
const SwitchControl$1 = reactExports.forwardRef((props, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getControlProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref });
});
SwitchControl$1.displayName = "SwitchControl";
const SwitchHiddenInput$1 = reactExports.forwardRef((props, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getHiddenInputProps(), props);
  const field = useFieldContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.input, { "aria-describedby": field?.ariaDescribedby, ...mergedProps, ref });
});
SwitchHiddenInput$1.displayName = "SwitchHiddenInput";
const SwitchLabel$1 = reactExports.forwardRef((props, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getLabelProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref });
});
SwitchLabel$1.displayName = "SwitchLabel";
var anatomy$3 = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts$3 = anatomy$3.build();
var getRootId$2 = (ctx) => ctx.ids?.root ?? `switch:${ctx.id}`;
var getLabelId = (ctx) => ctx.ids?.label ?? `switch:${ctx.id}:label`;
var getThumbId = (ctx) => ctx.ids?.thumb ?? `switch:${ctx.id}:thumb`;
var getControlId = (ctx) => ctx.ids?.control ?? `switch:${ctx.id}:control`;
var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `switch:${ctx.id}:input`;
var getRootEl$1 = (ctx) => ctx.getById(getRootId$2(ctx));
var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
function connect$3(service, normalize2) {
  const { context, send, prop, scope } = service;
  const disabled = prop("disabled");
  const readOnly = prop("readOnly");
  const checked = !!context.get("checked");
  const focused = !disabled && context.get("focused");
  const focusVisible = !disabled && context.get("focusVisible");
  const dataAttrs = {
    "data-active": dataAttr$1(context.get("active")),
    "data-focus": dataAttr$1(focused),
    "data-focus-visible": dataAttr$1(focusVisible),
    "data-readonly": dataAttr$1(readOnly),
    "data-hover": dataAttr$1(context.get("hovered")),
    "data-disabled": dataAttr$1(disabled),
    "data-state": checked ? "checked" : "unchecked",
    "data-invalid": dataAttr$1(prop("invalid"))
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize2.label({
        ...parts$3.root.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getRootId$2(scope),
        htmlFor: getHiddenInputId(scope),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === getHiddenInputEl(scope)) {
            event.stopPropagation();
          }
          if (isSafari()) {
            getHiddenInputEl(scope)?.focus();
          }
        }
      });
    },
    getLabelProps() {
      return normalize2.element({
        ...parts$3.label.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getLabelId(scope)
      });
    },
    getThumbProps() {
      return normalize2.element({
        ...parts$3.thumb.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getThumbId(scope),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize2.element({
        ...parts$3.control.attrs,
        ...dataAttrs,
        dir: prop("dir"),
        id: getControlId(scope),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize2.input({
        id: getHiddenInputId(scope),
        type: "checkbox",
        required: prop("required"),
        defaultChecked: checked,
        disabled,
        "aria-labelledby": getLabelId(scope),
        "aria-invalid": prop("invalid"),
        name: prop("name"),
        form: prop("form"),
        value: prop("value"),
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not$3 } = createGuards();
var machine$3 = createMachine$1({
  props({ props: props2 }) {
    return {
      defaultChecked: false,
      label: "switch",
      value: "on",
      ...props2
    };
  },
  initialState() {
    return "ready";
  },
  context({ prop, bindable }) {
    return {
      checked: bindable(() => ({
        defaultValue: prop("defaultChecked"),
        value: prop("checked"),
        onChange(value) {
          prop("onCheckedChange")?.({ checked: value });
        }
      })),
      fieldsetDisabled: bindable(() => ({
        defaultValue: false
      })),
      focusVisible: bindable(() => ({
        defaultValue: false
      })),
      active: bindable(() => ({
        defaultValue: false
      })),
      focused: bindable(() => ({
        defaultValue: false
      })),
      hovered: bindable(() => ({
        defaultValue: false
      }))
    };
  },
  computed: {
    isDisabled: ({ context, prop }) => prop("disabled") || context.get("fieldsetDisabled")
  },
  watch({ track, prop, context, action }) {
    track([() => prop("disabled")], () => {
      action(["removeFocusIfNeeded"]);
    });
    track([() => context.get("checked")], () => {
      action(["syncInputElement"]);
    });
  },
  effects: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
  on: {
    "CHECKED.TOGGLE": [
      {
        guard: not$3("isTrusted"),
        actions: ["toggleChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["toggleChecked"]
      }
    ],
    "CHECKED.SET": [
      {
        guard: not$3("isTrusted"),
        actions: ["setChecked", "dispatchChangeEvent"]
      },
      {
        actions: ["setChecked"]
      }
    ],
    "CONTEXT.SET": {
      actions: ["setContext"]
    }
  },
  states: {
    ready: {}
  },
  implementations: {
    guards: {
      isTrusted: ({ event }) => !!event.isTrusted
    },
    effects: {
      trackPressEvent({ computed, scope, context }) {
        if (computed("isDisabled")) return;
        return trackPress({
          pointerNode: getRootEl$1(scope),
          keyboardNode: getHiddenInputEl(scope),
          isValidKey: (event) => event.key === " ",
          onPress: () => context.set("active", false),
          onPressStart: () => context.set("active", true),
          onPressEnd: () => context.set("active", false)
        });
      },
      trackFocusVisible({ computed, scope }) {
        if (computed("isDisabled")) return;
        return trackFocusVisible({ root: scope.getRootNode() });
      },
      trackFormControlState({ context, send, scope }) {
        return trackFormControl(getHiddenInputEl(scope), {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            const checked = context.initial("checked");
            send({ type: "CHECKED.SET", checked: !!checked, src: "form-reset" });
          }
        });
      }
    },
    actions: {
      setContext({ context, event }) {
        for (const key in event.context) {
          context.set(key, event.context[key]);
        }
      },
      syncInputElement({ context, scope }) {
        const inputEl = getHiddenInputEl(scope);
        if (!inputEl) return;
        setElementChecked(inputEl, !!context.get("checked"));
      },
      removeFocusIfNeeded({ context, prop }) {
        if (prop("disabled")) {
          context.set("focused", false);
        }
      },
      setChecked({ context, event }) {
        context.set("checked", event.checked);
      },
      toggleChecked({ context }) {
        context.set("checked", !context.get("checked"));
      },
      dispatchChangeEvent({ context, scope }) {
        const inputEl = getHiddenInputEl(scope);
        dispatchInputCheckedEvent(inputEl, { checked: context.get("checked") });
      }
    }
  }
});
createProps$1()([
  "checked",
  "defaultChecked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
const useSwitch = (props) => {
  const id2 = reactExports.useId();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const machineProps = {
    id: id2,
    ids: {
      label: field?.ids.label,
      hiddenInput: field?.ids.control
    },
    dir,
    disabled: field?.disabled,
    readOnly: field?.readOnly,
    invalid: field?.invalid,
    required: field?.required,
    getRootNode,
    ...props
  };
  const service = useMachine(machine$3, machineProps);
  return connect$3(service, normalizeProps);
};
const SwitchRoot$1 = reactExports.forwardRef((props, ref) => {
  const [switchProps, localProps] = createSplitProps()(props, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps(switchContext.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchProvider, { value: switchContext, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref }) });
});
SwitchRoot$1.displayName = "SwitchRoot";
const SwitchRootProvider = reactExports.forwardRef((props, ref) => {
  const [{ value: api }, localProps] = createSplitProps()(props, ["value"]);
  const mergedProps = mergeProps(api.getRootProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchProvider, { value: api, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.label, { ...mergedProps, ref }) });
});
SwitchRootProvider.displayName = "SwitchRootProvider";
const SwitchThumb$1 = reactExports.forwardRef((props, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getThumbProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.span, { ...mergedProps, ref });
});
SwitchThumb$1.displayName = "SwitchThumb";
function useDebounce(value, delay2) {
  const [debouncedValue, setDebouncedValue] = reactExports.useState(value);
  reactExports.useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay2);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay2]);
  return debouncedValue;
}
const [TabsProvider, useTabsContext] = createContext({
  name: "TabsContext",
  hookName: "useTabsContext",
  providerName: "<TabsProvider />"
});
const TabContent = reactExports.forwardRef((props, ref) => {
  const [contentProps, localProps] = createSplitProps()(props, ["value"]);
  const tabs = useTabsContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: useDebounce(tabs.value === props.value, 0),
    immediate: true
  });
  const mergedProps = mergeProps(tabs.getContentProps(contentProps), presence.getPresenceProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children: presence.unmounted ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) }) });
});
TabContent.displayName = "TabContent";
const TabIndicator = reactExports.forwardRef((props, ref) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getIndicatorProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
TabIndicator.displayName = "TabIndicator";
const TabList = reactExports.forwardRef((props, ref) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getListProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
TabList.displayName = "TabList";
const TabTrigger = reactExports.forwardRef((props, ref) => {
  const [tabProps, localProps] = createSplitProps()(props, ["disabled", "value"]);
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getTriggerProps(tabProps), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
TabTrigger.displayName = "TabTrigger";
var anatomy$2 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts$2 = anatomy$2.build();
var getRootId$1 = (ctx) => ctx.ids?.root ?? `tabs:${ctx.id}`;
var getListId = (ctx) => ctx.ids?.list ?? `tabs:${ctx.id}:list`;
var getContentId$1 = (ctx, id2) => ctx.ids?.content ?? `tabs:${ctx.id}:content-${id2}`;
var getTriggerId$1 = (ctx, id2) => ctx.ids?.trigger ?? `tabs:${ctx.id}:trigger-${id2}`;
var getIndicatorId = (ctx) => ctx.ids?.indicator ?? `tabs:${ctx.id}:indicator`;
var getListEl = (ctx) => ctx.getById(getListId(ctx));
var getContentEl = (ctx, id2) => ctx.getById(getContentId$1(ctx, id2));
var getTriggerEl$1 = (ctx, id2) => ctx.getById(getTriggerId$1(ctx, id2));
var getIndicatorEl = (ctx) => ctx.getById(getIndicatorId(ctx));
var getElements = (ctx) => {
  const ownerId = CSS.escape(getListId(ctx));
  const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
  return queryAll(getListEl(ctx), selector);
};
var getFirstTriggerEl = (ctx) => first(getElements(ctx));
var getLastTriggerEl = (ctx) => last(getElements(ctx));
var getNextTriggerEl = (ctx, opts) => nextById(getElements(ctx), getTriggerId$1(ctx, opts.value), opts.loopFocus);
var getPrevTriggerEl = (ctx, opts) => prevById(getElements(ctx), getTriggerId$1(ctx, opts.value), opts.loopFocus);
var getOffsetRect = (el2) => {
  return {
    left: el2?.offsetLeft ?? 0,
    top: el2?.offsetTop ?? 0,
    width: el2?.offsetWidth ?? 0,
    height: el2?.offsetHeight ?? 0
  };
};
var getRectById = (ctx, id2) => {
  const tab = itemById(getElements(ctx), getTriggerId$1(ctx, id2));
  return resolveRect(getOffsetRect(tab));
};
var resolveRect = (rect) => ({
  width: `${rect.width}px`,
  height: `${rect.height}px`,
  left: `${rect.left}px`,
  top: `${rect.top}px`
});
function connect$2(service, normalize2) {
  const { state, send, context, prop, scope } = service;
  const translations = prop("translations");
  const focused = state.matches("focused");
  const isVertical = prop("orientation") === "vertical";
  const isHorizontal = prop("orientation") === "horizontal";
  const composite = prop("composite");
  function getTriggerState(props2) {
    return {
      selected: context.get("value") === props2.value,
      focused: context.get("focusedValue") === props2.value,
      disabled: !!props2.disabled
    };
  }
  return {
    value: context.get("value"),
    focusedValue: context.get("focusedValue"),
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id2 = getTriggerId$1(scope, value);
      send({ type: "SET_INDICATOR_RECT", id: id2 });
    },
    syncTabIndex() {
      send({ type: "SYNC_TAB_INDEX" });
    },
    selectNext(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
      send({ type: "ARROW_NEXT", src: "selectNext" });
    },
    selectPrev(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
      send({ type: "ARROW_PREV", src: "selectPrev" });
    },
    focus() {
      const value = context.get("value");
      if (!value) return;
      getTriggerEl$1(scope, value)?.focus();
    },
    getRootProps() {
      return normalize2.element({
        ...parts$2.root.attrs,
        id: getRootId$1(scope),
        "data-orientation": prop("orientation"),
        "data-focus": dataAttr$1(focused),
        dir: prop("dir")
      });
    },
    getListProps() {
      return normalize2.element({
        ...parts$2.list.attrs,
        id: getListId(scope),
        role: "tablist",
        dir: prop("dir"),
        "data-focus": dataAttr$1(focused),
        "aria-orientation": prop("orientation"),
        "data-orientation": prop("orientation"),
        "aria-label": translations?.listLabel,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          if (isComposingEvent(event)) return;
          const keyMap2 = {
            ArrowDown() {
              if (isHorizontal) return;
              send({ type: "ARROW_NEXT", key: "ArrowDown" });
            },
            ArrowUp() {
              if (isHorizontal) return;
              send({ type: "ARROW_PREV", key: "ArrowUp" });
            },
            ArrowLeft() {
              if (isVertical) return;
              send({ type: "ARROW_PREV", key: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical) return;
              send({ type: "ARROW_NEXT", key: "ArrowRight" });
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            },
            Enter() {
              send({ type: "ENTER" });
            }
          };
          let key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getTriggerState,
    getTriggerProps(props2) {
      const { value, disabled } = props2;
      const triggerState = getTriggerState(props2);
      return normalize2.button({
        ...parts$2.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        "data-disabled": dataAttr$1(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.selected,
        "data-selected": dataAttr$1(triggerState.selected),
        "data-focus": dataAttr$1(triggerState.focused),
        "aria-controls": triggerState.selected ? getContentId$1(scope, value) : void 0,
        "data-ownedby": getListId(scope),
        "data-ssr": dataAttr$1(context.get("ssr")),
        id: getTriggerId$1(scope, value),
        tabIndex: triggerState.selected && composite ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if (target?.getAttribute("role") !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props2) {
      const { value } = props2;
      const selected = context.get("value") === value;
      return normalize2.element({
        ...parts$2.content.attrs,
        dir: prop("dir"),
        id: getContentId$1(scope, value),
        tabIndex: composite ? 0 : -1,
        "aria-labelledby": getTriggerId$1(scope, value),
        role: "tabpanel",
        "data-ownedby": getListId(scope),
        "data-selected": dataAttr$1(selected),
        "data-orientation": prop("orientation"),
        hidden: !selected
      });
    },
    getIndicatorProps() {
      const indicatorRect = context.get("indicatorRect");
      const indicatorTransition = context.get("indicatorTransition");
      return normalize2.element({
        id: getIndicatorId(scope),
        ...parts$2.indicator.attrs,
        dir: prop("dir"),
        "data-orientation": prop("orientation"),
        style: {
          "--transition-property": "left, right, top, bottom, width, height",
          "--left": indicatorRect.left,
          "--top": indicatorRect.top,
          "--width": indicatorRect.width,
          "--height": indicatorRect.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: indicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not$2 } = createGuards();
var machine$2 = createMachine$1({
  props({ props: props2 }) {
    return {
      dir: "ltr",
      orientation: "horizontal",
      activationMode: "automatic",
      loopFocus: true,
      composite: true,
      navigate(details) {
        clickIfLink(details.node);
      },
      defaultValue: null,
      ...props2
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      })),
      focusedValue: bindable(() => ({
        defaultValue: prop("value") || prop("defaultValue"),
        sync: true,
        onChange(value) {
          prop("onFocusChange")?.({ focusedValue: value });
        }
      })),
      ssr: bindable(() => ({ defaultValue: true })),
      indicatorTransition: bindable(() => ({ defaultValue: false })),
      indicatorRect: bindable(() => ({
        defaultValue: { left: "0px", top: "0px", width: "0px", height: "0px" }
      }))
    };
  },
  watch({ context, prop, track, action }) {
    track([() => context.get("value")], () => {
      action(["allowIndicatorTransition", "syncIndicatorRect", "syncTabIndex", "navigateIfNeeded"]);
    });
    track([() => prop("dir"), () => prop("orientation")], () => {
      action(["syncIndicatorRect"]);
    });
  },
  on: {
    SET_VALUE: {
      actions: ["setValue"]
    },
    CLEAR_VALUE: {
      actions: ["clearValue"]
    },
    SET_INDICATOR_RECT: {
      actions: ["setIndicatorRect"]
    },
    SYNC_TAB_INDEX: {
      actions: ["syncTabIndex"]
    }
  },
  entry: ["syncIndicatorRect", "syncTabIndex", "syncSsr"],
  exit: ["cleanupObserver"],
  states: {
    idle: {
      on: {
        TAB_FOCUS: {
          target: "focused",
          actions: ["setFocusedValue"]
        },
        TAB_CLICK: {
          target: "focused",
          actions: ["setFocusedValue", "setValue"]
        }
      }
    },
    focused: {
      on: {
        TAB_CLICK: {
          target: "focused",
          actions: ["setFocusedValue", "setValue"]
        },
        ARROW_PREV: [
          {
            guard: "selectOnFocus",
            actions: ["focusPrevTab", "selectFocusedTab"]
          },
          {
            actions: ["focusPrevTab"]
          }
        ],
        ARROW_NEXT: [
          {
            guard: "selectOnFocus",
            actions: ["focusNextTab", "selectFocusedTab"]
          },
          {
            actions: ["focusNextTab"]
          }
        ],
        HOME: [
          {
            guard: "selectOnFocus",
            actions: ["focusFirstTab", "selectFocusedTab"]
          },
          {
            actions: ["focusFirstTab"]
          }
        ],
        END: [
          {
            guard: "selectOnFocus",
            actions: ["focusLastTab", "selectFocusedTab"]
          },
          {
            actions: ["focusLastTab"]
          }
        ],
        ENTER: {
          guard: not$2("selectOnFocus"),
          actions: ["selectFocusedTab"]
        },
        TAB_FOCUS: {
          actions: ["setFocusedValue"]
        },
        TAB_BLUR: {
          target: "idle",
          actions: ["clearFocusedValue"]
        }
      }
    }
  },
  implementations: {
    guards: {
      selectOnFocus: ({ prop }) => prop("activationMode") === "automatic"
    },
    actions: {
      selectFocusedTab({ context, prop }) {
        raf$1(() => {
          const focusedValue = context.get("focusedValue");
          if (!focusedValue) return;
          const nullable = prop("deselectable") && context.get("value") === focusedValue;
          const value = nullable ? null : focusedValue;
          context.set("value", value);
        });
      },
      setFocusedValue({ context, event, flush: flush2 }) {
        if (event.value == null) return;
        flush2(() => {
          context.set("focusedValue", event.value);
        });
      },
      clearFocusedValue({ context }) {
        context.set("focusedValue", null);
      },
      setValue({ context, event, prop }) {
        const nullable = prop("deselectable") && context.get("value") === context.get("focusedValue");
        context.set("value", nullable ? null : event.value);
      },
      clearValue({ context }) {
        context.set("value", null);
      },
      focusFirstTab({ scope }) {
        raf$1(() => {
          getFirstTriggerEl(scope)?.focus();
        });
      },
      focusLastTab({ scope }) {
        raf$1(() => {
          getLastTriggerEl(scope)?.focus();
        });
      },
      focusNextTab({ context, prop, scope, event }) {
        const focusedValue = event.value ?? context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getNextTriggerEl(scope, {
          value: focusedValue,
          loopFocus: prop("loopFocus")
        });
        raf$1(() => {
          if (prop("composite")) {
            triggerEl?.focus();
          } else if (triggerEl?.dataset.value != null) {
            context.set("focusedValue", triggerEl.dataset.value);
          }
        });
      },
      focusPrevTab({ context, prop, scope, event }) {
        const focusedValue = event.value ?? context.get("focusedValue");
        if (!focusedValue) return;
        const triggerEl = getPrevTriggerEl(scope, {
          value: focusedValue,
          loopFocus: prop("loopFocus")
        });
        raf$1(() => {
          if (prop("composite")) {
            triggerEl?.focus();
          } else if (triggerEl?.dataset.value != null) {
            context.set("focusedValue", triggerEl.dataset.value);
          }
        });
      },
      syncTabIndex({ context, scope }) {
        raf$1(() => {
          const value = context.get("value");
          if (!value) return;
          const contentEl = getContentEl(scope, value);
          if (!contentEl) return;
          const focusables = getFocusables(contentEl);
          if (focusables.length > 0) {
            contentEl.removeAttribute("tabindex");
          } else {
            contentEl.setAttribute("tabindex", "0");
          }
        });
      },
      cleanupObserver({ refs }) {
        const cleanup = refs.get("indicatorCleanup");
        if (cleanup) cleanup();
      },
      allowIndicatorTransition({ context }) {
        context.set("indicatorTransition", true);
      },
      setIndicatorRect({ context, event, scope }) {
        const value = event.id ?? context.get("value");
        const indicatorEl = getIndicatorEl(scope);
        if (!indicatorEl) return;
        if (!value) {
          context.set("indicatorTransition", false);
          return;
        }
        const triggerEl = getTriggerEl$1(scope, value);
        if (!triggerEl) return;
        context.set("indicatorRect", getRectById(scope, value));
        nextTick(() => {
          context.set("indicatorTransition", false);
        });
      },
      syncSsr({ context }) {
        context.set("ssr", false);
      },
      syncIndicatorRect({ context, refs, scope }) {
        const cleanup = refs.get("indicatorCleanup");
        if (cleanup) cleanup();
        const value = context.get("value");
        if (!value) {
          context.set("indicatorTransition", false);
          return;
        }
        const triggerEl = getTriggerEl$1(scope, value);
        const indicatorEl = getIndicatorEl(scope);
        if (!triggerEl || !indicatorEl) return;
        const indicatorCleanup = trackElementRect([triggerEl], {
          measure(el2) {
            return getOffsetRect(el2);
          },
          onEntry({ rects }) {
            const [rect] = rects;
            context.set("indicatorRect", resolveRect(rect));
          }
        });
        refs.set("indicatorCleanup", indicatorCleanup);
      },
      navigateIfNeeded({ context, prop, scope }) {
        const value = context.get("value");
        if (!value) return;
        const triggerEl = getTriggerEl$1(scope, value);
        if (!isAnchorElement(triggerEl)) return;
        prop("navigate")?.({ value, node: triggerEl });
      }
    }
  }
});
createProps$1()([
  "activationMode",
  "composite",
  "deselectable",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "value",
  "defaultValue"
]);
createProps$1()(["disabled", "value"]);
createProps$1()(["value"]);
const useTabs = (props) => {
  const id2 = reactExports.useId();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id: id2,
    dir,
    getRootNode,
    ...props
  };
  const service = useMachine(machine$2, machineProps);
  return connect$2(service, normalizeProps);
};
const TabsRoot$1 = reactExports.forwardRef((props, ref) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
  const [useTabsProps, localprops] = createSplitProps()(tabsProps, [
    "activationMode",
    "composite",
    "defaultValue",
    "deselectable",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const tabs = useTabs(useTabsProps);
  const mergedProps = mergeProps(tabs.getRootProps(), localprops);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsProvider, { value: tabs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
});
TabsRoot$1.displayName = "TabsRoot";
const TabsRootProvider = reactExports.forwardRef((props, ref) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
  const [{ value: tabs }, localprops] = createSplitProps()(tabsProps, ["value"]);
  const mergedProps = mergeProps(tabs.getRootProps(), localprops);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsProvider, { value: tabs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
});
TabsRootProvider.displayName = "TabsRootProvider";
var anatomy$1 = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts$1 = anatomy$1.build();
var getRegionId = (placement) => `toast-group:${placement}`;
var getRegionEl = (ctx, placement) => ctx.getById(`toast-group:${placement}`);
var getRootId = (ctx) => `toast:${ctx.id}`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getTitleId = (ctx) => `toast:${ctx.id}:title`;
var getDescriptionId = (ctx) => `toast:${ctx.id}:description`;
var getCloseTriggerId = (ctx) => `toast${ctx.id}:close`;
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
var getOffsets = (offsets) => typeof offsets === "string" ? { left: offsets, right: offsets, bottom: offsets, top: offsets } : offsets;
function getGroupPlacementStyle(service, placement) {
  const { prop, computed, context } = service;
  const { offsets, gap } = prop("store").attrs;
  const heights = context.get("heights");
  const computedOffset = getOffsets(offsets);
  const rtl = prop("dir") === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles2 = {
    position: "fixed",
    pointerEvents: computed("count") > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${gap}px`,
    "--first-height": `${heights[0]?.height || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles2.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset2 = computedOffset.top;
    styles2.top = `max(env(safe-area-inset-top, 0px), ${offset2})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset2 = computedOffset.bottom;
    styles2.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset2})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset2 = computedOffset.right;
    styles2.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset2})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset2 = computedOffset.left;
    styles2.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset2})`;
  }
  return styles2;
}
function getPlacementStyle(service, visible) {
  const { prop, context, computed } = service;
  const parent = prop("parent");
  const placement = parent.computed("placement");
  const { gap } = parent.prop("store").attrs;
  const [side] = placement.split("-");
  const mounted = context.get("mounted");
  const remainingTime = context.get("remainingTime");
  const height = computed("height");
  const frontmost = computed("frontmost");
  const sibling = !frontmost;
  const overlap = !prop("stacked");
  const stacked = prop("stacked");
  const type = prop("type");
  const duration = type === "loading" ? Number.MAX_SAFE_INTEGER : remainingTime;
  const offset2 = computed("heightIndex") * gap + computed("heightBefore");
  const styles2 = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${prop("removeDelay")}ms`,
    "--duration": `${duration}ms`,
    "--initial-height": `${height}px`,
    "--offset": `${offset2}px`,
    "--index": prop("index"),
    "--z-index": computed("zIndex"),
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign2 = (overrides) => Object.assign(styles2, overrides);
  if (side === "top") {
    assign2({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign2({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (mounted) {
    assign2({
      "--y": "0",
      "--opacity": "1"
    });
    if (stacked) {
      assign2({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign2({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign2({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign2({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && stacked && !visible) {
    assign2({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (frontmost && !visible) {
    assign2({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles2;
}
function getGhostBeforeStyle(service, visible) {
  const { computed } = service;
  const styles2 = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign2 = (overrides) => Object.assign(styles2, overrides);
  if (computed("frontmost") && !visible) {
    assign2({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles2;
}
function getGhostAfterStyle() {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(service, normalize2) {
  const { context, prop, send, refs, computed } = service;
  return {
    getCount() {
      return context.get("toasts").length;
    },
    getToasts() {
      return context.get("toasts");
    },
    getGroupProps(options2 = {}) {
      const { label = "Notifications" } = options2;
      const { hotkey } = prop("store").attrs;
      const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const placement = computed("placement");
      const [side, align = "center"] = placement.split("-");
      return normalize2.element({
        ...parts$1.group.attrs,
        dir: prop("dir"),
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(service, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (refs.get("isFocusWithin") && !contains(event.currentTarget, event.relatedTarget)) {
            queueMicrotask(() => send({ type: "REGION.BLUR" }));
          }
        }
      });
    },
    subscribe(fn) {
      const store2 = prop("store");
      return store2.subscribe(() => fn(context.get("toasts")));
    }
  };
}
var groupMachine = createMachine$1({
  props({ props }) {
    return {
      dir: "ltr",
      id: uuid(),
      ...props,
      store: props.store
    };
  },
  initialState({ prop }) {
    return prop("store").attrs.overlap ? "overlap" : "stack";
  },
  refs() {
    return {
      lastFocusedEl: null,
      isFocusWithin: false,
      dismissableCleanup: void 0
    };
  },
  context({ bindable }) {
    return {
      toasts: bindable(() => ({
        defaultValue: [],
        sync: true,
        hash: (toasts) => toasts.map((t2) => t2.id).join(",")
      })),
      heights: bindable(() => ({
        defaultValue: [],
        sync: true
      }))
    };
  },
  computed: {
    count: ({ context }) => context.get("toasts").length,
    overlap: ({ prop }) => prop("store").attrs.overlap,
    placement: ({ prop }) => prop("store").attrs.placement
  },
  effects: ["subscribeToStore", "trackDocumentVisibility", "trackHotKeyPress"],
  watch({ track, context, action }) {
    track([() => context.hash("toasts")], () => {
      queueMicrotask(() => {
        action(["collapsedIfEmpty", "setDismissableBranch"]);
      });
    });
  },
  exit: ["clearDismissableBranch", "clearLastFocusedEl"],
  on: {
    "DOC.HOTKEY": {
      actions: ["focusRegionEl"]
    },
    "REGION.BLUR": [
      {
        guard: "isOverlapping",
        target: "overlap",
        actions: ["collapseToasts", "resumeToasts", "restoreLastFocusedEl"]
      },
      {
        target: "stack",
        actions: ["resumeToasts", "restoreLastFocusedEl"]
      }
    ],
    "TOAST.REMOVE": {
      actions: ["removeToast", "removeHeight"]
    },
    "TOAST.PAUSE": {
      actions: ["pauseToasts"]
    }
  },
  states: {
    stack: {
      on: {
        "REGION.POINTER_LEAVE": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "collapseToasts"]
          },
          {
            actions: ["resumeToasts"]
          }
        ],
        "REGION.OVERLAP": {
          target: "overlap",
          actions: ["collapseToasts"]
        },
        "REGION.FOCUS": {
          actions: ["setLastFocusedEl", "pauseToasts"]
        },
        "REGION.POINTER_ENTER": {
          actions: ["pauseToasts"]
        }
      }
    },
    overlap: {
      on: {
        "REGION.STACK": {
          target: "stack",
          actions: ["expandToasts"]
        },
        "REGION.POINTER_ENTER": {
          target: "stack",
          actions: ["pauseToasts", "expandToasts"]
        },
        "REGION.FOCUS": {
          target: "stack",
          actions: ["setLastFocusedEl", "pauseToasts", "expandToasts"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOverlapping: ({ computed }) => computed("overlap")
    },
    effects: {
      subscribeToStore({ context, prop }) {
        return prop("store").subscribe((toast) => {
          if (toast.dismiss) {
            context.set("toasts", (prev2) => prev2.filter((t2) => t2.id !== toast.id));
            return;
          }
          context.set("toasts", (prev2) => {
            const index = prev2.findIndex((t2) => t2.id === toast.id);
            if (index !== -1) {
              return [...prev2.slice(0, index), { ...prev2[index], ...toast }, ...prev2.slice(index + 1)];
            }
            return [toast, ...prev2];
          });
        });
      },
      trackHotKeyPress({ prop, send }) {
        const handleKeyDown = (event) => {
          const { hotkey } = prop("store").attrs;
          const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
          if (!isHotkeyPressed) return;
          send({ type: "DOC.HOTKEY" });
        };
        return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
      },
      trackDocumentVisibility({ prop, send, scope }) {
        const { pauseOnPageIdle } = prop("store").attrs;
        if (!pauseOnPageIdle) return;
        const doc = scope.getDoc();
        return addDomEvent(doc, "visibilitychange", () => {
          const isHidden = doc.visibilityState === "hidden";
          send({ type: isHidden ? "PAUSE_ALL" : "RESUME_ALL" });
        });
      }
    },
    actions: {
      setDismissableBranch({ refs, context, computed, scope }) {
        const toasts = context.get("toasts");
        const placement = computed("placement");
        const hasToasts = toasts.length > 0;
        if (!hasToasts) {
          refs.get("dismissableCleanup")?.();
          return;
        }
        if (hasToasts && refs.get("dismissableCleanup")) {
          return;
        }
        const groupEl = () => getRegionEl(scope, placement);
        const cleanup = trackDismissableBranch(groupEl, { defer: true });
        refs.set("dismissableCleanup", cleanup);
      },
      clearDismissableBranch({ refs }) {
        refs.get("dismissableCleanup")?.();
      },
      focusRegionEl({ scope, computed }) {
        queueMicrotask(() => {
          getRegionEl(scope, computed("placement"))?.focus();
        });
      },
      pauseToasts({ prop }) {
        prop("store").pause();
      },
      resumeToasts({ prop }) {
        prop("store").resume();
      },
      expandToasts({ prop }) {
        prop("store").expand();
      },
      collapseToasts({ prop }) {
        prop("store").collapse();
      },
      removeToast({ prop, event }) {
        prop("store").remove(event.id);
      },
      removeHeight({ event, context }) {
        if (event?.id == null) return;
        queueMicrotask(() => {
          context.set("heights", (heights) => heights.filter((height) => height.id !== event.id));
        });
      },
      collapsedIfEmpty({ send, computed }) {
        if (!computed("overlap") || computed("count") > 1) return;
        send({ type: "REGION.OVERLAP" });
      },
      setLastFocusedEl({ refs, event }) {
        if (refs.get("isFocusWithin") || !event.target) return;
        refs.set("isFocusWithin", true);
        refs.set("lastFocusedEl", event.target);
      },
      restoreLastFocusedEl({ refs }) {
        if (!refs.get("lastFocusedEl")) return;
        refs.get("lastFocusedEl")?.focus({ preventScroll: true });
        refs.set("lastFocusedEl", null);
        refs.set("isFocusWithin", false);
      },
      clearLastFocusedEl({ refs }) {
        if (!refs.get("lastFocusedEl")) return;
        refs.get("lastFocusedEl")?.focus({ preventScroll: true });
        refs.set("lastFocusedEl", null);
        refs.set("isFocusWithin", false);
      }
    }
  }
});
function connect$1(service, normalize2) {
  const { state, send, prop, scope, context, computed } = service;
  const visible = state.hasTag("visible");
  const paused = state.hasTag("paused");
  const mounted = context.get("mounted");
  const frontmost = computed("frontmost");
  const placement = prop("parent").computed("placement");
  const type = prop("type");
  const stacked = prop("stacked");
  const title = prop("title");
  const description = prop("description");
  const action = prop("action");
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title,
    description,
    placement,
    visible,
    paused,
    closable: !!prop("closable"),
    pause() {
      send({ type: "PAUSE" });
    },
    resume() {
      send({ type: "RESUME" });
    },
    dismiss() {
      send({ type: "DISMISS", src: "programmatic" });
    },
    getRootProps() {
      return normalize2.element({
        ...parts$1.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr$1(mounted),
        "data-paused": dataAttr$1(paused),
        "data-first": dataAttr$1(frontmost),
        "data-sibling": dataAttr$1(!frontmost),
        "data-stack": dataAttr$1(stacked),
        "data-overlap": dataAttr$1(!stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": description ? getDescriptionId(scope) : void 0,
        "aria-labelledby": title ? getTitleId(scope) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(service, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send({ type: "DISMISS", src: "keyboard" });
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize2.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(service, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize2.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize2.element({
        ...parts$1.title.attrs,
        id: getTitleId(scope)
      });
    },
    getDescriptionProps() {
      return normalize2.element({
        ...parts$1.description.attrs,
        id: getDescriptionId(scope)
      });
    },
    getActionTriggerProps() {
      return normalize2.button({
        ...parts$1.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          action?.onClick?.();
          send({ type: "DISMISS", src: "user" });
        }
      });
    },
    getCloseTriggerProps() {
      return normalize2.button({
        id: getCloseTriggerId(scope),
        ...parts$1.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DISMISS", src: "user" });
        }
      });
    }
  };
}
var { not: not$1 } = createGuards();
var machine$1 = createMachine$1({
  props({ props }) {
    ensureProps(props, ["id", "type", "parent", "removeDelay"], "toast");
    return {
      closable: true,
      ...props,
      duration: getToastDuration(props.duration, props.type)
    };
  },
  initialState({ prop }) {
    const persist = prop("type") === "loading" || prop("duration") === Infinity;
    return persist ? "visible:persist" : "visible";
  },
  context({ prop, bindable }) {
    return {
      remainingTime: bindable(() => ({
        defaultValue: getToastDuration(prop("duration"), prop("type"))
      })),
      createdAt: bindable(() => ({
        defaultValue: Date.now()
      })),
      mounted: bindable(() => ({
        defaultValue: false
      })),
      initialHeight: bindable(() => ({
        defaultValue: 0
      }))
    };
  },
  refs() {
    return {
      closeTimerStartTime: Date.now(),
      lastCloseStartTimerStartTime: 0
    };
  },
  computed: {
    zIndex: ({ prop }) => {
      const toasts = prop("parent").context.get("toasts");
      const index = toasts.findIndex((toast) => toast.id === prop("id"));
      return toasts.length - index;
    },
    height: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      const height = heights.find((height2) => height2.id === prop("id"));
      return height?.height ?? 0;
    },
    heightIndex: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      return heights.findIndex((height) => height.id === prop("id"));
    },
    frontmost: ({ prop }) => prop("index") === 0,
    heightBefore: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      const heightIndex = heights.findIndex((height) => height.id === prop("id"));
      return heights.reduce((prev2, curr, reducerIndex) => {
        if (reducerIndex >= heightIndex) return prev2;
        return prev2 + curr.height;
      }, 0);
    },
    shouldPersist: ({ prop }) => prop("type") === "loading" || prop("duration") === Infinity
  },
  watch({ track, prop, send }) {
    track([() => prop("message")], () => {
      const message = prop("message");
      if (message) send({ type: message, src: "programmatic" });
    });
    track([() => prop("type"), () => prop("duration")], () => {
      send({ type: "UPDATE" });
    });
  },
  on: {
    UPDATE: [
      {
        guard: "shouldPersist",
        target: "visible:persist",
        actions: ["resetCloseTimer"]
      },
      {
        target: "visible:updating",
        actions: ["resetCloseTimer"]
      }
    ],
    MEASURE: {
      actions: ["measureHeight"]
    }
  },
  entry: ["setMounted", "measureHeight", "invokeOnVisible"],
  effects: ["trackHeight"],
  states: {
    "visible:updating": {
      tags: ["visible", "updating"],
      effects: ["waitForNextTick"],
      on: {
        SHOW: {
          target: "visible"
        }
      }
    },
    "visible:persist": {
      tags: ["visible", "paused"],
      on: {
        RESUME: {
          guard: not$1("isLoadingType"),
          target: "visible",
          actions: ["setCloseTimer"]
        },
        DISMISS: {
          target: "dismissing"
        }
      }
    },
    visible: {
      tags: ["visible"],
      effects: ["waitForDuration"],
      on: {
        DISMISS: {
          target: "dismissing"
        },
        PAUSE: {
          target: "visible:persist",
          actions: ["syncRemainingTime"]
        }
      }
    },
    dismissing: {
      entry: ["invokeOnDismiss"],
      effects: ["waitForRemoveDelay"],
      on: {
        REMOVE: {
          target: "unmounted",
          actions: ["notifyParentToRemove"]
        }
      }
    },
    unmounted: {
      entry: ["invokeOnUnmount"]
    }
  },
  implementations: {
    effects: {
      waitForRemoveDelay({ prop, send }) {
        return setRafTimeout(() => {
          send({ type: "REMOVE", src: "timer" });
        }, prop("removeDelay"));
      },
      waitForDuration({ send, context, computed }) {
        if (computed("shouldPersist")) return;
        return setRafTimeout(() => {
          send({ type: "DISMISS", src: "timer" });
        }, context.get("remainingTime"));
      },
      waitForNextTick({ send }) {
        return setRafTimeout(() => {
          send({ type: "SHOW", src: "timer" });
        }, 0);
      },
      trackHeight({ scope, prop }) {
        let cleanup;
        raf$1(() => {
          const rootEl = getRootEl(scope);
          if (!rootEl) return;
          const syncHeight = () => {
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const height = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            const item = { id: prop("id"), height };
            setHeight(prop("parent"), item);
          };
          const win = scope.getWin();
          const observer = new win.MutationObserver(syncHeight);
          observer.observe(rootEl, {
            childList: true,
            subtree: true,
            characterData: true
          });
          cleanup = () => observer.disconnect();
        });
        return () => cleanup?.();
      }
    },
    guards: {
      isLoadingType: ({ prop }) => prop("type") === "loading",
      shouldPersist: ({ computed }) => computed("shouldPersist")
    },
    actions: {
      setMounted({ context }) {
        raf$1(() => {
          context.set("mounted", true);
        });
      },
      measureHeight({ scope, prop, context }) {
        queueMicrotask(() => {
          const rootEl = getRootEl(scope);
          if (!rootEl) return;
          const originalHeight = rootEl.style.height;
          rootEl.style.height = "auto";
          const height = rootEl.getBoundingClientRect().height;
          rootEl.style.height = originalHeight;
          context.set("initialHeight", height);
          const item = { id: prop("id"), height };
          setHeight(prop("parent"), item);
        });
      },
      setCloseTimer({ refs }) {
        refs.set("closeTimerStartTime", Date.now());
      },
      resetCloseTimer({ context, refs, prop }) {
        refs.set("closeTimerStartTime", Date.now());
        context.set("remainingTime", getToastDuration(prop("duration"), prop("type")));
      },
      syncRemainingTime({ context, refs }) {
        context.set("remainingTime", (prev2) => {
          const closeTimerStartTime = refs.get("closeTimerStartTime");
          const elapsedTime = Date.now() - closeTimerStartTime;
          refs.set("lastCloseStartTimerStartTime", Date.now());
          return prev2 - elapsedTime;
        });
      },
      notifyParentToRemove({ prop }) {
        const parent = prop("parent");
        parent.send({ type: "TOAST.REMOVE", id: prop("id") });
      },
      invokeOnDismiss({ prop, event }) {
        prop("onStatusChange")?.({ status: "dismissing", src: event.src });
      },
      invokeOnUnmount({ prop }) {
        prop("onStatusChange")?.({ status: "unmounted" });
      },
      invokeOnVisible({ prop }) {
        prop("onStatusChange")?.({ status: "visible" });
      }
    }
  }
});
function setHeight(parent, item) {
  const { id: id2, height } = item;
  parent.context.set("heights", (prev2) => {
    const alreadyExists = prev2.find((i) => i.id === id2);
    if (!alreadyExists) {
      return [{ id: id2, height }, ...prev2];
    } else {
      return prev2.map((i) => i.id === id2 ? { ...i, height } : i);
    }
  });
}
var withDefaults = (options2, defaults2) => {
  return { ...defaults2, ...compact(options2) };
};
function createToastStore(props) {
  const attrs2 = withDefaults(props, {
    placement: "bottom",
    overlap: false,
    max: 24,
    gap: 16,
    offsets: "1rem",
    hotkey: ["altKey", "KeyT"],
    removeDelay: 200,
    pauseOnPageIdle: true
  });
  let subscribers = [];
  let toasts = [];
  let dismissedToasts = /* @__PURE__ */ new Set();
  const subscribe2 = (subscriber) => {
    subscribers.push(subscriber);
    return () => {
      const index = subscribers.indexOf(subscriber);
      subscribers.splice(index, 1);
    };
  };
  const publish2 = (data) => {
    subscribers.forEach((subscriber) => subscriber(data));
    return data;
  };
  const addToast = (data) => {
    if (toasts.length >= attrs2.max) return;
    publish2(data);
    toasts.unshift(data);
  };
  const create2 = (data) => {
    const id2 = data.id ?? `toast:${uuid()}`;
    const exists = toasts.find((toast) => toast.id === id2);
    if (dismissedToasts.has(id2)) dismissedToasts.delete(id2);
    if (exists) {
      toasts = toasts.map((toast) => {
        if (toast.id === id2) {
          return publish2({ ...toast, ...data, id: id2 });
        }
        return toast;
      });
    } else {
      addToast({
        id: id2,
        duration: attrs2.duration,
        removeDelay: attrs2.removeDelay,
        type: "info",
        ...data,
        stacked: !attrs2.overlap,
        gap: attrs2.gap
      });
    }
    return id2;
  };
  const remove2 = (id2) => {
    dismissedToasts.add(id2);
    if (!id2) {
      toasts.forEach((toast) => {
        subscribers.forEach((subscriber) => subscriber({ id: toast.id, dismiss: true }));
      });
      toasts = [];
    } else {
      subscribers.forEach((subscriber) => subscriber({ id: id2, dismiss: true }));
      toasts = toasts.filter((toast) => toast.id !== id2);
    }
    return id2;
  };
  const error2 = (data) => {
    return create2({ ...data, type: "error" });
  };
  const success = (data) => {
    return create2({ ...data, type: "success" });
  };
  const info = (data) => {
    return create2({ ...data, type: "info" });
  };
  const warning = (data) => {
    return create2({ ...data, type: "warning" });
  };
  const loading = (data) => {
    return create2({ ...data, type: "loading" });
  };
  const getVisibleToasts = () => {
    return toasts.filter((toast) => !dismissedToasts.has(toast.id));
  };
  const getCount = () => {
    return toasts.length;
  };
  const promise = (promise2, options2, shared = {}) => {
    if (!options2) return;
    let id2 = void 0;
    if (options2.loading !== void 0) {
      id2 = create2({
        ...shared,
        ...options2.loading,
        promise: promise2,
        type: "loading"
      });
    }
    let removable = id2 !== void 0;
    let result;
    const prom = runIfFn(promise2).then(async (response) => {
      result = ["resolve", response];
      if (isHttpResponse(response) && !response.ok) {
        removable = false;
        const errorOptions = runIfFn(options2.error, `HTTP Error! status: ${response.status}`);
        create2({ ...shared, ...errorOptions, id: id2, type: "error" });
      } else if (options2.success !== void 0) {
        removable = false;
        const successOptions = runIfFn(options2.success, response);
        create2({ ...shared, ...successOptions, id: id2, type: "success" });
      }
    }).catch(async (error22) => {
      result = ["reject", error22];
      if (options2.error !== void 0) {
        removable = false;
        const errorOptions = runIfFn(options2.error, error22);
        create2({ ...shared, ...errorOptions, id: id2, type: "error" });
      }
    }).finally(() => {
      if (removable) {
        remove2(id2);
        id2 = void 0;
      }
      options2.finally?.();
    });
    const unwrap = () => new Promise(
      (resolve2, reject2) => prom.then(() => result[0] === "reject" ? reject2(result[1]) : resolve2(result[1])).catch(reject2)
    );
    return { id: id2, unwrap };
  };
  const update2 = (id2, data) => {
    return create2({ id: id2, ...data });
  };
  const pause = (id2) => {
    if (id2 != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id2) return publish2({ ...toast, message: "PAUSE" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish2({ ...toast, message: "PAUSE" }));
    }
  };
  const resume = (id2) => {
    if (id2 != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id2) return publish2({ ...toast, message: "RESUME" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish2({ ...toast, message: "RESUME" }));
    }
  };
  const dismiss = (id2) => {
    if (id2 != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id2) return publish2({ ...toast, message: "DISMISS" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish2({ ...toast, message: "DISMISS" }));
    }
  };
  const isVisible = (id2) => {
    return !dismissedToasts.has(id2) && !!toasts.find((toast) => toast.id === id2);
  };
  const isDismissed = (id2) => {
    return dismissedToasts.has(id2);
  };
  const expand = () => {
    toasts = toasts.map((toast) => publish2({ ...toast, stacked: true }));
  };
  const collapse = () => {
    toasts = toasts.map((toast) => publish2({ ...toast, stacked: false }));
  };
  return {
    attrs: attrs2,
    subscribe: subscribe2,
    create: create2,
    update: update2,
    remove: remove2,
    dismiss,
    error: error2,
    success,
    info,
    warning,
    loading,
    getVisibleToasts,
    getCount,
    promise,
    pause,
    resume,
    isVisible,
    isDismissed,
    expand,
    collapse
  };
}
var isHttpResponse = (data) => {
  return data && typeof data === "object" && "ok" in data && typeof data.ok === "boolean" && "status" in data && typeof data.status === "number";
};
var group$2 = {
  connect: groupConnect,
  machine: groupMachine
};
const createToaster = (props) => {
  return createToastStore(props);
};
const [ToastProvider, useToastContext] = createContext({
  name: "ToastContext",
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});
const ToastActionTrigger$1 = reactExports.forwardRef((props, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getActionTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
ToastActionTrigger$1.displayName = "ToastActionTrigger";
const ToastCloseTrigger$1 = reactExports.forwardRef((props, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getCloseTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
ToastCloseTrigger$1.displayName = "ToastCloseTrigger";
const ToastDescription$1 = reactExports.forwardRef((props, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getDescriptionProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
ToastDescription$1.displayName = "ToastDescription";
const ToastRoot$1 = reactExports.forwardRef((props, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getRootProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...mergedProps, ref, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...toast.getGhostBeforeProps() }),
    props.children,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...toast.getGhostAfterProps() })
  ] });
});
ToastRoot$1.displayName = "ToastRoot";
const ToastTitle$1 = reactExports.forwardRef((props, ref) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getTitleProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
ToastTitle$1.displayName = "ToastTitle";
const Toaster$2 = reactExports.forwardRef((props, ref) => {
  const { toaster: toaster2, children, ...localProps } = props;
  const locale = useLocaleContext();
  const env2 = useEnvironmentContext();
  const service = useMachine(group$2.machine, {
    store: toaster2,
    id: reactExports.useId(),
    dir: locale?.dir,
    getRootNode: env2?.getRootNode
  });
  const api = group$2.connect(service, normalizeProps);
  const mergedProps = mergeProps(api.getGroupProps(), localProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref, children: api.getToasts().map((toast2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(ToastActor, { value: toast2, parent: service, index, children: (ctx) => children(ctx) }, toast2.id)) });
});
Toaster$2.displayName = "Toaster";
const ToastActor = (props) => {
  const localProps = {
    ...props.value,
    parent: props.parent,
    index: props.index
  };
  const service = useMachine(machine$1, { ...localProps });
  const api = connect$1(service, normalizeProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastProvider, { value: api, children: props.children(props.value) });
};
ToastActor.displayName = "ToastActor";
const [TooltipProvider, useTooltipContext] = createContext({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});
const TooltipArrow$1 = reactExports.forwardRef((props, ref) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
TooltipArrow$1.displayName = "TooltipArrow";
const TooltipArrowTip$1 = reactExports.forwardRef((props, ref) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowTipProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
TooltipArrowTip$1.displayName = "TooltipArrowTip";
const TooltipContent$1 = reactExports.forwardRef((props, ref) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(tooltip.getContentProps(), presence.getPresenceProps(), props);
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs(presence.ref, ref) });
});
TooltipContent$1.displayName = "TooltipContent";
const TooltipPositioner$1 = reactExports.forwardRef((props, ref) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getPositionerProps(), props);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
});
TooltipPositioner$1.displayName = "TooltipPositioner";
const GET_ORIGINAL_SYMBOL = Symbol();
const getProto = Object.getPrototypeOf;
const objectsToTrack = /* @__PURE__ */ new WeakMap();
const isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
const getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
const markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};
function glob() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
}
function globalRef(key, value) {
  const g2 = glob();
  if (!g2) return value();
  g2[key] || (g2[key] = value());
  return g2[key];
}
var refSet = globalRef("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var isReactElement = (x2) => typeof x2 === "object" && x2 !== null && "$$typeof" in x2 && "props" in x2;
var isVueElement = (x2) => typeof x2 === "object" && x2 !== null && "__v_isVNode" in x2;
var isDOMElement = (x2) => typeof x2 === "object" && x2 !== null && "nodeType" in x2 && typeof x2.nodeName === "string";
var isElement = (x2) => isReactElement(x2) || isVueElement(x2) || isDOMElement(x2);
var isObject$1 = (x2) => x2 !== null && typeof x2 === "object";
var canProxy = (x2) => isObject$1(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !isElement(x2) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer) && !(x2 instanceof Promise);
var proxyStateMap = globalRef("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version) => {
  const cache2 = snapCache.get(target);
  if (cache2?.[0] === version) {
    return cache2[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject$1(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener3) => listener3(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (listeners.size) {
      const remove2 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove2]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      entry[1]?.();
    }
  };
  const addListener = (listener3) => {
    listeners.add(listener3);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        const remove2 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove2]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener3);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove2], prop) => {
          if (remove2) {
            remove2();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject$1(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if (Object.getOwnPropertyDescriptor(target, prop)?.set) ;
      else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener3 = (op) => {
    ops.push(op);
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener3);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion());
}
var anatomy = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts = anatomy.build();
var getTriggerId = (scope) => scope.ids?.trigger ?? `tooltip:${scope.id}:trigger`;
var getContentId = (scope) => scope.ids?.content ?? `tooltip:${scope.id}:content`;
var getArrowId = (scope) => scope.ids?.arrow ?? `tooltip:${scope.id}:arrow`;
var getPositionerId = (scope) => scope.ids?.positioner ?? `tooltip:${scope.id}:popper`;
var getTriggerEl = (scope) => scope.getById(getTriggerId(scope));
var getPositionerEl = (scope) => scope.getById(getPositionerId(scope));
var store = proxy({ id: null });
function connect(service, normalize2) {
  const { state, context, send, scope, prop, event: _event } = service;
  const id2 = prop("id");
  const hasAriaLabel = !!prop("aria-label");
  const open = state.matches("open", "closing");
  const triggerId = getTriggerId(scope);
  const contentId = getContentId(scope);
  const disabled = prop("disabled");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: context.get("currentPlacement")
  });
  return {
    open,
    setOpen(nextOpen) {
      const open2 = state.matches("open", "closing");
      if (open2 === nextOpen) return;
      send({ type: nextOpen ? "open" : "close" });
    },
    reposition(options2 = {}) {
      send({ type: "positioning.set", options: options2 });
    },
    getTriggerProps() {
      return normalize2.button({
        ...parts.trigger.attrs,
        id: triggerId,
        dir: prop("dir"),
        "data-expanded": dataAttr$1(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!prop("closeOnClick")) return;
          send({ type: "close", src: "trigger.click" });
        },
        onFocus(event) {
          queueMicrotask(() => {
            if (event.defaultPrevented) return;
            if (disabled) return;
            if (_event.src === "trigger.pointerdown") return;
            if (!isFocusVisible()) return;
            send({ type: "open", src: "trigger.focus" });
          });
        },
        onBlur(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (id2 === store.id) {
            send({ type: "close", src: "trigger.blur" });
          }
        },
        onPointerDown(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (!prop("closeOnPointerDown")) return;
          if (id2 === store.id) {
            send({ type: "close", src: "trigger.pointerdown" });
          }
        },
        onPointerMove(event) {
          if (event.defaultPrevented) return;
          if (disabled) return;
          if (event.pointerType === "touch") return;
          send({ type: "pointer.move" });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "pointer.leave" });
        },
        onPointerCancel() {
          if (disabled) return;
          send({ type: "pointer.leave" });
        }
      });
    },
    getArrowProps() {
      return normalize2.element({
        id: getArrowId(scope),
        ...parts.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize2.element({
        ...parts.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize2.element({
        id: getPositionerId(scope),
        ...parts.positioner.attrs,
        dir: prop("dir"),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize2.element({
        ...parts.content.attrs,
        dir: prop("dir"),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": context.get("currentPlacement"),
        onPointerEnter() {
          send({ type: "content.pointer.move" });
        },
        onPointerLeave() {
          send({ type: "content.pointer.leave" });
        },
        style: {
          pointerEvents: prop("interactive") ? "auto" : "none"
        }
      });
    }
  };
}
var { and, not } = createGuards();
var machine = createMachine$1({
  initialState: ({ prop }) => {
    const open = prop("open") || prop("defaultOpen");
    return open ? "open" : "closed";
  },
  props({ props: props2 }) {
    return {
      id: "x",
      openDelay: 1e3,
      closeDelay: 500,
      closeOnPointerDown: true,
      closeOnEscape: true,
      interactive: false,
      closeOnScroll: true,
      closeOnClick: true,
      disabled: false,
      ...props2,
      positioning: {
        placement: "bottom",
        ...props2.positioning
      }
    };
  },
  effects: ["trackFocusVisible", "trackStore"],
  context: ({ bindable }) => ({
    currentPlacement: bindable(() => ({ defaultValue: void 0 })),
    hasPointerMoveOpened: bindable(() => ({ defaultValue: false }))
  }),
  watch({ track, action, prop }) {
    track([() => prop("disabled")], () => {
      action(["closeIfDisabled"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    closed: {
      entry: ["clearGlobalId"],
      on: {
        "controlled.open": {
          target: "open"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "pointer.leave": {
          actions: ["clearPointerMoveOpened"]
        },
        "pointer.move": [
          {
            guard: and("noVisibleTooltip", not("hasPointerMoveOpened")),
            target: "opening"
          },
          {
            guard: not("hasPointerMoveOpened"),
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      effects: ["trackScroll", "trackPointerlockChange", "waitForOpenDelay"],
      on: {
        "after.openDelay": [
          {
            guard: "isOpenControlled",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ],
        "controlled.open": {
          target: "open"
        },
        "controlled.close": {
          target: "closed"
        },
        open: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        "pointer.leave": [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          }
        ],
        close: [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["invokeOnClose", "toggleVisibility"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    open: {
      effects: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
      entry: ["setGlobalId"],
      on: {
        "controlled.close": {
          target: "closed"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "pointer.leave": [
          {
            guard: "isVisible",
            target: "closing",
            actions: ["clearPointerMoveOpened"]
          },
          // == group ==
          {
            guard: "isOpenControlled",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["clearPointerMoveOpened", "invokeOnClose"]
          }
        ],
        "content.pointer.leave": {
          guard: "isInteractive",
          target: "closing"
        },
        "positioning.set": {
          actions: ["reposition"]
        }
      }
    },
    closing: {
      effects: ["trackPositioning", "waitForCloseDelay"],
      on: {
        "after.closeDelay": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "controlled.close": {
          target: "closed"
        },
        "controlled.open": {
          target: "open"
        },
        close: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "pointer.move": [
          {
            guard: "isOpenControlled",
            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)
            actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
          },
          {
            target: "open",
            actions: ["setPointerMoveOpened", "invokeOnOpen"]
          }
        ],
        "content.pointer.move": {
          guard: "isInteractive",
          target: "open"
        },
        "positioning.set": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      noVisibleTooltip: () => store.id === null,
      isVisible: ({ prop }) => prop("id") === store.id,
      isInteractive: ({ prop }) => !!prop("interactive"),
      hasPointerMoveOpened: ({ context }) => context.get("hasPointerMoveOpened"),
      isOpenControlled: ({ prop }) => prop("open") !== void 0
    },
    actions: {
      setGlobalId: ({ prop }) => {
        store.id = prop("id");
      },
      clearGlobalId: ({ prop }) => {
        if (prop("id") === store.id) {
          store.id = null;
        }
      },
      invokeOnOpen: ({ prop }) => {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose: ({ prop }) => {
        prop("onOpenChange")?.({ open: false });
      },
      closeIfDisabled: ({ prop, send }) => {
        if (!prop("disabled")) return;
        send({ type: "close", src: "disabled.change" });
      },
      reposition: ({ context, event, prop, scope }) => {
        if (event.type !== "positioning.set") return;
        const getPositionerEl2 = () => getPositionerEl(scope);
        return getPlacement(getTriggerEl(scope), getPositionerEl2, {
          ...prop("positioning"),
          ...event.options,
          defer: true,
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      toggleVisibility: ({ prop, event, send }) => {
        queueMicrotask(() => {
          send({
            type: prop("open") ? "controlled.open" : "controlled.close",
            previousEvent: event
          });
        });
      },
      setPointerMoveOpened: ({ context }) => {
        context.set("hasPointerMoveOpened", true);
      },
      clearPointerMoveOpened: ({ context }) => {
        context.set("hasPointerMoveOpened", false);
      }
    },
    effects: {
      trackFocusVisible: ({ scope }) => {
        return trackFocusVisible({ root: scope.getRootNode?.() });
      },
      trackPositioning: ({ context, prop, scope }) => {
        if (!context.get("currentPlacement")) {
          context.set("currentPlacement", prop("positioning").placement);
        }
        const getPositionerEl2 = () => getPositionerEl(scope);
        return getPlacement(getTriggerEl(scope), getPositionerEl2, {
          ...prop("positioning"),
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackPointerlockChange: ({ send, scope }) => {
        const doc = scope.getDoc();
        const onChange = () => send({ type: "close", src: "pointerlock:change" });
        return addDomEvent(doc, "pointerlockchange", onChange, false);
      },
      trackScroll: ({ send, prop, scope }) => {
        if (!prop("closeOnScroll")) return;
        const triggerEl = getTriggerEl(scope);
        if (!triggerEl) return;
        const overflowParents = getOverflowAncestors$1(triggerEl);
        const cleanups = overflowParents.map((overflowParent) => {
          const onScroll2 = () => {
            send({ type: "close", src: "scroll" });
          };
          return addDomEvent(overflowParent, "scroll", onScroll2, {
            passive: true,
            capture: true
          });
        });
        return () => {
          cleanups.forEach((fn) => fn?.());
        };
      },
      trackStore: ({ prop, send }) => {
        let cleanup;
        queueMicrotask(() => {
          cleanup = subscribe(store, () => {
            if (store.id !== prop("id")) {
              send({ type: "close", src: "id.change" });
            }
          });
        });
        return () => cleanup?.();
      },
      trackEscapeKey: ({ send, prop }) => {
        if (!prop("closeOnEscape")) return;
        const onKeyDown = (event) => {
          if (isComposingEvent(event)) return;
          if (event.key !== "Escape") return;
          event.stopPropagation();
          send({ type: "close", src: "keydown.escape" });
        };
        return addDomEvent(document, "keydown", onKeyDown, true);
      },
      waitForOpenDelay: ({ send, prop }) => {
        const id2 = setTimeout(() => {
          send({ type: "after.openDelay" });
        }, prop("openDelay"));
        return () => clearTimeout(id2);
      },
      waitForCloseDelay: ({ send, prop }) => {
        const id2 = setTimeout(() => {
          send({ type: "after.closeDelay" });
        }, prop("closeDelay"));
        return () => clearTimeout(id2);
      }
    }
  }
});
createProps$1()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "closeOnScroll",
  "closeOnClick",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "defaultOpen",
  "open",
  "openDelay",
  "positioning"
]);
const useTooltip = (props) => {
  const id2 = reactExports.useId();
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const machineProps = {
    id: id2,
    dir,
    getRootNode,
    ...props
  };
  const service = useMachine(machine, machineProps);
  return connect(service, normalizeProps);
};
const TooltipRoot$1 = (props) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { value: tooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) });
};
const TooltipRootProvider = (props) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { value: tooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children }) });
};
const TooltipTrigger$1 = reactExports.forwardRef((props, ref) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getTriggerProps(), props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
});
TooltipTrigger$1.displayName = "TooltipTrigger";
function omit(object, keysToOmit = []) {
  const clone2 = Object.assign({}, object);
  for (const key of keysToOmit) {
    if (key in clone2) {
      delete clone2[key];
    }
  }
  return clone2;
}
const colorMix = (value, token2) => {
  if (!value || typeof value !== "string") {
    return { invalid: true, value };
  }
  const [rawColor, rawOpacity] = value.split("/");
  if (!rawColor || !rawOpacity || rawColor === "currentBg") {
    return { invalid: true, value: rawColor };
  }
  const colorToken = token2(`colors.${rawColor}`);
  const opacityToken = token2.raw(`opacity.${rawOpacity}`)?.value;
  if (!opacityToken && isNaN(Number(rawOpacity))) {
    return { invalid: true, value: rawColor };
  }
  const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
  const color = colorToken ?? rawColor;
  return {
    invalid: false,
    color,
    value: `color-mix(in srgb, ${color} ${percent}, transparent)`
  };
};
const createColorMixTransform = (prop) => (value, args) => {
  const mix = args.utils.colorMix(value);
  if (mix.invalid) return { [prop]: value };
  const cssVar2 = "--mix-" + prop;
  return {
    [cssVar2]: mix.value,
    [prop]: `var(${cssVar2}, ${mix.color})`
  };
};
function clone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map((prop) => clone(prop));
  const _clone = Object.create(Object.getPrototypeOf(obj));
  for (const key of Object.keys(obj)) {
    _clone[key] = clone(obj[key]);
  }
  return _clone;
}
function merge(target, source) {
  if (source == null) return target;
  for (const key of Object.keys(source)) {
    if (source[key] === void 0 || key === "__proto__") continue;
    if (!isObject$4(target[key]) && isObject$4(source[key])) {
      Object.assign(target, { [key]: source[key] });
    } else if (target[key] && isObject$4(source[key])) {
      merge(target[key], source[key]);
    } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
      let i = 0;
      for (; i < source[key].length; i++) {
        if (isObject$4(target[key][i]) && isObject$4(source[key][i])) {
          merge(target[key][i], source[key][i]);
        } else {
          target[key][i] = source[key][i];
        }
      }
    } else {
      Object.assign(target, { [key]: source[key] });
    }
  }
  return target;
}
function mergeWith(target, ...sources) {
  for (const source of sources) {
    merge(target, source);
  }
  return target;
}
const defineConditions = (v2) => v2;
const defineRecipe = (v2) => v2;
const defineSlotRecipe = (v2) => v2;
const defineKeyframes = (v2) => v2;
const defineGlobalStyles = (v2) => v2;
const defineStyle = (v2) => v2;
const defineTextStyles = (v2) => v2;
const defineAnimationStyles = (v2) => v2;
const defineLayerStyles = (v2) => v2;
function createProxy() {
  const identity2 = (v2) => v2;
  return new Proxy(identity2, {
    get() {
      return identity2;
    }
  });
}
const defineTokens = /* @__PURE__ */ createProxy();
const defineSemanticTokens = /* @__PURE__ */ createProxy();
const defineConfig = (v2) => v2;
const mergeConfigs = (...configs) => {
  return mergeWith({}, ...configs.map(clone));
};
const escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
function esc$1(string) {
  return `${string}`.replace(escRegex, (s) => `\\${s}`);
}
const dashCaseRegex = /[A-Z]/g;
function dashCase(string) {
  return string.replace(dashCaseRegex, (match2) => `-${match2.toLowerCase()}`);
}
function cssVar(name2, options2 = {}) {
  const { fallback: fallback2 = "", prefix: prefix2 = "" } = options2;
  const variable = dashCase(["-", prefix2, esc$1(name2)].filter(Boolean).join("-"));
  return {
    var: variable,
    ref: `var(${variable}${fallback2 ? `, ${fallback2}` : ""})`
  };
}
const isCssVar = (v2) => /^var\(--.+\)$/.test(v2);
const wrap = (str, v2) => v2 != null ? `${str}(${v2})` : v2;
const deg = (v2) => {
  if (isCssVar(v2) || v2 == null) return v2;
  const unitless = typeof v2 === "string" && !v2.endsWith("deg");
  return typeof v2 === "number" || unitless ? `${v2}deg` : v2;
};
const createFocusRing = (selector) => {
  return {
    values: ["outside", "inside", "mixed", "none"],
    transform(value, { token: token2 }) {
      const focusRingColor = token2("colors.colorPalette.focusRing");
      const styles2 = {
        inside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineOffset: "0px",
            outlineWidth: "var(--focus-ring-width, 1px)",
            outlineColor: "var(--focus-ring-color)",
            outlineStyle: "var(--focus-ring-style, solid)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        outside: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 2px)",
            outlineOffset: "var(--focus-ring-offset, 2px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "var(--focus-ring-color)"
          }
        },
        mixed: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outlineWidth: "var(--focus-ring-width, 3px)",
            outlineStyle: "var(--focus-ring-style, solid)",
            outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
            borderColor: "var(--focus-ring-color)"
          }
        },
        none: {
          "--focus-ring-color": focusRingColor,
          [selector]: {
            outline: "none"
          }
        }
      };
      return styles2[value] ?? {};
    }
  };
};
const divideColor = createColorMixTransform("borderColor");
const createTransition = (value) => {
  return {
    transition: value,
    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
    transitionDuration: "150ms"
  };
};
const defaultConditions = defineConditions({
  hover: [
    "@media (hover: hover)",
    "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
  ],
  active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
  focus: "&:is(:focus, [data-focus])",
  focusWithin: "&:is(:focus-within, [data-focus-within])",
  focusVisible: "&:is(:focus-visible, [data-focus-visible])",
  disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
  visited: "&:visited",
  target: "&:target",
  readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
  readWrite: "&:read-write",
  empty: "&:is(:empty, [data-empty])",
  checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
  enabled: "&:enabled",
  expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
  highlighted: "&[data-highlighted]",
  complete: "&[data-complete]",
  incomplete: "&[data-incomplete]",
  dragging: "&[data-dragging]",
  before: "&::before",
  after: "&::after",
  firstLetter: "&::first-letter",
  firstLine: "&::first-line",
  marker: "&::marker",
  selection: "&::selection",
  file: "&::file-selector-button",
  backdrop: "&::backdrop",
  first: "&:first-of-type",
  last: "&:last-of-type",
  notFirst: "&:not(:first-of-type)",
  notLast: "&:not(:last-of-type)",
  only: "&:only-child",
  even: "&:nth-of-type(even)",
  odd: "&:nth-of-type(odd)",
  peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
  peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
  peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
  peerFocusWithin: ".peer:focus-within ~ &",
  peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
  peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
  peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
  peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
  peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
  peerPlaceholderShown: ".peer:placeholder-shown ~ &",
  groupFocus: ".group:is(:focus, [data-focus]) &",
  groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
  groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
  groupFocusWithin: ".group:focus-within &",
  groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
  groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
  groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
  groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
  groupInvalid: ".group:invalid &",
  indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
  required: "&:is([data-required], [aria-required=true])",
  valid: "&:is([data-valid], [data-state=valid])",
  invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
  autofill: "&:autofill",
  inRange: "&:is(:in-range, [data-in-range])",
  outOfRange: "&:is(:out-of-range, [data-outside-range])",
  placeholder: "&::placeholder, &[data-placeholder]",
  placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
  pressed: "&:is([aria-pressed=true], [data-pressed])",
  selected: "&:is([aria-selected=true], [data-selected])",
  grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
  underValue: "&[data-state=under-value]",
  overValue: "&[data-state=over-value]",
  atValue: "&[data-state=at-value]",
  default: "&:default",
  optional: "&:optional",
  open: "&:is([open], [data-open], [data-state=open])",
  closed: "&:is([closed], [data-closed], [data-state=closed])",
  fullscreen: "&is(:fullscreen, [data-fullscreen])",
  loading: "&:is([data-loading], [aria-busy=true])",
  hidden: "&:is([hidden], [data-hidden])",
  current: "&[data-current]",
  currentPage: "&[aria-current=page]",
  currentStep: "&[aria-current=step]",
  today: "&[data-today]",
  unavailable: "&[data-unavailable]",
  rangeStart: "&[data-range-start]",
  rangeEnd: "&[data-range-end]",
  now: "&[data-now]",
  topmost: "&[data-topmost]",
  motionReduce: "@media (prefers-reduced-motion: reduce)",
  motionSafe: "@media (prefers-reduced-motion: no-preference)",
  print: "@media print",
  landscape: "@media (orientation: landscape)",
  portrait: "@media (orientation: portrait)",
  dark: ".dark &, .dark .chakra-theme:not(.light) &",
  light: ":root &, .light &",
  osDark: "@media (prefers-color-scheme: dark)",
  osLight: "@media (prefers-color-scheme: light)",
  highContrast: "@media (forced-colors: active)",
  lessContrast: "@media (prefers-contrast: less)",
  moreContrast: "@media (prefers-contrast: more)",
  ltr: "[dir=ltr] &",
  rtl: "[dir=rtl] &",
  scrollbar: "&::-webkit-scrollbar",
  scrollbarThumb: "&::-webkit-scrollbar-thumb",
  scrollbarTrack: "&::-webkit-scrollbar-track",
  horizontal: "&[data-orientation=horizontal]",
  vertical: "&[data-orientation=vertical]",
  icon: "& :where(svg)",
  starting: "@starting-style"
});
const currentBgVar = cssVar("bg-currentcolor");
const isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
const colorValues = (theme) => ({
  ...theme("colors"),
  currentBg: currentBgVar
});
const defaultBaseConfig = defineConfig({
  conditions: defaultConditions,
  utilities: {
    // background
    background: {
      values: colorValues,
      shorthand: ["bg"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
        const styleObj = createColorMixTransform("background")(value, args);
        return { ...styleObj, [currentBgVar.var]: styleObj?.background };
      }
    },
    backgroundColor: {
      values: colorValues,
      shorthand: ["bgColor"],
      transform(value, args) {
        if (isCurrentBgVar(args.raw))
          return { backgroundColor: currentBgVar.ref };
        const styleObj = createColorMixTransform("backgroundColor")(value, args);
        return {
          ...styleObj,
          [currentBgVar.var]: styleObj?.backgroundColor
        };
      }
    },
    backgroundSize: { shorthand: ["bgSize"] },
    backgroundPosition: { shorthand: ["bgPos"] },
    backgroundRepeat: { shorthand: ["bgRepeat"] },
    backgroundAttachment: { shorthand: ["bgAttachment"] },
    backgroundClip: {
      shorthand: ["bgClip"],
      values: ["text"],
      transform(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      }
    },
    backgroundGradient: {
      shorthand: ["bgGradient"],
      values(theme) {
        return {
          ...theme("gradients"),
          "to-t": "linear-gradient(to top, var(--gradient))",
          "to-tr": "linear-gradient(to top right, var(--gradient))",
          "to-r": "linear-gradient(to right, var(--gradient))",
          "to-br": "linear-gradient(to bottom right, var(--gradient))",
          "to-b": "linear-gradient(to bottom, var(--gradient))",
          "to-bl": "linear-gradient(to bottom left, var(--gradient))",
          "to-l": "linear-gradient(to left, var(--gradient))",
          "to-tl": "linear-gradient(to top left, var(--gradient))"
        };
      },
      transform(value) {
        return {
          "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
          "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
          backgroundImage: value
        };
      }
    },
    gradientFrom: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-from")
    },
    gradientTo: {
      values: colorValues,
      transform: createColorMixTransform("--gradient-to")
    },
    gradientVia: {
      values: colorValues,
      transform(value, args) {
        const styles2 = createColorMixTransform("--gradient-via")(value, args);
        return {
          ...styles2,
          "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
        };
      }
    },
    backgroundImage: {
      values(theme) {
        return { ...theme("gradients"), ...theme("assets") };
      },
      shorthand: ["bgImg", "bgImage"]
    },
    // border
    border: { values: "borders" },
    borderTop: { values: "borders" },
    borderLeft: { values: "borders" },
    borderBlockStart: { values: "borders" },
    borderRight: { values: "borders" },
    borderBottom: { values: "borders" },
    borderBlockEnd: { values: "borders" },
    borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
    borderInlineEnd: { values: "borders", shorthand: ["borderEnd"] },
    borderInline: { values: "borders", shorthand: ["borderX"] },
    borderBlock: { values: "borders", shorthand: ["borderY"] },
    // border colors
    borderColor: {
      values: colorValues,
      transform: createColorMixTransform("borderColor")
    },
    borderTopColor: {
      values: colorValues,
      transform: createColorMixTransform("borderTopColor")
    },
    borderBlockStartColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockStartColor")
    },
    borderBottomColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBottomColor")
    },
    borderBlockEndColor: {
      values: colorValues,
      transform: createColorMixTransform("borderBlockEndColor")
    },
    borderLeftColor: {
      values: colorValues,
      transform: createColorMixTransform("borderLeftColor")
    },
    borderInlineStartColor: {
      values: colorValues,
      shorthand: ["borderStartColor"],
      transform: createColorMixTransform("borderInlineStartColor")
    },
    borderRightColor: {
      values: colorValues,
      transform: createColorMixTransform("borderRightColor")
    },
    borderInlineEndColor: {
      values: colorValues,
      shorthand: ["borderEndColor"],
      transform: createColorMixTransform("borderInlineEndColor")
    },
    // border styles
    borderStyle: { values: "borderStyles" },
    borderTopStyle: { values: "borderStyles" },
    borderBlockStartStyle: { values: "borderStyles" },
    borderBottomStyle: { values: "borderStyles" },
    borderBlockEndStyle: {
      values: "borderStyles"
    },
    borderInlineStartStyle: {
      values: "borderStyles",
      shorthand: ["borderStartStyle"]
    },
    borderInlineEndStyle: {
      values: "borderStyles",
      shorthand: ["borderEndStyle"]
    },
    borderLeftStyle: { values: "borderStyles" },
    borderRightStyle: { values: "borderStyles" },
    // border radius
    borderRadius: { values: "radii", shorthand: ["rounded"] },
    borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
    borderStartStartRadius: {
      values: "radii",
      shorthand: ["roundedStartStart", "borderTopStartRadius"]
    },
    borderEndStartRadius: {
      values: "radii",
      shorthand: ["roundedEndStart", "borderBottomStartRadius"]
    },
    borderTopRightRadius: {
      values: "radii",
      shorthand: ["roundedTopRight"]
    },
    borderStartEndRadius: {
      values: "radii",
      shorthand: ["roundedStartEnd", "borderTopEndRadius"]
    },
    borderEndEndRadius: {
      values: "radii",
      shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
    },
    borderBottomLeftRadius: {
      values: "radii",
      shorthand: ["roundedBottomLeft"]
    },
    borderBottomRightRadius: {
      values: "radii",
      shorthand: ["roundedBottomRight"]
    },
    borderInlineStartRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedStart", "borderStartRadius"],
      transform: (value) => ({
        borderStartStartRadius: value,
        borderEndStartRadius: value
      })
    },
    borderInlineEndRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedEnd", "borderEndRadius"],
      transform: (value) => ({
        borderStartEndRadius: value,
        borderEndEndRadius: value
      })
    },
    borderTopRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedTop"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderTopRightRadius: value
      })
    },
    borderBottomRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedBottom"],
      transform: (value) => ({
        borderBottomLeftRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderLeftRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedLeft"],
      transform: (value) => ({
        borderTopLeftRadius: value,
        borderBottomLeftRadius: value
      })
    },
    borderRightRadius: {
      values: "radii",
      property: "borderRadius",
      shorthand: ["roundedRight"],
      transform: (value) => ({
        borderTopRightRadius: value,
        borderBottomRightRadius: value
      })
    },
    borderWidth: { values: "borderWidths" },
    borderBlockStartWidth: { values: "borderWidths" },
    borderTopWidth: { values: "borderWidths" },
    borderBottomWidth: { values: "borderWidths" },
    borderBlockEndWidth: { values: "borderWidths" },
    borderRightWidth: { values: "borderWidths" },
    borderInlineWidth: {
      values: "borderWidths",
      shorthand: ["borderXWidth"]
    },
    borderInlineStartWidth: {
      values: "borderWidths",
      shorthand: ["borderStartWidth"]
    },
    borderInlineEndWidth: {
      values: "borderWidths",
      shorthand: ["borderEndWidth"]
    },
    borderLeftWidth: { values: "borderWidths" },
    borderBlockWidth: {
      values: "borderWidths",
      shorthand: ["borderYWidth"]
    },
    // colors
    color: {
      values: colorValues,
      transform: createColorMixTransform("color")
    },
    fill: {
      values: colorValues,
      transform: createColorMixTransform("fill")
    },
    stroke: {
      values: colorValues,
      transform: createColorMixTransform("stroke")
    },
    accentColor: {
      values: colorValues,
      transform: createColorMixTransform("accentColor")
    },
    // divide
    divideX: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderInlineStartWidth: value,
            borderInlineEndWidth: "0px"
          }
        };
      }
    },
    divideY: {
      values: { type: "string" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderTopWidth: value,
            borderBottomWidth: "0px"
          }
        };
      }
    },
    divideColor: {
      values: colorValues,
      transform(value, args) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
            value,
            args
          )
        };
      }
    },
    divideStyle: {
      property: "borderStyle",
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            borderStyle: value
          }
        };
      }
    },
    // effects
    boxShadow: { values: "shadows", shorthand: ["shadow"] },
    boxShadowColor: {
      values: colorValues,
      transform: createColorMixTransform("--shadow-color"),
      shorthand: ["shadowColor"]
    },
    mixBlendMode: { shorthand: ["blendMode"] },
    backgroundBlendMode: { shorthand: ["bgBlendMode"] },
    opacity: { values: "opacity" },
    // filters
    filter: {
      transform(v2) {
        if (v2 !== "auto") {
          return { filter: v2 };
        }
        return {
          filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
        };
      }
    },
    blur: {
      values: "blurs",
      transform: (v2) => ({ "--blur": wrap("blur", v2) })
    },
    brightness: {
      transform: (v2) => ({ "--brightness": wrap("brightness", v2) })
    },
    contrast: {
      transform: (v2) => ({ "--contrast": wrap("contrast", v2) })
    },
    grayscale: {
      transform: (v2) => ({ "--grayscale": wrap("grayscale", v2) })
    },
    hueRotate: {
      transform: (v2) => ({ "--hue-rotate": wrap("hue-rotate", deg(v2)) })
    },
    invert: { transform: (v2) => ({ "--invert": wrap("invert", v2) }) },
    saturate: {
      transform: (v2) => ({ "--saturate": wrap("saturate", v2) })
    },
    sepia: { transform: (v2) => ({ "--sepia": wrap("sepia", v2) }) },
    dropShadow: {
      transform: (v2) => ({ "--drop-shadow": wrap("drop-shadow", v2) })
    },
    // backdrop filters
    backdropFilter: {
      transform(v2) {
        if (v2 !== "auto") {
          return { backdropFilter: v2 };
        }
        return {
          backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
        };
      }
    },
    backdropBlur: {
      values: "blurs",
      transform: (v2) => ({ "--backdrop-blur": wrap("blur", v2) })
    },
    backdropBrightness: {
      transform: (v2) => ({
        "--backdrop-brightness": wrap("brightness", v2)
      })
    },
    backdropContrast: {
      transform: (v2) => ({ "--backdrop-contrast": wrap("contrast", v2) })
    },
    backdropGrayscale: {
      transform: (v2) => ({
        "--backdrop-grayscale": wrap("grayscale", v2)
      })
    },
    backdropHueRotate: {
      transform: (v2) => ({
        "--backdrop-hue-rotate": wrap("hue-rotate", deg(v2))
      })
    },
    backdropInvert: {
      transform: (v2) => ({ "--backdrop-invert": wrap("invert", v2) })
    },
    backdropOpacity: {
      transform: (v2) => ({ "--backdrop-opacity": wrap("opacity", v2) })
    },
    backdropSaturate: {
      transform: (v2) => ({ "--backdrop-saturate": wrap("saturate", v2) })
    },
    backdropSepia: {
      transform: (v2) => ({ "--backdrop-sepia": wrap("sepia", v2) })
    },
    // flexbox
    flexBasis: { values: "sizes" },
    gap: { values: "spacing" },
    rowGap: { values: "spacing", shorthand: ["gapY"] },
    columnGap: { values: "spacing", shorthand: ["gapX"] },
    flexDirection: { shorthand: ["flexDir"] },
    // grid
    gridGap: { values: "spacing" },
    gridColumnGap: { values: "spacing" },
    gridRowGap: { values: "spacing" },
    // interactivity
    outlineColor: {
      values: colorValues,
      transform: createColorMixTransform("outlineColor")
    },
    focusRing: createFocusRing("&:is(:focus, [data-focus])"),
    focusVisibleRing: createFocusRing(
      "&:is(:focus-visible, [data-focus-visible])"
    ),
    focusRingColor: {
      values: colorValues,
      transform: createColorMixTransform("--focus-ring-color")
    },
    focusRingOffset: {
      values: "spacing",
      transform: (v2) => ({ "--focus-ring-offset": v2 })
    },
    focusRingWidth: {
      values: "borderWidths",
      property: "outlineWidth",
      transform: (v2) => ({ "--focus-ring-width": v2 })
    },
    focusRingStyle: {
      values: "borderStyles",
      property: "outlineStyle",
      transform: (v2) => ({ "--focus-ring-style": v2 })
    },
    // layout
    aspectRatio: { values: "aspectRatios" },
    width: { values: "sizes", shorthand: ["w"] },
    inlineSize: { values: "sizes" },
    height: { values: "sizes", shorthand: ["h"] },
    blockSize: { values: "sizes" },
    boxSize: {
      values: "sizes",
      property: "width",
      transform: (v2) => ({ width: v2, height: v2 })
    },
    minWidth: { values: "sizes", shorthand: ["minW"] },
    minInlineSize: { values: "sizes" },
    minHeight: { values: "sizes", shorthand: ["minH"] },
    minBlockSize: { values: "sizes" },
    maxWidth: { values: "sizes", shorthand: ["maxW"] },
    maxInlineSize: { values: "sizes" },
    maxHeight: { values: "sizes", shorthand: ["maxH"] },
    maxBlockSize: { values: "sizes" },
    hideFrom: {
      values: "breakpoints",
      //@ts-ignore
      transform: (value, { raw, token: token2 }) => {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
        return {
          [media]: { display: "none" }
        };
      }
    },
    hideBelow: {
      values: "breakpoints",
      //@ts-ignore
      transform(value, { raw, token: token2 }) {
        const bp = token2.raw(`breakpoints.${raw}`);
        const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
        return {
          [media]: {
            display: "none"
          }
        };
      }
    },
    // scroll
    overscrollBehavior: { shorthand: ["overscroll"] },
    overscrollBehaviorX: { shorthand: ["overscrollX"] },
    overscrollBehaviorY: { shorthand: ["overscrollY"] },
    scrollbar: {
      values: ["visible", "hidden"],
      transform(v2) {
        switch (v2) {
          case "visible":
            return {
              msOverflowStyle: "auto",
              scrollbarWidth: "auto",
              "&::-webkit-scrollbar": { display: "block" }
            };
          case "hidden":
            return {
              msOverflowStyle: "none",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" }
            };
          default:
            return {};
        }
      }
    },
    scrollbarColor: {
      values: colorValues,
      transform: createColorMixTransform("scrollbarColor")
    },
    scrollbarGutter: { values: "spacing" },
    scrollbarWidth: { values: "sizes" },
    // scroll margin
    scrollMargin: { values: "spacing" },
    scrollMarginTop: { values: "spacing" },
    scrollMarginBottom: { values: "spacing" },
    scrollMarginLeft: { values: "spacing" },
    scrollMarginRight: { values: "spacing" },
    scrollMarginX: {
      values: "spacing",
      transform: (v2) => ({ scrollMarginLeft: v2, scrollMarginRight: v2 })
    },
    scrollMarginY: {
      values: "spacing",
      transform: (v2) => ({ scrollMarginTop: v2, scrollMarginBottom: v2 })
    },
    // scroll padding
    scrollPadding: { values: "spacing" },
    scrollPaddingTop: { values: "spacing" },
    scrollPaddingBottom: { values: "spacing" },
    scrollPaddingLeft: { values: "spacing" },
    scrollPaddingRight: { values: "spacing" },
    scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
    scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
    // scroll snap
    scrollSnapType: {
      values: {
        none: "none",
        x: "x var(--scroll-snap-strictness)",
        y: "y var(--scroll-snap-strictness)",
        both: "both var(--scroll-snap-strictness)"
      }
    },
    scrollSnapStrictness: {
      values: ["mandatory", "proximity"],
      transform: (v2) => ({ "--scroll-snap-strictness": v2 })
    },
    scrollSnapMargin: { values: "spacing" },
    scrollSnapMarginTop: { values: "spacing" },
    scrollSnapMarginBottom: { values: "spacing" },
    scrollSnapMarginLeft: { values: "spacing" },
    scrollSnapMarginRight: { values: "spacing" },
    // list
    listStylePosition: { shorthand: ["listStylePos"] },
    listStyleImage: { values: "assets", shorthand: ["listStyleImg"] },
    // position
    position: { shorthand: ["pos"] },
    zIndex: { values: "zIndex" },
    inset: { values: "spacing" },
    insetInline: { values: "spacing", shorthand: ["insetX"] },
    insetBlock: { values: "spacing", shorthand: ["insetY"] },
    top: { values: "spacing" },
    insetBlockStart: { values: "spacing" },
    bottom: { values: "spacing" },
    insetBlockEnd: { values: "spacing" },
    left: { values: "spacing" },
    right: { values: "spacing" },
    insetInlineStart: {
      values: "spacing",
      shorthand: ["insetStart"]
    },
    insetInlineEnd: {
      values: "spacing",
      shorthand: ["insetEnd"]
    },
    // shadow / ring
    ring: {
      transform(value) {
        return {
          "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
          "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
          "--ring-width": value,
          boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
        };
      }
    },
    ringColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-color")
    },
    ringOffset: {
      transform: (value) => ({ "--ring-offset-width": value })
    },
    ringOffsetColor: {
      values: colorValues,
      transform: createColorMixTransform("--ring-offset-color")
    },
    ringInset: {
      transform: (v2) => ({ "--ring-inset": v2 })
    },
    // margin
    margin: { values: "spacing", shorthand: ["m"] },
    marginTop: { values: "spacing", shorthand: ["mt"] },
    marginBlockStart: { values: "spacing" },
    marginRight: { values: "spacing", shorthand: ["mr"] },
    marginBottom: { values: "spacing", shorthand: ["mb"] },
    marginBlockEnd: { values: "spacing" },
    marginLeft: { values: "spacing", shorthand: ["ml"] },
    marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
    marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
    marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
    marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
    // padding
    padding: { values: "spacing", shorthand: ["p"] },
    paddingTop: { values: "spacing", shorthand: ["pt"] },
    paddingRight: { values: "spacing", shorthand: ["pr"] },
    paddingBottom: { values: "spacing", shorthand: ["pb"] },
    paddingBlockStart: { values: "spacing" },
    paddingBlockEnd: { values: "spacing" },
    paddingLeft: { values: "spacing", shorthand: ["pl"] },
    paddingInlineStart: {
      values: "spacing",
      shorthand: ["ps", "paddingStart"]
    },
    paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
    paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
    paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
    // text decoration
    textDecoration: { shorthand: ["textDecor"] },
    textDecorationColor: {
      values: colorValues,
      transform: createColorMixTransform("textDecorationColor")
    },
    textShadow: { values: "shadows" },
    // transform
    transform: {
      transform: (value) => {
        let v2 = value;
        if (value === "auto") {
          v2 = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        if (value === "auto-gpu") {
          v2 = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
        }
        return { transform: v2 };
      }
    },
    skewX: { transform: (v2) => ({ "--skew-x": deg(v2) }) },
    skewY: { transform: (v2) => ({ "--skew-y": deg(v2) }) },
    scaleX: { transform: (v2) => ({ "--scale-x": v2 }) },
    scaleY: { transform: (v2) => ({ "--scale-y": v2 }) },
    scale: {
      transform(value) {
        if (value !== "auto") return { scale: value };
        return {
          scale: `var(--scale-x, 1) var(--scale-y, 1)`
        };
      }
    },
    spaceXReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceX: {
      property: "marginInlineStart",
      values: "spacing",
      transform: (v2) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-x-reverse": "0",
          marginInlineStart: `calc(${v2} * calc(1 - var(--space-x-reverse)))`,
          marginInlineEnd: `calc(${v2} * var(--space-x-reverse))`
        }
      })
    },
    spaceYReverse: {
      values: { type: "boolean" },
      transform(value) {
        return {
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": value ? "1" : void 0
          }
        };
      }
    },
    spaceY: {
      property: "marginTop",
      values: "spacing",
      transform: (v2) => ({
        "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
          "--space-y-reverse": "0",
          marginTop: `calc(${v2} * calc(1 - var(--space-y-reverse)))`,
          marginBottom: `calc(${v2} * var(--space-y-reverse))`
        }
      })
    },
    rotate: {
      transform(value) {
        if (value !== "auto") return { rotate: deg(value) };
        return {
          rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
        };
      }
    },
    rotateX: {
      transform(value) {
        return { "--rotate-x": deg(value) };
      }
    },
    rotateY: {
      transform(value) {
        return { "--rotate-y": deg(value) };
      }
    },
    // transform / translate
    translate: {
      transform(value) {
        if (value !== "auto") return { translate: value };
        return {
          translate: `var(--translate-x) var(--translate-y)`
        };
      }
    },
    translateX: {
      values: "spacing",
      transform: (v2) => ({ "--translate-x": v2 })
    },
    translateY: {
      values: "spacing",
      transform: (v2) => ({ "--translate-y": v2 })
    },
    // transition
    transition: {
      values: [
        "all",
        "common",
        "colors",
        "opacity",
        "position",
        "backgrounds",
        "size",
        "shadow",
        "transform"
      ],
      transform(value) {
        switch (value) {
          case "all":
            return createTransition("all");
          case "position":
            return createTransition(
              "left, right, top, bottom, inset-inline, inset-block"
            );
          case "colors":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke"
            );
          case "opacity":
            return createTransition("opacity");
          case "shadow":
            return createTransition("box-shadow");
          case "transform":
            return createTransition("transform");
          case "size":
            return createTransition("width, height");
          case "backgrounds":
            return createTransition(
              "background, background-color, background-image, background-position"
            );
          case "common":
            return createTransition(
              "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
            );
          default:
            return { transition: value };
        }
      }
    },
    transitionDuration: { values: "durations" },
    transitionProperty: {
      values: {
        common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
        colors: "background-color, border-color, color, fill, stroke",
        size: "width, height",
        position: "left, right, top, bottom, inset-inline, inset-block",
        background: "background, background-color, background-image, background-position"
      }
    },
    transitionTimingFunction: { values: "easings" },
    // animation
    animation: { values: "animations" },
    animationDuration: { values: "durations" },
    animationDelay: { values: "durations" },
    animationTimingFunction: { values: "easings" },
    // typography
    fontFamily: { values: "fonts" },
    fontSize: { values: "fontSizes" },
    fontWeight: { values: "fontWeights" },
    lineHeight: { values: "lineHeights" },
    letterSpacing: { values: "letterSpacings" },
    textIndent: { values: "spacing" },
    truncate: {
      values: { type: "boolean" },
      transform(value) {
        if (value === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
        return {};
      }
    },
    lineClamp: {
      transform(value) {
        if (value === "none") {
          return {
            WebkitLineClamp: "unset"
          };
        }
        return {
          overflow: "hidden",
          display: "-webkit-box",
          WebkitLineClamp: value,
          WebkitBoxOrient: "vertical",
          textWrap: "wrap"
        };
      }
    },
    // helpers
    srOnly: {
      values: { type: "boolean" },
      transform(value) {
        return srMapping[value] || {};
      }
    },
    debug: {
      values: { type: "boolean" },
      transform(value) {
        if (!value) return {};
        return {
          outline: "1px solid blue !important",
          "& > *": {
            outline: "1px solid red !important"
          }
        };
      }
    },
    caretColor: {
      values: colorValues,
      transform: createColorMixTransform("caretColor")
    },
    cursor: { values: "cursor" }
  }
});
const srMapping = {
  true: {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    borderWidth: "0"
  },
  false: {
    position: "static",
    width: "auto",
    height: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    clip: "auto",
    whiteSpace: "normal"
  }
};
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimingFunction,animationTimeline,appearance,aspectRatio,azimuth,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockStyle,borderBlockWidth,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineEnd,borderInlineColor,borderInlineStyle,borderInlineWidth,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,color,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicSize,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,direction,display,emptyCells,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontVariationSettings,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inputSecurity,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,printColorAdjust,quotes,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,scale,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginBottom,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,shapeImageThreshold,shapeMargin,shapeOutside,tabSize,tableLayout,textAlign,textAlignLast,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,zIndex,zoom,alignmentBaseline,baselineShift,clipRule,colorInterpolation,colorRendering,dominantBaseline,fill,fillOpacity,fillRule,floodColor,floodOpacity,glyphOrientationVertical,lightingColor,marker,markerEnd,markerMid,markerStart,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,textAnchor,vectorEffect";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop) => [prop, true]));
function memo$1(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (arg) => {
    if (cache2[arg] === void 0)
      cache2[arg] = fn(arg);
    return cache2[arg];
  };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = /* @__PURE__ */ memo$1((prop) => {
  return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});
const isNotNullish = (element) => element != null;
function walkObject(target, predicate, options2 = {}) {
  const { stop, getKey } = options2;
  function inner(value, path2 = []) {
    if (isObject$4(value) || Array.isArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key = getKey?.(prop, child) ?? prop;
        const childPath = [...path2, key];
        if (stop?.(value, childPath)) {
          return predicate(value, path2);
        }
        const next2 = inner(child, childPath);
        if (isNotNullish(next2)) {
          result[key] = next2;
        }
      }
      return result;
    }
    return predicate(value, path2);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  if (Array.isArray(obj)) return obj.map((value) => fn(value));
  if (!isObject$4(obj)) {
    if (obj !== null && obj !== void 0) return fn(obj);
    else return obj;
  }
  return walkObject(obj, (value) => fn(value));
}
function flatten(values, stop) {
  const result = {};
  walkObject(
    values,
    (token2, paths) => {
      if (token2) {
        result[paths.join(".")] = token2.value;
      }
    },
    { stop }
  );
  return result;
}
var fastSafeStringify = stringify;
stringify.default = stringify;
stringify.stable = deterministicStringify;
stringify.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = "[Circular]";
var arr = [];
var replacerStack = [];
function defaultOptions$2() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify(obj, replacer, spacer, options2) {
  if (typeof options2 === "undefined") {
    options2 = defaultOptions$2();
  }
  decirc(obj, "", 0, [], void 0, 0, options2);
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function setReplace(replace2, val, k2, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k2);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k2, { value: replace2 });
      arr.push([parent, k2, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k2, replace2]);
    }
  } else {
    parent[k2] = replace2;
    arr.push([parent, k2, val]);
  }
}
function decirc(val, k2, edgeIndex, stack, parent, depth, options2) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
        return;
      }
    }
    if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options2);
      }
    } else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options2);
      }
    }
    stack.pop();
  }
}
function compareFunction(a, b2) {
  if (a < b2) {
    return -1;
  }
  if (a > b2) {
    return 1;
  }
  return 0;
}
function deterministicStringify(obj, replacer, spacer, options2) {
  if (typeof options2 === "undefined") {
    options2 = defaultOptions$2();
  }
  var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options2) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function deterministicDecirc(val, k2, edgeIndex, stack, parent, depth, options2) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
        return;
      }
    }
    try {
      if (typeof val.toJSON === "function") {
        return;
      }
    } catch (_) {
      return;
    }
    if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options2);
      }
    } else {
      var tmp = {};
      var keys = Object.keys(val).sort(compareFunction);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        deterministicDecirc(val[key], key, i, stack, val, depth, options2);
        tmp[key] = val[key];
      }
      if (typeof parent !== "undefined") {
        arr.push([parent, k2, val]);
        parent[k2] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k2, v2) {
    return v2;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}
const stringify$1 = /* @__PURE__ */ getDefaultExportFromCjs(fastSafeStringify);
const memo = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  function get2(...args) {
    const key = args.map((v2) => stringify$1(v2)).join("|");
    if (cache2[key] === void 0) cache2[key] = fn(...args);
    return cache2[key];
  }
  return get2;
};
const BASE_FONT_SIZE = 16;
const UNIT_PX = "px";
const UNIT_EM = "em";
const UNIT_REM = "rem";
function getUnit(value = "") {
  const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
  const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
  const unit = value.match(
    new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
  );
  return unit?.[1];
}
function toPx(value = "") {
  if (typeof value === "number") {
    return `${value}px`;
  }
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_PX) {
    return value;
  }
  if (unit === UNIT_EM || unit === UNIT_REM) {
    return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
  }
}
function toRem(value = "") {
  const unit = getUnit(value);
  if (!unit) return value;
  if (unit === UNIT_REM) {
    return value;
  }
  if (unit === UNIT_EM) {
    return `${parseFloat(value)}${UNIT_REM}`;
  }
  if (unit === UNIT_PX) {
    return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
  }
}
const capitalize$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createBreakpoints(breakpoints2) {
  const sorted = sort(breakpoints2);
  const values = Object.fromEntries(sorted);
  function get2(name2) {
    return values[name2];
  }
  function only(name2) {
    return build$1(get2(name2));
  }
  function getRanges() {
    const breakpoints22 = Object.keys(values);
    const permuations = getPermutations(breakpoints22);
    const results = breakpoints22.flatMap((name2) => {
      const value = get2(name2);
      const down2 = [
        `${name2}Down`,
        build$1({ max: adjust(value.min) })
      ];
      const up2 = [name2, build$1({ min: value.min })];
      const _only = [`${name2}Only`, only(name2)];
      return [up2, _only, down2];
    }).filter(([, value]) => value !== "").concat(
      permuations.map(([min2, max2]) => {
        const minValue = get2(min2);
        const maxValue2 = get2(max2);
        return [
          `${min2}To${capitalize$1(max2)}`,
          build$1({ min: minValue.min, max: adjust(maxValue2.min) })
        ];
      })
    );
    return Object.fromEntries(results);
  }
  function toConditions() {
    const ranges = getRanges();
    return Object.fromEntries(Object.entries(ranges));
  }
  const conditions = toConditions();
  const getCondition = (key) => {
    return conditions[key];
  };
  function keys() {
    return ["base", ...Object.keys(values)];
  }
  function up(name2) {
    return build$1({ min: get2(name2).min });
  }
  function down(name2) {
    return build$1({ max: adjust(get2(name2).min) });
  }
  return {
    values: Object.values(values),
    only,
    keys,
    conditions,
    getCondition,
    up,
    down
  };
}
function adjust(value) {
  const computedMax = parseFloat(toPx(value) ?? "") - 0.04;
  return toRem(`${computedMax}px`);
}
function sort(breakpoints2) {
  const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
    return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
  });
  return entries.map(([name2, min2], index, entries2) => {
    let max2 = null;
    if (index <= entries2.length - 1) {
      max2 = entries2[index + 1]?.[1];
    }
    if (max2 != null) {
      max2 = adjust(max2);
    }
    return [name2, { name: name2, min: toRem(min2), max: max2 }];
  });
}
function getPermutations(values) {
  const result = [];
  values.forEach((current, index) => {
    let idx = index;
    idx++;
    let next2 = values[idx];
    while (next2) {
      result.push([current, next2]);
      idx++;
      next2 = values[idx];
    }
  });
  return result;
}
function build$1({ min: min2, max: max2 }) {
  if (min2 == null && max2 == null) return "";
  return [
    "@media screen",
    min2 && `(min-width: ${min2})`,
    max2 && `(max-width: ${max2})`
  ].filter(Boolean).join(" and ");
}
const mapEntries$1 = (obj, fn) => {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => fn(key, value))
  );
};
const createConditions = (options2) => {
  const { breakpoints: breakpoints2, conditions: conds = {} } = options2;
  const conditions = mapEntries$1(conds, (key, value) => [`_${key}`, value]);
  const values = Object.assign({}, conditions, breakpoints2.conditions);
  function keys() {
    return Object.keys(values);
  }
  function has2(key) {
    return keys().includes(key) || /^@|&|&$/.test(key) || key.startsWith("_");
  }
  function sort2(paths) {
    return paths.filter((v2) => v2 !== "base").sort((a, b2) => {
      const aa2 = has2(a);
      const bb2 = has2(b2);
      if (aa2 && !bb2) return 1;
      if (!aa2 && bb2) return -1;
      return 0;
    });
  }
  function expandAtRule(key) {
    if (!key.startsWith("@breakpoint")) return key;
    return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
  }
  function resolve2(key) {
    return Reflect.get(values, key) || key;
  }
  return {
    keys,
    sort: sort2,
    has: has2,
    resolve: resolve2,
    breakpoints: breakpoints2.keys(),
    expandAtRule
  };
};
const createMediaQueryRegex = (dimension) => ({
  minMax: new RegExp(
    `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
    "i"
  ),
  min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
  maxMin: new RegExp(
    `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
    "i"
  ),
  max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
});
const widthRegex = createMediaQueryRegex("width");
const heightRegex = createMediaQueryRegex("height");
const createQueryTester = (regexSet) => ({
  isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
  isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
});
const { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
const { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
const isPrint = /print/i;
const isPrintOnly = /^print$/i;
const isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
const lengthExec = /(\d)/;
const maxValue = Number.MAX_VALUE;
const multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
function getQueryLength(query) {
  const length2 = isLength.exec(query) || (isMinWidth(query) || isMinHeight(query) ? lengthExec.exec(query) : null);
  if (!length2) return maxValue;
  if (length2[0] === "0") return 0;
  const number = parseFloat(length2[1]);
  const unit = length2[2];
  return number * (multipliers[unit] || 1);
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
  return (query) => doubleTestTrue.test(query) || !doubleTestFalse.test(query) && singleTest.test(query);
}
function _testIsPrint(a, b2) {
  const isPrintA = isPrint.test(a), isPrintOnlyA = isPrintOnly.test(a);
  const isPrintB = isPrint.test(b2), isPrintOnlyB = isPrintOnly.test(b2);
  if (isPrintA && isPrintB) {
    if (!isPrintOnlyA && isPrintOnlyB) return 1;
    if (isPrintOnlyA && !isPrintOnlyB) return -1;
    return a.localeCompare(b2);
  }
  return isPrintA ? 1 : isPrintB ? -1 : null;
}
const sortAtParams = memo((a, b2) => {
  const testIsPrint = _testIsPrint(a, b2);
  if (testIsPrint !== null) return testIsPrint;
  const minA = isMinWidth(a) || isMinHeight(a), maxA = isMaxWidth(a) || isMaxHeight(a);
  const minB = isMinWidth(b2) || isMinHeight(b2), maxB = isMaxWidth(b2) || isMaxHeight(b2);
  if (minA && maxB) return -1;
  if (maxA && minB) return 1;
  const lengthA = getQueryLength(a), lengthB = getQueryLength(b2);
  if (lengthA === maxValue && lengthB === maxValue) return a.localeCompare(b2);
  if (lengthA === maxValue) return 1;
  if (lengthB === maxValue) return -1;
  if (lengthA !== lengthB) {
    return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
  }
  return a.localeCompare(b2);
});
function sortQueries(queries) {
  return queries.sort(([a], [b2]) => sortAtParams(a, b2));
}
function sortAtRules(obj) {
  const mediaQueries = [];
  const containerQueries = [];
  const rest = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key.startsWith("@media")) {
      mediaQueries.push([key, value]);
    } else if (key.startsWith("@container")) {
      containerQueries.push([key, value]);
    } else if (isObject$4(value)) {
      rest[key] = sortAtRules(value);
    } else {
      rest[key] = value;
    }
  }
  const sortedMediaQueries = sortQueries(mediaQueries);
  const sortedContainerQueries = sortQueries(containerQueries);
  return {
    ...rest,
    ...Object.fromEntries(sortedMediaQueries),
    ...Object.fromEntries(sortedContainerQueries)
  };
}
const importantRegex = /\s*!(important)?/i;
const isImportant = (v2) => isString$3(v2) ? importantRegex.test(v2) : false;
const withoutImportant = (v2) => isString$3(v2) ? v2.replace(importantRegex, "").trim() : v2;
function createCssFn(context) {
  const { transform: transform2, conditions, normalize: normalize2 } = context;
  const mergeFn = mergeCss(context);
  return memo(function cssFn(...styleArgs) {
    const styles2 = mergeFn(...styleArgs);
    const normalized = normalize2(styles2);
    const result = /* @__PURE__ */ Object.create(null);
    walkObject(normalized, (value, paths) => {
      const important = isImportant(value);
      if (value == null) return;
      const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
      if (important) {
        value = withoutImportant(value);
      }
      let transformed = transform2(prop, value) ?? /* @__PURE__ */ Object.create(null);
      transformed = walkObject(
        transformed,
        (v2) => isString$3(v2) && important ? `${v2} !important` : v2,
        { getKey: (prop2) => conditions.expandAtRule(prop2) }
      );
      mergeByPath(result, selectors.flat(), transformed);
    });
    return sortAtRules(result);
  });
}
function mergeByPath(target, paths, value) {
  let acc = target;
  for (const path2 of paths) {
    if (!path2) continue;
    if (!acc[path2]) acc[path2] = /* @__PURE__ */ Object.create(null);
    acc = acc[path2];
  }
  mergeWith(acc, value);
}
function compactFn(...styles2) {
  return styles2.filter(
    (style) => isObject$4(style) && Object.keys(compact$1(style)).length > 0
  );
}
function mergeCss(ctx) {
  function resolve2(styles2) {
    const comp = compactFn(...styles2);
    if (comp.length === 1) return comp;
    return comp.map((style) => ctx.normalize(style));
  }
  return memo(function mergeFn(...styles2) {
    return mergeWith({}, ...resolve2(styles2));
  });
}
const uniq = (...items) => {
  const _items = items.filter(Boolean);
  return Array.from(new Set(_items));
};
const defaults$1 = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function createRecipeFn(options2) {
  const { css: css2, conditions, normalize: normalize2, layers } = options2;
  function cva(config2 = {}) {
    const { base, variants: variants2, defaultVariants: defaultVariants2, compoundVariants } = defaults$1(config2);
    const getVariantCss = createCssFn({
      conditions,
      normalize: normalize2,
      transform(prop, value) {
        return variants2[prop]?.[value];
      }
    });
    const resolve2 = (props = {}) => {
      const variantSelections = normalize2({
        ...defaultVariants2,
        ...compact$1(props)
      });
      let variantCss = { ...base };
      mergeWith(variantCss, getVariantCss(variantSelections));
      const compoundVariantCss = getCompoundVariantCss(
        compoundVariants,
        variantSelections
      );
      return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
    };
    const variantKeys = Object.keys(variants2);
    const splitVariantProps = (props) => {
      const restProps = omit(props, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props.colorPalette || defaultVariants2.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props.orientation;
      }
      return [recipeProps, localProps];
    };
    const variantMap = Object.fromEntries(
      Object.entries(variants2).map(([key, value]) => [
        key,
        Object.keys(value)
      ])
    );
    const cvaFn = (props) => css2(resolve2(props));
    return Object.assign(cvaFn, {
      className: config2.className,
      __cva__: true,
      variantMap,
      variantKeys,
      raw: resolve2,
      config: config2,
      splitVariantProps,
      merge(other) {
        return cva(mergeCva(options2)(this, other));
      }
    });
  }
  function getCompoundVariantCss(cvs, vm) {
    let result = {};
    cvs.forEach((cv) => {
      const isMatching = Object.entries(cv).every(([key, value]) => {
        if (key === "css") return true;
        const values = Array.isArray(value) ? value : [value];
        return values.some((value2) => vm[key] === value2);
      });
      if (isMatching) {
        result = css2(result, cv.css);
      }
    });
    return result;
  }
  return cva;
}
function mergeCva(opts) {
  const { css: css2 } = opts;
  return function mergeCva2(cvaA, cvaB) {
    const override = defaults$1(cvaB.config);
    const variantKeys = uniq(cvaA.variantKeys, Object.keys(cvaB.variants));
    const base = css2(cvaA.base, override.base);
    const variants2 = Object.fromEntries(
      variantKeys.map((key) => [
        key,
        css2(cvaA.config.variants[key], override.variants[key])
      ])
    );
    const defaultVariants2 = mergeWith(
      cvaA.config.defaultVariants,
      override.defaultVariants
    );
    const compoundVariants = [
      ...cvaA.compoundVariants,
      ...override.compoundVariants
    ];
    const className = cx(cvaA.className, cvaB.className);
    return {
      className,
      base,
      variants: variants2,
      defaultVariants: defaultVariants2,
      compoundVariants
    };
  };
}
const defaultLayers = {
  reset: "reset",
  base: "base",
  tokens: "tokens",
  recipes: "recipes"
};
const layerOrder = {
  reset: 0,
  base: 1,
  tokens: 2,
  recipes: 3
};
function createLayers(config2) {
  const layers = config2.layers ?? defaultLayers;
  const values = Object.values(layers);
  const names = values.sort((a, b2) => layerOrder[a] - layerOrder[b2]);
  return {
    names,
    atRule: `@layer ${names.join(", ")};`,
    wrap(layer, styles2) {
      if (config2.disableLayers) return styles2;
      const params = layers[layer];
      return { [`@layer ${params}`]: styles2 };
    }
  };
}
function createNormalizeFn(context) {
  const { utility, normalize: normalize2 } = context;
  const { hasShorthand, resolveShorthand } = utility;
  return function(styles2) {
    return walkObject(styles2, normalize2, {
      stop: (value) => Array.isArray(value),
      getKey: hasShorthand ? resolveShorthand : void 0
    });
  };
}
function createPreflight(options2) {
  const { preflight } = options2;
  if (!preflight) return {};
  const { scope = "", level = "parent" } = isObject$4(preflight) ? preflight : {};
  let selector = "";
  if (scope && level === "parent") {
    selector = `${scope} `;
  } else if (scope && level === "element") {
    selector = `&${scope}`;
  }
  const scoped = {
    "*": {
      margin: "0px",
      padding: "0px",
      font: "inherit",
      wordWrap: "break-word",
      WebkitTapHighlightColor: "transparent"
    },
    "*, *::before, *::after, *::backdrop": {
      boxSizing: "border-box",
      borderWidth: "0px",
      borderStyle: "solid",
      borderColor: "var(--global-color-border, currentColor)"
    },
    hr: {
      height: "0px",
      color: "inherit",
      borderTopWidth: "1px"
    },
    body: {
      minHeight: "100dvh",
      position: "relative"
    },
    img: {
      borderStyle: "none"
    },
    "img, svg, video, canvas, audio, iframe, embed, object": {
      display: "block",
      verticalAlign: "middle"
    },
    iframe: { border: "none" },
    "img, video": { maxWidth: "100%", height: "auto" },
    "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
    "ol, ul": { listStyle: "none" },
    "code, kbd, pre, samp": { fontSize: "1em" },
    "button, [type='button'], [type='reset'], [type='submit']": {
      WebkitAppearance: "button",
      backgroundColor: "transparent",
      backgroundImage: "none"
    },
    "button, input, optgroup, select, textarea": { color: "inherit" },
    "button, select": { textTransform: "none" },
    table: {
      textIndent: "0px",
      borderColor: "inherit",
      borderCollapse: "collapse"
    },
    "*::placeholder": {
      opacity: "unset",
      color: "#9ca3af",
      userSelect: "none"
    },
    textarea: {
      resize: "vertical"
    },
    summary: {
      display: "list-item"
    },
    small: {
      fontSize: "80%"
    },
    "sub, sup": {
      fontSize: "75%",
      lineHeight: 0,
      position: "relative",
      verticalAlign: "baseline"
    },
    sub: {
      bottom: "-0.25em"
    },
    sup: {
      top: "-0.5em"
    },
    dialog: {
      padding: "0px"
    },
    a: {
      color: "inherit",
      textDecoration: "inherit"
    },
    "abbr:where([title])": {
      textDecoration: "underline dotted"
    },
    "b, strong": {
      fontWeight: "bolder"
    },
    "code, kbd, samp, pre": {
      fontSize: "1em",
      "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
      fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
    },
    'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
      WebkitAppearance: "none",
      MozAppearance: "none"
    },
    "input[type='search']": {
      WebkitAppearance: "textfield",
      outlineOffset: "-2px"
    },
    "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
      WebkitAppearance: "none"
    },
    "::-webkit-file-upload-button": {
      WebkitAppearance: "button",
      font: "inherit"
    },
    'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
      height: "auto"
    },
    "input[type='number']": {
      MozAppearance: "textfield"
    },
    ":-moz-ui-invalid": {
      boxShadow: "none"
    },
    ":-moz-focusring": {
      outline: "auto"
    },
    "[hidden]:where(:not([hidden='until-found']))": {
      display: "none !important"
    }
  };
  const preflightCss = {
    [scope || "html"]: {
      lineHeight: 1.5,
      "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
      WebkitTextSizeAdjust: "100%",
      WebkitFontSmoothing: "antialiased",
      MozOsxFontSmoothing: "grayscale",
      textRendering: "optimizeLegibility",
      touchAction: "manipulation",
      MozTabSize: "4",
      tabSize: "4",
      fontFamily: "var(--global-font-body, var(--font-fallback))"
    }
  };
  if (level === "element") {
    const modified = Object.entries(scoped).reduce((acc, [k2, v2]) => {
      acc[k2] = { [selector]: v2 };
      return acc;
    }, {});
    Object.assign(preflightCss, modified);
  } else if (selector) {
    preflightCss[selector] = scoped;
  } else {
    Object.assign(preflightCss, scoped);
  }
  return preflightCss;
}
function createSerializeFn(options2) {
  const { conditions, isValidProperty } = options2;
  return function serialize2(styles2) {
    return walkObject(styles2, (value) => value, {
      getKey: (prop, value) => {
        if (!isObject$4(value)) return prop;
        if (!conditions.has(prop) && !isValidProperty(prop)) {
          return parseSelectors(prop).map((s) => "&" + s).join(", ");
        }
        return prop;
      }
    });
  };
}
function parseSelectors(selector) {
  const result = [];
  let parenCount = 0;
  let currentSelector = "";
  let inEscape = false;
  for (let i = 0; i < selector.length; i++) {
    const char2 = selector[i];
    if (char2 === "\\" && !inEscape) {
      inEscape = true;
      currentSelector += char2;
      continue;
    }
    if (inEscape) {
      inEscape = false;
      currentSelector += char2;
      continue;
    }
    if (char2 === "(") {
      parenCount++;
    } else if (char2 === ")") {
      parenCount--;
    }
    if (char2 === "," && parenCount === 0) {
      result.push(currentSelector.trim());
      currentSelector = "";
    } else {
      currentSelector += char2;
    }
  }
  if (currentSelector) {
    result.push(currentSelector.trim());
  }
  return result;
}
const getSlotRecipes = (config2 = {}) => {
  const init = (slot) => ({
    base: config2.base?.[slot] ?? {},
    variants: {},
    defaultVariants: config2.defaultVariants ?? {},
    compoundVariants: config2.compoundVariants ? getSlotCompoundVariant(config2.compoundVariants, slot) : []
  });
  const slots = config2.slots ?? [];
  const entries = slots.map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(
    config2.variants ?? {}
  )) {
    for (const [variantKey, variantSpec] of Object.entries(
      variantsSpec
    )) {
      entries.forEach(([slot, slotRecipe]) => {
        var _a2;
        (_a2 = slotRecipe.variants)[variantsKey] ?? (_a2[variantsKey] = {});
        slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
    }
  }
  return Object.fromEntries(entries);
};
const getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
  ...compoundVariant,
  css: compoundVariant.css[slotName]
}));
function createSlotRecipeFn(options2) {
  const { cva } = options2;
  return function sva(config2 = {}) {
    const slots = Object.entries(getSlotRecipes(config2)).map(
      ([slot, slotCva]) => [slot, cva(slotCva)]
    );
    function svaFn(props) {
      const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props)]);
      return Object.fromEntries(result);
    }
    const variants2 = config2.variants ?? {};
    const variantKeys = Object.keys(variants2);
    function splitVariantProps(props) {
      const restProps = omit(props, ["recipe"]);
      const [recipeProps, localProps] = splitProps(restProps, variantKeys);
      if (!variantKeys.includes("colorPalette")) {
        recipeProps.colorPalette = props.colorPalette || config2.defaultVariants?.colorPalette;
      }
      if (variantKeys.includes("orientation")) {
        localProps.orientation = props.orientation;
      }
      return [recipeProps, localProps];
    }
    const variantMap = Object.fromEntries(
      Object.entries(variants2).map(([key, value]) => [key, Object.keys(value)])
    );
    let classNameMap = {};
    if (config2.className) {
      classNameMap = Object.fromEntries(
        config2.slots.map((slot) => [
          slot,
          `${config2.className}__${slot}`
        ])
      );
    }
    return Object.assign(svaFn, {
      variantMap,
      variantKeys,
      splitVariantProps,
      classNameMap
    });
  };
}
const createProps = () => (props) => Array.from(new Set(props));
const rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
const fcssescape = function(ch2, asCodePoint) {
  if (!asCodePoint) return "\\" + ch2;
  if (ch2 === "\0") return "";
  if (ch2 === "-" && ch2.length === 1) return "\\-";
  return ch2.slice(0, -1) + "\\" + ch2.charCodeAt(ch2.length - 1).toString(16);
};
const esc = (sel) => {
  return (sel + "").replace(rcssescape, fcssescape);
};
const expandTokenReferences = (str, resolve2) => {
  let expanded = "";
  let index = 0;
  let state = "char";
  let tokenPath = "";
  let fallback2 = "";
  const currentStates = [];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "{") {
      const endIndex = str.indexOf("}", index);
      if (endIndex === -1) {
        break;
      }
      const path2 = str.slice(index + 1, endIndex);
      const resolved = resolve2(path2);
      expanded += resolved ?? path2;
      index = endIndex + 1;
      continue;
    }
    if (state === "token") {
      if (char2 === ",") {
        if (str[index] === "") {
          index++;
        }
        state = "fallback";
        currentStates.push(state);
        const resolved = resolve2(tokenPath);
        if (resolved?.endsWith(")")) {
          expanded += resolved.slice(0, -1);
        }
        tokenPath = "";
        fallback2 = "";
        continue;
      }
    }
    if (state === "fallback") {
      const nextFallback = fallback2 + char2;
      if (nextFallback === ", var(") {
        const innerEndIndex = cssVarParser(str.slice(index + 1));
        const endIndex = innerEndIndex + index + 1;
        const cssVar2 = str.slice(index + 1, endIndex);
        if (endIndex === -1) {
          break;
        }
        expanded += ", var(" + cssVar2 + ")";
        index = endIndex + 1;
        state = currentStates.pop() ?? state;
        fallback2 = "";
        continue;
      }
    }
    if (state === "token" || state === "fallback") {
      index++;
      if (char2 === ")") {
        state = currentStates.pop() ?? state ?? "char";
        fallback2 += char2;
        const resolved = tokenPath ? resolve2(tokenPath) ?? esc(tokenPath) : tokenPath;
        if (fallback2) {
          fallback2 = fallback2.slice(1).trim();
          if (!fallback2.startsWith("token(") && fallback2.endsWith(")")) {
            fallback2 = fallback2.slice(0, -1);
          }
          if (fallback2.includes("token(")) {
            const parsed = expandTokenReferences(fallback2, resolve2);
            if (parsed) {
              fallback2 = parsed.slice(0, -1);
            }
          } else if (fallback2) {
            const resolvedFallback = resolve2(fallback2);
            if (resolvedFallback) {
              fallback2 = resolvedFallback;
            }
          }
        }
        const lastChar = expanded.at(-1);
        if (fallback2) {
          if (lastChar?.trim()) {
            expanded += resolved.slice(0, -1) + (", " + fallback2 + ")");
          } else {
            expanded += fallback2;
          }
        } else {
          expanded += resolved || ")";
        }
        tokenPath = "";
        fallback2 = "";
        state = "char";
        continue;
      }
      if (state === "token") {
        tokenPath += char2;
      }
      if (state === "fallback") {
        fallback2 += char2;
      }
      continue;
    }
    const tokenIndex = str.indexOf("token(", index);
    if (tokenIndex !== -1) {
      const innerTokenIndex = tokenIndex + "token(".length;
      expanded += str.slice(index, tokenIndex);
      index = innerTokenIndex;
      state = "token";
      currentStates.push(state);
      continue;
    }
    expanded += char2;
    index++;
  }
  return expanded;
};
const cssVarParser = (str) => {
  let index = 0;
  const openedParenthesises = ["("];
  while (index < str.length) {
    const char2 = str[index];
    if (char2 === "(") {
      openedParenthesises.push(char2);
    } else if (char2 === ")") {
      openedParenthesises.pop();
      if (openedParenthesises.length === 0) {
        return index;
      }
    }
    index++;
  }
  return index;
};
function mapToJson(map) {
  const obj = {};
  map.forEach((value, key) => {
    if (value instanceof Map) {
      obj[key] = Object.fromEntries(value);
    } else {
      obj[key] = value;
    }
  });
  return obj;
}
const REFERENCE_REGEX = /({([^}]*)})/g;
const CURLY_REGEX = /[{}]/g;
const TOKEN_PATH_REGEX = /\w+\.\w+/;
const getReferences = (value) => {
  if (!isString$3(value)) return [];
  const matches2 = value.match(REFERENCE_REGEX);
  if (!matches2) return [];
  return matches2.map((match2) => match2.replace(CURLY_REGEX, "")).map((value2) => value2.trim());
};
const hasReference = (value) => REFERENCE_REGEX.test(value);
function expandReferences(token2) {
  if (!token2.extensions?.references) {
    return token2.extensions?.cssVar?.ref ?? token2.value;
  }
  const references = token2.extensions.references ?? {};
  token2.value = Object.keys(references).reduce((valueStr, key) => {
    const referenceToken = references[key];
    if (referenceToken.extensions.conditions) {
      return valueStr;
    }
    const value = expandReferences(referenceToken);
    return valueStr.replace(`{${key}}`, value);
  }, token2.value);
  delete token2.extensions.references;
  return token2.value;
}
function resolveReference(operand) {
  if (isObject$4(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
const toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
const add = (...operands) => `calc(${toExpression("+", ...operands)})`;
const subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
const multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
const divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
const negate = (x2) => {
  const value = resolveReference(x2);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
const calc = Object.assign(
  (x2) => ({
    add: (...operands) => calc(add(x2, ...operands)),
    subtract: (...operands) => calc(subtract(x2, ...operands)),
    multiply: (...operands) => calc(multiply(x2, ...operands)),
    divide: (...operands) => calc(divide(x2, ...operands)),
    negate: () => calc(negate(x2)),
    toString: () => x2.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);
const addNegativeTokens = {
  enforce: "pre",
  transform(dictionary) {
    const { prefix: prefix2, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "spacing"
    );
    tokens.forEach((token2) => {
      const originalPath = token2.path.slice();
      const originalVar = formatCssVar(originalPath, prefix2);
      if (isString$3(token2.value) && token2.value === "0rem") {
        return;
      }
      const nextToken = structuredClone(token2);
      Object.assign(nextToken.extensions, {
        negative: true,
        prop: `-${token2.extensions.prop}`,
        originalPath
      });
      nextToken.value = calc.negate(originalVar.ref);
      const lastPath = nextToken.path[nextToken.path.length - 1];
      if (lastPath != null) {
        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;
      }
      if (nextToken.path) {
        nextToken.name = formatTokenName(nextToken.path);
      }
      registerToken(nextToken);
    });
  }
};
const units = /* @__PURE__ */ new Set([
  "spacing",
  "sizes",
  "borderWidths",
  "fontSizes",
  "radii"
]);
const addPixelUnit = {
  enforce: "post",
  transform(dictionary) {
    const tokens = dictionary.allTokens.filter((token2) => {
      return units.has(token2.extensions.category) && !token2.extensions.negative;
    });
    tokens.forEach((token2) => {
      Object.assign(token2.extensions, {
        pixelValue: toPx(token2.value)
      });
    });
  }
};
const addVirtualPalette = {
  enforce: "post",
  transform(dictionary) {
    const { allTokens, registerToken, formatTokenName } = dictionary;
    const tokens = allTokens.filter(
      ({ extensions }) => extensions.category === "colors"
    );
    const keys = /* @__PURE__ */ new Map();
    const colorPalettes = /* @__PURE__ */ new Map();
    tokens.forEach((token2) => {
      const { colorPalette } = token2.extensions;
      if (!colorPalette) return;
      colorPalette.keys.forEach((keyPath) => {
        keys.set(formatTokenName(keyPath), keyPath);
      });
      colorPalette.roots.forEach((colorPaletteRoot) => {
        const name2 = formatTokenName(colorPaletteRoot);
        const colorPaletteList = colorPalettes.get(name2) || [];
        colorPaletteList.push(token2);
        colorPalettes.set(name2, colorPaletteList);
        if (token2.extensions.default && colorPaletteRoot.length === 1) {
          const keyPath = colorPalette.keys[0]?.filter(Boolean);
          if (!keyPath.length) return;
          const path2 = colorPaletteRoot.concat(keyPath);
          keys.set(formatTokenName(path2), []);
        }
      });
    });
    keys.forEach((segments) => {
      const path2 = ["colors", "colorPalette", ...segments].filter(Boolean);
      const name2 = formatTokenName(path2);
      const prop = formatTokenName(path2.slice(1));
      const token2 = {
        name: name2,
        value: name2,
        originalValue: name2,
        path: path2,
        extensions: {
          condition: "base",
          originalPath: path2,
          category: "colors",
          prop,
          virtual: true
        }
      };
      registerToken(token2, "pre");
    });
  }
};
const removeEmptyTokens = {
  enforce: "post",
  transform(dictionary) {
    dictionary.allTokens = dictionary.allTokens.filter(
      (token2) => token2.value !== ""
    );
  }
};
const tokenMiddlewares = [
  addNegativeTokens,
  addVirtualPalette,
  addPixelUnit,
  removeEmptyTokens
];
const addCssVariables = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/css-var",
  transform(token2, dictionary) {
    const { prefix: prefix2, formatCssVar } = dictionary;
    const { negative, originalPath } = token2.extensions;
    const path2 = negative ? originalPath : token2.path;
    return {
      cssVar: formatCssVar(path2.filter(Boolean), prefix2)
    };
  }
};
const addConditionalCssVariables = {
  enforce: "post",
  type: "value",
  name: "tokens/conditionals",
  transform(token2, dictionary) {
    const { prefix: prefix2, formatCssVar } = dictionary;
    const refs = getReferences(token2.value);
    if (!refs.length) return token2.value;
    refs.forEach((ref) => {
      const variable = formatCssVar(ref.split("."), prefix2);
      token2.value = token2.value.replace(`{${variable.ref}}`, variable);
    });
    return token2.value;
  }
};
const addColorPalette = {
  type: "extensions",
  enforce: "pre",
  name: "tokens/colors/colorPalette",
  match(token2) {
    return token2.extensions.category === "colors" && !token2.extensions.virtual;
  },
  transform(token2, dict) {
    let path2 = token2.path.slice();
    path2.pop();
    path2.shift();
    if (path2.length === 0) {
      const newPath = [...token2.path];
      newPath.shift();
      path2 = newPath;
    }
    if (path2.length === 0) {
      return {};
    }
    const roots = path2.reduce((acc, _, i, arr2) => {
      const next2 = arr2.slice(0, i + 1);
      acc.push(next2);
      return acc;
    }, []);
    const root = path2[0];
    const value = dict.formatTokenName(path2);
    const keys = token2.path.slice(token2.path.indexOf(root) + 1).reduce((acc, _, i, arr2) => {
      acc.push(arr2.slice(i));
      return acc;
    }, []);
    if (keys.length === 0) {
      keys.push([""]);
    }
    return {
      colorPalette: { value, roots, keys }
    };
  }
};
const tokenTransforms = [
  addCssVariables,
  addConditionalCssVariables,
  addColorPalette
];
const isToken = (value) => {
  return isObject$4(value) && Object.prototype.hasOwnProperty.call(value, "value");
};
function expandBreakpoints(breakpoints2) {
  if (!breakpoints2) return { breakpoints: {}, sizes: {} };
  return {
    breakpoints: mapObject(breakpoints2, (value) => ({ value })),
    sizes: Object.fromEntries(
      Object.entries(breakpoints2).map(([key, value]) => [
        `breakpoint-${key}`,
        { value }
      ])
    )
  };
}
function createTokenDictionary(options2) {
  const {
    prefix: prefix2 = "",
    tokens = {},
    semanticTokens = {},
    breakpoints: breakpoints2 = {}
  } = options2;
  const formatTokenName = (path2) => path2.join(".");
  const formatCssVar = (path2, prefix22) => cssVar(path2.join("-"), { prefix: prefix22 });
  const allTokens = [];
  const tokenNameMap = /* @__PURE__ */ new Map();
  const conditionMap = /* @__PURE__ */ new Map();
  const cssVarMap = /* @__PURE__ */ new Map();
  const colorPaletteMap = /* @__PURE__ */ new Map();
  const flatMap = /* @__PURE__ */ new Map();
  const byCategory = /* @__PURE__ */ new Map();
  const categoryMap = /* @__PURE__ */ new Map();
  const transforms = /* @__PURE__ */ new Map();
  const middlewares = [];
  function registerToken(token2, phase) {
    allTokens.push(token2);
    tokenNameMap.set(token2.name, token2);
    if (phase) {
      transforms.forEach((fn) => {
        if (fn.enforce === phase) transformToken(fn, token2);
      });
    }
  }
  const breakpointTokens = expandBreakpoints(breakpoints2);
  const computedTokens = compact$1({
    ...tokens,
    breakpoints: breakpointTokens.breakpoints,
    sizes: {
      ...tokens.sizes,
      ...breakpointTokens.sizes
    }
  });
  function registerTokens() {
    walkObject(
      computedTokens,
      (entry, path2) => {
        const isDefault = path2.includes("DEFAULT");
        path2 = filterDefault(path2);
        const category = path2[0];
        const name2 = formatTokenName(path2);
        const t2 = isString$3(entry) ? { value: entry } : entry;
        const token2 = {
          value: t2.value,
          originalValue: t2.value,
          name: name2,
          path: path2,
          extensions: {
            condition: "base",
            originalPath: path2,
            category,
            prop: formatTokenName(path2.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
    walkObject(
      semanticTokens,
      (entry, path2) => {
        const isDefault = path2.includes("DEFAULT");
        path2 = filterBaseCondition(filterDefault(path2));
        const category = path2[0];
        const name2 = formatTokenName(path2);
        const t2 = isString$3(entry.value) ? { value: { base: entry.value } } : entry;
        const token2 = {
          value: t2.value.base || "",
          originalValue: t2.value.base || "",
          name: name2,
          path: path2,
          extensions: {
            originalPath: path2,
            category,
            conditions: t2.value,
            condition: "base",
            prop: formatTokenName(path2.slice(1))
          }
        };
        if (isDefault) {
          token2.extensions.default = true;
        }
        registerToken(token2);
      },
      { stop: isToken }
    );
  }
  function getByName(name2) {
    return tokenNameMap.get(name2);
  }
  function buildConditionMap(token2) {
    const { condition } = token2.extensions;
    if (!condition) return;
    if (!conditionMap.has(condition)) {
      conditionMap.set(condition, /* @__PURE__ */ new Set());
    }
    conditionMap.get(condition).add(token2);
  }
  function buildCategoryMap(token2) {
    const { category, prop } = token2.extensions;
    if (!category) return;
    if (!categoryMap.has(category)) {
      categoryMap.set(category, /* @__PURE__ */ new Map());
    }
    categoryMap.get(category).set(prop, token2);
  }
  function buildCssVars(token2) {
    const { condition, negative, virtual, cssVar: cssVar2 } = token2.extensions;
    if (negative || virtual || !condition || !cssVar2) return;
    if (!cssVarMap.has(condition)) {
      cssVarMap.set(condition, /* @__PURE__ */ new Map());
    }
    cssVarMap.get(condition).set(cssVar2.var, token2.value);
  }
  function buildFlatMap(token2) {
    const { category, prop, cssVar: cssVar2, negative } = token2.extensions;
    if (!category) return;
    if (!byCategory.has(category)) {
      byCategory.set(category, /* @__PURE__ */ new Map());
    }
    const value = negative ? token2.extensions.conditions ? token2.originalValue : token2.value : cssVar2.ref;
    byCategory.get(category).set(prop, value);
    flatMap.set([category, prop].join("."), value);
  }
  function buildColorPalette(token2) {
    const { colorPalette, virtual, default: isDefault } = token2.extensions;
    if (!colorPalette || virtual) return;
    colorPalette.roots.forEach((root) => {
      const name2 = formatTokenName(root);
      if (!colorPaletteMap.has(name2)) {
        colorPaletteMap.set(name2, /* @__PURE__ */ new Map());
      }
      const virtualPath = replaceRootWithColorPalette(
        [...token2.path],
        [...root]
      );
      const virtualName = formatTokenName(virtualPath);
      const virtualToken = getByName(virtualName);
      if (!virtualToken || !virtualToken.extensions.cssVar) return;
      const { var: virtualVar } = virtualToken.extensions.cssVar;
      colorPaletteMap.get(name2).set(virtualVar, token2.extensions.cssVar.ref);
      if (isDefault && root.length === 1) {
        const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
        const colorPaletteToken = getByName(colorPaletteName);
        if (!colorPaletteToken) return;
        const name22 = formatTokenName(token2.path);
        const virtualToken2 = getByName(name22);
        if (!virtualToken2) return;
        const keyPath = colorPalette.keys[0]?.filter(Boolean);
        if (!keyPath.length) return;
        const computedName = formatTokenName(root.concat(keyPath));
        if (!colorPaletteMap.has(computedName)) {
          colorPaletteMap.set(computedName, /* @__PURE__ */ new Map());
        }
        colorPaletteMap.get(computedName).set(
          colorPaletteToken.extensions.cssVar.var,
          virtualToken2.extensions.cssVar.ref
        );
      }
    });
  }
  let byCategoryJson = {};
  function setupViews() {
    allTokens.forEach((token2) => {
      buildConditionMap(token2);
      buildCategoryMap(token2);
      buildCssVars(token2);
      buildFlatMap(token2);
      buildColorPalette(token2);
    });
    byCategoryJson = mapToJson(byCategory);
  }
  const colorMix2 = (value, tokenFn) => {
    if (!value || typeof value !== "string") return { invalid: true, value };
    const [colorPath, rawOpacity] = value.split("/");
    if (!colorPath || !rawOpacity) {
      return { invalid: true, value: colorPath };
    }
    const colorToken = tokenFn(colorPath);
    const opacityToken = getByName(`opacity.${rawOpacity}`)?.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: colorPath };
    }
    const percent = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color = colorToken ?? colorPath;
    return {
      invalid: false,
      color,
      value: `color-mix(in srgb, ${color} ${percent}, transparent)`
    };
  };
  const getVar = memo((value, fallback2) => {
    return flatMap.get(value) ?? fallback2;
  });
  const getCategoryValues = memo((category) => {
    return byCategoryJson[category] || null;
  });
  const expandReferenceInValue = memo((value) => {
    return expandTokenReferences(value, (path2) => {
      if (!path2) return;
      if (path2.includes("/")) {
        const mix = colorMix2(path2, (v2) => getVar(v2));
        if (mix.invalid) {
          throw new Error("Invalid color mix at " + path2 + ": " + mix.value);
        }
        return mix.value;
      }
      const resolved = getVar(path2);
      if (resolved) return resolved;
      return TOKEN_PATH_REGEX.test(path2) ? esc(path2) : path2;
    });
  });
  const dictionary = {
    prefix: prefix2,
    allTokens,
    tokenMap: tokenNameMap,
    registerToken,
    getByName,
    formatTokenName,
    formatCssVar,
    flatMap,
    cssVarMap,
    categoryMap,
    colorPaletteMap,
    getVar,
    getCategoryValues,
    expandReferenceInValue
  };
  function registerTransform(...fns) {
    fns.forEach((fn) => {
      transforms.set(fn.name, fn);
    });
  }
  function registerMiddleware(...fns) {
    middlewares.push(...fns);
  }
  function transformToken(transform2, token2) {
    if (token2.extensions.references) return;
    if (isFunction$2(transform2.match) && !transform2.match(token2)) return;
    const fn = (v2) => transform2.transform(v2, dictionary);
    const transformed = fn(token2);
    switch (true) {
      case transform2.type === "extensions":
        Object.assign(token2.extensions, transformed);
        break;
      case transform2.type === "value":
        token2.value = transformed;
        break;
      default:
        token2[transform2.type] = transformed;
        break;
    }
  }
  function applyMiddlewares(enforce) {
    middlewares.forEach((middleware2) => {
      if (middleware2.enforce === enforce) {
        middleware2.transform(dictionary);
      }
    });
  }
  function applyTransforms(enforce) {
    transforms.forEach((transform2) => {
      if (transform2.enforce === enforce) {
        allTokens.forEach((token2) => {
          transformToken(transform2, token2);
        });
      }
    });
  }
  function addConditionalTokens() {
    allTokens.forEach((token2) => {
      const tokens2 = getConditionalTokens(token2);
      if (!tokens2 || tokens2.length === 0) return;
      tokens2.forEach((token22) => {
        registerToken(token22);
      });
    });
  }
  function getTokenReferences(value) {
    const refs = getReferences(value);
    return refs.map((ref) => getByName(ref)).filter(Boolean);
  }
  function addReferences() {
    allTokens.forEach((token2) => {
      if (!hasReference(token2.value)) return;
      const references = getTokenReferences(token2.value);
      token2.extensions.references = references.reduce((acc, ref) => {
        acc[ref.name] = ref;
        return acc;
      }, {});
    });
  }
  function expandTokenReferences$1() {
    allTokens.forEach((token2) => {
      expandReferences(token2);
    });
  }
  function build3() {
    applyMiddlewares("pre");
    applyTransforms("pre");
    addConditionalTokens();
    addReferences();
    expandTokenReferences$1();
    applyMiddlewares("post");
    applyTransforms("post");
    setupViews();
  }
  registerTokens();
  registerTransform(...tokenTransforms);
  registerMiddleware(...tokenMiddlewares);
  build3();
  return dictionary;
}
function filterDefault(path2) {
  if (path2[0] === "DEFAULT") return path2;
  return path2.filter((item) => item !== "DEFAULT");
}
function filterBaseCondition(path2) {
  return path2.filter((item) => item !== "base");
}
function getConditionalTokens(token2) {
  if (!token2.extensions.conditions) return;
  const { conditions } = token2.extensions;
  const tokens = [];
  walkObject(conditions, (value, path2) => {
    const nextPath = filterBaseCondition(path2);
    if (!nextPath.length) return;
    const nextToken = structuredClone(token2);
    nextToken.value = value;
    nextToken.extensions.condition = nextPath.join(":");
    tokens.push(nextToken);
  });
  return tokens;
}
function replaceRootWithColorPalette(path2, roots) {
  const startIndex = path2.findIndex(
    (_, index) => roots.every(
      (rootElement, rootIndex) => path2[index + rootIndex] === rootElement
    )
  );
  if (startIndex === -1) {
    return path2;
  }
  path2.splice(startIndex, roots.length);
  path2.splice(startIndex, 0, "colorPalette");
  return path2;
}
createProps()([
  "aspectRatios",
  "zIndex",
  "opacity",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "lineHeights",
  "letterSpacings",
  "sizes",
  "shadows",
  "spacing",
  "radii",
  "cursor",
  "borders",
  "borderWidths",
  "borderStyles",
  "durations",
  "easings",
  "animations",
  "blurs",
  "gradients",
  "breakpoints",
  "assets"
]);
function normalize(config2) {
  return config2;
}
function normalizeConfig(config2) {
  return Object.fromEntries(
    Object.entries(config2).map(([property, propertyConfig]) => {
      return [property, normalize(propertyConfig)];
    })
  );
}
function createUtility(options2) {
  const configs = normalizeConfig(options2.config);
  const tokens = options2.tokens;
  const shorthands = /* @__PURE__ */ new Map();
  const propValues = /* @__PURE__ */ new Map();
  function register(property, config2) {
    configs[property] = normalize(config2);
    assignProperty(property, config2);
  }
  const assignProperty = (property, config2) => {
    const values = getPropertyValues(config2);
    if (!values) return;
    propValues.set(property, values);
    assignPropertyType(property, config2);
  };
  const assignProperties = () => {
    for (const [prop, config2] of Object.entries(configs)) {
      if (!config2) continue;
      assignProperty(prop, config2);
    }
  };
  const assignShorthands = () => {
    for (const [property, config2] of Object.entries(configs)) {
      const { shorthand } = config2 ?? {};
      if (!shorthand) continue;
      const values = Array.isArray(shorthand) ? shorthand : [shorthand];
      values.forEach((name2) => shorthands.set(name2, property));
    }
  };
  const assignColorPaletteProperty = () => {
    const values = mapToJson(tokens.colorPaletteMap);
    register("colorPalette", {
      values: Object.keys(values),
      transform: memo((value) => values[value])
    });
  };
  const propTypes2 = /* @__PURE__ */ new Map();
  const assignPropertyType = (property, config2) => {
    if (!config2) return;
    const values = getPropertyValues(config2, (key) => `type:Tokens["${key}"]`);
    if (typeof values === "object" && values.type) {
      propTypes2.set(property, /* @__PURE__ */ new Set([`type:${values.type}`]));
      return;
    }
    if (values) {
      const keys2 = new Set(Object.keys(values));
      propTypes2.set(property, keys2);
    }
    const set2 = propTypes2.get(property) ?? /* @__PURE__ */ new Set();
    if (config2.property) {
      propTypes2.set(property, set2.add(`CssProperties["${config2.property}"]`));
    }
  };
  const assignPropertyTypes = () => {
    for (const [property, propertyConfig] of Object.entries(configs)) {
      if (!propertyConfig) continue;
      assignPropertyType(property, propertyConfig);
    }
  };
  const addPropertyType = (property, type) => {
    const set2 = propTypes2.get(property) ?? /* @__PURE__ */ new Set();
    propTypes2.set(property, /* @__PURE__ */ new Set([...set2, ...type]));
  };
  const getTypes = () => {
    const map = /* @__PURE__ */ new Map();
    for (const [prop, values] of propTypes2.entries()) {
      if (values.size === 0) {
        map.set(prop, ["string"]);
        continue;
      }
      const typeValues = Array.from(values).map((key) => {
        if (key.startsWith("CssProperties")) return key;
        if (key.startsWith("type:")) return key.replace("type:", "");
        return JSON.stringify(key);
      });
      map.set(prop, typeValues);
    }
    return map;
  };
  const getPropertyValues = (config2, resolveFn) => {
    const { values } = config2;
    const fn = (key) => {
      const value = resolveFn?.(key);
      return value ? { [value]: value } : void 0;
    };
    if (isString$3(values)) {
      return fn?.(values) ?? tokens.getCategoryValues(values) ?? {};
    }
    if (Array.isArray(values)) {
      return values.reduce((result, value) => {
        result[value] = value;
        return result;
      }, {});
    }
    if (isFunction$2(values)) {
      return values(resolveFn ? fn : tokens.getCategoryValues);
    }
    return values;
  };
  const defaultTransform = memo((prop, value) => {
    return {
      [prop]: prop.startsWith("--") ? tokens.getVar(value, value) : value
    };
  });
  const tokenFn = Object.assign(tokens.getVar, {
    raw: (path2) => tokens.getByName(path2)
  });
  const transform2 = memo((prop, raw) => {
    const key = resolveShorthand(prop);
    if (isString$3(raw) && !raw.includes("_EMO_")) {
      raw = tokens.expandReferenceInValue(raw);
    }
    const config2 = configs[key];
    if (!config2) {
      return defaultTransform(key, raw);
    }
    const value = propValues.get(key)?.[raw];
    if (!config2.transform) {
      return defaultTransform(prop, value ?? raw);
    }
    const _colorMix = (value2) => colorMix(value2, tokenFn);
    return config2.transform(value ?? raw, {
      raw,
      token: tokenFn,
      utils: { colorMix: _colorMix }
    });
  });
  function build3() {
    assignShorthands();
    assignColorPaletteProperty();
    assignProperties();
    assignPropertyTypes();
  }
  build3();
  const hasShorthand = shorthands.size > 0;
  const resolveShorthand = memo((prop) => {
    return shorthands.get(prop) ?? prop;
  });
  const keys = () => {
    return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
  };
  const instance2 = {
    keys,
    hasShorthand,
    transform: transform2,
    shorthands,
    resolveShorthand,
    register,
    getTypes,
    addPropertyType
  };
  return instance2;
}
function createSystem(...configs) {
  const config2 = mergeConfigs(...configs);
  const {
    theme = {},
    utilities = {},
    globalCss: globalCss2 = {},
    cssVarsRoot = ":where(:root, :host)",
    cssVarsPrefix = "chakra",
    preflight
  } = config2;
  const layers = createLayers(config2);
  const tokens = createTokenDictionary({
    breakpoints: theme.breakpoints,
    tokens: theme.tokens,
    semanticTokens: theme.semanticTokens,
    prefix: cssVarsPrefix
  });
  const breakpoints2 = createBreakpoints(theme.breakpoints ?? {});
  const conditions = createConditions({
    conditions: config2.conditions ?? {},
    breakpoints: breakpoints2
  });
  const utility = createUtility({
    config: utilities,
    tokens
  });
  function assignComposition() {
    const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
    const compositions = compact$1({
      textStyle: textStyles2,
      layerStyle: layerStyles2,
      animationStyle: animationStyles2
    });
    for (const [key, values] of Object.entries(compositions)) {
      const flatValues = flatten(
        values ?? {},
        (v2) => isObject$4(v2) && "value" in v2
      );
      utility.register(key, {
        values: Object.keys(flatValues),
        transform(value) {
          return css2(flatValues[value]);
        }
      });
    }
  }
  assignComposition();
  utility.addPropertyType("animationName", Object.keys(theme.keyframes ?? {}));
  const properties2 = /* @__PURE__ */ new Set(["css", ...utility.keys(), ...conditions.keys()]);
  const isValidProperty = memo(
    (prop) => properties2.has(prop) || isCssProperty(prop)
  );
  const normalizeValue = (value) => {
    if (Array.isArray(value)) {
      return value.reduce((acc, current, index) => {
        const key = conditions.breakpoints[index];
        if (current != null) acc[key] = current;
        return acc;
      }, {});
    }
    return value;
  };
  const normalizeFn = createNormalizeFn({
    utility,
    normalize: normalizeValue
  });
  const serialize2 = createSerializeFn({
    conditions,
    isValidProperty
  });
  const css2 = createCssFn({
    transform: utility.transform,
    conditions,
    normalize: normalizeFn
  });
  const cva = createRecipeFn({
    css: css2,
    conditions,
    normalize: normalizeFn,
    layers
  });
  const sva = createSlotRecipeFn({ cva });
  function getTokenCss() {
    const result = {};
    for (const [key, values] of tokens.cssVarMap.entries()) {
      const varsObj = Object.fromEntries(values);
      if (Object.keys(varsObj).length === 0) continue;
      const selector = key === "base" ? cssVarsRoot : conditions.resolve(key);
      const cssObject = css2(serialize2({ [selector]: varsObj }));
      mergeWith(result, cssObject);
    }
    return layers.wrap("tokens", result);
  }
  function getGlobalCss() {
    const keyframes2 = Object.fromEntries(
      Object.entries(theme.keyframes ?? {}).map(([key, value]) => [
        `@keyframes ${key}`,
        value
      ])
    );
    const result = Object.assign({}, keyframes2, css2(serialize2(globalCss2)));
    return layers.wrap("base", result);
  }
  function splitCssProps(props) {
    return splitProps(props, isValidProperty);
  }
  function getPreflightCss() {
    const result = createPreflight({ preflight });
    return layers.wrap("reset", result);
  }
  const tokenMap = getTokenMap(tokens);
  const tokenFn = (path2, fallback2) => {
    return tokenMap.get(path2)?.value || fallback2;
  };
  tokenFn.var = (path2, fallback2) => {
    return tokenMap.get(path2)?.variable || fallback2;
  };
  function getRecipe(key, fallback2) {
    return theme.recipes?.[key] ?? fallback2;
  }
  function getSlotRecipe(key, fallback2) {
    return theme.slotRecipes?.[key] ?? fallback2;
  }
  function isRecipe(key) {
    return Object.hasOwnProperty.call(theme.recipes ?? {}, key);
  }
  function isSlotRecipe(key) {
    return Object.hasOwnProperty.call(theme.slotRecipes ?? {}, key);
  }
  function hasRecipe(key) {
    return isRecipe(key) || isSlotRecipe(key);
  }
  const _global = [getPreflightCss(), getGlobalCss(), getTokenCss()];
  return {
    $$chakra: true,
    _config: config2,
    _global,
    breakpoints: breakpoints2,
    tokens,
    conditions,
    utility,
    token: tokenFn,
    properties: properties2,
    layers,
    isValidProperty,
    splitCssProps,
    normalizeValue,
    getTokenCss,
    getGlobalCss,
    getPreflightCss,
    css: css2,
    cva,
    sva,
    getRecipe,
    getSlotRecipe,
    hasRecipe,
    isRecipe,
    isSlotRecipe
  };
}
function getTokenMap(tokens) {
  const map = /* @__PURE__ */ new Map();
  tokens.allTokens.forEach((token2) => {
    const { cssVar: cssVar2, virtual, conditions } = token2.extensions;
    const value = !!conditions || virtual ? cssVar2.ref : token2.value;
    map.set(token2.name, { value, variable: cssVar2.ref });
  });
  return map;
}
const breakpoints = {
  sm: "480px",
  md: "768px",
  lg: "1024px",
  xl: "1280px",
  "2xl": "1536px"
};
const empty = "var(--chakra-empty,/*!*/ /*!*/)";
const globalCss = defineGlobalStyles({
  "*": {
    fontFeatureSettings: '"cv11"',
    "--ring-inset": empty,
    "--ring-offset-width": "0px",
    "--ring-offset-color": "#fff",
    "--ring-color": "rgba(66, 153, 225, 0.6)",
    "--ring-offset-shadow": "0 0 #0000",
    "--ring-shadow": "0 0 #0000",
    ...Object.fromEntries(
      [
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "saturate",
        "sepia",
        "drop-shadow"
      ].map((prop) => [`--${prop}`, empty])
    ),
    ...Object.fromEntries(
      [
        "blur",
        "brightness",
        "contrast",
        "grayscale",
        "hue-rotate",
        "invert",
        "opacity",
        "saturate",
        "sepia"
      ].map((prop) => [`--backdrop-${prop}`, empty])
    ),
    "--global-font-mono": "fonts.mono",
    "--global-font-body": "fonts.body",
    "--global-color-border": "colors.border"
  },
  html: {
    color: "fg",
    bg: "bg",
    lineHeight: "1.5",
    colorPalette: "gray"
  },
  "*::placeholder, *[data-placeholder]": {
    color: "fg.muted/80"
  },
  "*::selection": {
    bg: "colorPalette.emphasized/80"
  }
});
const layerStyles = defineLayerStyles({
  // fill: some background color + color combination
  "fill.muted": {
    value: {
      background: "colorPalette.muted",
      color: "colorPalette.fg"
    }
  },
  "fill.subtle": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  },
  "fill.surface": {
    value: {
      background: "colorPalette.subtle",
      color: "colorPalette.fg",
      boxShadow: "0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.muted"
    }
  },
  "fill.solid": {
    value: {
      background: "colorPalette.solid",
      color: "colorPalette.contrast"
    }
  },
  // outline: some border color + color combination
  "outline.subtle": {
    value: {
      color: "colorPalette.fg",
      boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
      boxShadowColor: "colorPalette.subtle"
    }
  },
  "outline.solid": {
    value: {
      borderWidth: "1px",
      borderColor: "colorPalette.solid",
      color: "colorPalette.fg"
    }
  },
  // indicator: floating border color or left/bottom border
  "indicator.bottom": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        bottom: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.top": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        top: "var(--indicator-offset-y, 0)",
        insetInline: "var(--indicator-offset-x, 0)",
        height: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.start": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineStart: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  "indicator.end": {
    value: {
      position: "relative",
      "--indicator-color-fallback": "colors.colorPalette.solid",
      _before: {
        content: `""`,
        position: "absolute",
        insetInlineEnd: "var(--indicator-offset-x, 0)",
        insetBlock: "var(--indicator-offset-y, 0)",
        width: "var(--indicator-thickness, 2px)",
        background: "var(--indicator-color, var(--indicator-color-fallback))"
      }
    }
  },
  disabled: {
    value: {
      opacity: "0.5",
      cursor: "not-allowed"
    }
  },
  none: {
    value: {}
  }
});
const animationStyles = defineAnimationStyles({
  "slide-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-from-bottom, fade-in"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-from-top, fade-in"
      },
      "&[data-placement^=left]": {
        animationName: "slide-from-right, fade-in"
      },
      "&[data-placement^=right]": {
        animationName: "slide-from-left, fade-in"
      }
    }
  },
  "slide-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      "&[data-placement^=top]": {
        animationName: "slide-to-bottom, fade-out"
      },
      "&[data-placement^=bottom]": {
        animationName: "slide-to-top, fade-out"
      },
      "&[data-placement^=left]": {
        animationName: "slide-to-right, fade-out"
      },
      "&[data-placement^=right]": {
        animationName: "slide-to-left, fade-out"
      }
    }
  },
  "scale-fade-in": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-in, fade-in"
    }
  },
  "scale-fade-out": {
    value: {
      transformOrigin: "var(--transform-origin)",
      animationName: "scale-out, fade-out"
    }
  }
});
const badgeRecipe = defineRecipe({
  className: "chakra-badge",
  base: {
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "l2",
    gap: "1",
    fontWeight: "medium",
    fontVariantNumeric: "tabular-nums",
    whiteSpace: "nowrap",
    userSelect: "none"
  },
  variants: {
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg"
      },
      outline: {
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "inset 0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      xs: {
        textStyle: "2xs",
        px: "1",
        minH: "4"
      },
      sm: {
        textStyle: "xs",
        px: "1.5",
        minH: "5"
      },
      md: {
        textStyle: "sm",
        px: "2",
        minH: "6"
      },
      lg: {
        textStyle: "sm",
        px: "2.5",
        minH: "7"
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    size: "sm"
  }
});
const buttonRecipe = defineRecipe({
  className: "chakra-button",
  base: {
    display: "inline-flex",
    appearance: "none",
    alignItems: "center",
    justifyContent: "center",
    userSelect: "none",
    position: "relative",
    borderRadius: "l2",
    whiteSpace: "nowrap",
    verticalAlign: "middle",
    borderWidth: "1px",
    borderColor: "transparent",
    cursor: "button",
    flexShrink: "0",
    outline: "0",
    lineHeight: "1.2",
    isolation: "isolate",
    fontWeight: "medium",
    transitionProperty: "common",
    transitionDuration: "moderate",
    focusVisibleRing: "outside",
    _disabled: {
      layerStyle: "disabled"
    },
    _icon: {
      flexShrink: "0"
    }
  },
  variants: {
    size: {
      "2xs": {
        h: "6",
        minW: "6",
        textStyle: "xs",
        px: "2",
        gap: "1",
        _icon: {
          width: "3.5",
          height: "3.5"
        }
      },
      xs: {
        h: "8",
        minW: "8",
        textStyle: "xs",
        px: "2.5",
        gap: "1",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      sm: {
        h: "9",
        minW: "9",
        px: "3.5",
        textStyle: "sm",
        gap: "2",
        _icon: {
          width: "4",
          height: "4"
        }
      },
      md: {
        h: "10",
        minW: "10",
        textStyle: "sm",
        px: "4",
        gap: "2",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      lg: {
        h: "11",
        minW: "11",
        textStyle: "md",
        px: "5",
        gap: "3",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      xl: {
        h: "12",
        minW: "12",
        textStyle: "md",
        px: "5",
        gap: "2.5",
        _icon: {
          width: "5",
          height: "5"
        }
      },
      "2xl": {
        h: "16",
        minW: "16",
        textStyle: "lg",
        px: "7",
        gap: "3",
        _icon: {
          width: "6",
          height: "6"
        }
      }
    },
    variant: {
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast",
        borderColor: "transparent",
        _hover: {
          bg: "colorPalette.solid/90"
        },
        _expanded: {
          bg: "colorPalette.solid/90"
        }
      },
      subtle: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderColor: "transparent",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      surface: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        shadow: "0 0 0px 1px var(--shadow-color)",
        shadowColor: "colorPalette.muted",
        _hover: {
          bg: "colorPalette.muted"
        },
        _expanded: {
          bg: "colorPalette.muted"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "colorPalette.muted",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      ghost: {
        bg: "transparent",
        color: "colorPalette.fg",
        _hover: {
          bg: "colorPalette.subtle"
        },
        _expanded: {
          bg: "colorPalette.subtle"
        }
      },
      plain: {
        color: "colorPalette.fg"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const checkmarkRecipe = defineRecipe({
  className: "chakra-checkmark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "l1",
    focusVisibleRing: "outside",
    _icon: {
      boxSize: "full"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "border.error"
    },
    _disabled: {
      opacity: "0.5"
    }
  },
  variants: {
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5",
        p: "0.5"
      },
      lg: {
        boxSize: "6",
        p: "0.5"
      }
    },
    variant: {
      solid: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      outline: {
        borderColor: "border",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      plain: {
        "&:is([data-state=checked], [data-state=indeterminate])": {
          color: "colorPalette.fg"
        }
      },
      inverted: {
        borderColor: "border",
        color: "colorPalette.fg",
        "&:is([data-state=checked], [data-state=indeterminate])": {
          borderColor: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const { variants: variants$1, defaultVariants: defaultVariants$1 } = badgeRecipe;
const codeRecipe = defineRecipe({
  className: "chakra-code",
  base: {
    fontFamily: "mono",
    alignItems: "center",
    display: "inline-flex",
    borderRadius: "l2"
  },
  variants: variants$1,
  defaultVariants: defaultVariants$1
});
const colorSwatchRecipe = defineRecipe({
  className: "color-swatch",
  base: {
    boxSize: "var(--swatch-size)",
    shadow: "inset 0 0 0 1px rgba(0, 0, 0, 0.1)",
    "--checker-size": "8px",
    "--checker-bg": "colors.bg",
    "--checker-fg": "colors.bg.emphasized",
    background: "linear-gradient(var(--color), var(--color)), repeating-conic-gradient(var(--checker-fg) 0%, var(--checker-fg) 25%, var(--checker-bg) 0%, var(--checker-bg) 50%) 0% 50% / var(--checker-size) var(--checker-size) !important",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: "0"
  },
  variants: {
    size: {
      "2xs": { "--swatch-size": "sizes.3.5" },
      xs: { "--swatch-size": "sizes.4" },
      sm: { "--swatch-size": "sizes.4.5" },
      md: { "--swatch-size": "sizes.5" },
      lg: { "--swatch-size": "sizes.6" },
      xl: { "--swatch-size": "sizes.7" },
      "2xl": { "--swatch-size": "sizes.8" },
      inherit: { "--swatch-size": "inherit" },
      full: { "--swatch-size": "100%" }
    },
    shape: {
      square: { borderRadius: "none" },
      circle: { borderRadius: "full" },
      rounded: { borderRadius: "l1" }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "rounded"
  }
});
const containerRecipe = defineRecipe({
  className: "chakra-container",
  base: {
    position: "relative",
    maxWidth: "8xl",
    w: "100%",
    mx: "auto",
    px: { base: "4", md: "6", lg: "8" }
  },
  variants: {
    centerContent: {
      true: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      }
    },
    fluid: {
      true: {
        maxWidth: "full"
      }
    }
  }
});
const headingRecipe = defineRecipe({
  className: "chakra-heading",
  base: {
    fontFamily: "heading",
    fontWeight: "semibold"
  },
  variants: {
    size: {
      xs: { textStyle: "xs" },
      sm: { textStyle: "sm" },
      md: { textStyle: "md" },
      lg: { textStyle: "lg" },
      xl: { textStyle: "xl" },
      "2xl": { textStyle: "2xl" },
      "3xl": { textStyle: "3xl" },
      "4xl": { textStyle: "4xl" },
      "5xl": { textStyle: "5xl" },
      "6xl": { textStyle: "6xl" },
      "7xl": { textStyle: "7xl" }
    }
  },
  defaultVariants: {
    size: "xl"
  }
});
const iconRecipe = defineRecipe({
  className: "chakra-icon",
  base: {
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: "0",
    color: "currentcolor",
    verticalAlign: "middle"
  },
  variants: {
    size: {
      inherit: {},
      xs: { boxSize: "3" },
      sm: { boxSize: "4" },
      md: { boxSize: "5" },
      lg: { boxSize: "6" },
      xl: { boxSize: "7" },
      "2xl": { boxSize: "8" }
    }
  },
  defaultVariants: {
    size: "inherit"
  }
});
const inputRecipe = defineRecipe({
  className: "chakra-input",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    height: "var(--input-height)",
    minW: "var(--input-height)",
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      "2xs": {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.7"
      },
      xs: {
        textStyle: "xs",
        px: "2",
        "--input-height": "sizes.8"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        "--input-height": "sizes.9"
      },
      md: {
        textStyle: "sm",
        px: "3",
        "--input-height": "sizes.10"
      },
      lg: {
        textStyle: "md",
        px: "4",
        "--input-height": "sizes.11"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        "--input-height": "sizes.12"
      },
      "2xl": {
        textStyle: "lg",
        px: "5",
        "--input-height": "sizes.16"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside",
        focusRingColor: "var(--focus-color)"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside",
        focusRingColor: "var(--focus-color)"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const inputAddonRecipe = defineRecipe({
  className: "chakra-input-addon",
  base: {
    flex: "0 0 auto",
    width: "auto",
    display: "flex",
    alignItems: "center",
    whiteSpace: "nowrap",
    alignSelf: "stretch",
    borderRadius: "l2"
  },
  variants: {
    size: inputRecipe.variants.size,
    variant: {
      outline: {
        borderWidth: "1px",
        borderColor: "border",
        bg: "bg.muted"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.emphasized"
      },
      flushed: {
        borderBottom: "1px solid",
        borderColor: "inherit",
        borderRadius: "0",
        px: "0",
        bg: "transparent"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const kbdRecipe = defineRecipe({
  className: "chakra-kbd",
  base: {
    display: "inline-flex",
    alignItems: "center",
    fontWeight: "medium",
    fontFamily: "mono",
    flexShrink: "0",
    whiteSpace: "nowrap",
    wordSpacing: "-0.5em",
    userSelect: "none",
    px: "1",
    borderRadius: "l2"
  },
  variants: {
    variant: {
      raised: {
        bg: "colorPalette.subtle",
        color: "colorPalette.fg",
        borderWidth: "1px",
        borderBottomWidth: "2px",
        borderColor: "colorPalette.muted"
      },
      outline: {
        borderWidth: "1px",
        color: "colorPalette.fg"
      },
      subtle: {
        bg: "colorPalette.muted",
        color: "colorPalette.fg"
      },
      plain: {
        color: "colorPalette.fg"
      }
    },
    size: {
      sm: {
        textStyle: "xs",
        height: "4.5"
      },
      md: {
        textStyle: "sm",
        height: "5"
      },
      lg: {
        textStyle: "md",
        height: "6"
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "raised"
  }
});
const linkRecipe = defineRecipe({
  className: "chakra-link",
  base: {
    display: "inline-flex",
    alignItems: "center",
    outline: "none",
    gap: "1.5",
    cursor: "pointer",
    borderRadius: "l1",
    focusRing: "outside"
  },
  variants: {
    variant: {
      underline: {
        color: "colorPalette.fg",
        textDecoration: "underline",
        textUnderlineOffset: "3px",
        textDecorationColor: "currentColor/20"
      },
      plain: {
        color: "colorPalette.fg",
        _hover: {
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain"
  }
});
const markRecipe = defineRecipe({
  className: "chakra-mark",
  base: {
    bg: "transparent",
    color: "inherit",
    whiteSpace: "nowrap"
  },
  variants: {
    variant: {
      subtle: {
        bg: "colorPalette.subtle",
        color: "inherit"
      },
      solid: {
        bg: "colorPalette.solid",
        color: "colorPalette.contrast"
      },
      text: {
        fontWeight: "medium"
      },
      plain: {}
    }
  }
});
const radiomarkRecipe = defineRecipe({
  className: "chakra-radiomark",
  base: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    verticalAlign: "top",
    color: "white",
    borderWidth: "1px",
    borderColor: "transparent",
    borderRadius: "full",
    cursor: "radio",
    _focusVisible: {
      outline: "2px solid",
      outlineColor: "colorPalette.focusRing",
      outlineOffset: "2px"
    },
    _invalid: {
      colorPalette: "red",
      borderColor: "red.500"
    },
    _disabled: {
      opacity: "0.5",
      cursor: "disabled"
    },
    "& .dot": {
      height: "100%",
      width: "100%",
      borderRadius: "full",
      bg: "currentColor",
      scale: "0.4"
    }
  },
  variants: {
    variant: {
      solid: {
        borderWidth: "1px",
        borderColor: "border",
        _checked: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "colorPalette.solid"
        }
      },
      subtle: {
        borderWidth: "1px",
        bg: "colorPalette.muted",
        borderColor: "colorPalette.muted",
        color: "transparent",
        _checked: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.fg",
          borderColor: "colorPalette.solid"
        },
        "& .dot": {
          scale: "0.6"
        }
      },
      inverted: {
        bg: "bg",
        borderWidth: "1px",
        borderColor: "inherit",
        _checked: {
          color: "colorPalette.solid",
          borderColor: "currentcolor"
        }
      }
    },
    size: {
      xs: {
        boxSize: "3"
      },
      sm: {
        boxSize: "4"
      },
      md: {
        boxSize: "5"
      },
      lg: {
        boxSize: "6"
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const separatorRecipe = defineRecipe({
  className: "chakra-separator",
  base: {
    display: "block",
    borderColor: "border"
  },
  variants: {
    variant: {
      solid: {
        borderStyle: "solid"
      },
      dashed: {
        borderStyle: "dashed"
      },
      dotted: {
        borderStyle: "dotted"
      }
    },
    orientation: {
      vertical: {
        borderInlineStartWidth: "var(--separator-thickness)"
      },
      horizontal: {
        borderTopWidth: "var(--separator-thickness)"
      }
    },
    size: {
      xs: {
        "--separator-thickness": "0.5px"
      },
      sm: {
        "--separator-thickness": "1px"
      },
      md: {
        "--separator-thickness": "2px"
      },
      lg: {
        "--separator-thickness": "3px"
      }
    }
  },
  defaultVariants: {
    size: "sm",
    variant: "solid",
    orientation: "horizontal"
  }
});
const skeletonRecipe = defineRecipe({
  className: "chakra-skeleton",
  base: {},
  variants: {
    loading: {
      true: {
        borderRadius: "l2",
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        flexShrink: "0",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      },
      false: {
        background: "unset",
        animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
      }
    },
    variant: {
      pulse: {
        background: "bg.emphasized",
        animation: "pulse",
        animationDuration: "var(--duration, 1.2s)"
      },
      shine: {
        "--animate-from": "200%",
        "--animate-to": "-200%",
        "--start-color": "colors.bg.muted",
        "--end-color": "colors.bg.emphasized",
        backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
        backgroundSize: "400% 100%",
        animation: "bg-position var(--duration, 5s) ease-in-out infinite"
      },
      none: {
        animation: "none"
      }
    }
  },
  defaultVariants: {
    variant: "pulse",
    loading: true
  }
});
const skipNavLinkRecipe = defineRecipe({
  className: "chakra-skip-nav",
  base: {
    display: "inline-flex",
    bg: "bg.panel",
    padding: "2.5",
    borderRadius: "l2",
    fontWeight: "semibold",
    focusVisibleRing: "outside",
    textStyle: "sm",
    // visually hidden
    userSelect: "none",
    border: "0",
    height: "1px",
    width: "1px",
    margin: "-1px",
    outline: "0",
    overflow: "hidden",
    position: "absolute",
    clip: "rect(0 0 0 0)",
    _focusVisible: {
      clip: "auto",
      width: "auto",
      height: "auto",
      position: "fixed",
      top: "6",
      insetStart: "6"
    }
  }
});
const spinnerRecipe = defineRecipe({
  className: "chakra-spinner",
  base: {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderWidth: "2px",
    borderRadius: "full",
    width: "var(--spinner-size)",
    height: "var(--spinner-size)",
    animation: "spin",
    animationDuration: "slowest",
    "--spinner-track-color": "transparent",
    borderBottomColor: "var(--spinner-track-color)",
    borderInlineStartColor: "var(--spinner-track-color)"
  },
  variants: {
    size: {
      inherit: { "--spinner-size": "1em" },
      xs: { "--spinner-size": "sizes.3" },
      sm: { "--spinner-size": "sizes.4" },
      md: { "--spinner-size": "sizes.5" },
      lg: { "--spinner-size": "sizes.8" },
      xl: { "--spinner-size": "sizes.10" }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const textareaRecipe = defineRecipe({
  className: "chakra-textarea",
  base: {
    width: "100%",
    minWidth: "0",
    outline: "0",
    position: "relative",
    appearance: "none",
    textAlign: "start",
    borderRadius: "l2",
    _disabled: {
      layerStyle: "disabled"
    },
    "--focus-color": "colors.colorPalette.focusRing",
    "--error-color": "colors.border.error",
    _invalid: {
      focusRingColor: "var(--error-color)",
      borderColor: "var(--error-color)"
    }
  },
  variants: {
    size: {
      xs: {
        textStyle: "xs",
        px: "2",
        py: "1.5",
        scrollPaddingBottom: "1.5"
      },
      sm: {
        textStyle: "sm",
        px: "2.5",
        py: "2",
        scrollPaddingBottom: "2"
      },
      md: {
        textStyle: "sm",
        px: "3",
        py: "2",
        scrollPaddingBottom: "2"
      },
      lg: {
        textStyle: "md",
        px: "4",
        py: "3",
        scrollPaddingBottom: "3"
      },
      xl: {
        textStyle: "md",
        px: "4.5",
        py: "3.5",
        scrollPaddingBottom: "3.5"
      }
    },
    variant: {
      outline: {
        bg: "transparent",
        borderWidth: "1px",
        borderColor: "border",
        focusVisibleRing: "inside"
      },
      subtle: {
        borderWidth: "1px",
        borderColor: "transparent",
        bg: "bg.muted",
        focusVisibleRing: "inside"
      },
      flushed: {
        bg: "transparent",
        borderBottomWidth: "1px",
        borderBottomColor: "border",
        borderRadius: "0",
        px: "0",
        _focusVisible: {
          borderColor: "var(--focus-color)",
          boxShadow: "0px 1px 0px 0px var(--focus-color)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const recipes = {
  badge: badgeRecipe,
  button: buttonRecipe,
  code: codeRecipe,
  container: containerRecipe,
  heading: headingRecipe,
  input: inputRecipe,
  inputAddon: inputAddonRecipe,
  kbd: kbdRecipe,
  link: linkRecipe,
  mark: markRecipe,
  separator: separatorRecipe,
  skeleton: skeletonRecipe,
  skipNavLink: skipNavLinkRecipe,
  spinner: spinnerRecipe,
  textarea: textareaRecipe,
  icon: iconRecipe,
  checkmark: checkmarkRecipe,
  radiomark: radiomarkRecipe,
  colorSwatch: colorSwatchRecipe
};
const semanticColors = defineSemanticTokens.colors({
  bg: {
    DEFAULT: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    inverted: {
      value: { _light: "{colors.black}", _dark: "{colors.white}" }
    },
    panel: {
      value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
    },
    error: {
      value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
    },
    warning: {
      value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
    },
    success: {
      value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
    },
    info: {
      value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
    }
  },
  fg: {
    DEFAULT: {
      value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
    },
    muted: {
      value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
    },
    subtle: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
    },
    inverted: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
    },
    success: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
    },
    info: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
    }
  },
  border: {
    DEFAULT: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    muted: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    subtle: {
      value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    inverted: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    error: {
      value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
    },
    warning: {
      value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
    },
    success: {
      value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
    },
    info: {
      value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
    }
  },
  gray: {
    contrast: {
      value: { _light: "{colors.white}", _dark: "{colors.black}" }
    },
    fg: {
      value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
    },
    subtle: {
      value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
    },
    muted: {
      value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
    },
    emphasized: {
      value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
    },
    solid: {
      value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
    },
    focusRing: {
      value: { _light: "{colors.gray.400}", _dark: "{colors.gray.400}" }
    }
  },
  red: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
    },
    subtle: {
      value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
    },
    muted: {
      value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
    },
    emphasized: {
      value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
    },
    solid: {
      value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
    },
    focusRing: {
      value: { _light: "{colors.red.400}", _dark: "{colors.red.400}" }
    }
  },
  orange: {
    contrast: {
      value: { _light: "white", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
    },
    subtle: {
      value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
    },
    muted: {
      value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
    },
    emphasized: {
      value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
    },
    solid: {
      value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
    },
    focusRing: {
      value: { _light: "{colors.orange.400}", _dark: "{colors.orange.400}" }
    }
  },
  green: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
    },
    subtle: {
      value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
    },
    muted: {
      value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
    },
    emphasized: {
      value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
    },
    solid: {
      value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
    },
    focusRing: {
      value: { _light: "{colors.green.400}", _dark: "{colors.green.400}" }
    }
  },
  blue: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
    },
    subtle: {
      value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
    },
    muted: {
      value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
    },
    emphasized: {
      value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
    },
    solid: {
      value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
    },
    focusRing: {
      value: { _light: "{colors.blue.400}", _dark: "{colors.blue.400}" }
    }
  },
  yellow: {
    contrast: {
      value: { _light: "black", _dark: "black" }
    },
    fg: {
      value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
    },
    subtle: {
      value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
    },
    muted: {
      value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
    },
    emphasized: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
    },
    solid: {
      value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
    },
    focusRing: {
      value: { _light: "{colors.yellow.400}", _dark: "{colors.yellow.400}" }
    }
  },
  teal: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
    },
    subtle: {
      value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
    },
    muted: {
      value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
    },
    emphasized: {
      value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
    },
    solid: {
      value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
    },
    focusRing: {
      value: { _light: "{colors.teal.400}", _dark: "{colors.teal.400}" }
    }
  },
  purple: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
    },
    subtle: {
      value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
    },
    muted: {
      value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
    },
    emphasized: {
      value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
    },
    solid: {
      value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
    },
    focusRing: {
      value: { _light: "{colors.purple.400}", _dark: "{colors.purple.400}" }
    }
  },
  pink: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
    },
    subtle: {
      value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
    },
    muted: {
      value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
    },
    emphasized: {
      value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
    },
    solid: {
      value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
    },
    focusRing: {
      value: { _light: "{colors.pink.400}", _dark: "{colors.pink.400}" }
    }
  },
  cyan: {
    contrast: {
      value: { _light: "white", _dark: "white" }
    },
    fg: {
      value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
    },
    subtle: {
      value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
    },
    muted: {
      value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
    },
    emphasized: {
      value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
    },
    solid: {
      value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
    },
    focusRing: {
      value: { _light: "{colors.cyan.400}", _dark: "{colors.cyan.400}" }
    }
  }
});
const semanticRadii = defineSemanticTokens.radii({
  l1: { value: "{radii.xs}" },
  l2: { value: "{radii.sm}" },
  l3: { value: "{radii.md}" }
});
const semanticShadows = defineSemanticTokens.shadows({
  xs: {
    value: {
      _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
      _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
    }
  },
  sm: {
    value: {
      _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  md: {
    value: {
      _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  lg: {
    value: {
      _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  xl: {
    value: {
      _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  "2xl": {
    value: {
      _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
      _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
    }
  },
  inner: {
    value: {
      _light: "inset 0 2px 4px 0 {black/5}",
      _dark: "inset 0 2px 4px 0 black"
    }
  },
  inset: {
    value: {
      _light: "inset 0 0 0 1px {black/5}",
      _dark: "inset 0 0 0 1px {colors.gray.300/5}"
    }
  }
});
const accordionAnatomy = anatomy$l.extendWith("itemBody");
const actionBarAnatomy = createAnatomy("action-bar").parts(
  "positioner",
  "content",
  "separator",
  "selectionTrigger",
  "closeTrigger"
);
const alertAnatomy = createAnatomy("alert").parts(
  "title",
  "description",
  "root",
  "indicator",
  "content"
);
const breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
  "link",
  "currentLink",
  "item",
  "list",
  "root",
  "ellipsis",
  "separator"
);
const blockquoteAnatomy = createAnatomy("blockquote").parts(
  "root",
  "icon",
  "content",
  "caption"
);
const cardAnatomy = createAnatomy("card").parts(
  "root",
  "header",
  "body",
  "footer",
  "title",
  "description"
);
const checkboxCardAnatomy = createAnatomy("checkbox-card", [
  "root",
  "control",
  "label",
  "description",
  "addon",
  "indicator",
  "content"
]);
const dataListAnatomy = createAnatomy("data-list").parts(
  "root",
  "item",
  "itemLabel",
  "itemValue"
);
const dialogAnatomy = anatomy$h.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
const drawerAnatomy = anatomy$h.extendWith(
  "header",
  "body",
  "footer",
  "backdrop"
);
const editableAnatomy = anatomy$g.extendWith("textarea");
const emptyStateAnatomy = createAnatomy("empty-state", [
  "root",
  "content",
  "indicator",
  "title",
  "description"
]);
const fieldAnatomy = fieldAnatomy$1.extendWith("requiredIndicator");
const fieldsetAnatomy = fieldsetAnatomy$1.extendWith("content");
const fileUploadAnatomy = anatomy$f.extendWith(
  "itemContent",
  "dropzoneContent",
  "fileText"
);
const listAnatomy = createAnatomy("list").parts(
  "root",
  "item",
  "indicator"
);
const menuAnatomy = anatomy$d.extendWith("itemCommand");
const nativeSelectAnatomy = createAnatomy("select").parts(
  "root",
  "field",
  "indicator"
);
const popoverAnatomy = anatomy$a.extendWith(
  "header",
  "body",
  "footer"
);
const radioGroupAnatomy = anatomy$7.extendWith(
  "itemAddon",
  "itemIndicator"
);
const radioCardAnatomy = radioGroupAnatomy.extendWith(
  "itemContent",
  "itemDescription"
);
const ratingGroupAnatomy = anatomy$6.extendWith("itemIndicator");
const selectAnatomy = anatomy$5.extendWith("indicatorGroup");
const sliderAnatomy = anatomy$4.extendWith("markerIndicator");
const statAnatomy = createAnatomy("stat").parts(
  "root",
  "label",
  "helpText",
  "valueText",
  "valueUnit",
  "indicator"
);
const statusAnatomy = createAnatomy("status").parts("root", "indicator");
const stepsAnatomy = createAnatomy("steps", [
  "root",
  "list",
  "item",
  "trigger",
  "indicator",
  "separator",
  "content",
  "title",
  "description",
  "nextTrigger",
  "prevTrigger",
  "progress"
]);
const switchAnatomy = anatomy$3.extendWith("indicator");
const tableAnatomy = createAnatomy("table").parts(
  "root",
  "header",
  "body",
  "row",
  "columnHeader",
  "cell",
  "footer",
  "caption"
);
const toastAnatomy = createAnatomy("toast").parts(
  "root",
  "title",
  "description",
  "indicator",
  "closeTrigger",
  "actionTrigger"
);
const tabsAnatomy = createAnatomy("tabs").parts(
  "root",
  "trigger",
  "list",
  "content",
  "contentGroup",
  "indicator"
);
const tagAnatomy = createAnatomy("tag").parts(
  "root",
  "label",
  "closeTrigger",
  "startElement",
  "endElement"
);
const timelineAnatomy = createAnatomy("timeline").parts(
  "root",
  "item",
  "content",
  "separator",
  "indicator",
  "connector",
  "title",
  "description"
);
const colorPickerAnatomy = colorPickerAnatomy$1.extendWith("channelText");
const accordionSlotRecipe = defineSlotRecipe({
  className: "chakra-accordion",
  slots: accordionAnatomy.keys(),
  base: {
    root: {
      width: "full",
      "--accordion-radius": "radii.l2"
    },
    item: {
      overflowAnchor: "none"
    },
    itemTrigger: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      width: "full",
      outline: "0",
      gap: "3",
      fontWeight: "medium",
      borderRadius: "var(--accordion-radius)",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        layerStyle: "disabled"
      }
    },
    itemBody: {
      pt: "var(--accordion-padding-y)",
      pb: "calc(var(--accordion-padding-y) * 2)"
    },
    itemContent: {
      overflow: "hidden",
      borderRadius: "var(--accordion-radius)",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    },
    itemIndicator: {
      transition: "rotate 0.2s",
      transformOrigin: "center",
      color: "fg.subtle",
      _open: {
        rotate: "180deg"
      },
      _icon: {
        width: "1.2em",
        height: "1.2em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        item: {
          borderBottomWidth: "1px"
        }
      },
      subtle: {
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          borderRadius: "var(--accordion-radius)",
          _open: {
            bg: "colorPalette.subtle"
          }
        }
      },
      enclosed: {
        root: {
          borderWidth: "1px",
          borderRadius: "var(--accordion-radius)",
          divideY: "1px",
          overflow: "hidden"
        },
        itemTrigger: {
          px: "var(--accordion-padding-x)"
        },
        itemContent: {
          px: "var(--accordion-padding-x)"
        },
        item: {
          _open: {
            bg: "bg.subtle"
          }
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--accordion-padding-x": "spacing.3",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "sm",
          py: "var(--accordion-padding-y)"
        }
      },
      md: {
        root: {
          "--accordion-padding-x": "spacing.4",
          "--accordion-padding-y": "spacing.2"
        },
        itemTrigger: {
          textStyle: "md",
          py: "var(--accordion-padding-y)"
        }
      },
      lg: {
        root: {
          "--accordion-padding-x": "spacing.4.5",
          "--accordion-padding-y": "spacing.2.5"
        },
        itemTrigger: {
          textStyle: "lg",
          py: "var(--accordion-padding-y)"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const actionBarSlotRecipe = defineSlotRecipe({
  className: "chakra-action-bar",
  slots: actionBarAnatomy.keys(),
  base: {
    positioner: {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      pointerEvents: "none",
      insetInline: "0",
      top: "unset",
      bottom: "calc(env(safe-area-inset-bottom) + 20px)"
    },
    content: {
      bg: "bg.panel",
      shadow: "md",
      display: "flex",
      alignItems: "center",
      gap: "3",
      borderRadius: "l3",
      py: "2.5",
      px: "3",
      pointerEvents: "auto",
      // Stabilize the position of the action bar when the scrollbar is hidden
      // by using the scrollbar width to offset the position.
      translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
      _open: {
        animationName: "slide-from-bottom, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "slide-to-bottom, fade-out",
        animationDuration: "faster"
      }
    },
    separator: {
      width: "1px",
      height: "5",
      bg: "border"
    },
    selectionTrigger: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2",
      alignSelf: "stretch",
      textStyle: "sm",
      px: "4",
      py: "1",
      borderRadius: "l2",
      borderWidth: "1px",
      borderStyle: "dashed"
    }
  }
});
const alertSlotRecipe = defineSlotRecipe({
  slots: alertAnatomy.keys(),
  className: "chakra-alert",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      borderRadius: "l3"
    },
    title: {
      fontWeight: "medium"
    },
    description: {
      display: "inline"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      width: "1em",
      height: "1em",
      _icon: { boxSize: "full" }
    },
    content: {
      display: "flex",
      flex: "1",
      gap: "1"
    }
  },
  variants: {
    status: {
      info: {
        root: { colorPalette: "blue" }
      },
      warning: {
        root: { colorPalette: "orange" }
      },
      success: {
        root: { colorPalette: "green" }
      },
      error: {
        root: { colorPalette: "red" }
      },
      neutral: {
        root: { colorPalette: "gray" }
      }
    },
    inline: {
      true: {
        content: {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center"
        }
      },
      false: {
        content: {
          display: "flex",
          flexDirection: "column"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        }
      },
      surface: {
        root: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        indicator: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        indicator: {
          color: "colorPalette.contrast"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "2",
          px: "3",
          py: "3",
          textStyle: "xs"
        },
        indicator: {
          textStyle: "lg"
        }
      },
      md: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "sm"
        },
        indicator: {
          textStyle: "xl"
        }
      },
      lg: {
        root: {
          gap: "3",
          px: "4",
          py: "4",
          textStyle: "md"
        },
        indicator: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    status: "info",
    variant: "subtle",
    size: "md",
    inline: false
  }
});
const avatarSlotRecipe = defineSlotRecipe({
  slots: anatomy$k.keys(),
  className: "chakra-avatar",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: "medium",
      position: "relative",
      verticalAlign: "top",
      flexShrink: "0",
      userSelect: "none",
      width: "var(--avatar-size)",
      height: "var(--avatar-size)",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)",
      "&[data-group-item]": {
        borderWidth: "2px",
        borderColor: "bg"
      }
    },
    image: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "var(--avatar-radius)"
    },
    fallback: {
      lineHeight: "1",
      textTransform: "uppercase",
      fontWeight: "medium",
      fontSize: "var(--avatar-font-size)",
      borderRadius: "var(--avatar-radius)"
    }
  },
  variants: {
    size: {
      full: {
        root: {
          "--avatar-size": "100%",
          "--avatar-font-size": "100%"
        }
      },
      "2xs": {
        root: {
          "--avatar-font-size": "fontSizes.2xs",
          "--avatar-size": "sizes.6"
        }
      },
      xs: {
        root: {
          "--avatar-font-size": "fontSizes.xs",
          "--avatar-size": "sizes.8"
        }
      },
      sm: {
        root: {
          "--avatar-font-size": "fontSizes.sm",
          "--avatar-size": "sizes.9"
        }
      },
      md: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.10"
        }
      },
      lg: {
        root: {
          "--avatar-font-size": "fontSizes.md",
          "--avatar-size": "sizes.11"
        }
      },
      xl: {
        root: {
          "--avatar-font-size": "fontSizes.lg",
          "--avatar-size": "sizes.12"
        }
      },
      "2xl": {
        root: {
          "--avatar-font-size": "fontSizes.xl",
          "--avatar-size": "sizes.16"
        }
      }
    },
    variant: {
      solid: {
        root: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      subtle: {
        root: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        }
      },
      outline: {
        root: {
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        root: { "--avatar-radius": "radii.l3" }
      },
      full: {
        root: { "--avatar-radius": "radii.full" }
      }
    },
    borderless: {
      true: {
        root: {
          "&[data-group-item]": {
            borderWidth: "0px"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    shape: "full",
    variant: "subtle"
  }
});
const blockquoteSlotRecipe = defineSlotRecipe({
  className: "chakra-blockquote",
  slots: blockquoteAnatomy.keys(),
  base: {
    root: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      gap: "2"
    },
    caption: {
      textStyle: "sm",
      color: "fg.muted"
    },
    icon: {
      boxSize: "5"
    }
  },
  variants: {
    justify: {
      start: {
        root: {
          alignItems: "flex-start",
          textAlign: "start"
        }
      },
      center: {
        root: {
          alignItems: "center",
          textAlign: "center"
        }
      },
      end: {
        root: {
          alignItems: "flex-end",
          textAlign: "end"
        }
      }
    },
    variant: {
      subtle: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.muted"
        },
        icon: {
          color: "colorPalette.fg"
        }
      },
      solid: {
        root: {
          paddingX: "5",
          borderStartWidth: "4px",
          borderStartColor: "colorPalette.solid"
        },
        icon: {
          color: "colorPalette.solid"
        }
      },
      plain: {
        root: {
          paddingX: "5"
        },
        icon: {
          color: "colorPalette.solid"
        }
      }
    }
  },
  defaultVariants: {
    variant: "subtle",
    justify: "start"
  }
});
const breadcrumbSlotRecipe = defineSlotRecipe({
  className: "chakra-breadcrumb",
  slots: breadcrumbAnatomy.keys(),
  base: {
    list: {
      display: "flex",
      alignItems: "center",
      wordBreak: "break-word",
      color: "fg.muted",
      listStyle: "none"
    },
    link: {
      outline: "0",
      textDecoration: "none",
      borderRadius: "l1",
      focusRing: "outside",
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    item: {
      display: "inline-flex",
      alignItems: "center"
    },
    separator: {
      color: "fg.muted",
      opacity: "0.8",
      _icon: {
        boxSize: "1em"
      },
      _rtl: {
        rotate: "180deg"
      }
    },
    ellipsis: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      _icon: {
        boxSize: "1em"
      }
    }
  },
  variants: {
    variant: {
      underline: {
        link: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "0.2em",
          textDecorationColor: "colorPalette.muted"
        },
        currentLink: {
          color: "colorPalette.fg"
        }
      },
      plain: {
        link: {
          color: "fg.muted",
          _hover: { color: "fg" }
        },
        currentLink: {
          color: "fg"
        }
      }
    },
    size: {
      sm: {
        list: {
          gap: "1",
          textStyle: "xs"
        }
      },
      md: {
        list: {
          gap: "1.5",
          textStyle: "sm"
        }
      },
      lg: {
        list: {
          gap: "2",
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "plain",
    size: "md"
  }
});
const cardSlotRecipe = defineSlotRecipe({
  className: "chakra-card",
  slots: cardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      minWidth: "0",
      wordWrap: "break-word",
      borderRadius: "l3",
      color: "fg",
      textAlign: "start"
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted",
      fontSize: "sm"
    },
    header: {
      paddingInline: "var(--card-padding)",
      paddingTop: "var(--card-padding)",
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    body: {
      padding: "var(--card-padding)",
      flex: "1",
      display: "flex",
      flexDirection: "column"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      paddingInline: "var(--card-padding)",
      paddingBottom: "var(--card-padding)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--card-padding": "spacing.4"
        },
        title: {
          textStyle: "md"
        }
      },
      md: {
        root: {
          "--card-padding": "spacing.6"
        },
        title: {
          textStyle: "lg"
        }
      },
      lg: {
        root: {
          "--card-padding": "spacing.7"
        },
        title: {
          textStyle: "xl"
        }
      }
    },
    variant: {
      elevated: {
        root: {
          bg: "bg.panel",
          boxShadow: "md"
        }
      },
      outline: {
        root: {
          bg: "bg.panel",
          borderWidth: "1px",
          borderColor: "border"
        }
      },
      subtle: {
        root: {
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md"
  }
});
const checkboxSlotRecipe = defineSlotRecipe({
  slots: checkboxAnatomy.keys(),
  className: "chakra-checkbox",
  base: {
    root: {
      display: "inline-flex",
      gap: "2",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    },
    control: checkmarkRecipe.base,
    label: {
      fontWeight: "medium",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    size: {
      xs: {
        root: { gap: "1.5" },
        label: { textStyle: "xs" },
        control: checkmarkRecipe.variants?.size?.xs
      },
      sm: {
        root: { gap: "2" },
        label: { textStyle: "sm" },
        control: checkmarkRecipe.variants?.size?.sm
      },
      md: {
        root: { gap: "2.5" },
        label: { textStyle: "sm" },
        control: checkmarkRecipe.variants?.size?.md
      },
      lg: {
        root: { gap: "3" },
        label: { textStyle: "md" },
        control: checkmarkRecipe.variants?.size?.lg
      }
    },
    variant: {
      outline: {
        control: checkmarkRecipe.variants?.variant?.outline
      },
      solid: {
        control: checkmarkRecipe.variants?.variant?.solid
      },
      subtle: {
        control: checkmarkRecipe.variants?.variant?.subtle
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const checkboxCardSlotRecipe = defineSlotRecipe({
  slots: checkboxCardAnatomy.keys(),
  className: "chakra-checkbox-card",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      flex: "1",
      focusVisibleRing: "outside",
      _disabled: {
        opacity: "0.8"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error"
      }
    },
    control: {
      display: "inline-flex",
      flex: "1",
      position: "relative",
      borderRadius: "inherit",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    },
    label: {
      fontWeight: "medium",
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: "1",
      _disabled: {
        opacity: "0.5"
      }
    },
    description: {
      opacity: "0.64",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    addon: {
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: checkmarkRecipe.base,
    content: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--checkbox-card-justify)",
      alignItems: "var(--checkbox-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "3",
          gap: "1.5"
        },
        addon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        indicator: checkmarkRecipe.variants?.size.sm
      },
      md: {
        root: {
          textStyle: "sm"
        },
        control: {
          padding: "4",
          gap: "2.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: checkmarkRecipe.variants?.size.md
      },
      lg: {
        root: {
          textStyle: "md"
        },
        control: {
          padding: "4",
          gap: "3.5"
        },
        addon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        indicator: checkmarkRecipe.variants?.size.lg
      }
    },
    variant: {
      surface: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          },
          _disabled: {
            bg: "bg.muted"
          }
        },
        indicator: checkmarkRecipe.variants?.variant.solid
      },
      subtle: {
        root: {
          bg: "bg.muted"
        },
        control: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        indicator: checkmarkRecipe.variants?.variant.plain
      },
      outline: {
        root: {
          borderWidth: "1px",
          borderColor: "border",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: checkmarkRecipe.variants?.variant.solid
      },
      solid: {
        root: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        indicator: checkmarkRecipe.variants?.variant.inverted
      }
    },
    justify: {
      start: {
        root: { "--checkbox-card-justify": "flex-start" }
      },
      end: {
        root: { "--checkbox-card-justify": "flex-end" }
      },
      center: {
        root: { "--checkbox-card-justify": "center" }
      }
    },
    align: {
      start: {
        root: { "--checkbox-card-align": "flex-start" },
        content: { textAlign: "start" }
      },
      end: {
        root: { "--checkbox-card-align": "flex-end" },
        content: { textAlign: "end" }
      },
      center: {
        root: { "--checkbox-card-align": "center" },
        content: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        control: { flexDirection: "column" }
      },
      horizontal: {
        control: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});
const collapsibleSlotRecipe = defineSlotRecipe({
  slots: anatomy$n.keys(),
  className: "chakra-collapsible",
  base: {
    content: {
      overflow: "hidden",
      _open: {
        animationName: "expand-height, fade-in",
        animationDuration: "moderate"
      },
      _closed: {
        animationName: "collapse-height, fade-out",
        animationDuration: "moderate"
      }
    }
  }
});
const colorPickerSlotRecipe = defineSlotRecipe({
  className: "colorPicker",
  slots: colorPickerAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5"
    },
    label: {
      color: "fg",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    valueText: {
      textAlign: "start"
    },
    control: {
      display: "flex",
      alignItems: "center",
      flexDirection: "row",
      gap: "2",
      position: "relative"
    },
    swatchTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "row",
      flexShrink: "0",
      gap: "2",
      textStyle: "sm",
      minH: "var(--input-height)",
      minW: "var(--input-height)",
      px: "1",
      rounded: "l2",
      _disabled: { opacity: "0.5" },
      "--focus-color": "colors.colorPalette.focusRing",
      "&:focus-visible": {
        borderColor: "var(--focus-color)",
        outline: "1px solid var(--focus-color)"
      },
      "&[data-fit-content]": {
        "--input-height": "unset",
        px: "0",
        border: "0"
      }
    },
    content: {
      display: "flex",
      flexDirection: "column",
      bg: "bg.panel",
      borderRadius: "l3",
      boxShadow: "lg",
      width: "64",
      p: "4",
      gap: "3",
      zIndex: "dropdown",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    area: {
      height: "180px",
      borderRadius: "l2",
      overflow: "hidden"
    },
    areaThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      focusVisibleRing: "mixed",
      focusRingColor: "white"
    },
    areaBackground: {
      height: "full"
    },
    channelSlider: {
      borderRadius: "l2",
      flex: "1"
    },
    channelSliderTrack: {
      height: "var(--slider-height)",
      borderRadius: "inherit",
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    },
    channelText: {
      textStyle: "xs",
      color: "fg.muted",
      fontWeight: "medium",
      textTransform: "capitalize"
    },
    swatchGroup: {
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      gap: "2"
    },
    swatch: {
      ...colorSwatchRecipe.base,
      borderRadius: "l1"
    },
    swatchIndicator: {
      color: "white",
      rounded: "full"
    },
    channelSliderThumb: {
      borderRadius: "full",
      height: "var(--thumb-size)",
      width: "var(--thumb-size)",
      borderWidth: "2px",
      borderColor: "white",
      shadow: "sm",
      transform: "translate(-50%, -50%)",
      focusVisibleRing: "outside",
      focusRingOffset: "1px"
    },
    channelInput: {
      ...inputRecipe.base,
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
        WebkitAppearance: "none",
        margin: 0
      }
    },
    formatSelect: {
      textStyle: "xs",
      textTransform: "uppercase",
      borderWidth: "1px",
      minH: "6",
      focusRing: "inside",
      rounded: "l2"
    },
    transparencyGrid: {
      borderRadius: "l2"
    },
    view: {
      display: "flex",
      flexDirection: "column",
      gap: "2"
    }
  },
  variants: {
    size: {
      "2xs": {
        channelInput: inputRecipe.variants?.size?.["2xs"],
        swatch: { "--swatch-size": "sizes.4.5" },
        trigger: { "--input-height": "sizes.7" },
        area: { "--thumb-size": "sizes.3" },
        channelSlider: {
          "--slider-height": "sizes.3",
          "--thumb-size": "sizes.3"
        }
      },
      xs: {
        channelInput: inputRecipe.variants?.size?.xs,
        swatch: { "--swatch-size": "sizes.5" },
        trigger: { "--input-height": "sizes.8" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      sm: {
        channelInput: inputRecipe.variants?.size?.sm,
        swatch: { "--swatch-size": "sizes.6" },
        trigger: { "--input-height": "sizes.9" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      md: {
        channelInput: inputRecipe.variants?.size?.md,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.10" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      lg: {
        channelInput: inputRecipe.variants?.size?.lg,
        swatch: { "--swatch-size": "sizes.7" },
        trigger: { "--input-height": "sizes.11" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      xl: {
        channelInput: inputRecipe.variants?.size?.xl,
        swatch: { "--swatch-size": "sizes.8" },
        trigger: { "--input-height": "sizes.12" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      },
      "2xl": {
        channelInput: inputRecipe.variants?.size?.["2xl"],
        swatch: { "--swatch-size": "sizes.10" },
        trigger: { "--input-height": "sizes.16" },
        area: { "--thumb-size": "sizes.3.5" },
        channelSlider: {
          "--slider-height": "sizes.3.5",
          "--thumb-size": "sizes.3.5"
        }
      }
    },
    variant: {
      outline: {
        channelInput: inputRecipe.variants?.variant?.outline,
        trigger: {
          borderWidth: "1px"
        }
      },
      subtle: {
        channelInput: inputRecipe.variants?.variant?.subtle,
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const dataListSlotRecipe = defineSlotRecipe({
  slots: dataListAnatomy.keys(),
  className: "chakra-data-list",
  base: {
    itemLabel: {
      display: "flex",
      alignItems: "center",
      gap: "1"
    },
    itemValue: {
      display: "flex",
      minWidth: "0",
      flex: "1"
    }
  },
  variants: {
    orientation: {
      horizontal: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "inline-flex",
          alignItems: "center",
          gap: "4"
        },
        itemLabel: {
          minWidth: "120px"
        }
      },
      vertical: {
        root: {
          display: "flex",
          flexDirection: "column"
        },
        item: {
          display: "flex",
          flexDirection: "column",
          gap: "1"
        }
      }
    },
    size: {
      sm: {
        root: {
          gap: "3"
        },
        item: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        item: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "5"
        },
        item: {
          textStyle: "md"
        }
      }
    },
    variant: {
      subtle: {
        itemLabel: {
          color: "fg.muted"
        }
      },
      bold: {
        itemLabel: {
          fontWeight: "medium"
        },
        itemValue: {
          color: "fg.muted"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    orientation: "vertical",
    variant: "subtle"
  }
});
const dialogSlotRecipe = defineSlotRecipe({
  slots: dialogAnatomy.keys(),
  className: "chakra-dialog",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      left: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "overlay",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      left: 0,
      top: 0,
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      justifyContent: "center",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      borderRadius: "l3",
      textStyle: "sm",
      my: "var(--dialog-margin, var(--dialog-base-margin))",
      "--dialog-z-index": "zIndex.modal",
      zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "moderate"
      },
      _closed: {
        animationDuration: "faster"
      }
    },
    header: {
      display: "flex",
      gap: "2",
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      flex: "1",
      px: "6",
      pt: "2",
      pb: "6"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    },
    closeTrigger: {
      pos: "absolute",
      top: "2",
      insetEnd: "2"
    }
  },
  variants: {
    placement: {
      center: {
        positioner: {
          alignItems: "center"
        },
        content: {
          "--dialog-base-margin": "auto",
          mx: "auto"
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          "--dialog-base-margin": "spacing.16",
          mx: "auto"
        }
      }
    },
    scrollBehavior: {
      inside: {
        positioner: {
          overflow: "hidden"
        },
        content: {
          maxH: "calc(100% - 7.5rem)"
        },
        body: {
          overflow: "auto"
        }
      },
      outside: {
        positioner: {
          overflow: "auto",
          pointerEvents: "auto"
        }
      }
    },
    size: {
      xs: {
        content: {
          maxW: "sm"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      cover: {
        positioner: {
          padding: "10"
        },
        content: {
          width: "100%",
          height: "100%",
          "--dialog-margin": "0"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          minH: "100vh",
          "--dialog-margin": "0",
          borderRadius: "0"
        }
      }
    },
    motionPreset: {
      scale: {
        content: {
          _open: { animationName: "scale-in, fade-in" },
          _closed: { animationName: "scale-out, fade-out" }
        }
      },
      "slide-in-bottom": {
        content: {
          _open: { animationName: "slide-from-bottom, fade-in" },
          _closed: { animationName: "slide-to-bottom, fade-out" }
        }
      },
      "slide-in-top": {
        content: {
          _open: { animationName: "slide-from-top, fade-in" },
          _closed: { animationName: "slide-to-top, fade-out" }
        }
      },
      "slide-in-left": {
        content: {
          _open: { animationName: "slide-from-left, fade-in" },
          _closed: { animationName: "slide-to-left, fade-out" }
        }
      },
      "slide-in-right": {
        content: {
          _open: { animationName: "slide-from-right, fade-in" },
          _closed: { animationName: "slide-to-right, fade-out" }
        }
      },
      none: {}
    }
  },
  defaultVariants: {
    size: "md",
    scrollBehavior: "outside",
    placement: "top",
    motionPreset: "scale"
  }
});
const drawerSlotRecipe = defineSlotRecipe({
  slots: drawerAnatomy.keys(),
  className: "chakra-drawer",
  base: {
    backdrop: {
      bg: "blackAlpha.500",
      pos: "fixed",
      insetInlineStart: 0,
      top: 0,
      w: "100vw",
      h: "100dvh",
      zIndex: "overlay",
      _open: {
        animationName: "fade-in",
        animationDuration: "slow"
      },
      _closed: {
        animationName: "fade-out",
        animationDuration: "moderate"
      }
    },
    positioner: {
      display: "flex",
      width: "100vw",
      height: "100dvh",
      position: "fixed",
      insetInlineStart: 0,
      top: 0,
      zIndex: "modal",
      overscrollBehaviorY: "none"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      zIndex: "modal",
      textStyle: "sm",
      maxH: "100dvh",
      color: "inherit",
      bg: "bg.panel",
      boxShadow: "lg",
      _open: {
        animationDuration: "slowest",
        animationTimingFunction: "ease-in-smooth"
      },
      _closed: {
        animationDuration: "slower",
        animationTimingFunction: "ease-in-smooth"
      }
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "2",
      flex: 0,
      px: "6",
      pt: "6",
      pb: "4"
    },
    body: {
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      gap: "3",
      px: "6",
      pt: "2",
      pb: "4"
    },
    title: {
      flex: "1",
      textStyle: "lg",
      fontWeight: "semibold"
    },
    description: {
      color: "fg.muted"
    },
    closeTrigger: {
      pos: "absolute",
      top: "3",
      insetEnd: "2"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          maxW: "xs"
        }
      },
      sm: {
        content: {
          maxW: "md"
        }
      },
      md: {
        content: {
          maxW: "lg"
        }
      },
      lg: {
        content: {
          maxW: "2xl"
        }
      },
      xl: {
        content: {
          maxW: "4xl"
        }
      },
      full: {
        content: {
          maxW: "100vw",
          h: "100dvh"
        }
      }
    },
    placement: {
      start: {
        positioner: {
          justifyContent: "flex-start"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-left-full, fade-in",
              _rtl: "slide-from-right-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-left-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      end: {
        positioner: {
          justifyContent: "flex-end"
        },
        content: {
          _open: {
            animationName: {
              base: "slide-from-right-full, fade-in",
              _rtl: "slide-from-left-full, fade-in"
            }
          },
          _closed: {
            animationName: {
              base: "slide-to-right-full, fade-out",
              _rtl: "slide-to-right-full, fade-out"
            }
          }
        }
      },
      top: {
        positioner: {
          alignItems: "flex-start"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-top-full, fade-in" },
          _closed: { animationName: "slide-to-top-full, fade-out" }
        }
      },
      bottom: {
        positioner: {
          alignItems: "flex-end"
        },
        content: {
          maxW: "100%",
          _open: { animationName: "slide-from-bottom-full, fade-in" },
          _closed: { animationName: "slide-to-bottom-full, fade-out" }
        }
      }
    },
    contained: {
      true: {
        positioner: {
          padding: "4"
        },
        content: {
          borderRadius: "l3"
        }
      }
    }
  },
  defaultVariants: {
    size: "xs",
    placement: "end"
  }
});
const sharedStyles = defineStyle({
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent",
  borderRadius: "l2"
});
const editableSlotRecipe = defineSlotRecipe({
  slots: editableAnatomy.keys(),
  className: "chakra-editable",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      gap: "1.5",
      width: "full"
    },
    preview: {
      ...sharedStyles,
      py: "1",
      px: "1",
      display: "inline-flex",
      alignItems: "center",
      transitionProperty: "common",
      transitionDuration: "normal",
      cursor: "text",
      _hover: {
        bg: "bg.muted"
      },
      _disabled: {
        userSelect: "none"
      }
    },
    input: {
      ...sharedStyles,
      outline: "0",
      py: "1",
      px: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      _placeholder: { opacity: 0.6 }
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      gap: "1.5"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "8" },
        input: { minH: "8" }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        preview: { minH: "9" },
        input: { minH: "9" }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        preview: { minH: "10" },
        input: { minH: "10" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const emptyStateSlotRecipe = defineSlotRecipe({
  slots: emptyStateAnatomy.keys(),
  className: "chakra-empty-state",
  base: {
    root: {
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "fg.subtle",
      _icon: {
        boxSize: "1em"
      }
    },
    title: {
      fontWeight: "semibold"
    },
    description: {
      textStyle: "sm",
      color: "fg.muted"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "4",
          py: "6"
        },
        title: {
          textStyle: "md"
        },
        content: {
          gap: "4"
        },
        indicator: {
          textStyle: "2xl"
        }
      },
      md: {
        root: {
          px: "8",
          py: "12"
        },
        title: {
          textStyle: "lg"
        },
        content: {
          gap: "6"
        },
        indicator: {
          textStyle: "4xl"
        }
      },
      lg: {
        root: {
          px: "12",
          py: "16"
        },
        title: {
          textStyle: "xl"
        },
        content: {
          gap: "8"
        },
        indicator: {
          textStyle: "6xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const fieldSlotRecipe = defineSlotRecipe({
  className: "chakra-field",
  slots: fieldAnatomy.keys(),
  base: {
    requiredIndicator: {
      color: "fg.error",
      lineHeight: "1"
    },
    root: {
      display: "flex",
      width: "100%",
      position: "relative",
      gap: "1.5"
    },
    label: {
      display: "flex",
      alignItems: "center",
      textAlign: "start",
      textStyle: "sm",
      fontWeight: "medium",
      gap: "1",
      userSelect: "none",
      _disabled: {
        opacity: "0.5"
      }
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      gap: "1",
      color: "fg.error",
      textStyle: "xs"
    },
    helperText: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "column",
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "space-between"
        },
        label: {
          flex: "0 0 var(--field-label-width, 80px)"
        }
      }
    }
  },
  defaultVariants: {
    orientation: "vertical"
  }
});
const fieldsetSlotRecipe = defineSlotRecipe({
  className: "fieldset",
  slots: fieldsetAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    content: {
      display: "flex",
      flexDirection: "column",
      width: "full"
    },
    legend: {
      color: "fg",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    helperText: {
      color: "fg.muted",
      textStyle: "sm"
    },
    errorText: {
      display: "inline-flex",
      alignItems: "center",
      color: "fg.error",
      gap: "2",
      fontWeight: "medium",
      textStyle: "sm"
    }
  },
  variants: {
    size: {
      sm: {
        root: { spaceY: "2" },
        content: { gap: "1.5" },
        legend: { textStyle: "sm" }
      },
      md: {
        root: { spaceY: "4" },
        content: { gap: "4" },
        legend: { textStyle: "sm" }
      },
      lg: {
        root: { spaceY: "6" },
        content: { gap: "4" },
        legend: { textStyle: "md" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const fileUploadSlotRecipe = defineSlotRecipe({
  className: "chakra-file-upload",
  slots: fileUploadAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "4",
      width: "100%",
      alignItems: "flex-start"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    dropzone: {
      background: "bg",
      borderRadius: "l3",
      borderWidth: "2px",
      borderStyle: "dashed",
      display: "flex",
      alignItems: "center",
      flexDirection: "column",
      gap: "4",
      justifyContent: "center",
      minHeight: "2xs",
      px: "3",
      py: "2",
      transition: "backgrounds",
      focusVisibleRing: "outside",
      _hover: {
        bg: "bg.subtle"
      },
      _dragging: {
        bg: "colorPalette.subtle",
        borderStyle: "solid",
        borderColor: "colorPalette.solid"
      }
    },
    dropzoneContent: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      gap: "1",
      textStyle: "sm"
    },
    item: {
      pos: "relative",
      textStyle: "sm",
      animationName: "fade-in",
      animationDuration: "moderate",
      background: "bg",
      borderRadius: "l2",
      borderWidth: "1px",
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: "3",
      p: "4"
    },
    itemGroup: {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: "3",
      _empty: {
        display: "none"
      }
    },
    itemName: {
      color: "fg",
      fontWeight: "medium",
      lineClamp: "1"
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      gap: "0.5",
      flex: "1"
    },
    itemSizeText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    itemDeleteTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      alignSelf: "flex-start",
      boxSize: "5",
      p: "2px",
      color: "fg.muted",
      cursor: "button"
    },
    itemPreview: {
      color: "fg.muted",
      _icon: {
        boxSize: "4.5"
      }
    }
  },
  defaultVariants: {}
});
const hoverCardSlotRecipe = defineSlotRecipe({
  className: "chakra-hover-card",
  slots: anatomy$e.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--hovercard-bg": "colors.bg.panel",
      bg: "var(--hovercard-bg)",
      boxShadow: "lg",
      maxWidth: "80",
      borderRadius: "l3",
      zIndex: "popover",
      transformOrigin: "var(--transform-origin)",
      outline: "0",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--hovercard-bg)"
    },
    arrowTip: {
      borderTopWidth: "0.5px",
      borderInlineStartWidth: "0.5px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          padding: "3"
        }
      },
      sm: {
        content: {
          padding: "4"
        }
      },
      md: {
        content: {
          padding: "5"
        }
      },
      lg: {
        content: {
          padding: "6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const listSlotRecipe = defineSlotRecipe({
  className: "chakra-list",
  slots: listAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "var(--list-gap)",
      "& :where(ul, ol)": {
        marginTop: "var(--list-gap)"
      }
    },
    item: {
      whiteSpace: "normal",
      display: "list-item"
    },
    indicator: {
      marginEnd: "2",
      minHeight: "1lh",
      flexShrink: 0,
      display: "inline-block",
      verticalAlign: "middle"
    }
  },
  variants: {
    variant: {
      marker: {
        root: {
          listStyle: "revert"
        },
        item: {
          _marker: {
            color: "fg.subtle"
          }
        }
      },
      plain: {
        item: {
          alignItems: "flex-start",
          display: "inline-flex"
        }
      }
    },
    align: {
      center: {
        item: { alignItems: "center" }
      },
      start: {
        item: { alignItems: "flex-start" }
      },
      end: {
        item: { alignItems: "flex-end" }
      }
    }
  },
  defaultVariants: {
    variant: "marker"
  }
});
const menuSlotRecipe = defineSlotRecipe({
  className: "chakra-menu",
  slots: menuAnatomy.keys(),
  base: {
    content: {
      outline: 0,
      bg: "bg.panel",
      boxShadow: "lg",
      color: "fg",
      maxHeight: "var(--available-height)",
      "--menu-z-index": "zIndex.dropdown",
      zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
      borderRadius: "l2",
      overflow: "hidden",
      overflowY: "auto",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "faster"
      }
    },
    item: {
      textDecoration: "none",
      color: "fg",
      userSelect: "none",
      borderRadius: "l1",
      width: "100%",
      display: "flex",
      cursor: "menuitem",
      alignItems: "center",
      textAlign: "start",
      position: "relative",
      flex: "0 0 auto",
      outline: 0,
      _disabled: {
        layerStyle: "disabled"
      },
      "&[data-type]": {
        ps: "8"
      }
    },
    itemText: {
      flex: "1"
    },
    itemIndicator: {
      position: "absolute",
      insetStart: "2",
      transform: "translateY(-50%)",
      top: "50%"
    },
    itemGroupLabel: {
      px: "2",
      py: "1.5",
      fontWeight: "semibold",
      textStyle: "sm"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    itemCommand: {
      opacity: "0.6",
      textStyle: "xs",
      ms: "auto",
      ps: "4",
      letterSpacing: "widest",
      fontFamily: "inherit"
    },
    separator: {
      height: "1px",
      bg: "bg.muted",
      my: "1",
      mx: "-1"
    }
  },
  variants: {
    variant: {
      subtle: {
        item: {
          _highlighted: {
            bg: "bg.emphasized/60"
          }
        }
      },
      solid: {
        item: {
          _highlighted: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        }
      }
    },
    size: {
      sm: {
        content: {
          minW: "8rem",
          padding: "1"
        },
        item: {
          gap: "1",
          textStyle: "xs",
          py: "1",
          px: "1.5"
        }
      },
      md: {
        content: {
          minW: "8rem",
          padding: "1.5"
        },
        item: {
          gap: "2",
          textStyle: "sm",
          py: "1.5",
          px: "2"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "subtle"
  }
});
const selectSlotRecipe = defineSlotRecipe({
  className: "chakra-select",
  slots: selectAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      width: "full"
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "full",
      minH: "var(--select-trigger-height)",
      "--input-height": "var(--select-trigger-height)",
      px: "var(--select-trigger-padding-x)",
      borderRadius: "l2",
      userSelect: "none",
      textAlign: "start",
      focusVisibleRing: "inside",
      _placeholderShown: {
        color: "fg.muted/80"
      },
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        borderColor: "border.error"
      }
    },
    indicatorGroup: {
      display: "flex",
      alignItems: "center",
      gap: "1",
      pos: "absolute",
      right: "0",
      top: "0",
      bottom: "0",
      px: "var(--select-trigger-padding-x)",
      pointerEvents: "none"
    },
    indicator: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
    },
    content: {
      background: "bg.panel",
      display: "flex",
      flexDirection: "column",
      zIndex: "dropdown",
      borderRadius: "l2",
      outline: 0,
      maxH: "96",
      overflowY: "auto",
      boxShadow: "md",
      _open: {
        animationStyle: "slide-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "slide-fade-out",
        animationDuration: "fastest"
      }
    },
    item: {
      position: "relative",
      userSelect: "none",
      display: "flex",
      alignItems: "center",
      gap: "2",
      cursor: "option",
      justifyContent: "space-between",
      flex: "1",
      textAlign: "start",
      borderRadius: "l1",
      _highlighted: {
        bg: "bg.emphasized/60"
      },
      _disabled: {
        pointerEvents: "none",
        opacity: "0.5"
      },
      _icon: {
        width: "4",
        height: "4"
      }
    },
    control: {
      pos: "relative"
    },
    itemText: {
      flex: "1"
    },
    itemGroup: {
      _first: { mt: "0" }
    },
    itemGroupLabel: {
      py: "1",
      fontWeight: "medium"
    },
    label: {
      fontWeight: "medium",
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        layerStyle: "disabled"
      }
    },
    valueText: {
      lineClamp: "1",
      maxW: "80%"
    },
    clearTrigger: {
      color: "fg.muted",
      pointerEvents: "auto",
      focusVisibleRing: "inside",
      focusRingWidth: "2px",
      rounded: "l1"
    }
  },
  variants: {
    variant: {
      outline: {
        trigger: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          _expanded: {
            borderColor: "border.emphasized"
          }
        }
      },
      subtle: {
        trigger: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted"
        }
      }
    },
    size: {
      xs: {
        root: {
          "--select-trigger-height": "sizes.8",
          "--select-trigger-padding-x": "spacing.2"
        },
        content: {
          p: "1",
          gap: "1",
          textStyle: "xs"
        },
        trigger: {
          textStyle: "xs",
          gap: "1"
        },
        item: {
          py: "1",
          px: "2"
        },
        itemGroupLabel: {
          py: "1",
          px: "2"
        },
        indicator: {
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        }
      },
      sm: {
        root: {
          "--select-trigger-height": "sizes.9",
          "--select-trigger-padding-x": "spacing.2.5"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        trigger: {
          textStyle: "sm",
          gap: "1"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        },
        item: {
          py: "1",
          px: "1.5"
        },
        itemGroup: {
          mt: "1"
        },
        itemGroupLabel: {
          py: "1",
          px: "1.5"
        }
      },
      md: {
        root: {
          "--select-trigger-height": "sizes.10",
          "--select-trigger-padding-x": "spacing.3"
        },
        content: {
          p: "1",
          textStyle: "sm"
        },
        itemGroup: {
          mt: "1.5"
        },
        item: {
          py: "1.5",
          px: "2"
        },
        itemIndicator: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        itemGroupLabel: {
          py: "1.5",
          px: "2"
        },
        trigger: {
          textStyle: "sm",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "4",
            height: "4"
          }
        }
      },
      lg: {
        root: {
          "--select-trigger-height": "sizes.12",
          "--select-trigger-padding-x": "spacing.4"
        },
        content: {
          p: "1.5",
          textStyle: "md"
        },
        itemGroup: {
          mt: "2"
        },
        item: {
          py: "2",
          px: "3"
        },
        itemGroupLabel: {
          py: "2",
          px: "3"
        },
        trigger: {
          textStyle: "md",
          py: "3",
          gap: "2"
        },
        indicator: {
          _icon: {
            width: "5",
            height: "5"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const nativeSelectSlotRecipe = defineSlotRecipe({
  className: "chakra-native-select",
  slots: nativeSelectAnatomy.keys(),
  base: {
    root: {
      height: "fit-content",
      display: "flex",
      width: "100%",
      position: "relative"
    },
    field: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      appearance: "none",
      borderRadius: "l2",
      "--error-color": "colors.border.error",
      _disabled: {
        layerStyle: "disabled"
      },
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      },
      focusVisibleRing: "inside",
      lineHeight: "normal",
      "& > option, & > optgroup": {
        bg: "bg"
      }
    },
    indicator: {
      position: "absolute",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      top: "50%",
      transform: "translateY(-50%)",
      height: "100%",
      color: "fg.muted",
      _disabled: {
        opacity: "0.5"
      },
      _invalid: {
        color: "fg.error"
      },
      _icon: {
        width: "1em",
        height: "1em"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        field: selectSlotRecipe.variants?.variant.outline.trigger
      },
      subtle: {
        field: selectSlotRecipe.variants?.variant.subtle.trigger
      },
      plain: {
        field: {
          bg: "transparent",
          color: "fg",
          focusRingWidth: "2px"
        }
      }
    },
    size: {
      xs: {
        field: {
          textStyle: "xs",
          ps: "2",
          pe: "6",
          height: "6"
        },
        indicator: {
          textStyle: "sm",
          insetEnd: "1.5"
        }
      },
      sm: {
        field: {
          textStyle: "sm",
          ps: "2.5",
          pe: "8",
          height: "8"
        },
        indicator: {
          textStyle: "md",
          insetEnd: "2"
        }
      },
      md: {
        field: {
          textStyle: "sm",
          ps: "3",
          pe: "8",
          height: "10"
        },
        indicator: {
          textStyle: "lg",
          insetEnd: "2"
        }
      },
      lg: {
        field: {
          textStyle: "md",
          ps: "4",
          pe: "8",
          height: "11"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      },
      xl: {
        field: {
          textStyle: "md",
          ps: "4.5",
          pe: "10",
          height: "12"
        },
        indicator: {
          textStyle: "xl",
          insetEnd: "3"
        }
      }
    }
  },
  defaultVariants: selectSlotRecipe.defaultVariants
});
function mapEntries(obj, f2) {
  const result = {};
  for (const key in obj) {
    const kv = f2(key, obj[key]);
    result[kv[0]] = kv[1];
  }
  return result;
}
const triggerStyle = defineStyle({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flex: "1",
  userSelect: "none",
  cursor: "button",
  lineHeight: "1",
  color: "fg.muted",
  "--stepper-base-radius": "radii.l1",
  "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
  _icon: {
    boxSize: "1em"
  },
  _disabled: {
    opacity: "0.5"
  },
  _hover: {
    bg: "bg.muted"
  },
  _active: {
    bg: "bg.emphasized"
  }
});
const numberInputSlotRecipe = defineSlotRecipe({
  className: "chakra-number-input",
  slots: anatomy$c.keys(),
  base: {
    root: {
      position: "relative",
      zIndex: "0",
      isolation: "isolate"
    },
    input: {
      ...inputRecipe.base,
      verticalAlign: "top",
      pe: "calc(var(--stepper-width) + 0.5rem)"
    },
    control: {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      width: "var(--stepper-width)",
      height: "calc(100% - 2px)",
      zIndex: "1",
      borderStartWidth: "1px",
      divideY: "1px"
    },
    incrementTrigger: {
      ...triggerStyle,
      borderTopEndRadius: "var(--stepper-radius)"
    },
    decrementTrigger: {
      ...triggerStyle,
      borderBottomEndRadius: "var(--stepper-radius)"
    },
    valueText: {
      fontWeight: "medium",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums"
    }
  },
  variants: {
    size: {
      xs: {
        input: inputRecipe.variants.size.xs,
        control: {
          fontSize: "2xs",
          "--stepper-width": "sizes.4"
        }
      },
      sm: {
        input: inputRecipe.variants.size.sm,
        control: {
          fontSize: "xs",
          "--stepper-width": "sizes.5"
        }
      },
      md: {
        input: inputRecipe.variants.size.md,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      },
      lg: {
        input: inputRecipe.variants.size.lg,
        control: {
          fontSize: "sm",
          "--stepper-width": "sizes.6"
        }
      }
    },
    variant: mapEntries(inputRecipe.variants.variant, (key, variantStyles) => [
      key,
      { input: variantStyles }
    ])
  },
  defaultVariants: {
    size: "md",
    variant: "outline"
  }
});
const { variants, defaultVariants } = inputRecipe;
const pinInputSlotRecipe = defineSlotRecipe({
  className: "chakra-pin-input",
  slots: anatomy$b.keys(),
  base: {
    input: {
      ...inputRecipe.base,
      textAlign: "center",
      width: "var(--input-height)"
    },
    control: {
      display: "inline-flex",
      gap: "2",
      isolation: "isolate"
    }
  },
  variants: {
    size: mapEntries(variants.size, (key, value) => [key, { input: value }]),
    variant: mapEntries(variants.variant, (key, value) => [
      key,
      { input: value }
    ]),
    attached: {
      true: {
        control: {
          gap: "0",
          spaceX: "-1px"
        },
        input: {
          _notFirst: { borderStartRadius: "0" },
          _notLast: { borderEndRadius: "0" },
          _focusVisible: { zIndex: "1" }
        }
      }
    }
  },
  defaultVariants
});
const popoverSlotRecipe = defineSlotRecipe({
  className: "chakra-popover",
  slots: popoverAnatomy.keys(),
  base: {
    content: {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      textStyle: "sm",
      "--popover-bg": "colors.bg.panel",
      bg: "var(--popover-bg)",
      boxShadow: "lg",
      "--popover-size": "sizes.xs",
      "--popover-mobile-size": "calc(100dvw - 1rem)",
      width: {
        base: "min(var(--popover-mobile-size), var(--popover-size))",
        sm: "var(--popover-size)"
      },
      borderRadius: "l3",
      "--popover-z-index": "zIndex.popover",
      zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
      outline: "0",
      transformOrigin: "var(--transform-origin)",
      maxHeight: "var(--available-height)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "faster"
      }
    },
    header: {
      paddingInline: "var(--popover-padding)",
      paddingTop: "var(--popover-padding)"
    },
    body: {
      padding: "var(--popover-padding)",
      flex: "1"
    },
    footer: {
      display: "flex",
      alignItems: "center",
      paddingInline: "var(--popover-padding)",
      paddingBottom: "var(--popover-padding)"
    },
    arrow: {
      "--arrow-size": "sizes.3",
      "--arrow-background": "var(--popover-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px"
    }
  },
  variants: {
    size: {
      xs: {
        content: {
          "--popover-padding": "spacing.3"
        }
      },
      sm: {
        content: {
          "--popover-padding": "spacing.4"
        }
      },
      md: {
        content: {
          "--popover-padding": "spacing.5"
        }
      },
      lg: {
        content: {
          "--popover-padding": "spacing.6"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const progressSlotRecipe = defineSlotRecipe({
  slots: anatomy$9.keys(),
  className: "chakra-progress",
  base: {
    root: {
      textStyle: "sm",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      position: "relative"
    },
    range: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transitionProperty: "width, height",
      transitionDuration: "slow",
      height: "100%",
      bgColor: "var(--track-color)",
      _indeterminate: {
        "--animate-from-x": "-40%",
        "--animate-to-x": "100%",
        position: "absolute",
        willChange: "left",
        minWidth: "50%",
        animation: "position 1s ease infinite normal none running",
        backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      alignItems: "center",
      gap: "1"
    },
    valueText: {
      textStyle: "xs",
      lineHeight: "1",
      fontWeight: "medium"
    }
  },
  variants: {
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bgColor: "bg.muted"
        },
        range: {
          bgColor: "colorPalette.solid"
        }
      },
      subtle: {
        track: {
          bgColor: "colorPalette.muted"
        },
        range: {
          bgColor: "colorPalette.solid/72"
        }
      }
    },
    shape: {
      square: {},
      rounded: {
        track: {
          borderRadius: "l1"
        }
      },
      full: {
        track: {
          borderRadius: "full"
        }
      }
    },
    striped: {
      true: {
        range: {
          backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
          backgroundSize: `var(--stripe-size) var(--stripe-size)`,
          "--stripe-size": "1rem",
          "--stripe-color": {
            _light: "rgba(255, 255, 255, 0.3)",
            _dark: "rgba(0, 0, 0, 0.3)"
          }
        }
      }
    },
    animated: {
      true: {
        range: {
          "--animate-from": "var(--stripe-size)",
          animation: "bg-position 1s linear infinite"
        }
      }
    },
    size: {
      xs: {
        track: { h: "1.5" }
      },
      sm: {
        track: { h: "2" }
      },
      md: {
        track: { h: "2.5" }
      },
      lg: {
        track: { h: "3" }
      },
      xl: {
        track: { h: "4" }
      }
    }
  },
  defaultVariants: {
    variant: "outline",
    size: "md",
    shape: "rounded"
  }
});
const progressCircleSlotRecipe = defineSlotRecipe({
  className: "chakra-progress-circle",
  slots: anatomy$9.keys(),
  base: {
    root: {
      display: "inline-flex",
      textStyle: "sm",
      position: "relative"
    },
    circle: {
      _indeterminate: {
        animation: "spin 2s linear infinite"
      }
    },
    circleTrack: {
      "--track-color": "colors.colorPalette.muted",
      stroke: "var(--track-color)"
    },
    circleRange: {
      stroke: "colorPalette.solid",
      transitionProperty: "stroke-dasharray",
      transitionDuration: "0.6s",
      _indeterminate: {
        animation: "circular-progress 1.5s linear infinite"
      }
    },
    label: {
      display: "inline-flex"
    },
    valueText: {
      lineHeight: "1",
      fontWeight: "medium",
      letterSpacing: "tight",
      fontVariantNumeric: "tabular-nums"
    }
  },
  variants: {
    size: {
      xs: {
        circle: {
          "--size": "24px",
          "--thickness": "4px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      sm: {
        circle: {
          "--size": "32px",
          "--thickness": "5px"
        },
        valueText: {
          textStyle: "2xs"
        }
      },
      md: {
        circle: {
          "--size": "40px",
          "--thickness": "6px"
        },
        valueText: {
          textStyle: "xs"
        }
      },
      lg: {
        circle: {
          "--size": "48px",
          "--thickness": "7px"
        },
        valueText: {
          textStyle: "sm"
        }
      },
      xl: {
        circle: {
          "--size": "64px",
          "--thickness": "8px"
        },
        valueText: {
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const qrCodeSlotRecipe = defineSlotRecipe({
  slots: anatomy$8.keys(),
  className: "chakra-qr-code",
  base: {
    root: {
      position: "relative",
      width: "fit-content",
      "--qr-code-overlay-size": "calc(var(--qr-code-size) / 3)"
    },
    frame: {
      width: "var(--qr-code-size)",
      height: "var(--qr-code-size)",
      fill: "currentColor"
    },
    overlay: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "var(--qr-code-overlay-size)",
      height: "var(--qr-code-overlay-size)",
      padding: "1",
      bg: "bg",
      rounded: "l1"
    }
  },
  variants: {
    size: {
      "2xs": {
        root: { "--qr-code-size": "40px" }
      },
      xs: {
        root: { "--qr-code-size": "64px" }
      },
      sm: {
        root: { "--qr-code-size": "80px" }
      },
      md: {
        root: { "--qr-code-size": "120px" }
      },
      lg: {
        root: { "--qr-code-size": "160px" }
      },
      xl: {
        root: { "--qr-code-size": "200px" }
      },
      "2xl": {
        root: { "--qr-code-size": "240px" }
      },
      full: {
        root: { "--qr-code-size": "100%" }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const radioCardSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-card",
  slots: radioCardAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1.5",
      isolation: "isolate"
    },
    item: {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      _focus: {
        bg: "colorPalette.muted/20"
      },
      _disabled: {
        opacity: "0.8",
        borderColor: "border.disabled"
      },
      _checked: {
        zIndex: "1"
      }
    },
    label: {
      display: "inline-flex",
      fontWeight: "medium",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    },
    itemText: {
      fontWeight: "medium",
      flex: "1"
    },
    itemDescription: {
      opacity: "0.64",
      textStyle: "sm"
    },
    itemControl: {
      display: "inline-flex",
      flex: "1",
      pos: "relative",
      rounded: "inherit",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)",
      _disabled: {
        bg: "bg.muted"
      }
    },
    itemIndicator: radiomarkRecipe.base,
    itemAddon: {
      roundedBottom: "inherit",
      _disabled: {
        color: "fg.muted"
      }
    },
    itemContent: {
      display: "flex",
      flexDirection: "column",
      flex: "1",
      gap: "1",
      justifyContent: "var(--radio-card-justify)",
      alignItems: "var(--radio-card-align)"
    }
  },
  variants: {
    size: {
      sm: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "3",
          gap: "1.5"
        },
        itemAddon: {
          px: "3",
          py: "1.5",
          borderTopWidth: "1px"
        },
        itemIndicator: radiomarkRecipe.variants?.size.sm
      },
      md: {
        item: {
          textStyle: "sm"
        },
        itemControl: {
          padding: "4",
          gap: "2.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: radiomarkRecipe.variants?.size.md
      },
      lg: {
        item: {
          textStyle: "md"
        },
        itemControl: {
          padding: "4",
          gap: "3.5"
        },
        itemAddon: {
          px: "4",
          py: "2",
          borderTopWidth: "1px"
        },
        itemIndicator: radiomarkRecipe.variants?.size.lg
      }
    },
    variant: {
      surface: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            borderColor: "colorPalette.muted"
          }
        },
        itemIndicator: radiomarkRecipe.variants?.variant.solid
      },
      subtle: {
        item: {
          bg: "bg.muted"
        },
        itemControl: {
          _checked: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        itemIndicator: radiomarkRecipe.variants?.variant.outline
      },
      outline: {
        item: {
          borderWidth: "1px",
          _checked: {
            boxShadow: "0 0 0 1px var(--shadow-color)",
            boxShadowColor: "colorPalette.solid",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: radiomarkRecipe.variants?.variant.solid
      },
      solid: {
        item: {
          borderWidth: "1px",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        itemIndicator: radiomarkRecipe.variants?.variant.inverted
      }
    },
    justify: {
      start: {
        item: { "--radio-card-justify": "flex-start" }
      },
      end: {
        item: { "--radio-card-justify": "flex-end" }
      },
      center: {
        item: { "--radio-card-justify": "center" }
      }
    },
    align: {
      start: {
        item: { "--radio-card-align": "flex-start" },
        itemControl: { textAlign: "start" }
      },
      end: {
        item: { "--radio-card-align": "flex-end" },
        itemControl: { textAlign: "end" }
      },
      center: {
        item: { "--radio-card-align": "center" },
        itemControl: { textAlign: "center" }
      }
    },
    orientation: {
      vertical: {
        itemControl: { flexDirection: "column" }
      },
      horizontal: {
        itemControl: { flexDirection: "row" }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    align: "start",
    orientation: "horizontal"
  }
});
const radioGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-radio-group",
  slots: radioGroupAnatomy.keys(),
  base: {
    item: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      fontWeight: "medium",
      _disabled: {
        cursor: "disabled"
      }
    },
    itemControl: radiomarkRecipe.base,
    label: {
      userSelect: "none",
      textStyle: "sm",
      _disabled: {
        opacity: "0.5"
      }
    }
  },
  variants: {
    variant: {
      outline: {
        itemControl: radiomarkRecipe.variants?.variant?.outline
      },
      subtle: {
        itemControl: radiomarkRecipe.variants?.variant?.subtle
      },
      solid: {
        itemControl: radiomarkRecipe.variants?.variant?.solid
      }
    },
    size: {
      xs: {
        item: { textStyle: "xs", gap: "1.5" },
        itemControl: radiomarkRecipe.variants?.size?.xs
      },
      sm: {
        item: { textStyle: "sm", gap: "2" },
        itemControl: radiomarkRecipe.variants?.size?.sm
      },
      md: {
        item: { textStyle: "sm", gap: "2.5" },
        itemControl: radiomarkRecipe.variants?.size?.md
      },
      lg: {
        item: { textStyle: "md", gap: "3" },
        itemControl: radiomarkRecipe.variants?.size?.lg
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const ratingGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-rating-group",
  slots: ratingGroupAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex"
    },
    control: {
      display: "inline-flex",
      alignItems: "center"
    },
    item: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none"
    },
    itemIndicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "1em",
      height: "1em",
      position: "relative",
      _icon: {
        stroke: "currentColor",
        width: "100%",
        height: "100%",
        display: "inline-block",
        flexShrink: 0,
        position: "absolute",
        left: 0,
        top: 0
      },
      "& [data-bg]": {
        color: "bg.emphasized"
      },
      "& [data-fg]": {
        color: "transparent"
      },
      "&[data-highlighted]:not([data-half])": {
        "& [data-fg]": {
          color: "colorPalette.solid"
        }
      },
      "&[data-half]": {
        "& [data-fg]": {
          color: "colorPalette.solid",
          clipPath: "inset(0 50% 0 0)"
        }
      }
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "sm"
        }
      },
      sm: {
        item: {
          textStyle: "md"
        }
      },
      md: {
        item: {
          textStyle: "xl"
        }
      },
      lg: {
        item: {
          textStyle: "2xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const segmentGroupSlotRecipe = defineSlotRecipe({
  className: "chakra-segment-group",
  slots: segmentGroupAnatomy.keys(),
  base: {
    root: {
      "--segment-radius": "radii.l2",
      borderRadius: "l2",
      display: "inline-flex",
      boxShadow: "inset",
      minW: "max-content",
      textAlign: "center",
      position: "relative",
      isolation: "isolate",
      bg: "bg.muted",
      _vertical: {
        flexDirection: "column"
      }
    },
    item: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      fontSize: "sm",
      position: "relative",
      color: "fg",
      borderRadius: "var(--segment-radius)",
      _disabled: {
        opacity: "0.5"
      },
      "&:has(input:focus-visible)": {
        focusRing: "outside"
      },
      _before: {
        content: '""',
        position: "absolute",
        bg: "border",
        transition: "opacity 0.2s"
      },
      _horizontal: {
        _before: {
          insetInlineStart: 0,
          insetBlock: "1.5",
          width: "1px"
        }
      },
      _vertical: {
        _before: {
          insetBlockStart: 0,
          insetInline: "1.5",
          height: "1px"
        }
      },
      "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
        _before: {
          opacity: "0"
        }
      },
      "&[data-state=checked][data-ssr]": {
        shadow: "sm",
        bg: "bg",
        borderRadius: "var(--segment-radius)"
      }
    },
    indicator: {
      shadow: "sm",
      pos: "absolute",
      bg: { _light: "bg", _dark: "bg.emphasized" },
      width: "var(--width)",
      height: "var(--height)",
      top: "var(--top)",
      left: "var(--left)",
      zIndex: -1,
      borderRadius: "var(--segment-radius)"
    }
  },
  variants: {
    size: {
      xs: {
        item: {
          textStyle: "xs",
          px: "3",
          gap: "1",
          height: "6"
        }
      },
      sm: {
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2",
          height: "8"
        }
      },
      md: {
        item: {
          textStyle: "sm",
          px: "4",
          gap: "2",
          height: "10"
        }
      },
      lg: {
        item: {
          textStyle: "md",
          px: "4.5",
          gap: "3",
          height: "11"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const sliderSlotRecipe = defineSlotRecipe({
  className: "chakra-slider",
  slots: sliderAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      textStyle: "sm",
      position: "relative",
      isolation: "isolate",
      touchAction: "none"
    },
    label: {
      fontWeight: "medium",
      textStyle: "sm"
    },
    control: {
      display: "inline-flex",
      alignItems: "center",
      position: "relative"
    },
    track: {
      overflow: "hidden",
      borderRadius: "full",
      flex: "1"
    },
    range: {
      width: "inherit",
      height: "inherit",
      _disabled: { bg: "border.emphasized!" }
    },
    markerGroup: {
      position: "absolute!",
      zIndex: "1"
    },
    marker: {
      "--marker-bg": { base: "white", _underValue: "colors.bg" },
      display: "flex",
      alignItems: "center",
      gap: "calc(var(--slider-thumb-size) / 2)",
      color: "fg.muted",
      textStyle: "xs"
    },
    markerIndicator: {
      width: "var(--slider-marker-size)",
      height: "var(--slider-marker-size)",
      borderRadius: "full",
      bg: "var(--marker-bg)"
    },
    thumb: {
      width: "var(--slider-thumb-size)",
      height: "var(--slider-thumb-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      zIndex: "2",
      borderRadius: "full",
      _focusVisible: {
        ring: "2px",
        ringColor: "colorPalette.focusRing",
        ringOffset: "2px",
        ringOffsetColor: "bg"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          "--slider-thumb-size": "sizes.4",
          "--slider-track-size": "sizes.1.5",
          "--slider-marker-center": "6px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "3px"
        }
      },
      md: {
        root: {
          "--slider-thumb-size": "sizes.5",
          "--slider-track-size": "sizes.2",
          "--slider-marker-center": "8px",
          "--slider-marker-size": "sizes.1",
          "--slider-marker-inset": "4px"
        }
      },
      lg: {
        root: {
          "--slider-thumb-size": "sizes.6",
          "--slider-track-size": "sizes.2.5",
          "--slider-marker-center": "9px",
          "--slider-marker-size": "sizes.1.5",
          "--slider-marker-inset": "5px"
        }
      }
    },
    variant: {
      outline: {
        track: {
          shadow: "inset",
          bg: "bg.emphasized/72"
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          borderWidth: "2px",
          borderColor: "colorPalette.solid",
          bg: "bg",
          _disabled: {
            bg: "border.emphasized",
            borderColor: "border.emphasized"
          }
        }
      },
      solid: {
        track: {
          bg: "colorPalette.subtle",
          _disabled: {
            bg: "bg.muted"
          }
        },
        range: {
          bg: "colorPalette.solid"
        },
        thumb: {
          bg: "colorPalette.solid",
          _disabled: {
            bg: "border.emphasized"
          }
        }
      }
    },
    orientation: {
      vertical: {
        root: {
          display: "inline-flex"
        },
        control: {
          flexDirection: "column",
          height: "100%",
          minWidth: "var(--slider-thumb-size)",
          "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
            marginEnd: "4"
          }
        },
        track: {
          width: "var(--slider-track-size)"
        },
        thumb: {
          left: "50%",
          translate: "-50% 0"
        },
        markerGroup: {
          insetStart: "var(--slider-marker-center)",
          insetBlock: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "row"
        }
      },
      horizontal: {
        control: {
          flexDirection: "row",
          width: "100%",
          minHeight: "var(--slider-thumb-size)",
          "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
            marginBottom: "4"
          }
        },
        track: {
          height: "var(--slider-track-size)"
        },
        thumb: {
          top: "50%",
          translate: "0 -50%"
        },
        markerGroup: {
          top: "var(--slider-marker-center)",
          insetInline: "var(--slider-marker-inset)"
        },
        marker: {
          flexDirection: "column"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "outline",
    orientation: "horizontal"
  }
});
const statSlotRecipe = defineSlotRecipe({
  className: "chakra-stat",
  slots: statAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      gap: "1",
      position: "relative",
      flex: "1"
    },
    label: {
      display: "inline-flex",
      gap: "1.5",
      alignItems: "center",
      color: "fg.muted",
      textStyle: "sm"
    },
    helpText: {
      color: "fg.muted",
      textStyle: "xs"
    },
    valueUnit: {
      color: "fg.muted",
      textStyle: "xs",
      fontWeight: "initial",
      letterSpacing: "initial"
    },
    valueText: {
      verticalAlign: "baseline",
      fontWeight: "semibold",
      letterSpacing: "tight",
      fontFeatureSettings: "pnum",
      fontVariantNumeric: "proportional-nums",
      display: "inline-flex",
      gap: "1"
    },
    indicator: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      marginEnd: 1,
      "& :where(svg)": {
        w: "1em",
        h: "1em"
      },
      "&[data-type=up]": {
        color: "fg.success"
      },
      "&[data-type=down]": {
        color: "fg.error"
      }
    }
  },
  variants: {
    size: {
      sm: {
        valueText: {
          textStyle: "xl"
        }
      },
      md: {
        valueText: {
          textStyle: "2xl"
        }
      },
      lg: {
        valueText: {
          textStyle: "3xl"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const statusSlotRecipe = defineSlotRecipe({
  className: "chakra-status",
  slots: statusAnatomy.keys(),
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      gap: "2"
    },
    indicator: {
      width: "0.64em",
      height: "0.64em",
      flexShrink: 0,
      borderRadius: "full",
      forcedColorAdjust: "none",
      bg: "colorPalette.solid"
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md"
  }
});
const stepsSlotRecipe = defineSlotRecipe({
  className: "chakra-steps",
  slots: stepsAnatomy.keys(),
  base: {
    root: {
      display: "flex",
      width: "full"
    },
    list: {
      display: "flex",
      justifyContent: "space-between",
      "--steps-gutter": "spacing.3",
      "--steps-thickness": "2px"
    },
    title: {
      fontWeight: "medium",
      color: "fg"
    },
    description: {
      color: "fg.muted"
    },
    separator: {
      bg: "border",
      flex: "1"
    },
    indicator: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexShrink: "0",
      borderRadius: "full",
      fontWeight: "medium",
      width: "var(--steps-size)",
      height: "var(--steps-size)",
      _icon: {
        flexShrink: "0",
        width: "var(--steps-icon-size)",
        height: "var(--steps-icon-size)"
      }
    },
    item: {
      position: "relative",
      display: "flex",
      gap: "3",
      flex: "1 0 0",
      "&:last-of-type": {
        flex: "initial",
        "& [data-part=separator]": {
          display: "none"
        }
      }
    },
    trigger: {
      display: "flex",
      alignItems: "center",
      gap: "3",
      textAlign: "start",
      focusVisibleRing: "outside",
      borderRadius: "l2"
    },
    content: {
      focusVisibleRing: "outside"
    }
  },
  variants: {
    orientation: {
      vertical: {
        root: {
          flexDirection: "row",
          height: "100%"
        },
        list: {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        separator: {
          position: "absolute",
          width: "var(--steps-thickness)",
          height: "100%",
          maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
          top: "calc(var(--steps-size) + var(--steps-gutter))",
          insetStart: "calc(var(--steps-size) / 2 - 1px)"
        },
        item: {
          alignItems: "flex-start"
        }
      },
      horizontal: {
        root: {
          flexDirection: "column",
          width: "100%"
        },
        list: {
          flexDirection: "row",
          alignItems: "center"
        },
        separator: {
          width: "100%",
          height: "var(--steps-thickness)",
          marginX: "var(--steps-gutter)"
        },
        item: {
          alignItems: "center"
        }
      }
    },
    variant: {
      solid: {
        indicator: {
          _incomplete: {
            borderWidth: "var(--steps-thickness)"
          },
          _current: {
            bg: "colorPalette.muted",
            borderWidth: "var(--steps-thickness)",
            borderColor: "colorPalette.solid",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.solid",
            borderColor: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.solid"
          }
        }
      },
      subtle: {
        indicator: {
          _incomplete: {
            bg: "bg.muted"
          },
          _current: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          },
          _complete: {
            bg: "colorPalette.emphasized",
            color: "colorPalette.fg"
          }
        },
        separator: {
          _complete: {
            bg: "colorPalette.emphasized"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          gap: "2.5"
        },
        list: {
          "--steps-size": "sizes.6",
          "--steps-icon-size": "sizes.3.5",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      sm: {
        root: {
          gap: "3"
        },
        list: {
          "--steps-size": "sizes.8",
          "--steps-icon-size": "sizes.4",
          textStyle: "xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      md: {
        root: {
          gap: "4"
        },
        list: {
          "--steps-size": "sizes.10",
          "--steps-icon-size": "sizes.4",
          textStyle: "sm"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          gap: "6"
        },
        list: {
          "--steps-size": "sizes.11",
          "--steps-icon-size": "sizes.5",
          textStyle: "md"
        },
        title: {
          textStyle: "md"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid",
    orientation: "horizontal"
  }
});
const switchSlotRecipe = defineSlotRecipe({
  slots: switchAnatomy.keys(),
  className: "chakra-switch",
  base: {
    root: {
      display: "inline-flex",
      gap: "2.5",
      alignItems: "center",
      position: "relative",
      verticalAlign: "middle",
      "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
      "--switch-x": {
        base: "var(--switch-diff)",
        _rtl: "calc(var(--switch-diff) * -1)"
      }
    },
    label: {
      lineHeight: "1",
      userSelect: "none",
      fontSize: "sm",
      fontWeight: "medium",
      _disabled: {
        opacity: "0.5"
      }
    },
    indicator: {
      position: "absolute",
      height: "var(--switch-height)",
      width: "var(--switch-height)",
      fontSize: "var(--switch-indicator-font-size)",
      fontWeight: "medium",
      flexShrink: 0,
      userSelect: "none",
      display: "grid",
      placeContent: "center",
      transition: "inset-inline-start 0.12s ease",
      insetInlineStart: "calc(var(--switch-x) - 2px)",
      _checked: {
        insetInlineStart: "2px"
      }
    },
    control: {
      display: "inline-flex",
      gap: "0.5rem",
      flexShrink: 0,
      justifyContent: "flex-start",
      cursor: "switch",
      borderRadius: "full",
      position: "relative",
      width: "var(--switch-width)",
      height: "var(--switch-height)",
      transition: "backgrounds",
      _disabled: {
        opacity: "0.5",
        cursor: "not-allowed"
      },
      _invalid: {
        outline: "2px solid",
        outlineColor: "border.error",
        outlineOffset: "2px"
      }
    },
    thumb: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      transitionProperty: "translate",
      transitionDuration: "fast",
      borderRadius: "inherit",
      _checked: {
        translate: "var(--switch-x) 0"
      }
    }
  },
  variants: {
    variant: {
      solid: {
        control: {
          borderRadius: "full",
          bg: "bg.emphasized",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        },
        thumb: {
          bg: "white",
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          scale: "0.8",
          boxShadow: "sm",
          _checked: {
            bg: "colorPalette.contrast"
          }
        }
      },
      raised: {
        control: {
          borderRadius: "full",
          height: "calc(var(--switch-height) / 2)",
          bg: "bg.muted",
          boxShadow: "inset",
          _checked: {
            bg: "colorPalette.solid/60"
          }
        },
        thumb: {
          width: "var(--switch-height)",
          height: "var(--switch-height)",
          position: "relative",
          top: "calc(var(--switch-height) * -0.25)",
          bg: "white",
          boxShadow: "xs",
          focusVisibleRing: "outside",
          _checked: {
            bg: "colorPalette.solid"
          }
        }
      }
    },
    size: {
      xs: {
        root: {
          "--switch-width": "sizes.6",
          "--switch-height": "sizes.3",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      sm: {
        root: {
          "--switch-width": "sizes.8",
          "--switch-height": "sizes.4",
          "--switch-indicator-font-size": "fontSizes.xs"
        }
      },
      md: {
        root: {
          "--switch-width": "sizes.10",
          "--switch-height": "sizes.5",
          "--switch-indicator-font-size": "fontSizes.sm"
        }
      },
      lg: {
        root: {
          "--switch-width": "sizes.12",
          "--switch-height": "sizes.6",
          "--switch-indicator-font-size": "fontSizes.md"
        }
      }
    }
  },
  defaultVariants: {
    variant: "solid",
    size: "md"
  }
});
const tableSlotRecipe = defineSlotRecipe({
  className: "chakra-table",
  slots: tableAnatomy.keys(),
  base: {
    root: {
      fontVariantNumeric: "lining-nums tabular-nums",
      borderCollapse: "collapse",
      width: "full",
      textAlign: "start",
      verticalAlign: "top"
    },
    row: {
      _selected: {
        bg: "colorPalette.subtle"
      }
    },
    cell: {
      textAlign: "start",
      alignItems: "center"
    },
    columnHeader: {
      fontWeight: "medium",
      textAlign: "start",
      color: "fg"
    },
    caption: {
      fontWeight: "medium",
      textStyle: "xs"
    },
    footer: {
      fontWeight: "medium"
    }
  },
  variants: {
    interactive: {
      true: {
        body: {
          "& tr": {
            _hover: {
              bg: "colorPalette.subtle"
            }
          }
        }
      }
    },
    stickyHeader: {
      true: {
        header: {
          "& :where(tr)": {
            top: "var(--table-sticky-offset, 0)",
            position: "sticky",
            zIndex: 1
          }
        }
      }
    },
    striped: {
      true: {
        row: {
          "&:nth-of-type(odd) td": {
            bg: "bg.muted"
          }
        }
      }
    },
    showColumnBorder: {
      true: {
        columnHeader: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        },
        cell: {
          "&:not(:last-of-type)": {
            borderInlineEndWidth: "1px"
          }
        }
      }
    },
    variant: {
      line: {
        columnHeader: {
          borderBottomWidth: "1px"
        },
        cell: {
          borderBottomWidth: "1px"
        },
        row: {
          bg: "bg"
        }
      },
      outline: {
        root: {
          boxShadow: "0 0 0 1px {colors.border}",
          overflow: "hidden"
        },
        columnHeader: {
          borderBottomWidth: "1px"
        },
        header: {
          bg: "bg.muted"
        },
        row: {
          "&:not(:last-of-type)": {
            borderBottomWidth: "1px"
          }
        },
        footer: {
          borderTopWidth: "1px"
        }
      }
    },
    size: {
      sm: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "2",
          py: "2"
        },
        cell: {
          px: "2",
          py: "2"
        }
      },
      md: {
        root: {
          textStyle: "sm"
        },
        columnHeader: {
          px: "3",
          py: "3"
        },
        cell: {
          px: "3",
          py: "3"
        }
      },
      lg: {
        root: {
          textStyle: "md"
        },
        columnHeader: {
          px: "4",
          py: "3"
        },
        cell: {
          px: "4",
          py: "3"
        }
      }
    }
  },
  defaultVariants: {
    variant: "line",
    size: "md"
  }
});
const tabsSlotRecipe = defineSlotRecipe({
  slots: tabsAnatomy.keys(),
  className: "chakra-tabs",
  base: {
    root: {
      "--tabs-trigger-radius": "radii.l2",
      position: "relative",
      _horizontal: {
        display: "block"
      },
      _vertical: {
        display: "flex"
      }
    },
    list: {
      display: "inline-flex",
      position: "relative",
      isolation: "isolate",
      "--tabs-indicator-shadow": "shadows.xs",
      "--tabs-indicator-bg": "colors.bg",
      minH: "var(--tabs-height)",
      _horizontal: {
        flexDirection: "row"
      },
      _vertical: {
        flexDirection: "column"
      }
    },
    trigger: {
      outline: "0",
      minW: "var(--tabs-height)",
      height: "var(--tabs-height)",
      display: "flex",
      alignItems: "center",
      fontWeight: "medium",
      position: "relative",
      cursor: "button",
      gap: "2",
      _focusVisible: {
        zIndex: 1,
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing"
      },
      _disabled: {
        cursor: "not-allowed",
        opacity: 0.5
      }
    },
    content: {
      focusVisibleRing: "inside",
      _horizontal: {
        width: "100%",
        pt: "var(--tabs-content-padding)"
      },
      _vertical: {
        height: "100%",
        ps: "var(--tabs-content-padding)"
      }
    },
    indicator: {
      width: "var(--width)",
      height: "var(--height)",
      borderRadius: "var(--tabs-indicator-radius)",
      bg: "var(--tabs-indicator-bg)",
      shadow: "var(--tabs-indicator-shadow)",
      zIndex: -1
    }
  },
  variants: {
    fitted: {
      true: {
        list: {
          display: "flex"
        },
        trigger: {
          flex: 1,
          textAlign: "center",
          justifyContent: "center"
        }
      }
    },
    justify: {
      start: {
        list: {
          justifyContent: "flex-start"
        }
      },
      center: {
        list: {
          justifyContent: "center"
        }
      },
      end: {
        list: {
          justifyContent: "flex-end"
        }
      }
    },
    size: {
      sm: {
        root: {
          "--tabs-height": "sizes.9",
          "--tabs-content-padding": "spacing.3"
        },
        trigger: {
          py: "1",
          px: "3",
          textStyle: "sm"
        }
      },
      md: {
        root: {
          "--tabs-height": "sizes.10",
          "--tabs-content-padding": "spacing.4"
        },
        trigger: {
          py: "2",
          px: "4",
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--tabs-height": "sizes.11",
          "--tabs-content-padding": "spacing.4.5"
        },
        trigger: {
          py: "2",
          px: "4.5",
          textStyle: "md"
        }
      }
    },
    variant: {
      line: {
        list: {
          display: "flex",
          borderColor: "border",
          _horizontal: {
            borderBottomWidth: "1px"
          },
          _vertical: {
            borderEndWidth: "1px"
          }
        },
        trigger: {
          color: "fg.muted",
          _disabled: {
            _active: { bg: "initial" }
          },
          _selected: {
            color: "fg",
            _horizontal: {
              layerStyle: "indicator.bottom",
              "--indicator-offset-y": "-1px",
              "--indicator-color": "colors.colorPalette.solid"
            },
            _vertical: {
              layerStyle: "indicator.end",
              "--indicator-offset-x": "-1px"
            }
          }
        }
      },
      subtle: {
        trigger: {
          borderRadius: "var(--tabs-trigger-radius)",
          color: "fg.muted",
          _selected: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        }
      },
      enclosed: {
        list: {
          bg: "bg.muted",
          padding: "1",
          borderRadius: "l3",
          minH: "calc(var(--tabs-height) - 4px)"
        },
        trigger: {
          justifyContent: "center",
          color: "fg.muted",
          borderRadius: "var(--tabs-trigger-radius)",
          _selected: {
            bg: "bg",
            color: "colorPalette.fg",
            shadow: "xs"
          }
        }
      },
      outline: {
        list: {
          "--line-thickness": "1px",
          "--line-offset": "calc(var(--line-thickness) * -1)",
          borderColor: "border",
          display: "flex",
          _horizontal: {
            _before: {
              content: '""',
              position: "absolute",
              bottom: "0px",
              width: "100%",
              borderBottomWidth: "var(--line-thickness)",
              borderBottomColor: "border"
            }
          },
          _vertical: {
            _before: {
              content: '""',
              position: "absolute",
              insetInline: "var(--line-offset)",
              height: "calc(100% - calc(var(--line-thickness) * 2))",
              borderEndWidth: "var(--line-thickness)",
              borderEndColor: "border"
            }
          }
        },
        trigger: {
          color: "fg.muted",
          borderWidth: "1px",
          borderColor: "transparent",
          _selected: {
            bg: "currentBg",
            color: "colorPalette.fg"
          },
          _horizontal: {
            borderTopRadius: "var(--tabs-trigger-radius)",
            marginBottom: "var(--line-offset)",
            marginEnd: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderBottomColor: "transparent"
            }
          },
          _vertical: {
            borderStartRadius: "var(--tabs-trigger-radius)",
            marginEnd: "var(--line-offset)",
            marginBottom: { _notLast: "var(--line-offset)" },
            _selected: {
              borderColor: "border",
              borderEndColor: "transparent"
            }
          }
        }
      },
      plain: {
        trigger: {
          color: "fg.muted",
          _selected: {
            color: "colorPalette.fg"
          },
          borderRadius: "var(--tabs-trigger-radius)",
          "&[data-selected][data-ssr]": {
            bg: "var(--tabs-indicator-bg)",
            shadow: "var(--tabs-indicator-shadow)",
            borderRadius: "var(--tabs-indicator-radius)"
          }
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "line"
  }
});
const badgeVariant = badgeRecipe.variants?.variant;
const tagSlotRecipe = defineSlotRecipe({
  slots: tagAnatomy.keys(),
  className: "chakra-tag",
  base: {
    root: {
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      maxWidth: "100%",
      userSelect: "none",
      borderRadius: "l2",
      focusVisibleRing: "outside"
    },
    label: {
      lineClamp: "1"
    },
    closeTrigger: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      borderRadius: "l1",
      color: "currentColor",
      focusVisibleRing: "inside",
      focusRingWidth: "2px"
    },
    startElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      ms: "var(--tag-element-offset)",
      "&:has([data-scope=avatar])": {
        boxSize: "var(--tag-avatar-size)",
        ms: "calc(var(--tag-element-offset) * 1.5)"
      },
      _icon: { boxSize: "100%" }
    },
    endElement: {
      flexShrink: 0,
      boxSize: "var(--tag-element-size)",
      me: "var(--tag-element-offset)",
      _icon: { boxSize: "100%" },
      "&:has(button)": {
        ms: "calc(var(--tag-element-offset) * -1)"
      }
    }
  },
  variants: {
    size: {
      sm: {
        root: {
          px: "1.5",
          minH: "4.5",
          gap: "1",
          "--tag-avatar-size": "spacing.3",
          "--tag-element-size": "spacing.3",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          px: "1.5",
          minH: "5",
          gap: "1",
          "--tag-avatar-size": "spacing.3.5",
          "--tag-element-size": "spacing.3.5",
          "--tag-element-offset": "-2px"
        },
        label: {
          textStyle: "xs"
        }
      },
      lg: {
        root: {
          px: "2",
          minH: "6",
          gap: "1.5",
          "--tag-avatar-size": "spacing.4.5",
          "--tag-element-size": "spacing.4",
          "--tag-element-offset": "-3px"
        },
        label: {
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          px: "2.5",
          minH: "8",
          gap: "1.5",
          "--tag-avatar-size": "spacing.6",
          "--tag-element-size": "spacing.4.5",
          "--tag-element-offset": "-4px"
        },
        label: {
          textStyle: "sm"
        }
      }
    },
    variant: {
      subtle: {
        root: badgeVariant?.subtle
      },
      solid: {
        root: badgeVariant?.solid
      },
      outline: {
        root: badgeVariant?.outline
      },
      surface: {
        root: badgeVariant?.surface
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "surface"
  }
});
const timelineSlotRecipe = defineSlotRecipe({
  slots: timelineAnatomy.keys(),
  className: "chakra-timeline",
  base: {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "full",
      "--timeline-thickness": "1px",
      "--timeline-gutter": "4px"
    },
    item: {
      display: "flex",
      position: "relative",
      alignItems: "flex-start",
      flexShrink: 0,
      gap: "4",
      _last: {
        "& :where(.chakra-timeline__separator)": { display: "none" }
      }
    },
    separator: {
      position: "absolute",
      borderStartWidth: "var(--timeline-thickness)",
      ms: "calc(-1 * var(--timeline-thickness) / 2)",
      insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
      insetBlock: "0",
      borderColor: "border"
    },
    indicator: {
      outline: "2px solid {colors.bg}",
      position: "relative",
      flexShrink: "0",
      boxSize: "var(--timeline-indicator-size)",
      fontSize: "var(--timeline-font-size)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "full",
      fontWeight: "medium"
    },
    connector: {
      alignSelf: "stretch",
      position: "relative"
    },
    content: {
      pb: "6",
      display: "flex",
      flexDirection: "column",
      width: "full",
      gap: "2"
    },
    title: {
      display: "flex",
      fontWeight: "medium",
      flexWrap: "wrap",
      gap: "1.5",
      alignItems: "center",
      mt: "var(--timeline-margin)"
    },
    description: {
      color: "fg.muted",
      textStyle: "xs"
    }
  },
  variants: {
    variant: {
      subtle: {
        indicator: {
          bg: "colorPalette.muted"
        }
      },
      solid: {
        indicator: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        }
      },
      outline: {
        indicator: {
          bg: "currentBg",
          borderWidth: "1px",
          borderColor: "colorPalette.muted"
        }
      },
      plain: {}
    },
    size: {
      sm: {
        root: {
          "--timeline-indicator-size": "sizes.4",
          "--timeline-font-size": "fontSizes.2xs"
        },
        title: {
          textStyle: "xs"
        }
      },
      md: {
        root: {
          "--timeline-indicator-size": "sizes.5",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          textStyle: "sm"
        }
      },
      lg: {
        root: {
          "--timeline-indicator-size": "sizes.6",
          "--timeline-font-size": "fontSizes.xs"
        },
        title: {
          mt: "0.5",
          textStyle: "sm"
        }
      },
      xl: {
        root: {
          "--timeline-indicator-size": "sizes.8",
          "--timeline-font-size": "fontSizes.sm"
        },
        title: {
          mt: "1.5",
          textStyle: "sm"
        }
      }
    }
  },
  defaultVariants: {
    size: "md",
    variant: "solid"
  }
});
const toastSlotRecipe = defineSlotRecipe({
  slots: toastAnatomy.keys(),
  className: "chakra-toast",
  base: {
    root: {
      width: "full",
      display: "flex",
      alignItems: "flex-start",
      position: "relative",
      gap: "3",
      py: "4",
      ps: "4",
      pe: "6",
      borderRadius: "l2",
      translate: "var(--x) var(--y)",
      scale: "var(--scale)",
      zIndex: "var(--z-index)",
      height: "var(--height)",
      opacity: "var(--opacity)",
      willChange: "translate, opacity, scale",
      transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
      transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
      _closed: {
        transition: "translate 400ms, scale 400ms, opacity 200ms",
        transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
      },
      bg: "bg.panel",
      color: "fg",
      boxShadow: "xl",
      "--toast-trigger-bg": "colors.bg.muted",
      "&[data-type=warning]": {
        bg: "orange.solid",
        color: "orange.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=success]": {
        bg: "green.solid",
        color: "green.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      },
      "&[data-type=error]": {
        bg: "red.solid",
        color: "red.contrast",
        "--toast-trigger-bg": "{white/10}",
        "--toast-border-color": "{white/40}"
      }
    },
    title: {
      fontWeight: "medium",
      textStyle: "sm",
      marginEnd: "2"
    },
    description: {
      display: "inline",
      textStyle: "sm",
      opacity: "0.8"
    },
    indicator: {
      flexShrink: "0",
      boxSize: "5"
    },
    actionTrigger: {
      textStyle: "sm",
      fontWeight: "medium",
      height: "8",
      px: "3",
      borderRadius: "l2",
      alignSelf: "center",
      borderWidth: "1px",
      borderColor: "var(--toast-border-color, inherit)",
      transition: "background 200ms",
      _hover: {
        bg: "var(--toast-trigger-bg)"
      }
    },
    closeTrigger: {
      position: "absolute",
      top: "1",
      insetEnd: "1",
      padding: "1",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      color: "{currentColor/60}",
      borderRadius: "l2",
      textStyle: "md",
      transition: "background 200ms",
      _icon: {
        boxSize: "1em"
      }
    }
  }
});
const tooltipSlotRecipe = defineSlotRecipe({
  slots: anatomy.keys(),
  className: "chakra-tooltip",
  base: {
    content: {
      "--tooltip-bg": "colors.bg.inverted",
      bg: "var(--tooltip-bg)",
      color: "fg.inverted",
      px: "2.5",
      py: "1",
      borderRadius: "l2",
      fontWeight: "medium",
      textStyle: "xs",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip",
      transformOrigin: "var(--transform-origin)",
      _open: {
        animationStyle: "scale-fade-in",
        animationDuration: "fast"
      },
      _closed: {
        animationStyle: "scale-fade-out",
        animationDuration: "fast"
      }
    },
    arrow: {
      "--arrow-size": "sizes.2",
      "--arrow-background": "var(--tooltip-bg)"
    },
    arrowTip: {
      borderTopWidth: "1px",
      borderInlineStartWidth: "1px",
      borderColor: "var(--tooltip-bg)"
    }
  }
});
const slotRecipes = {
  accordion: accordionSlotRecipe,
  actionBar: actionBarSlotRecipe,
  alert: alertSlotRecipe,
  avatar: avatarSlotRecipe,
  blockquote: blockquoteSlotRecipe,
  breadcrumb: breadcrumbSlotRecipe,
  card: cardSlotRecipe,
  checkbox: checkboxSlotRecipe,
  checkboxCard: checkboxCardSlotRecipe,
  collapsible: collapsibleSlotRecipe,
  dataList: dataListSlotRecipe,
  dialog: dialogSlotRecipe,
  drawer: drawerSlotRecipe,
  editable: editableSlotRecipe,
  emptyState: emptyStateSlotRecipe,
  field: fieldSlotRecipe,
  fieldset: fieldsetSlotRecipe,
  fileUpload: fileUploadSlotRecipe,
  hoverCard: hoverCardSlotRecipe,
  list: listSlotRecipe,
  menu: menuSlotRecipe,
  nativeSelect: nativeSelectSlotRecipe,
  numberInput: numberInputSlotRecipe,
  pinInput: pinInputSlotRecipe,
  popover: popoverSlotRecipe,
  progress: progressSlotRecipe,
  progressCircle: progressCircleSlotRecipe,
  radioCard: radioCardSlotRecipe,
  radioGroup: radioGroupSlotRecipe,
  ratingGroup: ratingGroupSlotRecipe,
  segmentGroup: segmentGroupSlotRecipe,
  select: selectSlotRecipe,
  slider: sliderSlotRecipe,
  stat: statSlotRecipe,
  steps: stepsSlotRecipe,
  switch: switchSlotRecipe,
  table: tableSlotRecipe,
  tabs: tabsSlotRecipe,
  tag: tagSlotRecipe,
  toast: toastSlotRecipe,
  tooltip: tooltipSlotRecipe,
  status: statusSlotRecipe,
  timeline: timelineSlotRecipe,
  colorPicker: colorPickerSlotRecipe,
  qrCode: qrCodeSlotRecipe
};
const textStyles = defineTextStyles({
  "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
  xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
  sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
  md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
  lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
  xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
  "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
  "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
  "4xl": {
    value: {
      fontSize: "4xl",
      lineHeight: "2.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "5xl": {
    value: {
      fontSize: "5xl",
      lineHeight: "3.75rem",
      letterSpacing: "-0.025em"
    }
  },
  "6xl": {
    value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
  },
  "7xl": {
    value: {
      fontSize: "7xl",
      lineHeight: "5.75rem",
      letterSpacing: "-0.025em"
    }
  },
  none: {
    value: {}
  },
  label: {
    value: {
      fontSize: "sm",
      lineHeight: "1.25rem",
      fontWeight: "medium"
    }
  }
});
const animations = defineTokens.animations({
  spin: { value: "spin 1s linear infinite" },
  ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
  pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
  bounce: { value: "bounce 1s infinite" }
});
const aspectRatios = defineTokens.aspectRatios({
  square: { value: "1 / 1" },
  landscape: { value: "4 / 3" },
  portrait: { value: "3 / 4" },
  wide: { value: "16 / 9" },
  ultrawide: { value: "18 / 5" },
  golden: { value: "1.618 / 1" }
});
const blurs = defineTokens.blurs({
  none: { value: " " },
  sm: { value: "4px" },
  md: { value: "8px" },
  lg: { value: "12px" },
  xl: { value: "16px" },
  "2xl": { value: "24px" },
  "3xl": { value: "40px" },
  "4xl": { value: "64px" }
});
const borders = defineTokens.borders({
  xs: { value: "0.5px solid" },
  sm: { value: "1px solid" },
  md: { value: "2px solid" },
  lg: { value: "4px solid" },
  xl: { value: "8px solid" }
});
const colors = defineTokens.colors({
  transparent: { value: "transparent" },
  current: { value: "currentColor" },
  black: { value: "#09090B" },
  white: { value: "#FFFFFF" },
  whiteAlpha: {
    50: { value: "rgba(255, 255, 255, 0.04)" },
    100: { value: "rgba(255, 255, 255, 0.06)" },
    200: { value: "rgba(255, 255, 255, 0.08)" },
    300: { value: "rgba(255, 255, 255, 0.16)" },
    400: { value: "rgba(255, 255, 255, 0.24)" },
    500: { value: "rgba(255, 255, 255, 0.36)" },
    600: { value: "rgba(255, 255, 255, 0.48)" },
    700: { value: "rgba(255, 255, 255, 0.64)" },
    800: { value: "rgba(255, 255, 255, 0.80)" },
    900: { value: "rgba(255, 255, 255, 0.92)" },
    950: { value: "rgba(255, 255, 255, 0.95)" }
  },
  blackAlpha: {
    50: { value: "rgba(0, 0, 0, 0.04)" },
    100: { value: "rgba(0, 0, 0, 0.06)" },
    200: { value: "rgba(0, 0, 0, 0.08)" },
    300: { value: "rgba(0, 0, 0, 0.16)" },
    400: { value: "rgba(0, 0, 0, 0.24)" },
    500: { value: "rgba(0, 0, 0, 0.36)" },
    600: { value: "rgba(0, 0, 0, 0.48)" },
    700: { value: "rgba(0, 0, 0, 0.64)" },
    800: { value: "rgba(0, 0, 0, 0.80)" },
    900: { value: "rgba(0, 0, 0, 0.92)" },
    950: { value: "rgba(0, 0, 0, 0.95)" }
  },
  gray: {
    50: { value: "#fafafa" },
    100: { value: "#f4f4f5" },
    200: { value: "#e4e4e7" },
    300: { value: "#d4d4d8" },
    400: { value: "#a1a1aa" },
    500: { value: "#71717a" },
    600: { value: "#52525b" },
    700: { value: "#3f3f46" },
    800: { value: "#27272a" },
    900: { value: "#18181b" },
    950: { value: "#111111" }
  },
  red: {
    50: { value: "#fef2f2" },
    100: { value: "#fee2e2" },
    200: { value: "#fecaca" },
    300: { value: "#fca5a5" },
    400: { value: "#f87171" },
    500: { value: "#ef4444" },
    600: { value: "#dc2626" },
    700: { value: "#991919" },
    800: { value: "#511111" },
    900: { value: "#300c0c" },
    950: { value: "#1f0808" }
  },
  orange: {
    50: { value: "#fff7ed" },
    100: { value: "#ffedd5" },
    200: { value: "#fed7aa" },
    300: { value: "#fdba74" },
    400: { value: "#fb923c" },
    500: { value: "#f97316" },
    600: { value: "#ea580c" },
    700: { value: "#92310a" },
    800: { value: "#6c2710" },
    900: { value: "#3b1106" },
    950: { value: "#220a04" }
  },
  yellow: {
    50: { value: "#fefce8" },
    100: { value: "#fef9c3" },
    200: { value: "#fef08a" },
    300: { value: "#fde047" },
    400: { value: "#facc15" },
    500: { value: "#eab308" },
    600: { value: "#ca8a04" },
    700: { value: "#845209" },
    800: { value: "#713f12" },
    900: { value: "#422006" },
    950: { value: "#281304" }
  },
  green: {
    50: { value: "#f0fdf4" },
    100: { value: "#dcfce7" },
    200: { value: "#bbf7d0" },
    300: { value: "#86efac" },
    400: { value: "#4ade80" },
    500: { value: "#22c55e" },
    600: { value: "#16a34a" },
    700: { value: "#116932" },
    800: { value: "#124a28" },
    900: { value: "#042713" },
    950: { value: "#03190c" }
  },
  teal: {
    50: { value: "#f0fdfa" },
    100: { value: "#ccfbf1" },
    200: { value: "#99f6e4" },
    300: { value: "#5eead4" },
    400: { value: "#2dd4bf" },
    500: { value: "#14b8a6" },
    600: { value: "#0d9488" },
    700: { value: "#0c5d56" },
    800: { value: "#114240" },
    900: { value: "#032726" },
    950: { value: "#021716" }
  },
  blue: {
    50: { value: "#eff6ff" },
    100: { value: "#dbeafe" },
    200: { value: "#bfdbfe" },
    300: { value: "#a3cfff" },
    400: { value: "#60a5fa" },
    500: { value: "#3b82f6" },
    600: { value: "#2563eb" },
    700: { value: "#173da6" },
    800: { value: "#1a3478" },
    900: { value: "#14204a" },
    950: { value: "#0c142e" }
  },
  cyan: {
    50: { value: "#ecfeff" },
    100: { value: "#cffafe" },
    200: { value: "#a5f3fc" },
    300: { value: "#67e8f9" },
    400: { value: "#22d3ee" },
    500: { value: "#06b6d4" },
    600: { value: "#0891b2" },
    700: { value: "#0c5c72" },
    800: { value: "#134152" },
    900: { value: "#072a38" },
    950: { value: "#051b24" }
  },
  purple: {
    50: { value: "#faf5ff" },
    100: { value: "#f3e8ff" },
    200: { value: "#e9d5ff" },
    300: { value: "#d8b4fe" },
    400: { value: "#c084fc" },
    500: { value: "#a855f7" },
    600: { value: "#9333ea" },
    700: { value: "#641ba3" },
    800: { value: "#4a1772" },
    900: { value: "#2f0553" },
    950: { value: "#1a032e" }
  },
  pink: {
    50: { value: "#fdf2f8" },
    100: { value: "#fce7f3" },
    200: { value: "#fbcfe8" },
    300: { value: "#f9a8d4" },
    400: { value: "#f472b6" },
    500: { value: "#ec4899" },
    600: { value: "#db2777" },
    700: { value: "#a41752" },
    800: { value: "#6d0e34" },
    900: { value: "#45061f" },
    950: { value: "#2c0514" }
  }
});
const cursor = defineTokens.cursor({
  button: { value: "pointer" },
  checkbox: { value: "default" },
  disabled: { value: "not-allowed" },
  menuitem: { value: "default" },
  option: { value: "default" },
  radio: { value: "default" },
  slider: { value: "default" },
  switch: { value: "pointer" }
});
const durations = defineTokens.durations({
  fastest: { value: "50ms" },
  faster: { value: "100ms" },
  fast: { value: "150ms" },
  moderate: { value: "200ms" },
  slow: { value: "300ms" },
  slower: { value: "400ms" },
  slowest: { value: "500ms" }
});
const easings = defineTokens.easings({
  "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
  "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
  "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
  "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
});
const fontSizes = defineTokens.fontSizes({
  "2xs": { value: "0.625rem" },
  xs: { value: "0.75rem" },
  sm: { value: "0.875rem" },
  md: { value: "1rem" },
  lg: { value: "1.125rem" },
  xl: { value: "1.25rem" },
  "2xl": { value: "1.5rem" },
  "3xl": { value: "1.875rem" },
  "4xl": { value: "2.25rem" },
  "5xl": { value: "3rem" },
  "6xl": { value: "3.75rem" },
  "7xl": { value: "4.5rem" },
  "8xl": { value: "6rem" },
  "9xl": { value: "8rem" }
});
const fontWeights = defineTokens.fontWeights({
  thin: { value: "100" },
  extralight: { value: "200" },
  light: { value: "300" },
  normal: { value: "400" },
  medium: { value: "500" },
  semibold: { value: "600" },
  bold: { value: "700" },
  extrabold: { value: "800" },
  black: { value: "900" }
});
const fallback = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
const fonts = defineTokens.fonts({
  heading: {
    value: `Inter, ${fallback}`
  },
  body: {
    value: `Inter, ${fallback}`
  },
  mono: {
    value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
  }
});
const keyframes = defineKeyframes({
  spin: {
    "0%": { transform: "rotate(0deg)" },
    "100%": { transform: "rotate(360deg)" }
  },
  pulse: {
    "50%": { opacity: "0.5" }
  },
  ping: {
    "75%, 100%": {
      transform: "scale(2)",
      opacity: "0"
    }
  },
  bounce: {
    "0%, 100%": {
      transform: "translateY(-25%)",
      animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
    },
    "50%": {
      transform: "none",
      animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
    }
  },
  "bg-position": {
    from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
    to: { backgroundPosition: "var(--animate-to, 0) 0" }
  },
  position: {
    from: {
      insetInlineStart: "var(--animate-from-x)",
      insetBlockStart: "var(--animate-from-y)"
    },
    to: {
      insetInlineStart: "var(--animate-to-x)",
      insetBlockStart: "var(--animate-to-y)"
    }
  },
  "circular-progress": {
    "0%": {
      strokeDasharray: "1, 400",
      strokeDashoffset: "0"
    },
    "50%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-100%"
    },
    "100%": {
      strokeDasharray: "400, 400",
      strokeDashoffset: "-260%"
    }
  },
  // collapse
  "expand-height": {
    from: { height: "0" },
    to: { height: "var(--height)" }
  },
  "collapse-height": {
    from: { height: "var(--height)" },
    to: { height: "0" }
  },
  "expand-width": {
    from: { width: "0" },
    to: { width: "var(--width)" }
  },
  "collapse-width": {
    from: { height: "var(--width)" },
    to: { height: "0" }
  },
  // fade
  "fade-in": {
    from: { opacity: 0 },
    to: { opacity: 1 }
  },
  "fade-out": {
    from: { opacity: 1 },
    to: { opacity: 0 }
  },
  // slide from (full)
  "slide-from-left-full": {
    from: { translate: "-100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-right-full": {
    from: { translate: "100% 0" },
    to: { translate: "0 0" }
  },
  "slide-from-top-full": {
    from: { translate: "0 -100%" },
    to: { translate: "0 0" }
  },
  "slide-from-bottom-full": {
    from: { translate: "0 100%" },
    to: { translate: "0 0" }
  },
  // slide to (full)
  "slide-to-left-full": {
    from: { translate: "0 0" },
    to: { translate: "-100% 0" }
  },
  "slide-to-right-full": {
    from: { translate: "0 0" },
    to: { translate: "100% 0" }
  },
  "slide-to-top-full": {
    from: { translate: "0 0" },
    to: { translate: "0 -100%" }
  },
  "slide-to-bottom-full": {
    from: { translate: "0 0" },
    to: { translate: "0 100%" }
  },
  // slide from
  "slide-from-top": {
    "0%": { translate: "0 -0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-bottom": {
    "0%": { translate: "0 0.5rem" },
    to: { translate: "0" }
  },
  "slide-from-left": {
    "0%": { translate: "-0.5rem 0" },
    to: { translate: "0" }
  },
  "slide-from-right": {
    "0%": { translate: "0.5rem 0" },
    to: { translate: "0" }
  },
  // slide to
  "slide-to-top": {
    "0%": { translate: "0" },
    to: { translate: "0 -0.5rem" }
  },
  "slide-to-bottom": {
    "0%": { translate: "0" },
    to: { translate: "0 0.5rem" }
  },
  "slide-to-left": {
    "0%": { translate: "0" },
    to: { translate: "-0.5rem 0" }
  },
  "slide-to-right": {
    "0%": { translate: "0" },
    to: { translate: "0.5rem 0" }
  },
  // scale
  "scale-in": {
    from: { scale: "0.95" },
    to: { scale: "1" }
  },
  "scale-out": {
    from: { scale: "1" },
    to: { scale: "0.95" }
  }
});
const letterSpacings = defineTokens.letterSpacings({
  tighter: { value: "-0.05em" },
  tight: { value: "-0.025em" },
  wide: { value: "0.025em" },
  wider: { value: "0.05em" },
  widest: { value: "0.1em" }
});
const lineHeights = defineTokens.lineHeights({
  shorter: { value: 1.25 },
  short: { value: 1.375 },
  moderate: { value: 1.5 },
  tall: { value: 1.625 },
  taller: { value: 2 }
});
const radii = defineTokens.radii({
  none: { value: "0" },
  "2xs": { value: "0.0625rem" },
  xs: { value: "0.125rem" },
  sm: { value: "0.25rem" },
  md: { value: "0.375rem" },
  lg: { value: "0.5rem" },
  xl: { value: "0.75rem" },
  "2xl": { value: "1rem" },
  "3xl": { value: "1.5rem" },
  "4xl": { value: "2rem" },
  full: { value: "9999px" }
});
const spacing = defineTokens.spacing({
  0.5: { value: "0.125rem" },
  1: { value: "0.25rem" },
  1.5: { value: "0.375rem" },
  2: { value: "0.5rem" },
  2.5: { value: "0.625rem" },
  3: { value: "0.75rem" },
  3.5: { value: "0.875rem" },
  4: { value: "1rem" },
  4.5: { value: "1.125rem" },
  5: { value: "1.25rem" },
  6: { value: "1.5rem" },
  7: { value: "1.75rem" },
  8: { value: "2rem" },
  9: { value: "2.25rem" },
  10: { value: "2.5rem" },
  11: { value: "2.75rem" },
  12: { value: "3rem" },
  14: { value: "3.5rem" },
  16: { value: "4rem" },
  20: { value: "5rem" },
  24: { value: "6rem" },
  28: { value: "7rem" },
  32: { value: "8rem" },
  36: { value: "9rem" },
  40: { value: "10rem" },
  44: { value: "11rem" },
  48: { value: "12rem" },
  52: { value: "13rem" },
  56: { value: "14rem" },
  60: { value: "15rem" },
  64: { value: "16rem" },
  72: { value: "18rem" },
  80: { value: "20rem" },
  96: { value: "24rem" }
});
const largeSizes = defineTokens.sizes({
  "3xs": { value: "14rem" },
  "2xs": { value: "16rem" },
  xs: { value: "20rem" },
  sm: { value: "24rem" },
  md: { value: "28rem" },
  lg: { value: "32rem" },
  xl: { value: "36rem" },
  "2xl": { value: "42rem" },
  "3xl": { value: "48rem" },
  "4xl": { value: "56rem" },
  "5xl": { value: "64rem" },
  "6xl": { value: "72rem" },
  "7xl": { value: "80rem" },
  "8xl": { value: "90rem" }
});
const namedSizes = defineTokens.sizes({
  max: { value: "max-content" },
  min: { value: "min-content" },
  fit: { value: "fit-content" },
  prose: { value: "60ch" },
  full: { value: "100%" },
  dvh: { value: "100dvh" },
  svh: { value: "100svh" },
  lvh: { value: "100lvh" },
  dvw: { value: "100dvw" },
  svw: { value: "100svw" },
  lvw: { value: "100lvw" },
  vw: { value: "100vw" },
  vh: { value: "100vh" }
});
const fractionalSizes = defineTokens.sizes({
  "1/2": { value: "50%" },
  "1/3": { value: "33.333333%" },
  "2/3": { value: "66.666667%" },
  "1/4": { value: "25%" },
  "3/4": { value: "75%" },
  "1/5": { value: "20%" },
  "2/5": { value: "40%" },
  "3/5": { value: "60%" },
  "4/5": { value: "80%" },
  "1/6": { value: "16.666667%" },
  "2/6": { value: "33.333333%" },
  "3/6": { value: "50%" },
  "4/6": { value: "66.666667%" },
  "5/6": { value: "83.333333%" },
  "1/12": { value: "8.333333%" },
  "2/12": { value: "16.666667%" },
  "3/12": { value: "25%" },
  "4/12": { value: "33.333333%" },
  "5/12": { value: "41.666667%" },
  "6/12": { value: "50%" },
  "7/12": { value: "58.333333%" },
  "8/12": { value: "66.666667%" },
  "9/12": { value: "75%" },
  "10/12": { value: "83.333333%" },
  "11/12": { value: "91.666667%" }
});
const sizes = defineTokens.sizes({
  ...largeSizes,
  ...spacing,
  ...fractionalSizes,
  ...namedSizes
});
const zIndices = defineTokens.zIndex({
  hide: { value: -1 },
  base: { value: 0 },
  docked: { value: 10 },
  dropdown: { value: 1e3 },
  sticky: { value: 1100 },
  banner: { value: 1200 },
  overlay: { value: 1300 },
  modal: { value: 1400 },
  popover: { value: 1500 },
  skipNav: { value: 1600 },
  toast: { value: 1700 },
  tooltip: { value: 1800 },
  max: { value: 2147483647 }
});
const defaultThemeConfig = defineConfig({
  preflight: true,
  cssVarsPrefix: "chakra",
  cssVarsRoot: ":where(html, .chakra-theme)",
  globalCss,
  theme: {
    breakpoints,
    keyframes,
    tokens: {
      aspectRatios,
      animations,
      blurs,
      borders,
      colors,
      durations,
      easings,
      fonts,
      fontSizes,
      fontWeights,
      letterSpacings,
      lineHeights,
      radii,
      spacing,
      sizes,
      zIndex: zIndices,
      cursor
    },
    semanticTokens: {
      colors: semanticColors,
      shadows: semanticShadows,
      radii: semanticRadii
    },
    recipes,
    slotRecipes,
    textStyles,
    layerStyles,
    animationStyles
  }
});
const defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
const defaultSystem = createSystem(defaultConfig);
const dataAttr = (condition) => condition ? "" : void 0;
const StyledGroup = chakra("div", {
  base: {
    display: "inline-flex",
    gap: "0.5rem",
    isolation: "isolate",
    position: "relative",
    "& [data-group-item]": {
      _focusVisible: {
        zIndex: 1
      }
    }
  },
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row"
      },
      vertical: {
        flexDirection: "column"
      }
    },
    attached: {
      true: {
        gap: "0!"
      }
    },
    grow: {
      true: {
        display: "flex",
        "& > *": {
          flex: 1
        }
      }
    },
    stacking: {
      "first-on-top": {
        "& > [data-group-item]": {
          zIndex: "calc(var(--group-count) - var(--group-index))"
        }
      },
      "last-on-top": {
        "& > [data-group-item]": {
          zIndex: "var(--group-index)"
        }
      }
    }
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderEndRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginEnd: "-1px"
        },
        "& > *[data-last]": {
          borderStartRadius: "0!"
        }
      }
    },
    {
      orientation: "vertical",
      attached: true,
      css: {
        "& > *[data-first]": {
          borderBottomRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-between]": {
          borderRadius: "0!",
          marginBottom: "-1px"
        },
        "& > *[data-last]": {
          borderTopRadius: "0!"
        }
      }
    }
  ],
  defaultVariants: {
    orientation: "horizontal"
  }
});
const Group = reactExports.memo(
  reactExports.forwardRef(function Group2(props, ref) {
    const {
      align = "center",
      justify = "flex-start",
      children,
      wrap: wrap2,
      skip,
      ...rest
    } = props;
    const _children = reactExports.useMemo(() => {
      let childArray = reactExports.Children.toArray(children).filter(reactExports.isValidElement);
      if (childArray.length === 1) return childArray;
      const validChildArray = childArray.filter((child) => !skip?.(child));
      const validChildCount = validChildArray.length;
      if (validChildArray.length === 1) return childArray;
      return childArray.map((child) => {
        const childProps = child.props;
        if (skip?.(child)) return child;
        const index = validChildArray.indexOf(child);
        return reactExports.cloneElement(child, {
          ...childProps,
          "data-group-item": "",
          "data-first": dataAttr(index === 0),
          "data-last": dataAttr(index === validChildCount - 1),
          "data-between": dataAttr(index > 0 && index < validChildCount - 1),
          style: {
            "--group-count": validChildCount,
            "--group-index": index,
            ...childProps?.style ?? {}
          }
        });
      });
    }, [children, skip]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      StyledGroup,
      {
        ref,
        alignItems: align,
        justifyContent: justify,
        flexWrap: wrap2,
        ...rest,
        className: cx("chakra-group", props.className),
        children: _children
      }
    );
  })
);
const Box = chakra("div");
Box.displayName = "Box";
const Span = chakra("span");
const AbsoluteCenter = chakra("div", {
  base: {
    position: "absolute",
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  },
  variants: {
    axis: {
      horizontal: {
        insetStart: "50%",
        translate: "-50%",
        _rtl: {
          translate: "50%"
        }
      },
      vertical: {
        top: "50%",
        translate: "0 -50%"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        translate: "-50% -50%",
        _rtl: {
          translate: "50% -50%"
        }
      }
    }
  },
  defaultVariants: {
    axis: "both"
  }
});
AbsoluteCenter.displayName = "AbsoluteCenter";
const { withContext: withContext$e } = createRecipeContext({
  key: "spinner"
});
const Spinner = withContext$e("span");
const Loader$1 = reactExports.forwardRef(
  function Loader2(props, ref) {
    const {
      spinner = /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "inherit", borderWidth: "0.125em", color: "inherit" }),
      spinnerPlacement = "start",
      children,
      text,
      visible = true,
      ...rest
    } = props;
    if (!visible) return children;
    if (text) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Span, { ref, display: "contents", ...rest, children: [
        spinnerPlacement === "start" && spinner,
        text,
        spinnerPlacement === "end" && spinner
      ] });
    }
    if (spinner) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Span, { ref, display: "contents", ...rest, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AbsoluteCenter, { display: "inline-flex", children: spinner }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Span, { opacity: 0, children })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Span, { ref, display: "contents", ...rest, children });
  }
);
const { useRecipeResult: useRecipeResult$1, usePropsContext } = createRecipeContext(
  { key: "button" }
);
const Button$2 = reactExports.forwardRef(
  function Button2(inProps, ref) {
    const propsContext = usePropsContext();
    const props = reactExports.useMemo(
      () => mergeProps$1(propsContext, inProps),
      [propsContext, inProps]
    );
    const result = useRecipeResult$1(props);
    const {
      loading,
      loadingText,
      children,
      spinner,
      spinnerPlacement,
      ...rest
    } = result.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.button,
      {
        type: "button",
        ref,
        ...rest,
        disabled: loading || rest.disabled,
        className: cx(result.className, props.className),
        css: [result.styles, props.css],
        children: !props.asChild && loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Loader$1,
          {
            spinner,
            text: loadingText,
            spinnerPlacement,
            children
          }
        ) : children
      }
    );
  }
);
const IconButton = reactExports.forwardRef(
  function IconButton2(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$2,
      {
        px: "0",
        py: "0",
        _icon: { fontSize: "1.2em" },
        ref,
        ...props
      }
    );
  }
);
const {
  withProvider: withProvider$6,
  withContext: withContext$d
} = createSlotRecipeContext({ key: "clipboard" });
withProvider$6(ClipboardRootProvider, "root", { forwardAsChild: true });
const ClipboardRoot$1 = withProvider$6(
  ClipboardRoot$2,
  "root",
  { forwardAsChild: true }
);
const ClipboardTrigger = withContext$d(ClipboardTrigger$1, "trigger", { forwardAsChild: true });
withContext$d(ClipboardControl, "control", { forwardAsChild: true });
const ClipboardIndicator = withContext$d(ClipboardIndicator$1, "indicator", {
  forwardAsChild: true,
  defaultProps: {
    copied: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { boxSize: "1em" }),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyIcon, { boxSize: "1em" })
  }
});
const ClipboardInput = withContext$d(ClipboardInput$1, "input", { forwardAsChild: true });
const ClipboardLabel = withContext$d(ClipboardLabel$1, "label", { forwardAsChild: true });
withContext$d(ClipboardValueText, "valueText", { forwardAsChild: true });
reactExports.forwardRef(function ClipboardCopyText2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIndicator, { copied: "Copied", ...props, ref, children: "Copy" });
});
function getSeparatorStyles(options2) {
  const { gap, direction } = options2;
  const styles2 = {
    column: {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    "column-reverse": {
      marginY: gap,
      marginX: 0,
      borderInlineStartWidth: 0,
      borderTopWidth: "1px"
    },
    row: {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    },
    "row-reverse": {
      marginX: gap,
      marginY: 0,
      borderInlineStartWidth: "1px",
      borderTopWidth: 0
    }
  };
  return {
    "&": mapObject(direction, (value) => styles2[value])
  };
}
function getValidChildren(children) {
  return reactExports.Children.toArray(children).filter(
    (child) => reactExports.isValidElement(child)
  );
}
const Stack = reactExports.forwardRef(
  function Stack2(props, ref) {
    const {
      direction = "column",
      align,
      justify,
      gap = "0.5rem",
      wrap: wrap2,
      children,
      separator,
      className,
      ...rest
    } = props;
    const separatorStyle = reactExports.useMemo(
      () => getSeparatorStyles({ gap, direction }),
      [gap, direction]
    );
    const clones = reactExports.useMemo(() => {
      if (!separator) return children;
      return getValidChildren(children).map((child, index, arr2) => {
        const key = typeof child.key !== "undefined" ? child.key : index;
        const sep = reactExports.cloneElement(separator, {
          css: [separatorStyle, separator.props.css]
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
          child,
          index === arr2.length - 1 ? null : sep
        ] }, key);
      });
    }, [children, separator, separatorStyle]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref,
        display: "flex",
        alignItems: align,
        justifyContent: justify,
        flexDirection: direction,
        flexWrap: wrap2,
        gap: separator ? void 0 : gap,
        className: cx("chakra-stack", className),
        ...rest,
        children: clones
      }
    );
  }
);
const {
  withRootProvider: withRootProvider$2,
  withContext: withContext$c
} = createSlotRecipeContext({ key: "drawer" });
withRootProvider$2(
  DialogRootProvider,
  {
    defaultProps: { unmountOnExit: true, lazyMount: true }
  }
);
const DrawerRoot$1 = withRootProvider$2(DialogRoot, {
  defaultProps: { unmountOnExit: true, lazyMount: true }
});
const DrawerTrigger$1 = withContext$c(
  DialogTrigger,
  "trigger",
  { forwardAsChild: true }
);
const DrawerPositioner = withContext$c(DialogPositioner, "positioner", { forwardAsChild: true });
const DrawerContent$1 = withContext$c(
  DialogContent,
  "content",
  { forwardAsChild: true }
);
withContext$c(DialogDescription, "description", { forwardAsChild: true });
const DrawerTitle$1 = withContext$c(
  DialogTitle,
  "title",
  { forwardAsChild: true }
);
const DrawerCloseTrigger$1 = withContext$c(DialogCloseTrigger, "closeTrigger", { forwardAsChild: true });
const DrawerActionTrigger$1 = reactExports.forwardRef(function DrawerActionTrigger2(props, ref) {
  const drawer = useDialogContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.button, { ...props, ref, onClick: () => drawer.setOpen(false) });
});
const DrawerBackdrop$1 = withContext$c(
  DialogBackdrop,
  "backdrop",
  { forwardAsChild: true }
);
const DrawerBody$1 = withContext$c(
  "div",
  "body"
);
const DrawerFooter$1 = withContext$c(
  "div",
  "footer"
);
const DrawerHeader$1 = withContext$c(
  "div",
  "header"
);
const { useRecipeResult } = createRecipeContext({ key: "icon" });
const Icon = reactExports.forwardRef(
  function Icon2(props, ref) {
    const {
      styles: styles2,
      className,
      props: otherProps
    } = useRecipeResult({ asChild: !props.as, ...props });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.svg,
      {
        ref,
        focusable: false,
        "aria-hidden": "true",
        ...otherProps,
        css: [styles2, props.css],
        className: cx(className, props.className)
      }
    );
  }
);
function createIcon(options2) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps = {}
  } = options2;
  const path2 = reactExports.Children.toArray(options2.path);
  const Comp = reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Icon,
    {
      ref,
      asChild: false,
      viewBox,
      ...defaultProps,
      ...props,
      children: path2.length ? path2 : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "currentColor", d: pathDefinition })
    }
  ));
  Comp.displayName = displayName;
  return Comp;
}
const {
  withProvider: withProvider$5,
  withContext: withContext$b,
  useStyles: useFieldStyles,
  useClassNames
} = createSlotRecipeContext({ key: "field" });
const FieldRoot = withProvider$5(
  FieldRoot$1,
  "root",
  { forwardAsChild: true }
);
const FieldLabel = withContext$b(
  FieldLabel$1,
  "label",
  { forwardAsChild: true }
);
const FieldHelperText = withContext$b(FieldHelperText$1, "helperText", { forwardAsChild: true });
const FieldErrorText = withContext$b(
  FieldErrorText$1,
  "errorText",
  { forwardAsChild: true }
);
createIcon({
  d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
});
const FieldRequiredIndicator = reactExports.forwardRef(function RequiredIndicator(props, ref) {
  const { fallback: fallback2, children = "*", ...restProps } = props;
  const field = useFieldContext();
  const classNames2 = useClassNames();
  const styles2 = useFieldStyles();
  if (!field?.required) {
    return fallback2;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      ref,
      "aria-hidden": "true",
      ...restProps,
      className: cx(classNames2.requiredIndicator, props.className),
      css: [styles2.requiredIndicator, props.css],
      children
    }
  );
});
const Flex = reactExports.forwardRef(
  function Flex2(props, ref) {
    const {
      direction,
      align,
      justify,
      wrap: wrap2,
      basis,
      grow,
      shrink,
      inline,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.div,
      {
        ref,
        ...rest,
        css: {
          display: inline ? "inline-flex" : "flex",
          flexDirection: direction,
          alignItems: align,
          justifyContent: justify,
          flexWrap: wrap2,
          flexBasis: basis,
          flexGrow: grow,
          flexShrink: shrink,
          ...props.css
        }
      }
    );
  }
);
const Image$1 = reactExports.forwardRef(
  function Image2(props, ref) {
    const { align, fit = "cover", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      chakra.img,
      {
        ref,
        objectFit: fit,
        objectPosition: align,
        className: cx("chakra-image", props.className),
        ...rest
      }
    );
  }
);
const { withContext: withContext$a } = createRecipeContext({
  key: "input"
});
const Input$1 = withContext$a(FieldInput);
const InputElement = chakra("div", {
  base: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    zIndex: 2,
    color: "fg.muted",
    height: "full",
    fontSize: "sm",
    px: "3"
  },
  variants: {
    placement: {
      start: {
        insetInlineStart: "0"
      },
      end: {
        insetInlineEnd: "0"
      }
    }
  }
});
const {
  withRootProvider: withRootProvider$1,
  withContext: withContext$9
} = createSlotRecipeContext({ key: "menu" });
withRootProvider$1(
  MenuRootProvider
);
const MenuRoot = withRootProvider$1(MenuRoot$1, {
  defaultProps: { lazyMount: true, unmountOnExit: true }
});
const MenuTrigger = withContext$9(
  MenuTrigger$1,
  "trigger",
  { forwardAsChild: true }
);
withContext$9(MenuContextTrigger, "contextTrigger", { forwardAsChild: true });
const MenuPositioner = withContext$9(
  MenuPositioner$1,
  "positioner",
  { forwardAsChild: true }
);
withContext$9(
  MenuSeparator,
  "separator",
  { forwardAsChild: true }
);
const MenuContent = withContext$9(
  MenuContent$1,
  "content",
  { forwardAsChild: true }
);
const MenuArrowTip = withContext$9(
  MenuArrowTip$1,
  "arrowTip",
  { forwardAsChild: true }
);
withContext$9(
  MenuArrow,
  "arrow",
  { forwardAsChild: true, defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuArrowTip, {}) } }
);
withContext$9(
  MenuIndicator,
  "indicator",
  { forwardAsChild: true }
);
withContext$9(
  MenuItemGroup,
  "itemGroup",
  { forwardAsChild: true }
);
withContext$9(MenuItemGroupLabel, "itemGroupLabel", { forwardAsChild: true });
withContext$9(
  MenuItem,
  "item",
  { forwardAsChild: true }
);
withContext$9(MenuTriggerItem, "item", { forwardAsChild: true });
withContext$9(
  MenuItemText,
  "itemText",
  { forwardAsChild: true }
);
withContext$9(
  "kbd",
  "itemCommand"
);
const MenuItemIndicator = withContext$9(MenuItemIndicator$1, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { boxSize: "4" }) }
});
withContext$9(MenuCheckboxItem, "item", { forwardAsChild: true });
const MenuRadioItemGroup = withContext$9(MenuRadioItemGroup$1, "itemGroup", { forwardAsChild: true });
const MenuRadioItem = withContext$9(
  MenuRadioItem$1,
  "item",
  { forwardAsChild: true }
);
const {
  withProvider: withProvider$4,
  withContext: withContext$8
} = createSlotRecipeContext({ key: "numberInput" });
withProvider$4(NumberInputRootProvider, "root", { forwardAsChild: true });
const NumberInputRoot = withProvider$4(NumberInputRoot$1, "root", { forwardAsChild: true });
withContext$8(NumberInputLabel, "label", { forwardAsChild: true });
const NumberInputInput = withContext$8(NumberInputInput$1, "input", { forwardAsChild: true });
const NumberInputIncrementTrigger = withContext$8(NumberInputIncrementTrigger$1, "incrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUpIcon, {}) }
});
const NumberInputDecrementTrigger = withContext$8(NumberInputDecrementTrigger$1, "decrementTrigger", {
  forwardAsChild: true,
  defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDownIcon, {}) }
});
const NumberInputControl = withContext$8(NumberInputControl$1, "control", {
  forwardAsChild: true,
  defaultProps: {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputIncrementTrigger, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputDecrementTrigger, {})
    ] })
  }
});
withContext$8(NumberInputScrubber, "scrubber", { forwardAsChild: true });
withContext$8(NumberInputValueText, "valueText", { forwardAsChild: true });
const {
  withProvider: withProvider$3,
  withContext: withContext$7
} = createSlotRecipeContext({ key: "select" });
withProvider$3(SelectRootProvider, "root", {
  forwardAsChild: true
});
const SelectRoot$1 = withProvider$3(
  SelectRoot$2,
  "root",
  {
    forwardAsChild: true,
    defaultProps: { positioning: { sameWidth: true } }
  }
);
const SelectTrigger$1 = withContext$7(
  SelectTrigger$2,
  "trigger",
  { forwardAsChild: true }
);
const SelectPositioner = withContext$7(SelectPositioner$1, "positioner", { forwardAsChild: true });
const SelectContent$1 = withContext$7(
  SelectContent$2,
  "content",
  { forwardAsChild: true }
);
const SelectValueText$1 = withContext$7(SelectValueText$2, "valueText", { forwardAsChild: true });
const SelectClearTrigger$1 = withContext$7(SelectClearTrigger$2, "clearTrigger", {
  forwardAsChild: true,
  defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { boxSize: "1em" }) }
});
const SelectItemGroup = withContext$7(SelectItemGroup$1, "itemGroup", { forwardAsChild: true });
const SelectItemGroupLabel = withContext$7(SelectItemGroupLabel$1, "itemGroupLabel", { forwardAsChild: true });
const SelectItem$1 = withContext$7(
  SelectItem$2,
  "item",
  { forwardAsChild: true }
);
withContext$7(
  SelectItemText,
  "itemText",
  { forwardAsChild: true }
);
const SelectItemIndicator = withContext$7(SelectItemIndicator$1, "itemIndicator", {
  forwardAsChild: true,
  defaultProps: {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, {})
  }
});
const SelectIndicatorGroup = withContext$7("div", "indicatorGroup");
const SelectIndicator = withContext$7(SelectIndicator$1, "indicator", {
  forwardAsChild: true,
  defaultProps: {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDownIcon, {})
  }
});
const SelectControl = withContext$7(
  SelectControl$1,
  "control",
  { forwardAsChild: true }
);
withContext$7(
  SelectLabel,
  "label",
  { forwardAsChild: true }
);
const SelectContext = SelectContext$1;
const SelectHiddenSelect = SelectHiddenSelect$1;
const HStack = reactExports.forwardRef(
  function HStack2(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "row", ref });
  }
);
const VStack = reactExports.forwardRef(
  function VStack2(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "column", ref });
  }
);
const {
  withProvider: withProvider$2,
  withContext: withContext$6,
  useStyles: useSwitchStyles
} = createSlotRecipeContext({ key: "switch" });
withProvider$2(SwitchRootProvider, "root", { forwardAsChild: true });
const SwitchRoot = withProvider$2(
  SwitchRoot$1,
  "root",
  { forwardAsChild: true }
);
const SwitchLabel = withContext$6(
  SwitchLabel$1,
  "label",
  { forwardAsChild: true }
);
const SwitchThumb = withContext$6(
  SwitchThumb$1,
  "thumb",
  { forwardAsChild: true }
);
const SwitchControl = withContext$6(
  SwitchControl$1,
  "control",
  {
    forwardAsChild: true,
    defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, {}) }
  }
);
const SwitchIndicator = reactExports.forwardRef(function SwitchIndicator2(props, ref) {
  const api = useSwitchContext();
  const styles2 = useSwitchStyles();
  const { fallback: fallback2, children, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    chakra.span,
    {
      ref,
      "data-checked": dataAttr(api.checked),
      ...rest,
      css: [styles2.indicator, props.css],
      children: api.checked ? children : fallback2
    }
  );
});
const SwitchThumbIndicator = reactExports.forwardRef(function SwitchThumbIndicator2(props, ref) {
  const api = useSwitchContext();
  const { fallback: fallback2, children, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.span, { ref, "data-checked": dataAttr(api.checked), ...rest, children: api.checked ? children : fallback2 });
});
const SwitchHiddenInput = SwitchHiddenInput$1;
const {
  withProvider: withProvider$1,
  withContext: withContext$5
} = createSlotRecipeContext({ key: "tabs" });
withProvider$1(TabsRootProvider, "root", { forwardAsChild: true });
const TabsRoot = withProvider$1(
  TabsRoot$1,
  "root",
  { forwardAsChild: true }
);
const TabsTrigger = withContext$5(
  TabTrigger,
  "trigger",
  { forwardAsChild: true }
);
const TabsContent = withContext$5(
  TabContent,
  "content",
  { forwardAsChild: true }
);
const TabsContentGroup = withContext$5("div", "contentGroup");
const TabsList = withContext$5(
  TabList,
  "list",
  { forwardAsChild: true }
);
withContext$5(
  TabIndicator,
  "indicator",
  { forwardAsChild: true }
);
const { withContext: withContext$4 } = createRecipeContext({
  key: "textarea"
});
const Textarea = withContext$4(
  FieldTextarea
);
const {
  withProvider,
  withContext: withContext$3,
  useStyles: useToastStyles
} = createSlotRecipeContext({ key: "toast" });
const Toaster$1 = chakra(
  Toaster$2,
  {},
  { forwardAsChild: true }
);
const ToastRoot = withProvider(
  ToastRoot$1,
  "root",
  { forwardAsChild: true }
);
const ToastCloseTrigger = withContext$3(ToastCloseTrigger$1, "closeTrigger", {
  forwardAsChild: true,
  defaultProps: {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
  }
});
const ToastTitle = withContext$3(
  ToastTitle$1,
  "title",
  { forwardAsChild: true }
);
const ToastDescription = withContext$3(ToastDescription$1, "description", { forwardAsChild: true });
const ToastActionTrigger = withContext$3(ToastActionTrigger$1, "actionTrigger", { forwardAsChild: true });
const iconMap = {
  warning: WarningIcon,
  success: CheckCircleIcon,
  error: WarningIcon
};
const ToastIndicator = reactExports.forwardRef(
  function ToastIndicator2(props, ref) {
    const api = useToastContext();
    const styles2 = useToastStyles();
    const Component = iconMap[api.type];
    if (!Component) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ref, ...props, css: [styles2.indicator, props.css] });
  }
);
const {
  withRootProvider,
  withContext: withContext$2
} = createSlotRecipeContext({ key: "tooltip" });
withRootProvider(
  TooltipRootProvider
);
const TooltipRoot = withRootProvider(TooltipRoot$1, {
  defaultProps: { lazyMount: true, unmountOnExit: true }
});
const TooltipTrigger = withContext$2(TooltipTrigger$1, "trigger", { forwardAsChild: true });
const TooltipPositioner = withContext$2(TooltipPositioner$1, "positioner", { forwardAsChild: true });
const TooltipContent = withContext$2(
  TooltipContent$1,
  "content",
  { forwardAsChild: true }
);
const TooltipArrowTip = withContext$2(TooltipArrowTip$1, "arrowTip", { forwardAsChild: true });
const TooltipArrow = withContext$2(
  TooltipArrow$1,
  "arrow",
  { forwardAsChild: true, defaultProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipArrowTip, {}) } }
);
const { withContext: withContext$1 } = createRecipeContext({
  key: "heading"
});
const Heading = withContext$1("h2");
const { withContext } = createRecipeContext({
  key: "text"
});
const Text = withContext("p");
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && /* @__PURE__ */ React.createContext(DefaultContext);
var _excluded$x = ["attr", "size", "title"];
function _objectWithoutProperties$x(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$x(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$x(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _extends$w() {
  _extends$w = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$w.apply(this, arguments);
}
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$g(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$g(obj, key, value) {
  key = _toPropertyKey$f(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$f(t2) {
  var i = _toPrimitive$f(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$f(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function Tree2Element(tree) {
  return tree && tree.map((node2, i) => /* @__PURE__ */ React.createElement(node2.tag, _objectSpread$2({
    key: i
  }, node2.attr), Tree2Element(node2.child)));
}
function GenIcon(data) {
  return (props) => /* @__PURE__ */ React.createElement(IconBase, _extends$w({
    attr: _objectSpread$2({}, data.attr)
  }, props), Tree2Element(data.child));
}
function IconBase(props) {
  var elem = (conf) => {
    var {
      attr,
      size: size2,
      title
    } = props, svgProps = _objectWithoutProperties$x(props, _excluded$x);
    var computedSize = size2 || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + " " : "") + props.className;
    return /* @__PURE__ */ React.createElement("svg", _extends$w({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: _objectSpread$2(_objectSpread$2({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && /* @__PURE__ */ React.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? /* @__PURE__ */ React.createElement(IconContext.Consumer, null, (conf) => elem(conf)) : elem(DefaultContext);
}
function FiCamera(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" }, "child": [] }, { "tag": "circle", "attr": { "cx": "12", "cy": "13", "r": "4" }, "child": [] }] })(props);
}
function FiChevronDown(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "6 9 12 15 18 9" }, "child": [] }] })(props);
}
function FiChevronLeft(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "15 18 9 12 15 6" }, "child": [] }] })(props);
}
function FiChevronsDown(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "7 13 12 18 17 13" }, "child": [] }, { "tag": "polyline", "attr": { "points": "7 6 12 11 17 6" }, "child": [] }] })(props);
}
function FiClock(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "10" }, "child": [] }, { "tag": "polyline", "attr": { "points": "12 6 12 12 16 14" }, "child": [] }] })(props);
}
function FiGlobe(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "10" }, "child": [] }, { "tag": "line", "attr": { "x1": "2", "y1": "12", "x2": "22", "y2": "12" }, "child": [] }, { "tag": "path", "attr": { "d": "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" }, "child": [] }] })(props);
}
function FiLayers(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polygon", "attr": { "points": "12 2 2 7 12 12 22 7 12 2" }, "child": [] }, { "tag": "polyline", "attr": { "points": "2 17 12 22 22 17" }, "child": [] }, { "tag": "polyline", "attr": { "points": "2 12 12 17 22 12" }, "child": [] }] })(props);
}
function FiMaximize2(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "15 3 21 3 21 9" }, "child": [] }, { "tag": "polyline", "attr": { "points": "9 21 3 21 3 15" }, "child": [] }, { "tag": "line", "attr": { "x1": "21", "y1": "3", "x2": "14", "y2": "10" }, "child": [] }, { "tag": "line", "attr": { "x1": "3", "y1": "21", "x2": "10", "y2": "14" }, "child": [] }] })(props);
}
function FiMinimize2(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "4 14 10 14 10 20" }, "child": [] }, { "tag": "polyline", "attr": { "points": "20 10 14 10 14 4" }, "child": [] }, { "tag": "line", "attr": { "x1": "14", "y1": "10", "x2": "21", "y2": "3" }, "child": [] }, { "tag": "line", "attr": { "x1": "3", "y1": "21", "x2": "10", "y2": "14" }, "child": [] }] })(props);
}
function FiMinus(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "line", "attr": { "x1": "5", "y1": "12", "x2": "19", "y2": "12" }, "child": [] }] })(props);
}
function FiMonitor(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "rect", "attr": { "x": "2", "y": "3", "width": "20", "height": "14", "rx": "2", "ry": "2" }, "child": [] }, { "tag": "line", "attr": { "x1": "8", "y1": "21", "x2": "16", "y2": "21" }, "child": [] }, { "tag": "line", "attr": { "x1": "12", "y1": "17", "x2": "12", "y2": "21" }, "child": [] }] })(props);
}
function FiPlus(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "line", "attr": { "x1": "12", "y1": "5", "x2": "12", "y2": "19" }, "child": [] }, { "tag": "line", "attr": { "x1": "5", "y1": "12", "x2": "19", "y2": "12" }, "child": [] }] })(props);
}
function FiSettings(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "3" }, "child": [] }, { "tag": "path", "attr": { "d": "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" }, "child": [] }] })(props);
}
function FiTrash2(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "3 6 5 6 21 6" }, "child": [] }, { "tag": "path", "attr": { "d": "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }, "child": [] }, { "tag": "line", "attr": { "x1": "10", "y1": "11", "x2": "10", "y2": "17" }, "child": [] }, { "tag": "line", "attr": { "x1": "14", "y1": "11", "x2": "14", "y2": "17" }, "child": [] }] })(props);
}
function FiUsers(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" }, "child": [] }, { "tag": "circle", "attr": { "cx": "9", "cy": "7", "r": "4" }, "child": [] }, { "tag": "path", "attr": { "d": "M23 21v-2a4 4 0 0 0-3-3.87" }, "child": [] }, { "tag": "path", "attr": { "d": "M16 3.13a4 4 0 0 1 0 7.75" }, "child": [] }] })(props);
}
function FiX(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "line", "attr": { "x1": "18", "y1": "6", "x2": "6", "y2": "18" }, "child": [] }, { "tag": "line", "attr": { "x1": "6", "y1": "6", "x2": "18", "y2": "18" }, "child": [] }] })(props);
}
const isElectron$2 = window.api !== void 0;
const commonStyles = {
  scrollbar: {
    "&::-webkit-scrollbar": {
      width: "4px"
    },
    "&::-webkit-scrollbar-track": {
      bg: "whiteAlpha.100",
      borderRadius: "full"
    },
    "&::-webkit-scrollbar-thumb": {
      bg: "whiteAlpha.300",
      borderRadius: "full"
    }
  },
  panel: {
    border: "1px solid",
    borderColor: "whiteAlpha.200",
    borderRadius: "lg",
    bg: "blackAlpha.400"
  }
};
const sidebarStyles = {
  sidebar: {
    container: (isCollapsed) => ({
      position: "absolute",
      left: 0,
      top: 0,
      height: "100%",
      width: "440px",
      bg: "gray.900",
      transform: isCollapsed ? "translateX(calc(-100% + 24px))" : "translateX(0)",
      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      display: "flex",
      flexDirection: "column",
      gap: 4,
      overflow: isCollapsed ? "visible" : "hidden",
      pb: "4"
    }),
    toggleButton: {
      position: "absolute",
      right: 0,
      top: 0,
      width: "24px",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      cursor: "pointer",
      color: "whiteAlpha.700",
      _hover: { color: "white" },
      bg: "transparent",
      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      zIndex: 1
    },
    content: {
      flex: 1,
      width: "100%",
      display: "flex",
      flexDirection: "column",
      gap: 4,
      overflow: "hidden"
    },
    header: {
      width: "100%",
      display: "flex",
      alignItems: "center",
      gap: 1,
      p: 2
    }
  },
  chatHistoryPanel: {
    messageList: {
      css: {
        ...commonStyles.scrollbar
      }
    }
  },
  historyDrawer: {
    listContainer: {
      flex: 1,
      overflowY: "auto",
      px: 4,
      py: 2,
      css: commonStyles.scrollbar
    },
    historyItem: {
      mb: 4,
      p: 3,
      borderRadius: "md",
      bg: "whiteAlpha.50",
      cursor: "pointer",
      transition: "all 0.2s",
      _hover: {
        bg: "whiteAlpha.100"
      }
    },
    historyItemSelected: {
      bg: "whiteAlpha.200",
      borderLeft: "3px solid",
      borderColor: "blue.500"
    },
    historyHeader: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      mb: 2
    },
    timestamp: {
      fontSize: "sm",
      color: "whiteAlpha.700",
      fontFamily: "mono"
    },
    deleteButton: {
      variant: "ghost",
      colorScheme: "red",
      size: "sm",
      color: "red.300",
      opacity: 0.8,
      _hover: {
        opacity: 1,
        bg: "whiteAlpha.200"
      }
    },
    messagePreview: {
      fontSize: "sm",
      color: "whiteAlpha.900",
      noOfLines: 2,
      overflow: "hidden",
      textOverflow: "ellipsis"
    },
    drawer: {
      content: {
        background: "var(--chakra-colors-gray-900)",
        maxWidth: "440px",
        marginTop: isElectron$2 ? "30px" : "0",
        height: isElectron$2 ? "calc(100vh - 30px)" : "100vh"
      },
      title: {
        color: "white"
      },
      closeButton: {
        color: "white"
      },
      actionButton: {
        color: "white",
        borderColor: "white",
        variant: "outline"
      }
    }
  },
  cameraPanel: {
    container: {
      width: "97%",
      overflow: "hidden",
      px: 4,
      minH: "240px"
    },
    header: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      mb: 4
    },
    videoContainer: {
      ...commonStyles.panel,
      width: "100%",
      height: "240px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      overflow: "hidden",
      transition: "all 0.2s"
    },
    video: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      transform: "scaleX(-1)",
      borderRadius: "8px",
      display: "block"
    }
  },
  screenPanel: {
    container: {
      width: "97%",
      overflow: "hidden",
      px: 4,
      minH: "240px"
    },
    header: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      mb: 4
    },
    screenContainer: {
      ...commonStyles.panel,
      width: "100%",
      height: "240px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      overflow: "hidden",
      transition: "all 0.2s"
    },
    video: {
      width: "100%",
      height: "100%",
      objectFit: "cover",
      borderRadius: "8px",
      display: "block"
    }
  },
  // Add Browser Panel Styles
  browserPanel: {
    container: {
      width: "97%",
      overflow: "hidden",
      px: 4,
      minH: "240px"
    },
    header: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      mb: 4
    },
    browserContainer: {
      ...commonStyles.panel,
      width: "100%",
      height: "240px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      overflow: "hidden",
      transition: "all 0.2s",
      cursor: "pointer",
      _hover: {
        bg: "whiteAlpha.100"
      }
    },
    iframe: {
      width: "100%",
      height: "100%",
      border: "none",
      borderRadius: "8px"
    }
  },
  bottomTab: {
    container: {
      width: "97%",
      px: 4,
      position: "relative",
      zIndex: 0
    },
    list: {
      borderBottom: "none",
      gap: "2"
    },
    trigger: {
      color: "whiteAlpha.700",
      display: "flex",
      alignItems: "center",
      gap: 2,
      px: 3,
      py: 2,
      borderRadius: "md",
      _hover: {
        color: "white",
        bg: "whiteAlpha.50"
      },
      _selected: {
        color: "white",
        bg: "whiteAlpha.200"
      }
    }
  },
  groupDrawer: {
    section: {
      mb: 6
    },
    sectionTitle: {
      fontSize: "lg",
      fontWeight: "semibold",
      color: "white",
      mb: 3
    },
    inviteBox: {
      display: "flex",
      gap: 2
    },
    input: {
      bg: "whiteAlpha.100",
      border: "none",
      color: "white",
      _placeholder: {
        color: "whiteAlpha.400"
      }
    },
    memberList: {
      display: "flex",
      flexDirection: "column",
      gap: 2
    },
    memberItem: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      p: 2,
      borderRadius: "md",
      bg: "whiteAlpha.100"
    },
    memberText: {
      color: "white",
      fontSize: "sm"
    },
    removeButton: {
      size: "sm",
      color: "red.300",
      bg: "transparent",
      _hover: {
        bg: "whiteAlpha.200"
      }
    },
    button: {
      color: "white",
      bg: "whiteAlpha.100",
      _hover: {
        bg: "whiteAlpha.200"
      }
    },
    clipboardButton: {
      color: "white",
      bg: "transparent",
      _hover: {
        bg: "whiteAlpha.200"
      },
      size: "sm"
    }
  },
  // Add styles for the Tool Call Indicator
  toolCallIndicator: {
    container: {
      pl: "44px",
      // Indent to align with message content (avatar width + gap)
      my: "1",
      // Reduced vertical margin (e.g., 4px if theme space 1 = 4px)
      gap: 2,
      width: "100%",
      minHeight: "24px",
      // Ensure minimum height
      display: "flex",
      // Ensure display is flex
      alignItems: "center",
      // Keep vertical alignment
      justifyContent: "center"
      // Center items horizontally
    },
    icon: {
      color: "blue.300",
      boxSize: "14px"
    },
    text: {
      fontSize: "xs",
      color: "whiteAlpha.700",
      fontStyle: "italic"
    },
    spinner: {
      color: "blue.300",
      ml: 0
    },
    completedIcon: {
      color: "green.300",
      boxSize: "14px",
      ml: 0
    },
    errorIcon: {
      color: "red.300",
      boxSize: "14px",
      ml: 0
    }
  }
};
const chatPanelStyles = css$2`
  .cs-message-list {
    background: var(--chakra-colors-gray-900) !important;
    padding: var(--chakra-space-4);
  }
  
  .cs-message {
    margin: 12px 0;
    // padding-top: 20px !important;
  }

  .cs-message__content {
    background-color: var(--chakra-colors-gray-700) !important;
    border-radius: var(--chakra-radii-md);
    padding: 8px !important;
    color: var(--chakra-colors-white) !important;
    font-size: 0.95rem !important;
    line-height: 1.5 !important;
    margin-top: 4px !important;
  }

  .cs-message__text {
    padding: 8px 0 !important;
  }

  .cs-message--outgoing .cs-message__content {
    background-color: var(--chakra-colors-gray-600) !important;
  }

  .cs-chat-container {
    background: transparent !important;
    border: 1px solid var(--chakra-colors-whiteAlpha-200);
    border-radius: var(--chakra-radii-lg);
    padding: var(--chakra-space-2);
  }

  .cs-main-container {
    border: none !important;
    background: transparent !important;
    width: calc(100% - 24px) !important;
    margin-left: 0 !important;
  }

  .cs-message__sender {
    position: absolute !important;
    top: 0 !important;
    left: 36px !important;
    font-size: 0.875rem !important;
    font-weight: 600 !important;
    color: var(--chakra-colors-whiteAlpha-900) !important;
  }

  .cs-message__content-wrapper {
    max-width: 80%;
    margin: 0 8px;
  }

  .cs-avatar {
    background-color: var(--chakra-colors-blue-500) !important;
    color: white !important;
    width: 28px !important;
    height: 28px !important;
    font-size: 14px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    border-radius: 50% !important;
  }

  .cs-message--outgoing .cs-avatar {
    background-color: var(--chakra-colors-green-500) !important;
  }

  .cs-message__header {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
  }
`;
const warn = (i18n, code, msg, rest) => {
  const args = [msg, {
    code,
    ...rest || {}
  }];
  if (i18n?.services?.logger?.forward) {
    return i18n.services.logger.forward(args, "warn", "react-i18next::", true);
  }
  if (isString$1(args[0])) args[0] = `react-i18next:: ${args[0]}`;
  if (i18n?.services?.logger?.warn) {
    i18n.services.logger.warn(...args);
  } else if (console?.warn) {
    console.warn(...args);
  }
};
const alreadyWarned = {};
const warnOnce = (i18n, code, msg, rest) => {
  if (isString$1(msg) && alreadyWarned[msg]) return;
  if (isString$1(msg)) alreadyWarned[msg] = /* @__PURE__ */ new Date();
  warn(i18n, code, msg, rest);
};
const loadedClb = (i18n, cb2) => () => {
  if (i18n.isInitialized) {
    cb2();
  } else {
    const initialized = () => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0);
      cb2();
    };
    i18n.on("initialized", initialized);
  }
};
const loadNamespaces = (i18n, ns, cb2) => {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb2));
};
const loadLanguages = (i18n, lng, ns, cb2) => {
  if (isString$1(ns)) ns = [ns];
  if (i18n.options.preload && i18n.options.preload.indexOf(lng) > -1) return loadNamespaces(i18n, ns, cb2);
  ns.forEach((n2) => {
    if (i18n.options.ns.indexOf(n2) < 0) i18n.options.ns.push(n2);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb2));
};
const hasLoadedNamespace = (ns, i18n, options2 = {}) => {
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce(i18n, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
      languages: i18n.languages
    });
    return true;
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options2.lng,
    precheck: (i18nInstance2, loadNotPending) => {
      if (options2.bindI18n?.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns)) return false;
    }
  });
};
const isString$1 = (obj) => typeof obj === "string";
const isObject = (obj) => typeof obj === "object" && obj !== null;
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = (m2) => htmlEntities[m2];
const unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions$1 = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape
};
const setDefaults = (options2 = {}) => {
  defaultOptions$1 = {
    ...defaultOptions$1,
    ...options2
  };
};
const getDefaults$1 = () => defaultOptions$1;
let i18nInstance;
const setI18n = (instance2) => {
  i18nInstance = instance2;
};
const getI18n = () => i18nInstance;
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};
const I18nContext = reactExports.createContext();
class ReportNamespaces {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns) => {
      if (!this.usedNamespaces[ns]) this.usedNamespaces[ns] = true;
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const usePrevious = (value, ignore) => {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = value;
  }, [value, ignore]);
  return ref.current;
};
const alwaysNewT = (i18n, language, namespace2, keyPrefix) => i18n.getFixedT(language, namespace2, keyPrefix);
const useMemoizedT = (i18n, language, namespace2, keyPrefix) => reactExports.useCallback(alwaysNewT(i18n, language, namespace2, keyPrefix), [i18n, language, namespace2, keyPrefix]);
const useTranslation = (ns, props = {}) => {
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = reactExports.useContext(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce(i18n, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = (k2, optsOrDefaultValue) => {
      if (isString$1(optsOrDefaultValue)) return optsOrDefaultValue;
      if (isObject(optsOrDefaultValue) && isString$1(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    };
    const retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react?.wait) warnOnce(i18n, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = {
    ...getDefaults$1(),
    ...i18n.options.react,
    ...props
  };
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = defaultNSFromContext || i18n.options?.defaultNS;
  namespaces = isString$1(namespaces) ? [namespaces] : namespaces || ["translation"];
  i18n.reportNamespaces.addUsedNamespaces?.(namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions));
  const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  const getT = () => memoGetT;
  const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  const [t2, setT] = reactExports.useState(getT);
  let joinedNS = namespaces.join();
  if (props.lng) joinedNS = `${props.lng}${joinedNS}`;
  const previousJoinedNS = usePrevious(joinedNS);
  const isMounted = reactExports.useRef(true);
  reactExports.useEffect(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, () => {
          if (isMounted.current) setT(getNewT);
        });
      } else {
        loadNamespaces(i18n, namespaces, () => {
          if (isMounted.current) setT(getNewT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getNewT);
    }
    const boundReset = () => {
      if (isMounted.current) setT(getNewT);
    };
    if (bindI18n) i18n?.on(bindI18n, boundReset);
    if (bindI18nStore) i18n?.store.on(bindI18nStore, boundReset);
    return () => {
      isMounted.current = false;
      if (i18n) bindI18n?.split(" ").forEach((e2) => i18n.off(e2, boundReset));
      if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
    };
  }, [i18n, joinedNS]);
  reactExports.useEffect(() => {
    if (isMounted.current && ready) {
      setT(getT);
    }
  }, [i18n, keyPrefix, ready]);
  const ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready) return ret;
  if (!ready && !useSuspense) return ret;
  throw new Promise((resolve2) => {
    if (props.lng) {
      loadLanguages(i18n, props.lng, namespaces, () => resolve2());
    } else {
      loadNamespaces(i18n, namespaces, () => resolve2());
    }
  });
};
function LuBell(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9" }, "child": [] }, { "tag": "path", "attr": { "d": "M10.3 21a1.94 1.94 0 0 0 3.4 0" }, "child": [] }] })(props);
}
function LuCheck(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M20 6 9 17l-5-5" }, "child": [] }] })(props);
}
function LuClipboard(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "rect", "attr": { "width": "8", "height": "4", "x": "8", "y": "2", "rx": "1", "ry": "1" }, "child": [] }, { "tag": "path", "attr": { "d": "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }, "child": [] }] })(props);
}
function LuHand(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2" }, "child": [] }, { "tag": "path", "attr": { "d": "M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2" }, "child": [] }, { "tag": "path", "attr": { "d": "M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8" }, "child": [] }, { "tag": "path", "attr": { "d": "M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" }, "child": [] }] })(props);
}
function LuLink(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" }, "child": [] }, { "tag": "path", "attr": { "d": "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" }, "child": [] }] })(props);
}
function LuMicOff(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "line", "attr": { "x1": "2", "x2": "22", "y1": "2", "y2": "22" }, "child": [] }, { "tag": "path", "attr": { "d": "M18.89 13.23A7.12 7.12 0 0 0 19 12v-2" }, "child": [] }, { "tag": "path", "attr": { "d": "M5 10v2a7 7 0 0 0 12 5" }, "child": [] }, { "tag": "path", "attr": { "d": "M15 9.34V5a3 3 0 0 0-5.68-1.33" }, "child": [] }, { "tag": "path", "attr": { "d": "M9 9v3a3 3 0 0 0 5.12 2.12" }, "child": [] }, { "tag": "line", "attr": { "x1": "12", "x2": "12", "y1": "19", "y2": "22" }, "child": [] }] })(props);
}
function LuMic(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z" }, "child": [] }, { "tag": "path", "attr": { "d": "M19 10v2a7 7 0 0 1-14 0v-2" }, "child": [] }, { "tag": "line", "attr": { "x1": "12", "x2": "12", "y1": "19", "y2": "22" }, "child": [] }] })(props);
}
function LuSend(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z" }, "child": [] }, { "tag": "path", "attr": { "d": "m21.854 2.147-10.94 10.939" }, "child": [] }] })(props);
}
function LuX(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M18 6 6 18" }, "child": [] }, { "tag": "path", "attr": { "d": "m6 6 12 12" }, "child": [] }] })(props);
}
const CloseButton = reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { variant: "ghost", "aria-label": "Close", ref, ...props, children: props.children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(LuX, {}) }));
const isElectron$1 = window.api !== void 0;
const settingStyles = {
  settingUI: {
    tabs: {
      root: {
        width: "100%",
        variant: "plain",
        colorPalette: "gray"
      },
      content: {},
      trigger: {
        color: "whiteAlpha.600",
        _selected: {
          color: "white"
        },
        _hover: {
          color: "white"
        }
      },
      list: {
        display: "flex",
        justifyContent: "flex-start",
        width: "100%",
        borderBottom: "1px solid",
        borderColor: "whiteAlpha.200",
        mb: 4,
        pl: 0
      }
    },
    drawerContent: {
      bg: "gray.900",
      maxWidth: "440px",
      height: isElectron$1 ? "calc(100vh - 30px)" : "100vh",
      borderLeft: "1px solid",
      borderColor: "whiteAlpha.200"
    },
    drawerHeader: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      width: "100%",
      position: "relative",
      px: 6,
      py: 4
    },
    drawerTitle: {
      color: "white",
      fontSize: "lg",
      fontWeight: "semibold"
    },
    closeButton: {
      position: "absolute",
      right: 1,
      top: 1,
      color: "white"
    }
  },
  general: {
    field: {
      label: {
        color: "whiteAlpha.800"
      }
    },
    select: {
      root: {
        colorPalette: "gray",
        bg: "gray.800"
      },
      trigger: {
        bg: "gray.800"
      }
    },
    input: {
      bg: "gray.800"
    }
  },
  common: {
    field: {
      orientation: "horizontal"
    },
    fieldLabel: {
      fontSize: "sm",
      color: "whiteAlpha.800",
      whiteSpace: "nowrap"
    },
    switch: {
      size: "md",
      colorPalette: "blue",
      variant: "solid"
    },
    numberInput: {
      root: {
        pattern: "[0-9]*\\.?[0-9]*",
        inputMode: "decimal"
      },
      input: {
        bg: "whiteAlpha.100",
        borderColor: "whiteAlpha.200",
        _hover: {
          bg: "whiteAlpha.200"
        }
      }
    },
    container: {
      gap: 8,
      maxW: "sm",
      css: { "--field-label-width": "120px" }
    }
  }
};
function useLocalStorage(key, initialValue, options2) {
  const [storedValue, setStoredValue] = reactExports.useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      const parsedValue = item ? JSON.parse(item) : initialValue;
      return parsedValue;
    } catch (error2) {
      console.error(`Error reading localStorage key "${key}":`, error2);
      return initialValue;
    }
  });
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      const filteredValue = options2?.filter ? options2.filter(valueToStore) : valueToStore;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(filteredValue));
    } catch (error2) {
      console.error(`Error setting localStorage key "${key}":`, error2);
    }
  };
  return [storedValue, setValue];
}
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2) return m2.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
  } catch (error2) {
    e2 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl2) {
  var _super = function(instance2) {
    Error.call(instance2);
    instance2.stack = new Error().stack;
  };
  var ctorFunc = createImpl2(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr2, item) {
  if (arr2) {
    var index = arr2.indexOf(item);
    0 <= index && arr2.splice(index, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a2, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return)) _a2.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a2;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config$1 = {
  Promise: void 0
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    return clearTimeout(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop$3() {
}
function errorContext(cb2) {
  {
    cb2();
  }
}
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next2, error2, complete) {
    return new SafeSubscriber(next2, error2, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error2) {
        handleUnhandledError(error2);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error2) {
        handleUnhandledError(error2);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error2) {
        handleUnhandledError(error2);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error2 !== null && error2 !== void 0 ? error2 : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error2) {
  {
    reportUnhandledError(error2);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop$3,
  error: defaultErrorHandler,
  complete: noop$3
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity$1(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity$1;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev2, fn) {
      return fn(prev2);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe2) {
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error2, complete);
    errorContext(function() {
      var _a2 = _this, operator = _a2.operator, source = _a2.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next2, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject2) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next2(value);
          } catch (err) {
            reject2(err);
            subscriber.unsubscribe();
          }
        },
        error: reject2,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a2;
    return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject2) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject2(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$1.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a2;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a2;
      return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a2, _b;
    return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
const toaster = createToaster({
  placement: "top-end",
  pauseOnPageIdle: true,
  max: 5
});
function Toaster() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster$1, { toaster, insetInline: { mdDown: "4" }, children: (toast) => /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastRoot, { width: { md: "sm" }, children: [
    toast.type === "loading" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm", color: "blue.solid" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ToastIndicator, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { gap: "1", flex: "1", maxWidth: "100%", children: [
      toast.title && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: toast.title }),
      toast.description && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: toast.description })
    ] }),
    toast.action && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastActionTrigger, { children: toast.action.label }),
    toast.meta?.closable && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastCloseTrigger, {})
  ] }) }) });
}
const getTranslation = () => {
  try {
    const i18next = require("i18next").default;
    return i18next.t.bind(i18next);
  } catch (e2) {
    return (key) => key;
  }
};
const FALLBACK_WS_URL = "ws://127.0.0.1:12393/client-ws";
const FALLBACK_BASE_URL = "http://127.0.0.1:12393";
const SLUG_PATH_PATTERN = /^\/s\/[^/]+/;
const getBasePath = () => {
  if (typeof window === "undefined") {
    return "";
  }
  const match = window.location.pathname.match(SLUG_PATH_PATTERN);
  return match ? match[0] : "";
};
const stripBasePath = (path) => {
  if (!path || typeof path !== "string") {
    return path;
  }
  const normalized = path.startsWith("/") ? path : "/" + path;
  if (typeof window === "undefined") {
    return normalized;
  }
  const base = getBasePath();
  if (!base) {
    return normalized;
  }
  if (normalized === base) {
    return "/";
  }
  if (normalized.startsWith(base + "/")) {
    return normalized.slice(base.length);
  }
  return normalized;
};
const withBasePath = (path) => {
  if (!path || typeof path !== "string" || typeof window === "undefined") {
    return path;
  }
  if (!path.startsWith("/")) {
    return path;
  }
  const base = getBasePath();
  if (!base) {
    return path;
  }
  if (path === base || path.startsWith(base + "/")) {
    return path;
  }
  return base + path;
};
const normalizeBaseUrl = (value) => {
  if (!value || typeof value !== "string") {
    return "";
  }
  return value.endsWith("/") ? value.slice(0, -1) : value;
};
const buildDefaultBaseUrl = () => {
  if (typeof window === "undefined") {
    return FALLBACK_BASE_URL;
  }
  return window.location.origin + getBasePath();
};
const buildDefaultWsUrl = () => {
  if (typeof window === "undefined") {
    return FALLBACK_WS_URL;
  }
  const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
  return protocol + "//" + window.location.host + withBasePath("/client-ws");
};
const DEFAULT_BASE_URL = buildDefaultBaseUrl();
const DEFAULT_WS_URL = buildDefaultWsUrl();
const normalizeSameOriginUrl = (url) => {
  if (!url || typeof url !== "string" || typeof window === "undefined") {
    return url;
  }
  try {
    const parsed = new URL(url);
    if (parsed.host !== window.location.host) {
      return url;
    }
    parsed.pathname = withBasePath(stripBasePath(parsed.pathname || "/"));
    return parsed.toString();
  } catch (error2) {
    console.warn("Failed to normalize URL:", url, error2);
    return url;
  }
};
const resolveStaticUrl = (value, baseUrl) => {
  if (!value || typeof value !== "string") {
    return value;
  }
  const trimmed = value.trim();
  if (/^https?:\/\//i.test(trimmed)) {
    return normalizeSameOriginUrl(trimmed);
  }
  const sanitized = trimmed.replace(/^\.\/+/, "");
  const relative = sanitized.startsWith("/") ? sanitized : "/" + sanitized;
  const normalizedBase = normalizeBaseUrl(baseUrl || DEFAULT_BASE_URL);
  const normalizedPath = stripBasePath(relative);
  return normalizedBase + normalizedPath;
};
class WebSocketService {
  static instance;
  ws = null;
  messageSubject = new Subject();
  stateSubject = new Subject();
  currentState = "CLOSED";
  static getInstance() {
    if (!WebSocketService.instance) {
      WebSocketService.instance = new WebSocketService();
    }
    return WebSocketService.instance;
  }
  initializeConnection() {
    this.sendMessage({
      type: "fetch-backgrounds"
    });
    this.sendMessage({
      type: "fetch-configs"
    });
    this.sendMessage({
      type: "fetch-history-list"
    });
    this.sendMessage({
      type: "create-new-history"
    });
  }
  connect(url) {
    if (this.ws?.readyState === WebSocket.CONNECTING || this.ws?.readyState === WebSocket.OPEN) {
      this.disconnect();
    }
    try {
      this.ws = new WebSocket(url);
      this.currentState = "CONNECTING";
      this.stateSubject.next("CONNECTING");
      this.ws.onopen = () => {
        this.currentState = "OPEN";
        this.stateSubject.next("OPEN");
        this.initializeConnection();
      };
      this.ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          this.messageSubject.next(message);
        } catch (error2) {
          console.error("Failed to parse WebSocket message:", error2);
          toaster.create({
            title: `${getTranslation()("error.failedParseWebSocket")}: ${error2}`,
            type: "error",
            duration: 2e3
          });
        }
      };
      this.ws.onclose = () => {
        this.currentState = "CLOSED";
        this.stateSubject.next("CLOSED");
      };
      this.ws.onerror = () => {
        this.currentState = "CLOSED";
        this.stateSubject.next("CLOSED");
      };
    } catch (error2) {
      console.error("Failed to connect to WebSocket:", error2);
      this.currentState = "CLOSED";
      this.stateSubject.next("CLOSED");
    }
  }
  sendMessage(message) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      console.warn("WebSocket is not open. Unable to send message:", message);
      toaster.create({
        title: getTranslation()("error.websocketNotOpen"),
        type: "error",
        duration: 2e3
      });
    }
  }
  onMessage(callback) {
    return this.messageSubject.subscribe(callback);
  }
  onStateChange(callback) {
    return this.stateSubject.subscribe(callback);
  }
  disconnect() {
    this.ws?.close();
    this.ws = null;
  }
  getCurrentState() {
    return this.currentState;
  }
}
const wsService = WebSocketService.getInstance();
const WebSocketContext = React.createContext({
  sendMessage: wsService.sendMessage.bind(wsService),
  wsState: "CLOSED",
  reconnect: () => wsService.connect(DEFAULT_WS_URL),
  wsUrl: DEFAULT_WS_URL,
  setWsUrl: () => {
  },
  baseUrl: DEFAULT_BASE_URL,
  setBaseUrl: () => {
  }
});
function useWebSocket() {
  const context = reactExports.useContext(WebSocketContext);
  if (!context) {
    throw new Error("useWebSocket must be used within a WebSocketProvider");
  }
  return context;
}
const defaultWsUrl = DEFAULT_WS_URL;
const defaultBaseUrl = DEFAULT_BASE_URL;
const BgUrlContext = reactExports.createContext(null);
function BgUrlProvider({ children }) {
  const { baseUrl } = useWebSocket();
  const DEFAULT_BACKGROUND = `${baseUrl}/bg/ceiling-window-room-night.jpeg`;
  const [backgroundUrl, setBackgroundUrl] = useLocalStorage(
    "backgroundUrl",
    DEFAULT_BACKGROUND
  );
  const [backgroundFiles, setBackgroundFiles] = reactExports.useState([]);
  const resetBackground = reactExports.useCallback(() => {
    setBackgroundUrl(DEFAULT_BACKGROUND);
  }, [setBackgroundUrl, DEFAULT_BACKGROUND]);
  const addBackgroundFile = reactExports.useCallback((file) => {
    setBackgroundFiles((prev2) => [...prev2, file]);
  }, []);
  const removeBackgroundFile = reactExports.useCallback((name2) => {
    setBackgroundFiles((prev2) => prev2.filter((file) => file.name !== name2));
  }, []);
  const isDefaultBackground = reactExports.useMemo(
    () => backgroundUrl === DEFAULT_BACKGROUND,
    [backgroundUrl, DEFAULT_BACKGROUND]
  );
  const [useCameraBackground, setUseCameraBackground] = reactExports.useState(false);
  const contextValue = reactExports.useMemo(() => ({
    backgroundUrl,
    setBackgroundUrl,
    backgroundFiles,
    setBackgroundFiles,
    resetBackground,
    addBackgroundFile,
    removeBackgroundFile,
    isDefaultBackground,
    useCameraBackground,
    setUseCameraBackground
  }), [backgroundUrl, setBackgroundUrl, backgroundFiles, resetBackground, addBackgroundFile, removeBackgroundFile, isDefaultBackground, useCameraBackground]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BgUrlContext.Provider, { value: contextValue, children });
}
function useBgUrl() {
  const context = reactExports.useContext(BgUrlContext);
  if (!context) {
    throw new Error("useBgUrl must be used within a BgUrlProvider");
  }
  return context;
}
const DEFAULT_CONFIG$1 = {
  confName: "",
  confUid: "",
  configFiles: []
};
const ConfigContext = reactExports.createContext(null);
function CharacterConfigProvider({ children }) {
  const [confName, setConfName] = reactExports.useState(DEFAULT_CONFIG$1.confName);
  const [confUid, setConfUid] = reactExports.useState(DEFAULT_CONFIG$1.confUid);
  const [configFiles, setConfigFiles] = reactExports.useState(DEFAULT_CONFIG$1.configFiles);
  const getFilenameByName = reactExports.useCallback(
    (name2) => configFiles.find((config2) => config2.name === name2)?.filename,
    [configFiles]
  );
  const contextValue = reactExports.useMemo(
    () => ({
      confName,
      confUid,
      configFiles,
      setConfName,
      setConfUid,
      setConfigFiles,
      getFilenameByName
    }),
    [confName, confUid, configFiles, getFilenameByName]
  );
  reactExports.useEffect(() => {
    window.api?.updateConfigFiles?.(configFiles);
  }, [configFiles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigContext.Provider, { value: contextValue, children });
}
function useConfig() {
  const context = reactExports.useContext(ConfigContext);
  if (!context) {
    throw new Error("useConfig must be used within a CharacterConfigProvider");
  }
  return context;
}
const DEFAULT_SUBTITLE = {
  text: "Hi, I'm some random AI VTuber. Who the hell are ya? Ahh, you must be amazed by my awesomeness, right? right?"
};
const SubtitleContext = reactExports.createContext(null);
const SubtitleProvider = reactExports.memo(({ children }) => {
  const [subtitleText, setSubtitleText] = reactExports.useState(DEFAULT_SUBTITLE.text);
  const [showSubtitle, setShowSubtitle] = reactExports.useState(true);
  const contextValue = reactExports.useMemo(
    () => ({
      subtitleText,
      setSubtitleText,
      showSubtitle,
      setShowSubtitle
    }),
    [subtitleText, showSubtitle]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubtitleContext.Provider, { value: contextValue, children });
});
function useSubtitle() {
  const context = reactExports.useContext(SubtitleContext);
  if (!context) {
    throw new Error("useSubtitle must be used within a SubtitleProvider");
  }
  return context;
}
const DEFAULT_CAMERA_CONFIG = {
  width: 320,
  height: 240
};
const CameraContext = reactExports.createContext(null);
function CameraProvider({ children }) {
  const { t: t2 } = useTranslation();
  const [isStreaming, setIsStreaming] = reactExports.useState(false);
  const [isBackgroundStreaming, setIsBackgroundStreaming] = reactExports.useState(false);
  const [cameraConfig, setCameraConfig] = reactExports.useState(
    DEFAULT_CAMERA_CONFIG
  );
  const streamRef = reactExports.useRef(null);
  const backgroundStreamRef = reactExports.useRef(null);
  const videoRef = reactExports.useRef(null);
  const startCamera = reactExports.useCallback(async () => {
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error(t2("error.cameraApiNotSupported"));
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const hasCamera = devices.some((device) => device.kind === "videoinput");
      if (!hasCamera) {
        throw new Error(t2("error.noCameraFound"));
      }
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: cameraConfig.width },
          height: { ideal: cameraConfig.height }
        }
      });
      streamRef.current = stream;
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
      }
      setIsStreaming(true);
    } catch (err) {
      console.error("Failed to start camera:", err);
      toaster.create({
        title: `${t2("error.failedStartCamera")}: ${err}`,
        type: "error",
        duration: 2e3
      });
      throw err;
    }
  }, [cameraConfig, t2]);
  const stopCamera = reactExports.useCallback(() => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
      setIsStreaming(false);
    }
  }, []);
  const startBackgroundCamera = reactExports.useCallback(async () => {
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error(t2("error.cameraApiNotSupported"));
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const hasCamera = devices.some((device) => device.kind === "videoinput");
      if (!hasCamera) {
        throw new Error(t2("error.noCameraFound"));
      }
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: cameraConfig.width },
          height: { ideal: cameraConfig.height }
        }
      });
      backgroundStreamRef.current = stream;
      setIsBackgroundStreaming(true);
    } catch (err) {
      console.error("Failed to start background camera:", err);
      toaster.create({
        title: `${t2("error.failedStartBackgroundCamera")}: ${err}`,
        type: "error",
        duration: 2e3
      });
      throw err;
    }
  }, [cameraConfig, t2]);
  const stopBackgroundCamera = reactExports.useCallback(() => {
    if (backgroundStreamRef.current) {
      backgroundStreamRef.current.getTracks().forEach((track) => track.stop());
      backgroundStreamRef.current = null;
      setIsBackgroundStreaming(false);
    }
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      isStreaming,
      stream: streamRef.current,
      startCamera,
      stopCamera,
      cameraConfig,
      setCameraConfig,
      videoRef,
      backgroundStream: backgroundStreamRef.current,
      startBackgroundCamera,
      stopBackgroundCamera,
      isBackgroundStreaming
    }),
    [isStreaming, startCamera, stopCamera, cameraConfig, isBackgroundStreaming, startBackgroundCamera, stopBackgroundCamera]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CameraContext.Provider, { value: contextValue, children });
}
function useCamera() {
  const context = reactExports.useContext(CameraContext);
  if (!context) {
    throw new Error("useCamera must be used within a CameraProvider");
  }
  return context;
}
const DEFAULT_CONFIG = {
  modelInfo: {
    scrollToResize: true
  },
  isLoading: false
};
const Live2DConfigContext = reactExports.createContext(null);
function Live2DConfigProvider({ children }) {
  const { confUid } = useConfig();
  const [isLoading, setIsLoading] = reactExports.useState(DEFAULT_CONFIG.isLoading);
  const [modelInfo, setModelInfoState] = useLocalStorage(
    "modelInfo",
    DEFAULT_CONFIG.modelInfo,
    {
      filter: (value) => value ? { ...value, url: "" } : value
    }
  );
  const setModelInfo = (info) => {
    if (!info?.url) {
      setModelInfoState(void 0);
      return;
    }
    const normalizedInfo = {
      ...info,
      url: resolveStaticUrl(info.url, defaultBaseUrl),
      resourcePath: info.resourcePath ? resolveStaticUrl(info.resourcePath, defaultBaseUrl) : info.resourcePath
    };
    const finalScale = Number(normalizedInfo.kScale || 0.5) * 2;
    console.log("Setting model info with default scale:", finalScale);
    setModelInfoState({
      ...normalizedInfo,
      kScale: finalScale,
      pointerInteractive: "pointerInteractive" in normalizedInfo ? normalizedInfo.pointerInteractive : modelInfo?.pointerInteractive ?? true,
      scrollToResize: "scrollToResize" in normalizedInfo ? normalizedInfo.scrollToResize : modelInfo?.scrollToResize ?? true
    });
  };
  const contextValue = reactExports.useMemo(
    () => ({
      modelInfo,
      setModelInfo,
      isLoading,
      setIsLoading
    }),
    [modelInfo, isLoading, setIsLoading]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Live2DConfigContext.Provider, { value: contextValue, children });
}
function useLive2DConfig() {
  const context = reactExports.useContext(Live2DConfigContext);
  if (!context) {
    throw new Error("useLive2DConfig must be used within a Live2DConfigProvider");
  }
  return context;
}
var dist = {};
var assetPath = {};
Object.defineProperty(assetPath, "__esModule", { value: true });
assetPath.baseAssetPath = void 0;
const isWeb = typeof window !== "undefined" && typeof window.document !== "undefined";
const currentScript = isWeb ? window.document.currentScript : null;
let basePath = "/";
if (currentScript) {
  basePath = currentScript.src.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
}
assetPath.baseAssetPath = basePath;
var defaultModelFetcher$1 = {};
Object.defineProperty(defaultModelFetcher$1, "__esModule", { value: true });
defaultModelFetcher$1.defaultModelFetcher = void 0;
const defaultModelFetcher = (path2) => {
  return fetch(path2).then((model) => model.arrayBuffer());
};
defaultModelFetcher$1.defaultModelFetcher = defaultModelFetcher;
var frameProcessor = {};
var logging = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.log = exports2.LOG_PREFIX = void 0;
  exports2.LOG_PREFIX = "[VAD]";
  const levels = ["error", "debug", "warn"];
  function getLog(level) {
    return (...args) => {
      console[level](exports2.LOG_PREFIX, ...args);
    };
  }
  const _log = levels.reduce((acc, level) => {
    acc[level] = getLog(level);
    return acc;
  }, {});
  exports2.log = _log;
})(logging);
var messages = {};
Object.defineProperty(messages, "__esModule", { value: true });
messages.Message = void 0;
var Message$1;
(function(Message3) {
  Message3["AudioFrame"] = "AUDIO_FRAME";
  Message3["SpeechStart"] = "SPEECH_START";
  Message3["VADMisfire"] = "VAD_MISFIRE";
  Message3["SpeechEnd"] = "SPEECH_END";
  Message3["SpeechStop"] = "SPEECH_STOP";
  Message3["SpeechRealStart"] = "SPEECH_REAL_START";
  Message3["FrameProcessed"] = "FRAME_PROCESSED";
})(Message$1 || (messages.Message = Message$1 = {}));
Object.defineProperty(frameProcessor, "__esModule", { value: true });
frameProcessor.FrameProcessor = frameProcessor.validateOptions = frameProcessor.defaultV5FrameProcessorOptions = frameProcessor.defaultLegacyFrameProcessorOptions = void 0;
const logging_1$3 = logging;
const messages_1 = messages;
const RECOMMENDED_FRAME_SAMPLES = [512, 1024, 1536];
frameProcessor.defaultLegacyFrameProcessorOptions = {
  positiveSpeechThreshold: 0.5,
  negativeSpeechThreshold: 0.5 - 0.15,
  preSpeechPadFrames: 1,
  redemptionFrames: 8,
  frameSamples: 1536,
  minSpeechFrames: 3,
  submitUserSpeechOnPause: false
};
frameProcessor.defaultV5FrameProcessorOptions = {
  positiveSpeechThreshold: 0.5,
  negativeSpeechThreshold: 0.5 - 0.15,
  preSpeechPadFrames: 3,
  redemptionFrames: 24,
  frameSamples: 512,
  minSpeechFrames: 9,
  submitUserSpeechOnPause: false
};
function validateOptions(options2) {
  if (!RECOMMENDED_FRAME_SAMPLES.includes(options2.frameSamples)) {
    logging_1$3.log.warn("You are using an unusual frame size");
  }
  if (options2.positiveSpeechThreshold < 0 || options2.positiveSpeechThreshold > 1) {
    logging_1$3.log.error("positiveSpeechThreshold should be a number between 0 and 1");
  }
  if (options2.negativeSpeechThreshold < 0 || options2.negativeSpeechThreshold > options2.positiveSpeechThreshold) {
    logging_1$3.log.error("negativeSpeechThreshold should be between 0 and positiveSpeechThreshold");
  }
  if (options2.preSpeechPadFrames < 0) {
    logging_1$3.log.error("preSpeechPadFrames should be positive");
  }
  if (options2.redemptionFrames < 0) {
    logging_1$3.log.error("redemptionFrames should be positive");
  }
}
frameProcessor.validateOptions = validateOptions;
const concatArrays = (arrays) => {
  const sizes2 = arrays.reduce((out, next2) => {
    out.push(out.at(-1) + next2.length);
    return out;
  }, [0]);
  const outArray = new Float32Array(sizes2.at(-1));
  arrays.forEach((arr2, index) => {
    const place = sizes2[index];
    outArray.set(arr2, place);
  });
  return outArray;
};
class FrameProcessor {
  constructor(modelProcessFunc, modelResetFunc, options2) {
    this.modelProcessFunc = modelProcessFunc;
    this.modelResetFunc = modelResetFunc;
    this.options = options2;
    this.speaking = false;
    this.redemptionCounter = 0;
    this.speechFrameCount = 0;
    this.active = false;
    this.speechRealStartFired = false;
    this.reset = () => {
      this.speaking = false;
      this.speechRealStartFired = false;
      this.audioBuffer = [];
      this.modelResetFunc();
      this.redemptionCounter = 0;
      this.speechFrameCount = 0;
    };
    this.pause = (handleEvent) => {
      this.active = false;
      if (this.options.submitUserSpeechOnPause) {
        this.endSegment(handleEvent);
      } else {
        this.reset();
      }
    };
    this.resume = () => {
      this.active = true;
    };
    this.endSegment = (handleEvent) => {
      const audioBuffer = this.audioBuffer;
      this.audioBuffer = [];
      const speaking = this.speaking;
      this.reset();
      if (speaking) {
        const speechFrameCount = audioBuffer.reduce((acc, item) => {
          return item.isSpeech ? acc + 1 : acc;
        }, 0);
        if (speechFrameCount >= this.options.minSpeechFrames) {
          const audio = concatArrays(audioBuffer.map((item) => item.frame));
          handleEvent({ msg: messages_1.Message.SpeechEnd, audio });
        } else {
          handleEvent({ msg: messages_1.Message.VADMisfire });
        }
      }
      return {};
    };
    this.process = async (frame, handleEvent) => {
      if (!this.active) {
        return;
      }
      const probs = await this.modelProcessFunc(frame);
      const isSpeech = probs.isSpeech >= this.options.positiveSpeechThreshold;
      handleEvent({ probs, msg: messages_1.Message.FrameProcessed, frame });
      this.audioBuffer.push({
        frame,
        isSpeech
      });
      if (isSpeech) {
        this.speechFrameCount++;
        this.redemptionCounter = 0;
      }
      if (isSpeech && !this.speaking) {
        this.speaking = true;
        handleEvent({ msg: messages_1.Message.SpeechStart });
      }
      if (this.speaking && this.speechFrameCount === this.options.minSpeechFrames && !this.speechRealStartFired) {
        this.speechRealStartFired = true;
        handleEvent({ msg: messages_1.Message.SpeechRealStart });
      }
      if (probs.isSpeech < this.options.negativeSpeechThreshold && this.speaking && ++this.redemptionCounter >= this.options.redemptionFrames) {
        this.redemptionCounter = 0;
        this.speechFrameCount = 0;
        this.speaking = false;
        this.speechRealStartFired = false;
        const audioBuffer = this.audioBuffer;
        this.audioBuffer = [];
        const speechFrameCount = audioBuffer.reduce((acc, item) => {
          return item.isSpeech ? acc + 1 : acc;
        }, 0);
        if (speechFrameCount >= this.options.minSpeechFrames) {
          const audio = concatArrays(audioBuffer.map((item) => item.frame));
          handleEvent({ msg: messages_1.Message.SpeechEnd, audio });
        } else {
          handleEvent({ msg: messages_1.Message.VADMisfire });
        }
      }
      if (!this.speaking) {
        while (this.audioBuffer.length > this.options.preSpeechPadFrames) {
          this.audioBuffer.shift();
        }
        this.speechFrameCount = 0;
      }
    };
    this.audioBuffer = [];
    this.reset();
  }
}
frameProcessor.FrameProcessor = FrameProcessor;
var nonRealTimeVad = {};
var ortWeb_min = { exports: {} };
const backends = {};
const backendsSortedByPriority = [];
const registerBackend = (name2, backend, priority) => {
  if (backend && typeof backend.init === "function" && typeof backend.createSessionHandler === "function") {
    const currentBackend = backends[name2];
    if (currentBackend === void 0) {
      backends[name2] = { backend, priority };
    } else if (currentBackend.priority > priority) {
      return;
    } else if (currentBackend.priority === priority) {
      if (currentBackend.backend !== backend) {
        throw new Error(`cannot register backend "${name2}" using priority ${priority}`);
      }
    }
    if (priority >= 0) {
      const i = backendsSortedByPriority.indexOf(name2);
      if (i !== -1) {
        backendsSortedByPriority.splice(i, 1);
      }
      for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
        if (backends[backendsSortedByPriority[i2]].priority <= priority) {
          backendsSortedByPriority.splice(i2, 0, name2);
          return;
        }
      }
      backendsSortedByPriority.push(name2);
    }
    return;
  }
  throw new TypeError("not a valid backend");
};
const resolveBackend = async (backendHints) => {
  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
  const errors = [];
  for (const backendName of backendNames) {
    const backendInfo = backends[backendName];
    if (backendInfo) {
      if (backendInfo.initialized) {
        return backendInfo.backend;
      } else if (backendInfo.aborted) {
        continue;
      }
      const isInitializing = !!backendInfo.initPromise;
      try {
        if (!isInitializing) {
          backendInfo.initPromise = backendInfo.backend.init();
        }
        await backendInfo.initPromise;
        backendInfo.initialized = true;
        return backendInfo.backend;
      } catch (e2) {
        if (!isInitializing) {
          errors.push({ name: backendName, err: e2 });
        }
        backendInfo.aborted = true;
      } finally {
        delete backendInfo.initPromise;
      }
    }
  }
  throw new Error(`no available backend found. ERR: ${errors.map((e2) => `[${e2.name}] ${e2.err}`).join(", ")}`);
};
class EnvImpl {
  constructor() {
    this.wasm = {};
    this.webgl = {};
    this.logLevelInternal = "warning";
  }
  // TODO standadize the getter and setter convention in env for other fields.
  set logLevel(value) {
    if (value === void 0) {
      return;
    }
    if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
      throw new Error(`Unsupported logging level: ${value}`);
    }
    this.logLevelInternal = value;
  }
  get logLevel() {
    return this.logLevelInternal;
  }
}
const env$1 = new EnvImpl();
const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && typeof BigInt64Array.from === "function";
const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && typeof BigUint64Array.from === "function";
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
  ["float32", Float32Array],
  ["uint8", Uint8Array],
  ["int8", Int8Array],
  ["uint16", Uint16Array],
  ["int16", Int16Array],
  ["int32", Int32Array],
  ["bool", Uint8Array],
  ["float64", Float64Array],
  ["uint32", Uint32Array]
]);
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
  [Float32Array, "float32"],
  [Uint8Array, "uint8"],
  [Int8Array, "int8"],
  [Uint16Array, "uint16"],
  [Int16Array, "int16"],
  [Int32Array, "int32"],
  [Float64Array, "float64"],
  [Uint32Array, "uint32"]
]);
if (isBigInt64ArrayAvailable) {
  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
}
if (isBigUint64ArrayAvailable) {
  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
}
const calculateSize = (dims) => {
  let size2 = 1;
  for (let i = 0; i < dims.length; i++) {
    const dim = dims[i];
    if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
    }
    if (dim < 0) {
      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
    }
    size2 *= dim;
  }
  return size2;
};
let Tensor$1 = class Tensor2 {
  constructor(arg0, arg1, arg2) {
    let type;
    let data;
    let dims;
    if (typeof arg0 === "string") {
      type = arg0;
      dims = arg2;
      if (arg0 === "string") {
        if (!Array.isArray(arg1)) {
          throw new TypeError("A string tensor's data must be a string array.");
        }
        data = arg1;
      } else {
        const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
        if (typedArrayConstructor === void 0) {
          throw new TypeError(`Unsupported tensor type: ${arg0}.`);
        }
        if (Array.isArray(arg1)) {
          data = typedArrayConstructor.from(arg1);
        } else if (arg1 instanceof typedArrayConstructor) {
          data = arg1;
        } else {
          throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
        }
      }
    } else {
      dims = arg1;
      if (Array.isArray(arg0)) {
        if (arg0.length === 0) {
          throw new TypeError("Tensor type cannot be inferred from an empty array.");
        }
        const firstElementType = typeof arg0[0];
        if (firstElementType === "string") {
          type = "string";
          data = arg0;
        } else if (firstElementType === "boolean") {
          type = "bool";
          data = Uint8Array.from(arg0);
        } else {
          throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
        }
      } else {
        const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
        if (mappedType === void 0) {
          throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
        }
        type = mappedType;
        data = arg0;
      }
    }
    if (dims === void 0) {
      dims = [data.length];
    } else if (!Array.isArray(dims)) {
      throw new TypeError("A tensor's dims must be a number array");
    }
    const size2 = calculateSize(dims);
    if (size2 !== data.length) {
      throw new Error(`Tensor's size(${size2}) does not match data length(${data.length}).`);
    }
    this.dims = dims;
    this.type = type;
    this.data = data;
    this.size = size2;
  }
  // #endregion
  /**
   * Create a new tensor object from image object
   *
   * @param buffer - Extracted image buffer data - assuming RGBA format
   * @param imageFormat - input image configuration - required configurations height, width, format
   * @param tensorFormat - output tensor configuration - Default is RGB format
   */
  static bufferToTensor(buffer, options2) {
    if (buffer === void 0) {
      throw new Error("Image buffer must be defined");
    }
    if (options2.height === void 0 || options2.width === void 0) {
      throw new Error("Image height and width must be defined");
    }
    const { height, width } = options2;
    const norm = options2.norm;
    let normMean;
    let normBias;
    if (norm === void 0 || norm.mean === void 0) {
      normMean = 255;
    } else {
      normMean = norm.mean;
    }
    if (norm === void 0 || norm.bias === void 0) {
      normBias = 0;
    } else {
      normBias = norm.bias;
    }
    const inputformat = options2.bitmapFormat !== void 0 ? options2.bitmapFormat : "RGBA";
    const outputformat = options2.tensorFormat !== void 0 ? options2.tensorFormat !== void 0 ? options2.tensorFormat : "RGB" : "RGB";
    const offset2 = height * width;
    const float32Data = outputformat === "RGBA" ? new Float32Array(offset2 * 4) : new Float32Array(offset2 * 3);
    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
    let rTensorPointer = 0, gTensorPointer = offset2, bTensorPointer = offset2 * 2, aTensorPointer = -1;
    if (inputformat === "RGB") {
      step = 3;
      rImagePointer = 0;
      gImagePointer = 1;
      bImagePointer = 2;
      aImagePointer = -1;
    }
    if (outputformat === "RGBA") {
      aTensorPointer = offset2 * 3;
    } else if (outputformat === "RBG") {
      rTensorPointer = 0;
      bTensorPointer = offset2;
      gTensorPointer = offset2 * 2;
    } else if (outputformat === "BGR") {
      bTensorPointer = 0;
      gTensorPointer = offset2;
      rTensorPointer = offset2 * 2;
    }
    for (let i = 0; i < offset2; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
      float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;
      float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;
      float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;
      if (aTensorPointer !== -1 && aImagePointer !== -1) {
        float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;
      }
    }
    const outputTensor = outputformat === "RGBA" ? new Tensor2("float32", float32Data, [1, 4, height, width]) : new Tensor2("float32", float32Data, [1, 3, height, width]);
    return outputTensor;
  }
  static async fromImage(image, options2) {
    const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
    const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
    const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
    const isURL = typeof String !== "undefined" && (image instanceof String || typeof image === "string");
    let data;
    let tensorConfig = {};
    if (isHTMLImageEle) {
      const canvas2 = document.createElement("canvas");
      const pixels2DContext = canvas2.getContext("2d");
      if (pixels2DContext != null) {
        let height = image.naturalHeight;
        let width = image.naturalWidth;
        if (options2 !== void 0 && options2.resizedHeight !== void 0 && options2.resizedWidth !== void 0) {
          height = options2.resizedHeight;
          width = options2.resizedWidth;
        }
        if (options2 !== void 0) {
          tensorConfig = options2;
          if (options2.tensorFormat !== void 0) {
            throw new Error("Image input config format must be RGBA for HTMLImageElement");
          } else {
            tensorConfig.tensorFormat = "RGBA";
          }
          if (options2.height !== void 0 && options2.height !== height) {
            throw new Error("Image input config height doesn't match HTMLImageElement height");
          } else {
            tensorConfig.height = height;
          }
          if (options2.width !== void 0 && options2.width !== width) {
            throw new Error("Image input config width doesn't match HTMLImageElement width");
          } else {
            tensorConfig.width = width;
          }
        } else {
          tensorConfig.tensorFormat = "RGBA";
          tensorConfig.height = height;
          tensorConfig.width = width;
        }
        canvas2.width = width;
        canvas2.height = height;
        pixels2DContext.drawImage(image, 0, 0, width, height);
        data = pixels2DContext.getImageData(0, 0, width, height).data;
      } else {
        throw new Error("Can not access image data");
      }
    } else if (isImageDataEle) {
      const format = "RGBA";
      let height;
      let width;
      if (options2 !== void 0 && options2.resizedWidth !== void 0 && options2.resizedHeight !== void 0) {
        height = options2.resizedHeight;
        width = options2.resizedWidth;
      } else {
        height = image.height;
        width = image.width;
      }
      if (options2 !== void 0) {
        tensorConfig = options2;
        if (options2.bitmapFormat !== void 0 && options2.bitmapFormat !== format) {
          throw new Error("Image input config format must be RGBA for ImageData");
        } else {
          tensorConfig.bitmapFormat = "RGBA";
        }
      } else {
        tensorConfig.bitmapFormat = "RGBA";
      }
      tensorConfig.height = height;
      tensorConfig.width = width;
      if (options2 !== void 0) {
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;
        const pixels2DContext = tempCanvas.getContext("2d");
        if (pixels2DContext != null) {
          pixels2DContext.putImageData(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else {
        data = image.data;
      }
    } else if (isImageBitmap) {
      if (options2 === void 0) {
        throw new Error("Please provide image config with format for Imagebitmap");
      }
      if (options2.bitmapFormat !== void 0) {
        throw new Error("Image input config format must be defined for ImageBitmap");
      }
      const pixels2DContext = document.createElement("canvas").getContext("2d");
      if (pixels2DContext != null) {
        const height = image.height;
        const width = image.width;
        pixels2DContext.drawImage(image, 0, 0, width, height);
        data = pixels2DContext.getImageData(0, 0, width, height).data;
        if (options2 !== void 0) {
          if (options2.height !== void 0 && options2.height !== height) {
            throw new Error("Image input config height doesn't match ImageBitmap height");
          } else {
            tensorConfig.height = height;
          }
          if (options2.width !== void 0 && options2.width !== width) {
            throw new Error("Image input config width doesn't match ImageBitmap width");
          } else {
            tensorConfig.width = width;
          }
        } else {
          tensorConfig.height = height;
          tensorConfig.width = width;
        }
        return Tensor2.bufferToTensor(data, tensorConfig);
      } else {
        throw new Error("Can not access image data");
      }
    } else if (isURL) {
      return new Promise((resolve2, reject2) => {
        const canvas2 = document.createElement("canvas");
        const context = canvas2.getContext("2d");
        if (!image || !context) {
          return reject2();
        }
        const newImage = new Image();
        newImage.crossOrigin = "Anonymous";
        newImage.src = image;
        newImage.onload = () => {
          canvas2.width = newImage.width;
          canvas2.height = newImage.height;
          context.drawImage(newImage, 0, 0, canvas2.width, canvas2.height);
          const img = context.getImageData(0, 0, canvas2.width, canvas2.height);
          if (options2 !== void 0) {
            if (options2.height !== void 0 && options2.height !== canvas2.height) {
              throw new Error("Image input config height doesn't match ImageBitmap height");
            } else {
              tensorConfig.height = canvas2.height;
            }
            if (options2.width !== void 0 && options2.width !== canvas2.width) {
              throw new Error("Image input config width doesn't match ImageBitmap width");
            } else {
              tensorConfig.width = canvas2.width;
            }
          } else {
            tensorConfig.height = canvas2.height;
            tensorConfig.width = canvas2.width;
          }
          resolve2(Tensor2.bufferToTensor(img.data, tensorConfig));
        };
      });
    } else {
      throw new Error("Input data provided is not supported - aborted tensor creation");
    }
    if (data !== void 0) {
      return Tensor2.bufferToTensor(data, tensorConfig);
    } else {
      throw new Error("Input data provided is not supported - aborted tensor creation");
    }
  }
  toImageData(options2) {
    var _a2, _b;
    const pixels2DContext = document.createElement("canvas").getContext("2d");
    let image;
    if (pixels2DContext != null) {
      const width = this.dims[3];
      const height = this.dims[2];
      const channels = this.dims[1];
      const inputformat = options2 !== void 0 ? options2.format !== void 0 ? options2.format : "RGB" : "RGB";
      const normMean = options2 !== void 0 ? ((_a2 = options2.norm) === null || _a2 === void 0 ? void 0 : _a2.mean) !== void 0 ? options2.norm.mean : 255 : 255;
      const normBias = options2 !== void 0 ? ((_b = options2.norm) === null || _b === void 0 ? void 0 : _b.bias) !== void 0 ? options2.norm.bias : 0 : 0;
      const offset2 = height * width;
      if (options2 !== void 0) {
        if (options2.height !== void 0 && options2.height !== height) {
          throw new Error("Image output config height doesn't match tensor height");
        }
        if (options2.width !== void 0 && options2.width !== width) {
          throw new Error("Image output config width doesn't match tensor width");
        }
        if (options2.format !== void 0 && (channels === 4 && options2.format !== "RGBA") || channels === 3 && (options2.format !== "RGB" && options2.format !== "BGR")) {
          throw new Error("Tensor format doesn't match input tensor dims");
        }
      }
      const step = 4;
      let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = offset2, bTensorPointer = offset2 * 2, aTensorPointer = -1;
      if (inputformat === "RGBA") {
        rTensorPointer = 0;
        gTensorPointer = offset2;
        bTensorPointer = offset2 * 2;
        aTensorPointer = offset2 * 3;
      } else if (inputformat === "RGB") {
        rTensorPointer = 0;
        gTensorPointer = offset2;
        bTensorPointer = offset2 * 2;
      } else if (inputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = offset2;
        gTensorPointer = offset2 * 2;
      }
      image = pixels2DContext.createImageData(width, height);
      for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
        image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean;
        image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean;
        image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean;
        image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean;
      }
    } else {
      throw new Error("Can not access image data");
    }
    return image;
  }
  // #endregion
  // #region tensor utilities
  reshape(dims) {
    return new Tensor2(this.type, this.data, dims);
  }
};
const Tensor = Tensor$1;
let InferenceSession$1 = class InferenceSession2 {
  constructor(handler) {
    this.handler = handler;
  }
  async run(feeds, arg1, arg2) {
    const fetches = {};
    let options2 = {};
    if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {
      throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
    }
    let isFetchesEmpty = true;
    if (typeof arg1 === "object") {
      if (arg1 === null) {
        throw new TypeError("Unexpected argument[1]: cannot be null.");
      }
      if (arg1 instanceof Tensor) {
        throw new TypeError("'fetches' cannot be a Tensor");
      }
      if (Array.isArray(arg1)) {
        if (arg1.length === 0) {
          throw new TypeError("'fetches' cannot be an empty array.");
        }
        isFetchesEmpty = false;
        for (const name2 of arg1) {
          if (typeof name2 !== "string") {
            throw new TypeError("'fetches' must be a string array or an object.");
          }
          if (this.outputNames.indexOf(name2) === -1) {
            throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
          }
          fetches[name2] = null;
        }
        if (typeof arg2 === "object" && arg2 !== null) {
          options2 = arg2;
        } else if (typeof arg2 !== "undefined") {
          throw new TypeError("'options' must be an object.");
        }
      } else {
        let isFetches = false;
        const arg1Keys = Object.getOwnPropertyNames(arg1);
        for (const name2 of this.outputNames) {
          if (arg1Keys.indexOf(name2) !== -1) {
            const v2 = arg1[name2];
            if (v2 === null || v2 instanceof Tensor) {
              isFetches = true;
              isFetchesEmpty = false;
              fetches[name2] = v2;
            }
          }
        }
        if (isFetches) {
          if (typeof arg2 === "object" && arg2 !== null) {
            options2 = arg2;
          } else if (typeof arg2 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else {
          options2 = arg1;
        }
      }
    } else if (typeof arg1 !== "undefined") {
      throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
    }
    for (const name2 of this.inputNames) {
      if (typeof feeds[name2] === "undefined") {
        throw new Error(`input '${name2}' is missing in 'feeds'.`);
      }
    }
    if (isFetchesEmpty) {
      for (const name2 of this.outputNames) {
        fetches[name2] = null;
      }
    }
    const results = await this.handler.run(feeds, fetches, options2);
    const returnValue = {};
    for (const key in results) {
      if (Object.hasOwnProperty.call(results, key)) {
        returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);
      }
    }
    return returnValue;
  }
  static async create(arg0, arg1, arg2, arg3) {
    let filePathOrUint8Array;
    let options2 = {};
    if (typeof arg0 === "string") {
      filePathOrUint8Array = arg0;
      if (typeof arg1 === "object" && arg1 !== null) {
        options2 = arg1;
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
    } else if (arg0 instanceof Uint8Array) {
      filePathOrUint8Array = arg0;
      if (typeof arg1 === "object" && arg1 !== null) {
        options2 = arg1;
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
    } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
      const buffer = arg0;
      let byteOffset = 0;
      let byteLength = arg0.byteLength;
      if (typeof arg1 === "object" && arg1 !== null) {
        options2 = arg1;
      } else if (typeof arg1 === "number") {
        byteOffset = arg1;
        if (!Number.isSafeInteger(byteOffset)) {
          throw new RangeError("'byteOffset' must be an integer.");
        }
        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
        }
        byteLength = arg0.byteLength - byteOffset;
        if (typeof arg2 === "number") {
          byteLength = arg2;
          if (!Number.isSafeInteger(byteLength)) {
            throw new RangeError("'byteLength' must be an integer.");
          }
          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
          }
          if (typeof arg3 === "object" && arg3 !== null) {
            options2 = arg3;
          } else if (typeof arg3 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (typeof arg2 !== "undefined") {
          throw new TypeError("'byteLength' must be a number.");
        }
      } else if (typeof arg1 !== "undefined") {
        throw new TypeError("'options' must be an object.");
      }
      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
    } else {
      throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
    }
    const eps = options2.executionProviders || [];
    const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
    const backend = await resolveBackend(backendHints);
    const handler = await backend.createSessionHandler(filePathOrUint8Array, options2);
    return new InferenceSession2(handler);
  }
  startProfiling() {
    this.handler.startProfiling();
  }
  endProfiling() {
    this.handler.endProfiling();
  }
  get inputNames() {
    return this.handler.inputNames;
  }
  get outputNames() {
    return this.handler.outputNames;
  }
};
const InferenceSession = InferenceSession$1;
const lib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InferenceSession,
  Tensor,
  env: env$1,
  registerBackend
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(lib);
/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2(require$$0);
  }(self, (__WEBPACK_EXTERNAL_MODULE__1670__) => (() => {
    var __webpack_modules__ = { 3474: (t2, e2, n2) => {
      var _scriptDir, r2 = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t3) {
        function e3() {
          return $.buffer != C2 && H2($.buffer), F2;
        }
        function r3() {
          return $.buffer != C2 && H2($.buffer), N2;
        }
        function i() {
          return $.buffer != C2 && H2($.buffer), L2;
        }
        function o() {
          return $.buffer != C2 && H2($.buffer), R2;
        }
        function a() {
          return $.buffer != C2 && H2($.buffer), j;
        }
        var s, u2, c2;
        t3 = t3 || {}, s || (s = void 0 !== t3 ? t3 : {}), s.ready = new Promise(function(t4, e4) {
          u2 = t4, c2 = e4;
        });
        var l2, p2, f2, d2, h2, g2, b2 = Object.assign({}, s), m2 = "./this.program", y2 = (t4, e4) => {
          throw e4;
        }, _ = "object" == typeof window, v2 = "function" == typeof importScripts, w2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, x2 = s.ENVIRONMENT_IS_PTHREAD || false, T2 = "";
        function S2(t4) {
          return s.locateFile ? s.locateFile(t4, T2) : T2 + t4;
        }
        if (w2) {
          let e4;
          T2 = v2 ? n2(908).dirname(T2) + "/" : "//", g2 = () => {
            h2 || (d2 = n2(1384), h2 = n2(908));
          }, l2 = function(t4, e5) {
            return g2(), t4 = h2.normalize(t4), d2.readFileSync(t4, e5 ? void 0 : "utf8");
          }, f2 = (t4) => ((t4 = l2(t4, true)).buffer || (t4 = new Uint8Array(t4)), t4), p2 = (t4, e5, n3) => {
            g2(), t4 = h2.normalize(t4), d2.readFile(t4, function(t5, r4) {
              t5 ? n3(t5) : e5(r4.buffer);
            });
          }, 1 < process.argv.length && (m2 = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t4) {
            if (!(t4 instanceof ut)) throw t4;
          }), process.on("unhandledRejection", function(t4) {
            throw t4;
          }), y2 = (t4, e5) => {
            if (J2()) throw process.exitCode = t4, e5;
            e5 instanceof ut || P2("exiting due to exception: " + e5), process.exit(t4);
          }, s.inspect = function() {
            return "[Emscripten Module object]";
          };
          try {
            e4 = n2(9925);
          } catch (t4) {
            throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), t4;
          }
          n2.g.Worker = e4.Worker;
        } else (_ || v2) && (v2 ? T2 = self.location.href : "undefined" != typeof document && document.currentScript && (T2 = document.currentScript.src), _scriptDir && (T2 = _scriptDir), T2 = 0 !== T2.indexOf("blob:") ? T2.substr(0, T2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", w2 || (l2 = (t4) => {
          var e4 = new XMLHttpRequest();
          return e4.open("GET", t4, false), e4.send(null), e4.responseText;
        }, v2 && (f2 = (t4) => {
          var e4 = new XMLHttpRequest();
          return e4.open("GET", t4, false), e4.responseType = "arraybuffer", e4.send(null), new Uint8Array(e4.response);
        }), p2 = (t4, e4, n3) => {
          var r4 = new XMLHttpRequest();
          r4.open("GET", t4, true), r4.responseType = "arraybuffer", r4.onload = () => {
            200 == r4.status || 0 == r4.status && r4.response ? e4(r4.response) : n3();
          }, r4.onerror = n3, r4.send(null);
        }));
        w2 && "undefined" == typeof performance && (n2.g.performance = n2(6953).performance);
        var O2 = console.log.bind(console), A2 = console.warn.bind(console);
        w2 && (g2(), O2 = (t4) => d2.writeSync(1, t4 + "\n"), A2 = (t4) => d2.writeSync(2, t4 + "\n"));
        var E2, I2 = s.print || O2, P2 = s.printErr || A2;
        Object.assign(s, b2), b2 = null, s.thisProgram && (m2 = s.thisProgram), s.quit && (y2 = s.quit), s.wasmBinary && (E2 = s.wasmBinary);
        var D2 = s.noExitRuntime || false;
        "object" != typeof WebAssembly && it("no native wasm support detected");
        var $, k2, C2, F2, N2, L2, R2, j, M2 = false, U2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function V2(t4, e4, n3) {
          var r4 = (e4 >>>= 0) + n3;
          for (n3 = e4; t4[n3] && !(n3 >= r4); ) ++n3;
          if (16 < n3 - e4 && t4.buffer && U2) return U2.decode(t4.buffer instanceof SharedArrayBuffer ? t4.slice(e4, n3) : t4.subarray(e4, n3));
          for (r4 = ""; e4 < n3; ) {
            var i2 = t4[e4++];
            if (128 & i2) {
              var o2 = 63 & t4[e4++];
              if (192 == (224 & i2)) r4 += String.fromCharCode((31 & i2) << 6 | o2);
              else {
                var a2 = 63 & t4[e4++];
                65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & t4[e4++]) ? r4 += String.fromCharCode(i2) : (i2 -= 65536, r4 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
              }
            } else r4 += String.fromCharCode(i2);
          }
          return r4;
        }
        function B2(t4, e4) {
          return (t4 >>>= 0) ? V2(r3(), t4, e4) : "";
        }
        function z2(t4, e4, n3, r4) {
          if (!(0 < r4)) return 0;
          var i2 = n3 >>>= 0;
          r4 = n3 + r4 - 1;
          for (var o2 = 0; o2 < t4.length; ++o2) {
            var a2 = t4.charCodeAt(o2);
            if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & t4.charCodeAt(++o2)), 127 >= a2) {
              if (n3 >= r4) break;
              e4[n3++ >>> 0] = a2;
            } else {
              if (2047 >= a2) {
                if (n3 + 1 >= r4) break;
                e4[n3++ >>> 0] = 192 | a2 >> 6;
              } else {
                if (65535 >= a2) {
                  if (n3 + 2 >= r4) break;
                  e4[n3++ >>> 0] = 224 | a2 >> 12;
                } else {
                  if (n3 + 3 >= r4) break;
                  e4[n3++ >>> 0] = 240 | a2 >> 18, e4[n3++ >>> 0] = 128 | a2 >> 12 & 63;
                }
                e4[n3++ >>> 0] = 128 | a2 >> 6 & 63;
              }
              e4[n3++ >>> 0] = 128 | 63 & a2;
            }
          }
          return e4[n3 >>> 0] = 0, n3 - i2;
        }
        function G2(t4) {
          for (var e4 = 0, n3 = 0; n3 < t4.length; ++n3) {
            var r4 = t4.charCodeAt(n3);
            127 >= r4 ? e4++ : 2047 >= r4 ? e4 += 2 : 55296 <= r4 && 57343 >= r4 ? (e4 += 4, ++n3) : e4 += 3;
          }
          return e4;
        }
        function H2(t4) {
          C2 = t4, s.HEAP8 = F2 = new Int8Array(t4), s.HEAP16 = new Int16Array(t4), s.HEAP32 = L2 = new Int32Array(t4), s.HEAPU8 = N2 = new Uint8Array(t4), s.HEAPU16 = new Uint16Array(t4), s.HEAPU32 = R2 = new Uint32Array(t4), s.HEAPF32 = new Float32Array(t4), s.HEAPF64 = j = new Float64Array(t4);
        }
        x2 && (C2 = s.buffer);
        var W2 = s.INITIAL_MEMORY || 16777216;
        if (x2) $ = s.wasmMemory, C2 = s.buffer;
        else if (s.wasmMemory) $ = s.wasmMemory;
        else if (!(($ = new WebAssembly.Memory({ initial: W2 / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer)) throw P2("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), w2 && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory");
        $ && (C2 = $.buffer), W2 = C2.byteLength, H2(C2);
        var q2, X2 = [], Y2 = [], K2 = [], Z2 = [];
        function J2() {
          return D2 || false;
        }
        function Q2() {
          var t4 = s.preRun.shift();
          X2.unshift(t4);
        }
        var tt, et = 0, rt = null;
        function it(t4) {
          throw x2 ? postMessage({ cmd: "onAbort", arg: t4 }) : s.onAbort && s.onAbort(t4), P2(t4 = "Aborted(" + t4 + ")"), M2 = true, t4 = new WebAssembly.RuntimeError(t4 + ". Build with -sASSERTIONS for more info."), c2(t4), t4;
        }
        function ot() {
          return tt.startsWith("data:application/octet-stream;base64,");
        }
        function at() {
          var t4 = tt;
          try {
            if (t4 == tt && E2) return new Uint8Array(E2);
            if (f2) return f2(t4);
            throw "both async and sync fetching of the wasm failed";
          } catch (t5) {
            it(t5);
          }
        }
        tt = "ort-wasm-threaded.wasm", ot() || (tt = S2(tt));
        var st = {};
        function ut(t4) {
          this.name = "ExitStatus", this.message = "Program terminated with exit(" + t4 + ")", this.status = t4;
        }
        function ct(t4) {
          (t4 = dt.Vb[t4]) || it(), dt.mc(t4);
        }
        function lt(t4) {
          var e4 = dt.Cc();
          if (!e4) return 6;
          dt.ac.push(e4), dt.Vb[t4.Ub] = e4, e4.Ub = t4.Ub;
          var n3 = { cmd: "run", start_routine: t4.Ic, arg: t4.zc, pthread_ptr: t4.Ub };
          return e4.$b = () => {
            n3.time = performance.now(), e4.postMessage(n3, t4.Nc);
          }, e4.loaded && (e4.$b(), delete e4.$b), 0;
        }
        function pt2(t4) {
          if (x2) return qt(1, 1, t4);
          J2() || (dt.oc(), s.onExit && s.onExit(t4), M2 = true), y2(t4, new ut(t4));
        }
        function ft(t4, e4) {
          if (!e4 && x2) throw bt(t4), "unwind";
          J2() || x2 || (me2(), ht(K2), be2(0), re2[1].length && ie2(1, 10), re2[2].length && ie2(2, 10), dt.oc()), pt2(t4);
        }
        var dt = { Yb: [], ac: [], qc: [], Vb: {}, fc: function() {
          x2 && dt.Ec();
        }, Pc: function() {
        }, Ec: function() {
          dt.receiveObjectTransfer = dt.Gc, dt.threadInitTLS = dt.pc, dt.setExitStatus = dt.nc, D2 = false;
        }, nc: function() {
        }, oc: function() {
          for (var t4 of Object.values(dt.Vb)) dt.mc(t4);
          for (t4 of dt.Yb) t4.terminate();
          dt.Yb = [];
        }, mc: function(t4) {
          var e4 = t4.Ub;
          delete dt.Vb[e4], dt.Yb.push(t4), dt.ac.splice(dt.ac.indexOf(t4), 1), t4.Ub = 0, xe2(e4);
        }, Gc: function() {
        }, pc: function() {
          dt.qc.forEach((t4) => t4());
        }, Fc: function(t4, e4) {
          t4.onmessage = (n3) => {
            var r4 = (n3 = n3.data).cmd;
            if (t4.Ub && (dt.Bc = t4.Ub), n3.targetThread && n3.targetThread != de2()) {
              var i2 = dt.Vb[n3.Qc];
              i2 ? i2.postMessage(n3, n3.transferList) : P2('Internal error! Worker sent a message "' + r4 + '" to target pthread ' + n3.targetThread + ", but that thread no longer exists!");
            } else "processProxyingQueue" === r4 ? Vt(n3.queue) : "spawnThread" === r4 ? lt(n3) : "cleanupThread" === r4 ? ct(n3.thread) : "killThread" === r4 ? (n3 = n3.thread, r4 = dt.Vb[n3], delete dt.Vb[n3], r4.terminate(), xe2(n3), dt.ac.splice(dt.ac.indexOf(r4), 1), r4.Ub = 0) : "cancelThread" === r4 ? dt.Vb[n3.thread].postMessage({ cmd: "cancel" }) : "loaded" === r4 ? (t4.loaded = true, e4 && e4(t4), t4.$b && (t4.$b(), delete t4.$b)) : "print" === r4 ? I2("Thread " + n3.threadId + ": " + n3.text) : "printErr" === r4 ? P2("Thread " + n3.threadId + ": " + n3.text) : "alert" === r4 ? alert("Thread " + n3.threadId + ": " + n3.text) : "setimmediate" === n3.target ? t4.postMessage(n3) : "onAbort" === r4 ? s.onAbort && s.onAbort(n3.arg) : r4 && P2("worker sent an unknown command " + r4);
            dt.Bc = void 0;
          }, t4.onerror = (t5) => {
            throw P2("worker sent an error! " + t5.filename + ":" + t5.lineno + ": " + t5.message), t5;
          }, w2 && (t4.on("message", function(e5) {
            t4.onmessage({ data: e5 });
          }), t4.on("error", function(e5) {
            t4.onerror(e5);
          }), t4.on("detachedExit", function() {
          })), t4.postMessage({ cmd: "load", urlOrBlob: s.mainScriptUrlOrBlob || _scriptDir, wasmMemory: $, wasmModule: k2 });
        }, yc: function() {
          var t4 = S2("ort-wasm-threaded.worker.js");
          dt.Yb.push(new Worker(t4));
        }, Cc: function() {
          return 0 == dt.Yb.length && (dt.yc(), dt.Fc(dt.Yb[0])), dt.Yb.pop();
        } };
        function ht(t4) {
          for (; 0 < t4.length; ) t4.shift()(s);
        }
        function gt(t4) {
          var e4 = Ae2();
          return t4 = t4(), Ee2(e4), t4;
        }
        function bt(t4) {
          if (x2) return qt(2, 0, t4);
          try {
            ft(t4);
          } catch (t5) {
            t5 instanceof ut || "unwind" == t5 || y2(1, t5);
          }
        }
        s.PThread = dt, s.establishStackSpace = function() {
          var t4 = de2(), e4 = i()[t4 + 44 >> 2 >>> 0];
          t4 = i()[t4 + 48 >> 2 >>> 0], Oe2(e4, e4 - t4), Ee2(e4);
        };
        var mt = [];
        function yt(t4) {
          var e4 = mt[t4];
          return e4 || (t4 >= mt.length && (mt.length = t4 + 1), mt[t4] = e4 = q2.get(t4)), e4;
        }
        s.invokeEntryPoint = function(t4, e4) {
          t4 = yt(t4)(e4), J2() ? dt.nc(t4) : Te2(t4);
        };
        var _t, vt, wt = [], xt = 0, Tt = 0;
        function St(t4) {
          this.Zb = t4, this.Sb = t4 - 24, this.xc = function(t5) {
            o()[this.Sb + 4 >> 2 >>> 0] = t5;
          }, this.bc = function() {
            return o()[this.Sb + 4 >> 2 >>> 0];
          }, this.wc = function(t5) {
            o()[this.Sb + 8 >> 2 >>> 0] = t5;
          }, this.Dc = function() {
            return o()[this.Sb + 8 >> 2 >>> 0];
          }, this.rc = function() {
            i()[this.Sb >> 2 >>> 0] = 0;
          }, this.hc = function(t5) {
            t5 = t5 ? 1 : 0, e3()[this.Sb + 12 >> 0 >>> 0] = t5;
          }, this.uc = function() {
            return 0 != e3()[this.Sb + 12 >> 0 >>> 0];
          }, this.ic = function(t5) {
            t5 = t5 ? 1 : 0, e3()[this.Sb + 13 >> 0 >>> 0] = t5;
          }, this.kc = function() {
            return 0 != e3()[this.Sb + 13 >> 0 >>> 0];
          }, this.fc = function(t5, e4) {
            this.cc(0), this.xc(t5), this.wc(e4), this.rc(), this.hc(false), this.ic(false);
          }, this.sc = function() {
            Atomics.add(i(), this.Sb >> 2, 1);
          }, this.Hc = function() {
            return 1 === Atomics.sub(i(), this.Sb >> 2, 1);
          }, this.cc = function(t5) {
            o()[this.Sb + 16 >> 2 >>> 0] = t5;
          }, this.tc = function() {
            return o()[this.Sb + 16 >> 2 >>> 0];
          }, this.vc = function() {
            if (De2(this.bc())) return o()[this.Zb >> 2 >>> 0];
            var t5 = this.tc();
            return 0 !== t5 ? t5 : this.Zb;
          };
        }
        function Ot(t4) {
          return ge2(new St(t4).Sb);
        }
        function At(t4, e4, n3, r4) {
          return x2 ? qt(3, 1, t4, e4, n3, r4) : Et(t4, e4, n3, r4);
        }
        function Et(t4, e4, n3, r4) {
          if ("undefined" == typeof SharedArrayBuffer) return P2("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
          var i2 = [];
          return x2 && 0 === i2.length ? At(t4, e4, n3, r4) : (t4 = { Ic: n3, Ub: t4, zc: r4, Nc: i2 }, x2 ? (t4.Oc = "spawnThread", postMessage(t4, i2), 0) : lt(t4));
        }
        function It(t4, e4, n3) {
          return x2 ? qt(4, 1, t4, e4, n3) : 0;
        }
        function Pt(t4, e4) {
          if (x2) return qt(5, 1, t4, e4);
        }
        function Dt(t4, e4) {
          if (x2) return qt(6, 1, t4, e4);
        }
        function $t(t4, e4, n3) {
          if (x2) return qt(7, 1, t4, e4, n3);
        }
        function kt(t4, e4, n3) {
          return x2 ? qt(8, 1, t4, e4, n3) : 0;
        }
        function Ct(t4, e4) {
          if (x2) return qt(9, 1, t4, e4);
        }
        function Ft(t4, e4, n3) {
          if (x2) return qt(10, 1, t4, e4, n3);
        }
        function Nt(t4, e4, n3, r4) {
          if (x2) return qt(11, 1, t4, e4, n3, r4);
        }
        function Lt(t4, e4, n3, r4) {
          if (x2) return qt(12, 1, t4, e4, n3, r4);
        }
        function Rt(t4, e4, n3, r4) {
          if (x2) return qt(13, 1, t4, e4, n3, r4);
        }
        function jt(t4) {
          if (x2) return qt(14, 1, t4);
        }
        function Mt(t4, e4) {
          if (x2) return qt(15, 1, t4, e4);
        }
        function Ut(t4, e4, n3) {
          if (x2) return qt(16, 1, t4, e4, n3);
        }
        function Vt(t4) {
          Atomics.store(i(), t4 >> 2, 1), de2() && we2(t4), Atomics.compareExchange(i(), t4 >> 2, 1, 0);
        }
        function Bt(t4) {
          return o()[t4 >>> 2] + 4294967296 * i()[t4 + 4 >>> 2];
        }
        function zt(t4, e4, n3, r4, i2, o2) {
          return x2 ? qt(17, 1, t4, e4, n3, r4, i2, o2) : -52;
        }
        function Gt(t4, e4, n3, r4, i2, o2) {
          if (x2) return qt(18, 1, t4, e4, n3, r4, i2, o2);
        }
        function Ht(t4) {
          var n3 = G2(t4) + 1, r4 = he2(n3);
          return r4 && z2(t4, e3(), r4, n3), r4;
        }
        function Wt(t4, e4, n3) {
          function r4(t5) {
            return (t5 = t5.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t5[1] : "GMT";
          }
          if (x2) return qt(19, 1, t4, e4, n3);
          var a2 = (/* @__PURE__ */ new Date()).getFullYear(), s2 = new Date(a2, 0, 1), u3 = new Date(a2, 6, 1);
          a2 = s2.getTimezoneOffset();
          var c3 = u3.getTimezoneOffset(), l3 = Math.max(a2, c3);
          i()[t4 >> 2 >>> 0] = 60 * l3, i()[e4 >> 2 >>> 0] = Number(a2 != c3), t4 = r4(s2), e4 = r4(u3), t4 = Ht(t4), e4 = Ht(e4), c3 < a2 ? (o()[n3 >> 2 >>> 0] = t4, o()[n3 + 4 >> 2 >>> 0] = e4) : (o()[n3 >> 2 >>> 0] = e4, o()[n3 + 4 >> 2 >>> 0] = t4);
        }
        function qt(t4, e4) {
          var n3 = arguments.length - 2, r4 = arguments;
          return gt(() => {
            for (var i2 = Ie2(8 * n3), o2 = i2 >> 3, s2 = 0; s2 < n3; s2++) {
              var u3 = r4[2 + s2];
              a()[o2 + s2 >>> 0] = u3;
            }
            return ve2(t4, n3, i2, e4);
          });
        }
        s.executeNotifiedProxyingQueue = Vt, vt = w2 ? () => {
          var t4 = process.hrtime();
          return 1e3 * t4[0] + t4[1] / 1e6;
        } : x2 ? () => performance.now() - s.__performance_now_clock_drift : () => performance.now();
        var Xt, Yt = [], Kt = {};
        function Zt() {
          if (!Xt) {
            var t4, e4 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: m2 || "./this.program" };
            for (t4 in Kt) void 0 === Kt[t4] ? delete e4[t4] : e4[t4] = Kt[t4];
            var n3 = [];
            for (t4 in e4) n3.push(t4 + "=" + e4[t4]);
            Xt = n3;
          }
          return Xt;
        }
        function Jt(t4, n3) {
          if (x2) return qt(20, 1, t4, n3);
          var r4 = 0;
          return Zt().forEach(function(i2, a2) {
            var s2 = n3 + r4;
            for (a2 = o()[t4 + 4 * a2 >> 2 >>> 0] = s2, s2 = 0; s2 < i2.length; ++s2) e3()[a2++ >> 0 >>> 0] = i2.charCodeAt(s2);
            e3()[a2 >> 0 >>> 0] = 0, r4 += i2.length + 1;
          }), 0;
        }
        function Qt(t4, e4) {
          if (x2) return qt(21, 1, t4, e4);
          var n3 = Zt();
          o()[t4 >> 2 >>> 0] = n3.length;
          var r4 = 0;
          return n3.forEach(function(t5) {
            r4 += t5.length + 1;
          }), o()[e4 >> 2 >>> 0] = r4, 0;
        }
        function te2(t4) {
          return x2 ? qt(22, 1, t4) : 52;
        }
        function ee2(t4, e4, n3, r4) {
          return x2 ? qt(23, 1, t4, e4, n3, r4) : 52;
        }
        function ne2(t4, e4, n3, r4, i2) {
          return x2 ? qt(24, 1, t4, e4, n3, r4, i2) : 70;
        }
        var re2 = [null, [], []];
        function ie2(t4, e4) {
          var n3 = re2[t4];
          0 === e4 || 10 === e4 ? ((1 === t4 ? I2 : P2)(V2(n3, 0)), n3.length = 0) : n3.push(e4);
        }
        function oe2(t4, e4, n3, i2) {
          if (x2) return qt(25, 1, t4, e4, n3, i2);
          for (var a2 = 0, s2 = 0; s2 < n3; s2++) {
            var u3 = o()[e4 >> 2 >>> 0], c3 = o()[e4 + 4 >> 2 >>> 0];
            e4 += 8;
            for (var l3 = 0; l3 < c3; l3++) ie2(t4, r3()[u3 + l3 >>> 0]);
            a2 += c3;
          }
          return o()[i2 >> 2 >>> 0] = a2, 0;
        }
        var ae2 = 0;
        function se2(t4) {
          return 0 == t4 % 4 && (0 != t4 % 100 || 0 == t4 % 400);
        }
        var ue2 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ce2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function le2(t4, n3, r4, o2) {
          function a2(t5, e4, n4) {
            for (t5 = "number" == typeof t5 ? t5.toString() : t5 || ""; t5.length < e4; ) t5 = n4[0] + t5;
            return t5;
          }
          function s2(t5, e4) {
            return a2(t5, e4, "0");
          }
          function u3(t5, e4) {
            function n4(t6) {
              return 0 > t6 ? -1 : 0 < t6 ? 1 : 0;
            }
            var r5;
            return 0 === (r5 = n4(t5.getFullYear() - e4.getFullYear())) && 0 === (r5 = n4(t5.getMonth() - e4.getMonth())) && (r5 = n4(t5.getDate() - e4.getDate())), r5;
          }
          function c3(t5) {
            switch (t5.getDay()) {
              case 0:
                return new Date(t5.getFullYear() - 1, 11, 29);
              case 1:
                return t5;
              case 2:
                return new Date(t5.getFullYear(), 0, 3);
              case 3:
                return new Date(t5.getFullYear(), 0, 2);
              case 4:
                return new Date(t5.getFullYear(), 0, 1);
              case 5:
                return new Date(t5.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(t5.getFullYear() - 1, 11, 30);
            }
          }
          function l3(t5) {
            var e4 = t5.Wb;
            for (t5 = new Date(new Date(t5.Xb + 1900, 0, 1).getTime()); 0 < e4; ) {
              var n4 = t5.getMonth(), r5 = (se2(t5.getFullYear()) ? ue2 : ce2)[n4];
              if (!(e4 > r5 - t5.getDate())) {
                t5.setDate(t5.getDate() + e4);
                break;
              }
              e4 -= r5 - t5.getDate() + 1, t5.setDate(1), 11 > n4 ? t5.setMonth(n4 + 1) : (t5.setMonth(0), t5.setFullYear(t5.getFullYear() + 1));
            }
            return n4 = new Date(t5.getFullYear() + 1, 0, 4), e4 = c3(new Date(t5.getFullYear(), 0, 4)), n4 = c3(n4), 0 >= u3(e4, t5) ? 0 >= u3(n4, t5) ? t5.getFullYear() + 1 : t5.getFullYear() : t5.getFullYear() - 1;
          }
          var p3 = i()[o2 + 40 >> 2 >>> 0];
          for (var f3 in o2 = { Lc: i()[o2 >> 2 >>> 0], Kc: i()[o2 + 4 >> 2 >>> 0], dc: i()[o2 + 8 >> 2 >>> 0], jc: i()[o2 + 12 >> 2 >>> 0], ec: i()[o2 + 16 >> 2 >>> 0], Xb: i()[o2 + 20 >> 2 >>> 0], Tb: i()[o2 + 24 >> 2 >>> 0], Wb: i()[o2 + 28 >> 2 >>> 0], Rc: i()[o2 + 32 >> 2 >>> 0], Jc: i()[o2 + 36 >> 2 >>> 0], Mc: p3 ? B2(p3) : "" }, r4 = B2(r4), p3 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }) r4 = r4.replace(new RegExp(f3, "g"), p3[f3]);
          var d3 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), h3 = "January February March April May June July August September October November December".split(" ");
          for (f3 in p3 = { "%a": function(t5) {
            return d3[t5.Tb].substring(0, 3);
          }, "%A": function(t5) {
            return d3[t5.Tb];
          }, "%b": function(t5) {
            return h3[t5.ec].substring(0, 3);
          }, "%B": function(t5) {
            return h3[t5.ec];
          }, "%C": function(t5) {
            return s2((t5.Xb + 1900) / 100 | 0, 2);
          }, "%d": function(t5) {
            return s2(t5.jc, 2);
          }, "%e": function(t5) {
            return a2(t5.jc, 2, " ");
          }, "%g": function(t5) {
            return l3(t5).toString().substring(2);
          }, "%G": function(t5) {
            return l3(t5);
          }, "%H": function(t5) {
            return s2(t5.dc, 2);
          }, "%I": function(t5) {
            return 0 == (t5 = t5.dc) ? t5 = 12 : 12 < t5 && (t5 -= 12), s2(t5, 2);
          }, "%j": function(t5) {
            for (var e4 = 0, n4 = 0; n4 <= t5.ec - 1; e4 += (se2(t5.Xb + 1900) ? ue2 : ce2)[n4++]) ;
            return s2(t5.jc + e4, 3);
          }, "%m": function(t5) {
            return s2(t5.ec + 1, 2);
          }, "%M": function(t5) {
            return s2(t5.Kc, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(t5) {
            return 0 <= t5.dc && 12 > t5.dc ? "AM" : "PM";
          }, "%S": function(t5) {
            return s2(t5.Lc, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(t5) {
            return t5.Tb || 7;
          }, "%U": function(t5) {
            return s2(Math.floor((t5.Wb + 7 - t5.Tb) / 7), 2);
          }, "%V": function(t5) {
            var e4 = Math.floor((t5.Wb + 7 - (t5.Tb + 6) % 7) / 7);
            if (2 >= (t5.Tb + 371 - t5.Wb - 2) % 7 && e4++, e4) 53 == e4 && (4 == (n4 = (t5.Tb + 371 - t5.Wb) % 7) || 3 == n4 && se2(t5.Xb) || (e4 = 1));
            else {
              e4 = 52;
              var n4 = (t5.Tb + 7 - t5.Wb - 1) % 7;
              (4 == n4 || 5 == n4 && se2(t5.Xb % 400 - 1)) && e4++;
            }
            return s2(e4, 2);
          }, "%w": function(t5) {
            return t5.Tb;
          }, "%W": function(t5) {
            return s2(Math.floor((t5.Wb + 7 - (t5.Tb + 6) % 7) / 7), 2);
          }, "%y": function(t5) {
            return (t5.Xb + 1900).toString().substring(2);
          }, "%Y": function(t5) {
            return t5.Xb + 1900;
          }, "%z": function(t5) {
            var e4 = 0 <= (t5 = t5.Jc);
            return t5 = Math.abs(t5) / 60, (e4 ? "+" : "-") + String("0000" + (t5 / 60 * 100 + t5 % 60)).slice(-4);
          }, "%Z": function(t5) {
            return t5.Mc;
          }, "%%": function() {
            return "%";
          } }, r4 = r4.replace(/%%/g, "\0\0"), p3) r4.includes(f3) && (r4 = r4.replace(new RegExp(f3, "g"), p3[f3](o2)));
          return f3 = function(t5) {
            var e4 = Array(G2(t5) + 1);
            return z2(t5, e4, 0, e4.length), e4;
          }(r4 = r4.replace(/\0\0/g, "%")), f3.length > n3 ? 0 : (function(t5, n4) {
            e3().set(t5, n4 >>> 0);
          }(f3, t4), f3.length - 1);
        }
        dt.fc();
        var pe2 = [null, pt2, bt, At, It, Pt, Dt, $t, kt, Ct, Ft, Nt, Lt, Rt, jt, Mt, Ut, zt, Gt, Wt, Jt, Qt, te2, ee2, ne2, oe2], fe2 = { b: function(t4) {
          return he2(t4 + 24) + 24;
        }, n: function(t4) {
          return (t4 = new St(t4)).uc() || (t4.hc(true), xt--), t4.ic(false), wt.push(t4), t4.sc(), t4.vc();
        }, ma: function(t4) {
          throw P2("Unexpected exception thrown, this is not properly supported - aborting"), M2 = true, t4;
        }, x: function() {
          Se2(0);
          var t4 = wt.pop();
          if (t4.Hc() && !t4.kc()) {
            var e4 = t4.Dc();
            e4 && yt(e4)(t4.Zb), Ot(t4.Zb);
          }
          Tt = 0;
        }, e: function() {
          var t4 = Tt;
          if (!t4) return ae2 = 0;
          var e4 = new St(t4);
          e4.cc(t4);
          var n3 = e4.bc();
          if (!n3) return ae2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r4.length; i2++) {
            var o2 = r4[i2];
            if (0 === o2 || o2 === n3) break;
            if (Pe2(o2, n3, e4.Sb + 16)) return ae2 = o2, t4;
          }
          return ae2 = n3, t4;
        }, l: function() {
          var t4 = Tt;
          if (!t4) return ae2 = 0;
          var e4 = new St(t4);
          e4.cc(t4);
          var n3 = e4.bc();
          if (!n3) return ae2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r4.length; i2++) {
            var o2 = r4[i2];
            if (0 === o2 || o2 === n3) break;
            if (Pe2(o2, n3, e4.Sb + 16)) return ae2 = o2, t4;
          }
          return ae2 = n3, t4;
        }, h: function() {
          var t4 = Tt;
          if (!t4) return ae2 = 0;
          var e4 = new St(t4);
          e4.cc(t4);
          var n3 = e4.bc();
          if (!n3) return ae2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r4.length; i2++) {
            var o2 = r4[i2];
            if (0 === o2 || o2 === n3) break;
            if (Pe2(o2, n3, e4.Sb + 16)) return ae2 = o2, t4;
          }
          return ae2 = n3, t4;
        }, t: Ot, M: function() {
          var t4 = wt.pop();
          t4 || it("no exception to throw");
          var e4 = t4.Zb;
          throw t4.kc() || (wt.push(t4), t4.ic(true), t4.hc(false), xt++), Tt = e4, e4;
        }, c: function(t4, e4, n3) {
          throw new St(t4).fc(e4, n3), Tt = t4, xt++, t4;
        }, pa: function() {
          return xt;
        }, Fa: function(t4) {
          ye2(t4, !v2, 1, !_), dt.pc();
        }, T: function(t4) {
          x2 ? postMessage({ cmd: "cleanupThread", thread: t4 }) : ct(t4);
        }, xa: Et, j: function(t4) {
          throw Tt || (Tt = t4), t4;
        }, H: It, Ma: Pt, ua: Dt, wa: $t, oa: kt, Ka: Ct, Ca: Ft, Ja: Nt, V: Lt, va: Rt, sa: jt, La: Mt, ta: Ut, Ta: function() {
        }, X: function() {
          it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
        }, Ua: function() {
          it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
        }, W: function() {
          return Date.now();
        }, ya: function() {
          return 2097152;
        }, Oa: function() {
          return true;
        }, za: function(t4, e4, n3, r4) {
          if (t4 == e4) setTimeout(() => Vt(r4));
          else if (x2) postMessage({ targetThread: t4, cmd: "processProxyingQueue", queue: r4 });
          else {
            if (!(t4 = dt.Vb[t4])) return;
            t4.postMessage({ cmd: "processProxyingQueue", queue: r4 });
          }
          return 1;
        }, Ea: function() {
          return -1;
        }, Pa: function(t4, e4) {
          t4 = new Date(1e3 * Bt(t4)), i()[e4 >> 2 >>> 0] = t4.getUTCSeconds(), i()[e4 + 4 >> 2 >>> 0] = t4.getUTCMinutes(), i()[e4 + 8 >> 2 >>> 0] = t4.getUTCHours(), i()[e4 + 12 >> 2 >>> 0] = t4.getUTCDate(), i()[e4 + 16 >> 2 >>> 0] = t4.getUTCMonth(), i()[e4 + 20 >> 2 >>> 0] = t4.getUTCFullYear() - 1900, i()[e4 + 24 >> 2 >>> 0] = t4.getUTCDay(), t4 = (t4.getTime() - Date.UTC(t4.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[e4 + 28 >> 2 >>> 0] = t4;
        }, Qa: function(t4, e4) {
          t4 = new Date(1e3 * Bt(t4)), i()[e4 >> 2 >>> 0] = t4.getSeconds(), i()[e4 + 4 >> 2 >>> 0] = t4.getMinutes(), i()[e4 + 8 >> 2 >>> 0] = t4.getHours(), i()[e4 + 12 >> 2 >>> 0] = t4.getDate(), i()[e4 + 16 >> 2 >>> 0] = t4.getMonth(), i()[e4 + 20 >> 2 >>> 0] = t4.getFullYear() - 1900, i()[e4 + 24 >> 2 >>> 0] = t4.getDay();
          var n3 = new Date(t4.getFullYear(), 0, 1), r4 = (t4.getTime() - n3.getTime()) / 864e5 | 0;
          i()[e4 + 28 >> 2 >>> 0] = r4, i()[e4 + 36 >> 2 >>> 0] = -60 * t4.getTimezoneOffset(), r4 = new Date(t4.getFullYear(), 6, 1).getTimezoneOffset(), t4 = 0 | (r4 != (n3 = n3.getTimezoneOffset()) && t4.getTimezoneOffset() == Math.min(n3, r4)), i()[e4 + 32 >> 2 >>> 0] = t4;
        }, Ra: function(t4) {
          var e4 = new Date(i()[t4 + 20 >> 2 >>> 0] + 1900, i()[t4 + 16 >> 2 >>> 0], i()[t4 + 12 >> 2 >>> 0], i()[t4 + 8 >> 2 >>> 0], i()[t4 + 4 >> 2 >>> 0], i()[t4 >> 2 >>> 0], 0), n3 = i()[t4 + 32 >> 2 >>> 0], r4 = e4.getTimezoneOffset(), o2 = new Date(e4.getFullYear(), 0, 1), a2 = new Date(e4.getFullYear(), 6, 1).getTimezoneOffset(), s2 = o2.getTimezoneOffset(), u3 = Math.min(s2, a2);
          return 0 > n3 ? i()[t4 + 32 >> 2 >>> 0] = Number(a2 != s2 && u3 == r4) : 0 < n3 != (u3 == r4) && (a2 = Math.max(s2, a2), e4.setTime(e4.getTime() + 6e4 * ((0 < n3 ? u3 : a2) - r4))), i()[t4 + 24 >> 2 >>> 0] = e4.getDay(), n3 = (e4.getTime() - o2.getTime()) / 864e5 | 0, i()[t4 + 28 >> 2 >>> 0] = n3, i()[t4 >> 2 >>> 0] = e4.getSeconds(), i()[t4 + 4 >> 2 >>> 0] = e4.getMinutes(), i()[t4 + 8 >> 2 >>> 0] = e4.getHours(), i()[t4 + 12 >> 2 >>> 0] = e4.getDate(), i()[t4 + 16 >> 2 >>> 0] = e4.getMonth(), e4.getTime() / 1e3 | 0;
        }, Aa: zt, Ba: Gt, Sa: function t4(e4, n3, r4) {
          t4.Ac || (t4.Ac = true, Wt(e4, n3, r4));
        }, y: function() {
          it("");
        }, U: function() {
          if (!w2 && !v2) {
            var t4 = "Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";
            _t || (_t = {}), _t[t4] || (_t[t4] = 1, w2 && (t4 = "warning: " + t4), P2(t4));
          }
        }, ra: function() {
          return 4294901760;
        }, B: vt, Ia: function(t4, e4, n3) {
          r3().copyWithin(t4 >>> 0, e4 >>> 0, e4 + n3 >>> 0);
        }, F: function() {
          return w2 ? n2(3993).cpus().length : navigator.hardwareConcurrency;
        }, Da: function(t4, e4, n3) {
          Yt.length = e4, n3 >>= 3;
          for (var r4 = 0; r4 < e4; r4++) Yt[r4] = a()[n3 + r4 >>> 0];
          return (0 > t4 ? st[-t4 - 1] : pe2[t4]).apply(null, Yt);
        }, qa: function(t4) {
          var e4 = r3().length;
          if ((t4 >>>= 0) <= e4 || 4294901760 < t4) return false;
          for (var n3 = 1; 4 >= n3; n3 *= 2) {
            var i2 = e4 * (1 + 0.2 / n3);
            i2 = Math.min(i2, t4 + 100663296);
            var o2 = Math;
            i2 = Math.max(t4, i2), o2 = o2.min.call(o2, 4294901760, i2 + (65536 - i2 % 65536) % 65536);
            t: {
              try {
                $.grow(o2 - C2.byteLength + 65535 >>> 16), H2($.buffer);
                var a2 = 1;
                break t;
              } catch (t5) {
              }
              a2 = void 0;
            }
            if (a2) return true;
          }
          return false;
        }, Na: function() {
          throw "unwind";
        }, Ga: Jt, Ha: Qt, J: ft, I: te2, S: ee2, ga: ne2, R: oe2, d: function() {
          return ae2;
        }, na: function t4(r4, i2) {
          t4.lc || (t4.lc = function() {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
              var t5 = new Uint8Array(1);
              return () => (crypto.getRandomValues(t5), t5[0]);
            }
            if (w2) try {
              var e4 = n2(Object(function() {
                var t6 = new Error("Cannot find module 'crypto'");
                throw t6.code = "MODULE_NOT_FOUND", t6;
              }()));
              return () => e4.randomBytes(1)[0];
            } catch (t6) {
            }
            return () => it("randomDevice");
          }());
          for (var o2 = 0; o2 < i2; o2++) e3()[r4 + o2 >> 0 >>> 0] = t4.lc();
          return 0;
        }, ia: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ja: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, K: function(t4) {
          var e4 = Ae2();
          try {
            return yt(t4)();
          } catch (t5) {
            if (Ee2(e4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, f: function(t4, e4) {
          var n3 = Ae2();
          try {
            return yt(t4)(e4);
          } catch (t5) {
            if (Ee2(n3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, P: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, Q: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, k: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, p: function(t4, e4, n3, r4) {
          var i2 = Ae2();
          try {
            return yt(t4)(e4, n3, r4);
          } catch (t5) {
            if (Ee2(i2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, q: function(t4, e4, n3, r4, i2) {
          var o2 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i2);
          } catch (t5) {
            if (Ee2(o2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, N: function(t4, e4, n3, r4, i2, o2) {
          var a2 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i2, o2);
          } catch (t5) {
            if (Ee2(a2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, s: function(t4, e4, n3, r4, i2, o2) {
          var a2 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i2, o2);
          } catch (t5) {
            if (Ee2(a2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, w: function(t4, e4, n3, r4, i2, o2, a2) {
          var s2 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i2, o2, a2);
          } catch (t5) {
            if (Ee2(s2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, L: function(t4, e4, n3, r4, i2, o2, a2, s2) {
          var u3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i2, o2, a2, s2);
          } catch (t5) {
            if (Ee2(u3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, E: function(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3) {
          var f3 = Ae2();
          try {
            return yt(t4)(e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3);
          } catch (t5) {
            if (Ee2(f3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, aa: function(t4, e4, n3, r4, i2, o2, a2, s2) {
          var u3 = Ae2();
          try {
            return Me2(t4, e4, n3, r4, i2, o2, a2, s2);
          } catch (t5) {
            if (Ee2(u3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, _: function(t4, e4, n3, r4, i2, o2, a2) {
          var s2 = Ae2();
          try {
            return ke2(t4, e4, n3, r4, i2, o2, a2);
          } catch (t5) {
            if (Ee2(s2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, Z: function(t4, e4, n3, r4, i2) {
          var o2 = Ae2();
          try {
            return Ue2(t4, e4, n3, r4, i2);
          } catch (t5) {
            if (Ee2(o2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ca: function(t4, e4, n3, r4) {
          var i2 = Ae2();
          try {
            return Re2(t4, e4, n3, r4);
          } catch (t5) {
            if (Ee2(i2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, $: function(t4) {
          var e4 = Ae2();
          try {
            return $e2(t4);
          } catch (t5) {
            if (Ee2(e4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ba: function(t4, e4) {
          var n3 = Ae2();
          try {
            return je2(t4, e4);
          } catch (t5) {
            if (Ee2(n3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, Y: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            return Ce2(t4, e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, g: function(t4) {
          var e4 = Ae2();
          try {
            yt(t4)();
          } catch (t5) {
            if (Ee2(e4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, r: function(t4, e4) {
          var n3 = Ae2();
          try {
            yt(t4)(e4);
          } catch (t5) {
            if (Ee2(n3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, i: function(t4, e4, n3) {
          var r4 = Ae2();
          try {
            yt(t4)(e4, n3);
          } catch (t5) {
            if (Ee2(r4), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ha: function(t4, e4, n3, r4) {
          var i2 = Ae2();
          try {
            yt(t4)(e4, n3, r4);
          } catch (t5) {
            if (Ee2(i2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, m: function(t4, e4, n3, r4) {
          var i2 = Ae2();
          try {
            yt(t4)(e4, n3, r4);
          } catch (t5) {
            if (Ee2(i2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, v: function(t4, e4, n3, r4, i2) {
          var o2 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i2);
          } catch (t5) {
            if (Ee2(o2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, u: function(t4, e4, n3, r4, i2, o2) {
          var a2 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i2, o2);
          } catch (t5) {
            if (Ee2(a2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, O: function(t4, e4, n3, r4, i2, o2, a2) {
          var s2 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i2, o2, a2);
          } catch (t5) {
            if (Ee2(s2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, A: function(t4, e4, n3, r4, i2, o2, a2, s2) {
          var u3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i2, o2, a2, s2);
          } catch (t5) {
            if (Ee2(u3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ka: function(t4, e4, n3, r4, i2, o2, a2, s2, u3) {
          var c3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i2, o2, a2, s2, u3);
          } catch (t5) {
            if (Ee2(c3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, C: function(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3) {
          var p3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i2, o2, a2, s2, u3, c3, l3);
          } catch (t5) {
            if (Ee2(p3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, D: function(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3, f3, d3, h3, g3) {
          var b3 = Ae2();
          try {
            yt(t4)(e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3, f3, d3, h3, g3);
          } catch (t5) {
            if (Ee2(b3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, fa: function(t4, e4, n3, r4, i2, o2, a2, s2) {
          var u3 = Ae2();
          try {
            Fe2(t4, e4, n3, r4, i2, o2, a2, s2);
          } catch (t5) {
            if (Ee2(u3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, da: function(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3) {
          var f3 = Ae2();
          try {
            Le2(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3);
          } catch (t5) {
            if (Ee2(f3), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, ea: function(t4, e4, n3, r4, i2, o2) {
          var a2 = Ae2();
          try {
            Ne2(t4, e4, n3, r4, i2, o2);
          } catch (t5) {
            if (Ee2(a2), t5 !== t5 + 0) throw t5;
            Se2(1, 0);
          }
        }, o: function(t4) {
          return t4;
        }, a: $ || s.wasmMemory, G: function(t4) {
          ae2 = t4;
        }, la: le2, z: function(t4, e4, n3, r4) {
          return le2(t4, e4, n3, r4);
        } };
        !function() {
          function t4(t5, e5) {
            s.asm = t5.exports, dt.qc.push(s.asm.sb), q2 = s.asm.ub, Y2.unshift(s.asm.Va), k2 = e5, x2 || (et--, s.monitorRunDependencies && s.monitorRunDependencies(et), 0 == et && (rt && (t5 = rt, rt = null, t5())));
          }
          function e4(e5) {
            t4(e5.instance, e5.module);
          }
          function n3(t5) {
            return function() {
              if (!E2 && (_ || v2)) {
                if ("function" == typeof fetch && !tt.startsWith("file://")) return fetch(tt, { credentials: "same-origin" }).then(function(t6) {
                  if (!t6.ok) throw "failed to load wasm binary file at '" + tt + "'";
                  return t6.arrayBuffer();
                }).catch(function() {
                  return at();
                });
                if (p2) return new Promise(function(t6, e5) {
                  p2(tt, function(e6) {
                    t6(new Uint8Array(e6));
                  }, e5);
                });
              }
              return Promise.resolve().then(function() {
                return at();
              });
            }().then(function(t6) {
              return WebAssembly.instantiate(t6, r4);
            }).then(function(t6) {
              return t6;
            }).then(t5, function(t6) {
              P2("failed to asynchronously prepare wasm: " + t6), it(t6);
            });
          }
          var r4 = { a: fe2 };
          if (x2 || (et++, s.monitorRunDependencies && s.monitorRunDependencies(et)), s.instantiateWasm) try {
            return s.instantiateWasm(r4, t4);
          } catch (t5) {
            return P2("Module.instantiateWasm callback failed with error: " + t5), false;
          }
          (E2 || "function" != typeof WebAssembly.instantiateStreaming || ot() || tt.startsWith("file://") || w2 || "function" != typeof fetch ? n3(e4) : fetch(tt, { credentials: "same-origin" }).then(function(t5) {
            return WebAssembly.instantiateStreaming(t5, r4).then(e4, function(t6) {
              return P2("wasm streaming compile failed: " + t6), P2("falling back to ArrayBuffer instantiation"), n3(e4);
            });
          })).catch(c2);
        }(), s.___wasm_call_ctors = function() {
          return (s.___wasm_call_ctors = s.asm.Va).apply(null, arguments);
        }, s._OrtInit = function() {
          return (s._OrtInit = s.asm.Wa).apply(null, arguments);
        }, s._OrtCreateSessionOptions = function() {
          return (s._OrtCreateSessionOptions = s.asm.Xa).apply(null, arguments);
        }, s._OrtAppendExecutionProvider = function() {
          return (s._OrtAppendExecutionProvider = s.asm.Ya).apply(null, arguments);
        }, s._OrtAddSessionConfigEntry = function() {
          return (s._OrtAddSessionConfigEntry = s.asm.Za).apply(null, arguments);
        }, s._OrtReleaseSessionOptions = function() {
          return (s._OrtReleaseSessionOptions = s.asm._a).apply(null, arguments);
        }, s._OrtCreateSession = function() {
          return (s._OrtCreateSession = s.asm.$a).apply(null, arguments);
        }, s._OrtReleaseSession = function() {
          return (s._OrtReleaseSession = s.asm.ab).apply(null, arguments);
        }, s._OrtGetInputCount = function() {
          return (s._OrtGetInputCount = s.asm.bb).apply(null, arguments);
        }, s._OrtGetOutputCount = function() {
          return (s._OrtGetOutputCount = s.asm.cb).apply(null, arguments);
        }, s._OrtGetInputName = function() {
          return (s._OrtGetInputName = s.asm.db).apply(null, arguments);
        }, s._OrtGetOutputName = function() {
          return (s._OrtGetOutputName = s.asm.eb).apply(null, arguments);
        }, s._OrtFree = function() {
          return (s._OrtFree = s.asm.fb).apply(null, arguments);
        }, s._OrtCreateTensor = function() {
          return (s._OrtCreateTensor = s.asm.gb).apply(null, arguments);
        }, s._OrtGetTensorData = function() {
          return (s._OrtGetTensorData = s.asm.hb).apply(null, arguments);
        }, s._OrtReleaseTensor = function() {
          return (s._OrtReleaseTensor = s.asm.ib).apply(null, arguments);
        }, s._OrtCreateRunOptions = function() {
          return (s._OrtCreateRunOptions = s.asm.jb).apply(null, arguments);
        }, s._OrtAddRunConfigEntry = function() {
          return (s._OrtAddRunConfigEntry = s.asm.kb).apply(null, arguments);
        }, s._OrtReleaseRunOptions = function() {
          return (s._OrtReleaseRunOptions = s.asm.lb).apply(null, arguments);
        }, s._OrtRun = function() {
          return (s._OrtRun = s.asm.mb).apply(null, arguments);
        }, s._OrtEndProfiling = function() {
          return (s._OrtEndProfiling = s.asm.nb).apply(null, arguments);
        };
        var de2 = s._pthread_self = function() {
          return (de2 = s._pthread_self = s.asm.ob).apply(null, arguments);
        }, he2 = s._malloc = function() {
          return (he2 = s._malloc = s.asm.pb).apply(null, arguments);
        }, ge2 = s._free = function() {
          return (ge2 = s._free = s.asm.qb).apply(null, arguments);
        }, be2 = s._fflush = function() {
          return (be2 = s._fflush = s.asm.rb).apply(null, arguments);
        };
        s.__emscripten_tls_init = function() {
          return (s.__emscripten_tls_init = s.asm.sb).apply(null, arguments);
        };
        var me2 = s.___funcs_on_exit = function() {
          return (me2 = s.___funcs_on_exit = s.asm.tb).apply(null, arguments);
        }, ye2 = s.__emscripten_thread_init = function() {
          return (ye2 = s.__emscripten_thread_init = s.asm.vb).apply(null, arguments);
        };
        s.__emscripten_thread_crashed = function() {
          return (s.__emscripten_thread_crashed = s.asm.wb).apply(null, arguments);
        };
        var _e, ve2 = s._emscripten_run_in_main_runtime_thread_js = function() {
          return (ve2 = s._emscripten_run_in_main_runtime_thread_js = s.asm.xb).apply(null, arguments);
        }, we2 = s.__emscripten_proxy_execute_task_queue = function() {
          return (we2 = s.__emscripten_proxy_execute_task_queue = s.asm.yb).apply(null, arguments);
        }, xe2 = s.__emscripten_thread_free_data = function() {
          return (xe2 = s.__emscripten_thread_free_data = s.asm.zb).apply(null, arguments);
        }, Te2 = s.__emscripten_thread_exit = function() {
          return (Te2 = s.__emscripten_thread_exit = s.asm.Ab).apply(null, arguments);
        }, Se2 = s._setThrew = function() {
          return (Se2 = s._setThrew = s.asm.Bb).apply(null, arguments);
        }, Oe2 = s._emscripten_stack_set_limits = function() {
          return (Oe2 = s._emscripten_stack_set_limits = s.asm.Cb).apply(null, arguments);
        }, Ae2 = s.stackSave = function() {
          return (Ae2 = s.stackSave = s.asm.Db).apply(null, arguments);
        }, Ee2 = s.stackRestore = function() {
          return (Ee2 = s.stackRestore = s.asm.Eb).apply(null, arguments);
        }, Ie2 = s.stackAlloc = function() {
          return (Ie2 = s.stackAlloc = s.asm.Fb).apply(null, arguments);
        }, Pe2 = s.___cxa_can_catch = function() {
          return (Pe2 = s.___cxa_can_catch = s.asm.Gb).apply(null, arguments);
        }, De2 = s.___cxa_is_pointer_type = function() {
          return (De2 = s.___cxa_is_pointer_type = s.asm.Hb).apply(null, arguments);
        }, $e2 = s.dynCall_j = function() {
          return ($e2 = s.dynCall_j = s.asm.Ib).apply(null, arguments);
        }, ke2 = s.dynCall_iiiiij = function() {
          return (ke2 = s.dynCall_iiiiij = s.asm.Jb).apply(null, arguments);
        }, Ce2 = s.dynCall_jii = function() {
          return (Ce2 = s.dynCall_jii = s.asm.Kb).apply(null, arguments);
        }, Fe2 = s.dynCall_viiiiij = function() {
          return (Fe2 = s.dynCall_viiiiij = s.asm.Lb).apply(null, arguments);
        }, Ne2 = s.dynCall_vjji = function() {
          return (Ne2 = s.dynCall_vjji = s.asm.Mb).apply(null, arguments);
        }, Le2 = s.dynCall_viiijjjii = function() {
          return (Le2 = s.dynCall_viiijjjii = s.asm.Nb).apply(null, arguments);
        }, Re2 = s.dynCall_iij = function() {
          return (Re2 = s.dynCall_iij = s.asm.Ob).apply(null, arguments);
        }, je2 = s.dynCall_ji = function() {
          return (je2 = s.dynCall_ji = s.asm.Pb).apply(null, arguments);
        }, Me2 = s.dynCall_iiiiiij = function() {
          return (Me2 = s.dynCall_iiiiiij = s.asm.Qb).apply(null, arguments);
        }, Ue2 = s.dynCall_iiij = function() {
          return (Ue2 = s.dynCall_iiij = s.asm.Rb).apply(null, arguments);
        };
        function Ve2() {
          function t4() {
            if (!_e && (_e = true, s.calledRun = true, !M2) && (x2 || ht(Y2), u2(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), !x2)) {
              if (s.postRun) for ("function" == typeof s.postRun && (s.postRun = [s.postRun]); s.postRun.length; ) {
                var t5 = s.postRun.shift();
                Z2.unshift(t5);
              }
              ht(Z2);
            }
          }
          if (!(0 < et)) if (x2) u2(s), x2 || ht(Y2), postMessage({ cmd: "loaded" });
          else {
            if (s.preRun) for ("function" == typeof s.preRun && (s.preRun = [s.preRun]); s.preRun.length; ) Q2();
            ht(X2), 0 < et || (s.setStatus ? (s.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                s.setStatus("");
              }, 1), t4();
            }, 1)) : t4());
          }
        }
        if (s.UTF8ToString = B2, s.stringToUTF8 = function(t4, e4, n3) {
          return z2(t4, r3(), e4, n3);
        }, s.lengthBytesUTF8 = G2, s.keepRuntimeAlive = J2, s.wasmMemory = $, s.stackSave = Ae2, s.stackRestore = Ee2, s.stackAlloc = Ie2, s.ExitStatus = ut, s.PThread = dt, rt = function t4() {
          _e || Ve2(), _e || (rt = t4);
        }, s.preInit) for ("function" == typeof s.preInit && (s.preInit = [s.preInit]); 0 < s.preInit.length; ) s.preInit.pop()();
        return Ve2(), t3.ready;
      });
      t2.exports = r2;
    }, 932: (t2, e2, n2) => {
      var _scriptDir, r2 = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t3) {
        var e3, r3, i;
        t3 = t3 || {}, e3 || (e3 = void 0 !== t3 ? t3 : {}), e3.ready = new Promise(function(t4, e4) {
          r3 = t4, i = e4;
        });
        var o, a, s, u2, c2, l2, p2 = Object.assign({}, e3), f2 = "./this.program", d2 = (t4, e4) => {
          throw e4;
        }, h2 = "object" == typeof window, g2 = "function" == typeof importScripts, b2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, m2 = "";
        b2 ? (m2 = g2 ? n2(908).dirname(m2) + "/" : "//", l2 = () => {
          c2 || (u2 = n2(1384), c2 = n2(908));
        }, o = function(t4, e4) {
          return l2(), t4 = c2.normalize(t4), u2.readFileSync(t4, e4 ? void 0 : "utf8");
        }, s = (t4) => ((t4 = o(t4, true)).buffer || (t4 = new Uint8Array(t4)), t4), a = (t4, e4, n3) => {
          l2(), t4 = c2.normalize(t4), u2.readFile(t4, function(t5, r4) {
            t5 ? n3(t5) : e4(r4.buffer);
          });
        }, 1 < process.argv.length && (f2 = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t4) {
          if (!(t4 instanceof K2)) throw t4;
        }), process.on("unhandledRejection", function(t4) {
          throw t4;
        }), d2 = (t4, e4) => {
          if (w2 || 0 < U2) throw process.exitCode = t4, e4;
          e4 instanceof K2 || v2("exiting due to exception: " + e4), process.exit(t4);
        }, e3.inspect = function() {
          return "[Emscripten Module object]";
        }) : (h2 || g2) && (g2 ? m2 = self.location.href : "undefined" != typeof document && document.currentScript && (m2 = document.currentScript.src), _scriptDir && (m2 = _scriptDir), m2 = 0 !== m2.indexOf("blob:") ? m2.substr(0, m2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", o = (t4) => {
          var e4 = new XMLHttpRequest();
          return e4.open("GET", t4, false), e4.send(null), e4.responseText;
        }, g2 && (s = (t4) => {
          var e4 = new XMLHttpRequest();
          return e4.open("GET", t4, false), e4.responseType = "arraybuffer", e4.send(null), new Uint8Array(e4.response);
        }), a = (t4, e4, n3) => {
          var r4 = new XMLHttpRequest();
          r4.open("GET", t4, true), r4.responseType = "arraybuffer", r4.onload = () => {
            200 == r4.status || 0 == r4.status && r4.response ? e4(r4.response) : n3();
          }, r4.onerror = n3, r4.send(null);
        });
        var y2, _ = e3.print || console.log.bind(console), v2 = e3.printErr || console.warn.bind(console);
        Object.assign(e3, p2), p2 = null, e3.thisProgram && (f2 = e3.thisProgram), e3.quit && (d2 = e3.quit), e3.wasmBinary && (y2 = e3.wasmBinary);
        var w2 = e3.noExitRuntime || false;
        "object" != typeof WebAssembly && W2("no native wasm support detected");
        var x2, T2, S2, O2, A2, E2, I2 = false, P2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function D2(t4, e4, n3) {
          var r4 = (e4 >>>= 0) + n3;
          for (n3 = e4; t4[n3] && !(n3 >= r4); ) ++n3;
          if (16 < n3 - e4 && t4.buffer && P2) return P2.decode(t4.subarray(e4, n3));
          for (r4 = ""; e4 < n3; ) {
            var i2 = t4[e4++];
            if (128 & i2) {
              var o2 = 63 & t4[e4++];
              if (192 == (224 & i2)) r4 += String.fromCharCode((31 & i2) << 6 | o2);
              else {
                var a2 = 63 & t4[e4++];
                65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & t4[e4++]) ? r4 += String.fromCharCode(i2) : (i2 -= 65536, r4 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
              }
            } else r4 += String.fromCharCode(i2);
          }
          return r4;
        }
        function $(t4, e4) {
          return (t4 >>>= 0) ? D2(O2, t4, e4) : "";
        }
        function k2(t4, e4, n3, r4) {
          if (!(0 < r4)) return 0;
          var i2 = n3 >>>= 0;
          r4 = n3 + r4 - 1;
          for (var o2 = 0; o2 < t4.length; ++o2) {
            var a2 = t4.charCodeAt(o2);
            if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & t4.charCodeAt(++o2)), 127 >= a2) {
              if (n3 >= r4) break;
              e4[n3++ >>> 0] = a2;
            } else {
              if (2047 >= a2) {
                if (n3 + 1 >= r4) break;
                e4[n3++ >>> 0] = 192 | a2 >> 6;
              } else {
                if (65535 >= a2) {
                  if (n3 + 2 >= r4) break;
                  e4[n3++ >>> 0] = 224 | a2 >> 12;
                } else {
                  if (n3 + 3 >= r4) break;
                  e4[n3++ >>> 0] = 240 | a2 >> 18, e4[n3++ >>> 0] = 128 | a2 >> 12 & 63;
                }
                e4[n3++ >>> 0] = 128 | a2 >> 6 & 63;
              }
              e4[n3++ >>> 0] = 128 | 63 & a2;
            }
          }
          return e4[n3 >>> 0] = 0, n3 - i2;
        }
        function C2(t4) {
          for (var e4 = 0, n3 = 0; n3 < t4.length; ++n3) {
            var r4 = t4.charCodeAt(n3);
            127 >= r4 ? e4++ : 2047 >= r4 ? e4 += 2 : 55296 <= r4 && 57343 >= r4 ? (e4 += 4, ++n3) : e4 += 3;
          }
          return e4;
        }
        function F2() {
          var t4 = x2.buffer;
          T2 = t4, e3.HEAP8 = S2 = new Int8Array(t4), e3.HEAP16 = new Int16Array(t4), e3.HEAP32 = A2 = new Int32Array(t4), e3.HEAPU8 = O2 = new Uint8Array(t4), e3.HEAPU16 = new Uint16Array(t4), e3.HEAPU32 = E2 = new Uint32Array(t4), e3.HEAPF32 = new Float32Array(t4), e3.HEAPF64 = new Float64Array(t4);
        }
        var N2, L2 = [], R2 = [], j = [], M2 = [], U2 = 0;
        function V2() {
          var t4 = e3.preRun.shift();
          L2.unshift(t4);
        }
        var B2, z2 = 0, H2 = null;
        function W2(t4) {
          throw e3.onAbort && e3.onAbort(t4), v2(t4 = "Aborted(" + t4 + ")"), I2 = true, t4 = new WebAssembly.RuntimeError(t4 + ". Build with -sASSERTIONS for more info."), i(t4), t4;
        }
        function q2() {
          return B2.startsWith("data:application/octet-stream;base64,");
        }
        if (B2 = "ort-wasm.wasm", !q2()) {
          var X2 = B2;
          B2 = e3.locateFile ? e3.locateFile(X2, m2) : m2 + X2;
        }
        function Y2() {
          var t4 = B2;
          try {
            if (t4 == B2 && y2) return new Uint8Array(y2);
            if (s) return s(t4);
            throw "both async and sync fetching of the wasm failed";
          } catch (t5) {
            W2(t5);
          }
        }
        function K2(t4) {
          this.name = "ExitStatus", this.message = "Program terminated with exit(" + t4 + ")", this.status = t4;
        }
        function Z2(t4) {
          for (; 0 < t4.length; ) t4.shift()(e3);
        }
        var J2 = [], Q2 = 0, tt = 0;
        function et(t4) {
          this.Db = t4, this.zb = t4 - 24, this.Ub = function(t5) {
            E2[this.zb + 4 >> 2 >>> 0] = t5;
          }, this.Eb = function() {
            return E2[this.zb + 4 >> 2 >>> 0];
          }, this.Sb = function(t5) {
            E2[this.zb + 8 >> 2 >>> 0] = t5;
          }, this.Wb = function() {
            return E2[this.zb + 8 >> 2 >>> 0];
          }, this.Tb = function() {
            A2[this.zb >> 2 >>> 0] = 0;
          }, this.Ib = function(t5) {
            S2[this.zb + 12 >> 0 >>> 0] = t5 ? 1 : 0;
          }, this.Pb = function() {
            return 0 != S2[this.zb + 12 >> 0 >>> 0];
          }, this.Jb = function(t5) {
            S2[this.zb + 13 >> 0 >>> 0] = t5 ? 1 : 0;
          }, this.Lb = function() {
            return 0 != S2[this.zb + 13 >> 0 >>> 0];
          }, this.Rb = function(t5, e4) {
            this.Fb(0), this.Ub(t5), this.Sb(e4), this.Tb(), this.Ib(false), this.Jb(false);
          }, this.Nb = function() {
            A2[this.zb >> 2 >>> 0] += 1;
          }, this.Xb = function() {
            var t5 = A2[this.zb >> 2 >>> 0];
            return A2[this.zb >> 2 >>> 0] = t5 - 1, 1 === t5;
          }, this.Fb = function(t5) {
            E2[this.zb + 16 >> 2 >>> 0] = t5;
          }, this.Ob = function() {
            return E2[this.zb + 16 >> 2 >>> 0];
          }, this.Qb = function() {
            if (Et(this.Eb())) return E2[this.Db >> 2 >>> 0];
            var t5 = this.Ob();
            return 0 !== t5 ? t5 : this.Db;
          };
        }
        function nt(t4) {
          return _t(new et(t4).zb);
        }
        var rt = [];
        function it(t4) {
          var e4 = rt[t4];
          return e4 || (t4 >= rt.length && (rt.length = t4 + 1), rt[t4] = e4 = N2.get(t4)), e4;
        }
        function ot(t4) {
          var e4 = C2(t4) + 1, n3 = yt(e4);
          return n3 && k2(t4, S2, n3, e4), n3;
        }
        var at = {};
        function st() {
          if (!ut) {
            var t4, e4 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: f2 || "./this.program" };
            for (t4 in at) void 0 === at[t4] ? delete e4[t4] : e4[t4] = at[t4];
            var n3 = [];
            for (t4 in e4) n3.push(t4 + "=" + e4[t4]);
            ut = n3;
          }
          return ut;
        }
        var ut, ct = [null, [], []];
        function lt(t4, e4) {
          var n3 = ct[t4];
          0 === e4 || 10 === e4 ? ((1 === t4 ? _ : v2)(D2(n3, 0)), n3.length = 0) : n3.push(e4);
        }
        var pt2 = 0;
        function ft(t4) {
          return 0 == t4 % 4 && (0 != t4 % 100 || 0 == t4 % 400);
        }
        var dt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ht = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function gt(t4, e4, n3, r4) {
          function i2(t5, e5, n4) {
            for (t5 = "number" == typeof t5 ? t5.toString() : t5 || ""; t5.length < e5; ) t5 = n4[0] + t5;
            return t5;
          }
          function o2(t5, e5) {
            return i2(t5, e5, "0");
          }
          function a2(t5, e5) {
            function n4(t6) {
              return 0 > t6 ? -1 : 0 < t6 ? 1 : 0;
            }
            var r5;
            return 0 === (r5 = n4(t5.getFullYear() - e5.getFullYear())) && 0 === (r5 = n4(t5.getMonth() - e5.getMonth())) && (r5 = n4(t5.getDate() - e5.getDate())), r5;
          }
          function s2(t5) {
            switch (t5.getDay()) {
              case 0:
                return new Date(t5.getFullYear() - 1, 11, 29);
              case 1:
                return t5;
              case 2:
                return new Date(t5.getFullYear(), 0, 3);
              case 3:
                return new Date(t5.getFullYear(), 0, 2);
              case 4:
                return new Date(t5.getFullYear(), 0, 1);
              case 5:
                return new Date(t5.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(t5.getFullYear() - 1, 11, 30);
            }
          }
          function u3(t5) {
            var e5 = t5.Bb;
            for (t5 = new Date(new Date(t5.Cb + 1900, 0, 1).getTime()); 0 < e5; ) {
              var n4 = t5.getMonth(), r5 = (ft(t5.getFullYear()) ? dt : ht)[n4];
              if (!(e5 > r5 - t5.getDate())) {
                t5.setDate(t5.getDate() + e5);
                break;
              }
              e5 -= r5 - t5.getDate() + 1, t5.setDate(1), 11 > n4 ? t5.setMonth(n4 + 1) : (t5.setMonth(0), t5.setFullYear(t5.getFullYear() + 1));
            }
            return n4 = new Date(t5.getFullYear() + 1, 0, 4), e5 = s2(new Date(t5.getFullYear(), 0, 4)), n4 = s2(n4), 0 >= a2(e5, t5) ? 0 >= a2(n4, t5) ? t5.getFullYear() + 1 : t5.getFullYear() : t5.getFullYear() - 1;
          }
          var c3 = A2[r4 + 40 >> 2 >>> 0];
          for (var l3 in r4 = { $b: A2[r4 >> 2 >>> 0], Zb: A2[r4 + 4 >> 2 >>> 0], Gb: A2[r4 + 8 >> 2 >>> 0], Kb: A2[r4 + 12 >> 2 >>> 0], Hb: A2[r4 + 16 >> 2 >>> 0], Cb: A2[r4 + 20 >> 2 >>> 0], Ab: A2[r4 + 24 >> 2 >>> 0], Bb: A2[r4 + 28 >> 2 >>> 0], bc: A2[r4 + 32 >> 2 >>> 0], Yb: A2[r4 + 36 >> 2 >>> 0], ac: c3 ? $(c3) : "" }, n3 = $(n3), c3 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }) n3 = n3.replace(new RegExp(l3, "g"), c3[l3]);
          var p3 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), f3 = "January February March April May June July August September October November December".split(" ");
          for (l3 in c3 = { "%a": function(t5) {
            return p3[t5.Ab].substring(0, 3);
          }, "%A": function(t5) {
            return p3[t5.Ab];
          }, "%b": function(t5) {
            return f3[t5.Hb].substring(0, 3);
          }, "%B": function(t5) {
            return f3[t5.Hb];
          }, "%C": function(t5) {
            return o2((t5.Cb + 1900) / 100 | 0, 2);
          }, "%d": function(t5) {
            return o2(t5.Kb, 2);
          }, "%e": function(t5) {
            return i2(t5.Kb, 2, " ");
          }, "%g": function(t5) {
            return u3(t5).toString().substring(2);
          }, "%G": function(t5) {
            return u3(t5);
          }, "%H": function(t5) {
            return o2(t5.Gb, 2);
          }, "%I": function(t5) {
            return 0 == (t5 = t5.Gb) ? t5 = 12 : 12 < t5 && (t5 -= 12), o2(t5, 2);
          }, "%j": function(t5) {
            for (var e5 = 0, n4 = 0; n4 <= t5.Hb - 1; e5 += (ft(t5.Cb + 1900) ? dt : ht)[n4++]) ;
            return o2(t5.Kb + e5, 3);
          }, "%m": function(t5) {
            return o2(t5.Hb + 1, 2);
          }, "%M": function(t5) {
            return o2(t5.Zb, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(t5) {
            return 0 <= t5.Gb && 12 > t5.Gb ? "AM" : "PM";
          }, "%S": function(t5) {
            return o2(t5.$b, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(t5) {
            return t5.Ab || 7;
          }, "%U": function(t5) {
            return o2(Math.floor((t5.Bb + 7 - t5.Ab) / 7), 2);
          }, "%V": function(t5) {
            var e5 = Math.floor((t5.Bb + 7 - (t5.Ab + 6) % 7) / 7);
            if (2 >= (t5.Ab + 371 - t5.Bb - 2) % 7 && e5++, e5) 53 == e5 && (4 == (n4 = (t5.Ab + 371 - t5.Bb) % 7) || 3 == n4 && ft(t5.Cb) || (e5 = 1));
            else {
              e5 = 52;
              var n4 = (t5.Ab + 7 - t5.Bb - 1) % 7;
              (4 == n4 || 5 == n4 && ft(t5.Cb % 400 - 1)) && e5++;
            }
            return o2(e5, 2);
          }, "%w": function(t5) {
            return t5.Ab;
          }, "%W": function(t5) {
            return o2(Math.floor((t5.Bb + 7 - (t5.Ab + 6) % 7) / 7), 2);
          }, "%y": function(t5) {
            return (t5.Cb + 1900).toString().substring(2);
          }, "%Y": function(t5) {
            return t5.Cb + 1900;
          }, "%z": function(t5) {
            var e5 = 0 <= (t5 = t5.Yb);
            return t5 = Math.abs(t5) / 60, (e5 ? "+" : "-") + String("0000" + (t5 / 60 * 100 + t5 % 60)).slice(-4);
          }, "%Z": function(t5) {
            return t5.ac;
          }, "%%": function() {
            return "%";
          } }, n3 = n3.replace(/%%/g, "\0\0"), c3) n3.includes(l3) && (n3 = n3.replace(new RegExp(l3, "g"), c3[l3](r4)));
          return l3 = function(t5) {
            var e5 = Array(C2(t5) + 1);
            return k2(t5, e5, 0, e5.length), e5;
          }(n3 = n3.replace(/\0\0/g, "%")), l3.length > e4 ? 0 : (S2.set(l3, t4 >>> 0), l3.length - 1);
        }
        var bt = { a: function(t4) {
          return yt(t4 + 24) + 24;
        }, m: function(t4) {
          return (t4 = new et(t4)).Pb() || (t4.Ib(true), Q2--), t4.Jb(false), J2.push(t4), t4.Nb(), t4.Qb();
        }, ia: function(t4) {
          throw v2("Unexpected exception thrown, this is not properly supported - aborting"), I2 = true, t4;
        }, w: function() {
          xt(0);
          var t4 = J2.pop();
          if (t4.Xb() && !t4.Lb()) {
            var e4 = t4.Wb();
            e4 && it(e4)(t4.Db), nt(t4.Db);
          }
          tt = 0;
        }, d: function() {
          var t4 = tt;
          if (!t4) return pt2 = 0;
          var e4 = new et(t4);
          e4.Fb(t4);
          var n3 = e4.Eb();
          if (!n3) return pt2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r4.length; i2++) {
            var o2 = r4[i2];
            if (0 === o2 || o2 === n3) break;
            if (At(o2, n3, e4.zb + 16)) return pt2 = o2, t4;
          }
          return pt2 = n3, t4;
        }, k: function() {
          var t4 = tt;
          if (!t4) return pt2 = 0;
          var e4 = new et(t4);
          e4.Fb(t4);
          var n3 = e4.Eb();
          if (!n3) return pt2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r4.length; i2++) {
            var o2 = r4[i2];
            if (0 === o2 || o2 === n3) break;
            if (At(o2, n3, e4.zb + 16)) return pt2 = o2, t4;
          }
          return pt2 = n3, t4;
        }, g: function() {
          var t4 = tt;
          if (!t4) return pt2 = 0;
          var e4 = new et(t4);
          e4.Fb(t4);
          var n3 = e4.Eb();
          if (!n3) return pt2 = 0, t4;
          for (var r4 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r4.length; i2++) {
            var o2 = r4[i2];
            if (0 === o2 || o2 === n3) break;
            if (At(o2, n3, e4.zb + 16)) return pt2 = o2, t4;
          }
          return pt2 = n3, t4;
        }, s: nt, L: function() {
          var t4 = J2.pop();
          t4 || W2("no exception to throw");
          var e4 = t4.Db;
          throw t4.Lb() || (J2.push(t4), t4.Jb(true), t4.Ib(false), Q2++), tt = e4, e4;
        }, b: function(t4, e4, n3) {
          throw new et(t4).Rb(e4, n3), tt = t4, Q2++, t4;
        }, la: function() {
          return Q2;
        }, i: function(t4) {
          throw tt || (tt = t4), t4;
        }, H: function() {
          return 0;
        }, Ba: function() {
        }, pa: function() {
        }, ra: function() {
        }, ka: function() {
          return 0;
        }, za: function() {
        }, ua: function() {
        }, ya: function() {
        }, R: function() {
        }, qa: function() {
        }, na: function() {
        }, Aa: function() {
        }, oa: function() {
        }, Ha: function() {
        }, Ja: function() {
          W2("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
        }, Ia: function() {
          W2("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
        }, S: function() {
          return Date.now();
        }, Ca: function() {
          return true;
        }, Da: function(t4, e4) {
          t4 = new Date(1e3 * (E2[t4 >>> 2] + 4294967296 * A2[t4 + 4 >>> 2])), A2[e4 >> 2 >>> 0] = t4.getUTCSeconds(), A2[e4 + 4 >> 2 >>> 0] = t4.getUTCMinutes(), A2[e4 + 8 >> 2 >>> 0] = t4.getUTCHours(), A2[e4 + 12 >> 2 >>> 0] = t4.getUTCDate(), A2[e4 + 16 >> 2 >>> 0] = t4.getUTCMonth(), A2[e4 + 20 >> 2 >>> 0] = t4.getUTCFullYear() - 1900, A2[e4 + 24 >> 2 >>> 0] = t4.getUTCDay(), A2[e4 + 28 >> 2 >>> 0] = (t4.getTime() - Date.UTC(t4.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
        }, Ea: function(t4, e4) {
          t4 = new Date(1e3 * (E2[t4 >>> 2] + 4294967296 * A2[t4 + 4 >>> 2])), A2[e4 >> 2 >>> 0] = t4.getSeconds(), A2[e4 + 4 >> 2 >>> 0] = t4.getMinutes(), A2[e4 + 8 >> 2 >>> 0] = t4.getHours(), A2[e4 + 12 >> 2 >>> 0] = t4.getDate(), A2[e4 + 16 >> 2 >>> 0] = t4.getMonth(), A2[e4 + 20 >> 2 >>> 0] = t4.getFullYear() - 1900, A2[e4 + 24 >> 2 >>> 0] = t4.getDay();
          var n3 = new Date(t4.getFullYear(), 0, 1);
          A2[e4 + 28 >> 2 >>> 0] = (t4.getTime() - n3.getTime()) / 864e5 | 0, A2[e4 + 36 >> 2 >>> 0] = -60 * t4.getTimezoneOffset();
          var r4 = new Date(t4.getFullYear(), 6, 1).getTimezoneOffset();
          n3 = n3.getTimezoneOffset(), A2[e4 + 32 >> 2 >>> 0] = 0 | (r4 != n3 && t4.getTimezoneOffset() == Math.min(n3, r4));
        }, Fa: function(t4) {
          var e4 = new Date(A2[t4 + 20 >> 2 >>> 0] + 1900, A2[t4 + 16 >> 2 >>> 0], A2[t4 + 12 >> 2 >>> 0], A2[t4 + 8 >> 2 >>> 0], A2[t4 + 4 >> 2 >>> 0], A2[t4 >> 2 >>> 0], 0), n3 = A2[t4 + 32 >> 2 >>> 0], r4 = e4.getTimezoneOffset(), i2 = new Date(e4.getFullYear(), 0, 1), o2 = new Date(e4.getFullYear(), 6, 1).getTimezoneOffset(), a2 = i2.getTimezoneOffset(), s2 = Math.min(a2, o2);
          return 0 > n3 ? A2[t4 + 32 >> 2 >>> 0] = Number(o2 != a2 && s2 == r4) : 0 < n3 != (s2 == r4) && (o2 = Math.max(a2, o2), e4.setTime(e4.getTime() + 6e4 * ((0 < n3 ? s2 : o2) - r4))), A2[t4 + 24 >> 2 >>> 0] = e4.getDay(), A2[t4 + 28 >> 2 >>> 0] = (e4.getTime() - i2.getTime()) / 864e5 | 0, A2[t4 >> 2 >>> 0] = e4.getSeconds(), A2[t4 + 4 >> 2 >>> 0] = e4.getMinutes(), A2[t4 + 8 >> 2 >>> 0] = e4.getHours(), A2[t4 + 12 >> 2 >>> 0] = e4.getDate(), A2[t4 + 16 >> 2 >>> 0] = e4.getMonth(), e4.getTime() / 1e3 | 0;
        }, sa: function() {
          return -52;
        }, ta: function() {
        }, Ga: function t4(e4, n3, r4) {
          t4.Vb || (t4.Vb = true, function(t5, e5, n4) {
            function r5(t6) {
              return (t6 = t6.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t6[1] : "GMT";
            }
            var i2 = (/* @__PURE__ */ new Date()).getFullYear(), o2 = new Date(i2, 0, 1), a2 = new Date(i2, 6, 1);
            i2 = o2.getTimezoneOffset();
            var s2 = a2.getTimezoneOffset();
            A2[t5 >> 2 >>> 0] = 60 * Math.max(i2, s2), A2[e5 >> 2 >>> 0] = Number(i2 != s2), t5 = r5(o2), e5 = r5(a2), t5 = ot(t5), e5 = ot(e5), s2 < i2 ? (E2[n4 >> 2 >>> 0] = t5, E2[n4 + 4 >> 2 >>> 0] = e5) : (E2[n4 >> 2 >>> 0] = e5, E2[n4 + 4 >> 2 >>> 0] = t5);
          }(e4, n3, r4));
        }, B: function() {
          W2("");
        }, ma: function() {
          return 4294901760;
        }, I: b2 ? () => {
          var t4 = process.hrtime();
          return 1e3 * t4[0] + t4[1] / 1e6;
        } : () => performance.now(), xa: function(t4, e4, n3) {
          O2.copyWithin(t4 >>> 0, e4 >>> 0, e4 + n3 >>> 0);
        }, G: function(t4) {
          var e4 = O2.length;
          if (4294901760 < (t4 >>>= 0)) return false;
          for (var n3 = 1; 4 >= n3; n3 *= 2) {
            var r4 = e4 * (1 + 0.2 / n3);
            r4 = Math.min(r4, t4 + 100663296);
            var i2 = Math;
            r4 = Math.max(t4, r4), i2 = i2.min.call(i2, 4294901760, r4 + (65536 - r4 % 65536) % 65536);
            t: {
              try {
                x2.grow(i2 - T2.byteLength + 65535 >>> 16), F2();
                var o2 = 1;
                break t;
              } catch (t5) {
              }
              o2 = void 0;
            }
            if (o2) return true;
          }
          return false;
        }, va: function(t4, e4) {
          var n3 = 0;
          return st().forEach(function(r4, i2) {
            var o2 = e4 + n3;
            for (i2 = E2[t4 + 4 * i2 >> 2 >>> 0] = o2, o2 = 0; o2 < r4.length; ++o2) S2[i2++ >> 0 >>> 0] = r4.charCodeAt(o2);
            S2[i2 >> 0 >>> 0] = 0, n3 += r4.length + 1;
          }), 0;
        }, wa: function(t4, e4) {
          var n3 = st();
          E2[t4 >> 2 >>> 0] = n3.length;
          var r4 = 0;
          return n3.forEach(function(t5) {
            r4 += t5.length + 1;
          }), E2[e4 >> 2 >>> 0] = r4, 0;
        }, ba: function(t4) {
          w2 || 0 < U2 || (wt(), Z2(j), vt(0), ct[1].length && lt(1, 10), ct[2].length && lt(2, 10)), w2 || 0 < U2 || (e3.onExit && e3.onExit(t4), I2 = true), d2(t4, new K2(t4));
        }, E: function() {
          return 52;
        }, Q: function() {
          return 52;
        }, ca: function() {
          return 70;
        }, P: function(t4, e4, n3, r4) {
          for (var i2 = 0, o2 = 0; o2 < n3; o2++) {
            var a2 = E2[e4 >> 2 >>> 0], s2 = E2[e4 + 4 >> 2 >>> 0];
            e4 += 8;
            for (var u3 = 0; u3 < s2; u3++) lt(t4, O2[a2 + u3 >>> 0]);
            i2 += s2;
          }
          return E2[r4 >> 2 >>> 0] = i2, 0;
        }, c: function() {
          return pt2;
        }, ja: function t4(e4, r4) {
          t4.Mb || (t4.Mb = function() {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
              var t5 = new Uint8Array(1);
              return () => (crypto.getRandomValues(t5), t5[0]);
            }
            if (b2) try {
              var e5 = n2(Object(function() {
                var t6 = new Error("Cannot find module 'crypto'");
                throw t6.code = "MODULE_NOT_FOUND", t6;
              }()));
              return () => e5.randomBytes(1)[0];
            } catch (t6) {
            }
            return () => W2("randomDevice");
          }());
          for (var i2 = 0; i2 < r4; i2++) S2[e4 + i2 >> 0 >>> 0] = t4.Mb();
          return 0;
        }, ea: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, fa: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, J: function(t4) {
          var e4 = Tt();
          try {
            return it(t4)();
          } catch (t5) {
            if (St(e4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, e: function(t4, e4) {
          var n3 = Tt();
          try {
            return it(t4)(e4);
          } catch (t5) {
            if (St(n3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, N: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, O: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, j: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, o: function(t4, e4, n3, r4) {
          var i2 = Tt();
          try {
            return it(t4)(e4, n3, r4);
          } catch (t5) {
            if (St(i2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, p: function(t4, e4, n3, r4, i2) {
          var o2 = Tt();
          try {
            return it(t4)(e4, n3, r4, i2);
          } catch (t5) {
            if (St(o2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, M: function(t4, e4, n3, r4, i2, o2) {
          var a2 = Tt();
          try {
            return it(t4)(e4, n3, r4, i2, o2);
          } catch (t5) {
            if (St(a2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, r: function(t4, e4, n3, r4, i2, o2) {
          var a2 = Tt();
          try {
            return it(t4)(e4, n3, r4, i2, o2);
          } catch (t5) {
            if (St(a2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, v: function(t4, e4, n3, r4, i2, o2, a2) {
          var s2 = Tt();
          try {
            return it(t4)(e4, n3, r4, i2, o2, a2);
          } catch (t5) {
            if (St(s2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, K: function(t4, e4, n3, r4, i2, o2, a2, s2) {
          var u3 = Tt();
          try {
            return it(t4)(e4, n3, r4, i2, o2, a2, s2);
          } catch (t5) {
            if (St(u3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, D: function(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3) {
          var f3 = Tt();
          try {
            return it(t4)(e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3);
          } catch (t5) {
            if (St(f3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, X: function(t4, e4, n3, r4, i2, o2, a2, s2) {
          var u3 = Tt();
          try {
            return Lt(t4, e4, n3, r4, i2, o2, a2, s2);
          } catch (t5) {
            if (St(u3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, V: function(t4, e4, n3, r4, i2, o2, a2) {
          var s2 = Tt();
          try {
            return Pt(t4, e4, n3, r4, i2, o2, a2);
          } catch (t5) {
            if (St(s2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, U: function(t4, e4, n3, r4, i2) {
          var o2 = Tt();
          try {
            return Rt(t4, e4, n3, r4, i2);
          } catch (t5) {
            if (St(o2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, Z: function(t4, e4, n3, r4) {
          var i2 = Tt();
          try {
            return Ft(t4, e4, n3, r4);
          } catch (t5) {
            if (St(i2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, W: function(t4) {
          var e4 = Tt();
          try {
            return It(t4);
          } catch (t5) {
            if (St(e4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, Y: function(t4, e4) {
          var n3 = Tt();
          try {
            return Nt(t4, e4);
          } catch (t5) {
            if (St(n3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, T: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            return Dt(t4, e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, f: function(t4) {
          var e4 = Tt();
          try {
            it(t4)();
          } catch (t5) {
            if (St(e4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, q: function(t4, e4) {
          var n3 = Tt();
          try {
            it(t4)(e4);
          } catch (t5) {
            if (St(n3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, h: function(t4, e4, n3) {
          var r4 = Tt();
          try {
            it(t4)(e4, n3);
          } catch (t5) {
            if (St(r4), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, da: function(t4, e4, n3, r4) {
          var i2 = Tt();
          try {
            it(t4)(e4, n3, r4);
          } catch (t5) {
            if (St(i2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, l: function(t4, e4, n3, r4) {
          var i2 = Tt();
          try {
            it(t4)(e4, n3, r4);
          } catch (t5) {
            if (St(i2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, t: function(t4, e4, n3, r4, i2) {
          var o2 = Tt();
          try {
            it(t4)(e4, n3, r4, i2);
          } catch (t5) {
            if (St(o2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, u: function(t4, e4, n3, r4, i2, o2) {
          var a2 = Tt();
          try {
            it(t4)(e4, n3, r4, i2, o2);
          } catch (t5) {
            if (St(a2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, x: function(t4, e4, n3, r4, i2, o2, a2) {
          var s2 = Tt();
          try {
            it(t4)(e4, n3, r4, i2, o2, a2);
          } catch (t5) {
            if (St(s2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, z: function(t4, e4, n3, r4, i2, o2, a2, s2) {
          var u3 = Tt();
          try {
            it(t4)(e4, n3, r4, i2, o2, a2, s2);
          } catch (t5) {
            if (St(u3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, ga: function(t4, e4, n3, r4, i2, o2, a2, s2, u3) {
          var c3 = Tt();
          try {
            it(t4)(e4, n3, r4, i2, o2, a2, s2, u3);
          } catch (t5) {
            if (St(c3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, A: function(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3) {
          var p3 = Tt();
          try {
            it(t4)(e4, n3, r4, i2, o2, a2, s2, u3, c3, l3);
          } catch (t5) {
            if (St(p3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, C: function(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3, f3, d3, h3, g3) {
          var b3 = Tt();
          try {
            it(t4)(e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3, f3, d3, h3, g3);
          } catch (t5) {
            if (St(b3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, aa: function(t4, e4, n3, r4, i2, o2, a2, s2) {
          var u3 = Tt();
          try {
            $t(t4, e4, n3, r4, i2, o2, a2, s2);
          } catch (t5) {
            if (St(u3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, _: function(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3) {
          var f3 = Tt();
          try {
            Ct(t4, e4, n3, r4, i2, o2, a2, s2, u3, c3, l3, p3);
          } catch (t5) {
            if (St(f3), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, $: function(t4, e4, n3, r4, i2, o2) {
          var a2 = Tt();
          try {
            kt(t4, e4, n3, r4, i2, o2);
          } catch (t5) {
            if (St(a2), t5 !== t5 + 0) throw t5;
            xt(1, 0);
          }
        }, n: function(t4) {
          return t4;
        }, F: function(t4) {
          pt2 = t4;
        }, ha: gt, y: function(t4, e4, n3, r4) {
          return gt(t4, e4, n3, r4);
        } };
        !function() {
          function t4(t5) {
            e3.asm = t5.exports, x2 = e3.asm.Ka, F2(), N2 = e3.asm.ib, R2.unshift(e3.asm.La), z2--, e3.monitorRunDependencies && e3.monitorRunDependencies(z2), 0 == z2 && (H2 && (t5 = H2, H2 = null, t5()));
          }
          function n3(e4) {
            t4(e4.instance);
          }
          function r4(t5) {
            return function() {
              if (!y2 && (h2 || g2)) {
                if ("function" == typeof fetch && !B2.startsWith("file://")) return fetch(B2, { credentials: "same-origin" }).then(function(t6) {
                  if (!t6.ok) throw "failed to load wasm binary file at '" + B2 + "'";
                  return t6.arrayBuffer();
                }).catch(function() {
                  return Y2();
                });
                if (a) return new Promise(function(t6, e4) {
                  a(B2, function(e5) {
                    t6(new Uint8Array(e5));
                  }, e4);
                });
              }
              return Promise.resolve().then(function() {
                return Y2();
              });
            }().then(function(t6) {
              return WebAssembly.instantiate(t6, o2);
            }).then(function(t6) {
              return t6;
            }).then(t5, function(t6) {
              v2("failed to asynchronously prepare wasm: " + t6), W2(t6);
            });
          }
          var o2 = { a: bt };
          if (z2++, e3.monitorRunDependencies && e3.monitorRunDependencies(z2), e3.instantiateWasm) try {
            return e3.instantiateWasm(o2, t4);
          } catch (t5) {
            return v2("Module.instantiateWasm callback failed with error: " + t5), false;
          }
          (y2 || "function" != typeof WebAssembly.instantiateStreaming || q2() || B2.startsWith("file://") || b2 || "function" != typeof fetch ? r4(n3) : fetch(B2, { credentials: "same-origin" }).then(function(t5) {
            return WebAssembly.instantiateStreaming(t5, o2).then(n3, function(t6) {
              return v2("wasm streaming compile failed: " + t6), v2("falling back to ArrayBuffer instantiation"), r4(n3);
            });
          })).catch(i);
        }(), e3.___wasm_call_ctors = function() {
          return (e3.___wasm_call_ctors = e3.asm.La).apply(null, arguments);
        }, e3._OrtInit = function() {
          return (e3._OrtInit = e3.asm.Ma).apply(null, arguments);
        }, e3._OrtCreateSessionOptions = function() {
          return (e3._OrtCreateSessionOptions = e3.asm.Na).apply(null, arguments);
        }, e3._OrtAppendExecutionProvider = function() {
          return (e3._OrtAppendExecutionProvider = e3.asm.Oa).apply(null, arguments);
        }, e3._OrtAddSessionConfigEntry = function() {
          return (e3._OrtAddSessionConfigEntry = e3.asm.Pa).apply(null, arguments);
        }, e3._OrtReleaseSessionOptions = function() {
          return (e3._OrtReleaseSessionOptions = e3.asm.Qa).apply(null, arguments);
        }, e3._OrtCreateSession = function() {
          return (e3._OrtCreateSession = e3.asm.Ra).apply(null, arguments);
        }, e3._OrtReleaseSession = function() {
          return (e3._OrtReleaseSession = e3.asm.Sa).apply(null, arguments);
        }, e3._OrtGetInputCount = function() {
          return (e3._OrtGetInputCount = e3.asm.Ta).apply(null, arguments);
        }, e3._OrtGetOutputCount = function() {
          return (e3._OrtGetOutputCount = e3.asm.Ua).apply(null, arguments);
        }, e3._OrtGetInputName = function() {
          return (e3._OrtGetInputName = e3.asm.Va).apply(null, arguments);
        }, e3._OrtGetOutputName = function() {
          return (e3._OrtGetOutputName = e3.asm.Wa).apply(null, arguments);
        }, e3._OrtFree = function() {
          return (e3._OrtFree = e3.asm.Xa).apply(null, arguments);
        }, e3._OrtCreateTensor = function() {
          return (e3._OrtCreateTensor = e3.asm.Ya).apply(null, arguments);
        }, e3._OrtGetTensorData = function() {
          return (e3._OrtGetTensorData = e3.asm.Za).apply(null, arguments);
        }, e3._OrtReleaseTensor = function() {
          return (e3._OrtReleaseTensor = e3.asm._a).apply(null, arguments);
        }, e3._OrtCreateRunOptions = function() {
          return (e3._OrtCreateRunOptions = e3.asm.$a).apply(null, arguments);
        }, e3._OrtAddRunConfigEntry = function() {
          return (e3._OrtAddRunConfigEntry = e3.asm.ab).apply(null, arguments);
        }, e3._OrtReleaseRunOptions = function() {
          return (e3._OrtReleaseRunOptions = e3.asm.bb).apply(null, arguments);
        }, e3._OrtRun = function() {
          return (e3._OrtRun = e3.asm.cb).apply(null, arguments);
        }, e3._OrtEndProfiling = function() {
          return (e3._OrtEndProfiling = e3.asm.db).apply(null, arguments);
        };
        var mt, yt = e3._malloc = function() {
          return (yt = e3._malloc = e3.asm.eb).apply(null, arguments);
        }, _t = e3._free = function() {
          return (_t = e3._free = e3.asm.fb).apply(null, arguments);
        }, vt = e3._fflush = function() {
          return (vt = e3._fflush = e3.asm.gb).apply(null, arguments);
        }, wt = e3.___funcs_on_exit = function() {
          return (wt = e3.___funcs_on_exit = e3.asm.hb).apply(null, arguments);
        }, xt = e3._setThrew = function() {
          return (xt = e3._setThrew = e3.asm.jb).apply(null, arguments);
        }, Tt = e3.stackSave = function() {
          return (Tt = e3.stackSave = e3.asm.kb).apply(null, arguments);
        }, St = e3.stackRestore = function() {
          return (St = e3.stackRestore = e3.asm.lb).apply(null, arguments);
        }, Ot = e3.stackAlloc = function() {
          return (Ot = e3.stackAlloc = e3.asm.mb).apply(null, arguments);
        }, At = e3.___cxa_can_catch = function() {
          return (At = e3.___cxa_can_catch = e3.asm.nb).apply(null, arguments);
        }, Et = e3.___cxa_is_pointer_type = function() {
          return (Et = e3.___cxa_is_pointer_type = e3.asm.ob).apply(null, arguments);
        }, It = e3.dynCall_j = function() {
          return (It = e3.dynCall_j = e3.asm.pb).apply(null, arguments);
        }, Pt = e3.dynCall_iiiiij = function() {
          return (Pt = e3.dynCall_iiiiij = e3.asm.qb).apply(null, arguments);
        }, Dt = e3.dynCall_jii = function() {
          return (Dt = e3.dynCall_jii = e3.asm.rb).apply(null, arguments);
        }, $t = e3.dynCall_viiiiij = function() {
          return ($t = e3.dynCall_viiiiij = e3.asm.sb).apply(null, arguments);
        }, kt = e3.dynCall_vjji = function() {
          return (kt = e3.dynCall_vjji = e3.asm.tb).apply(null, arguments);
        }, Ct = e3.dynCall_viiijjjii = function() {
          return (Ct = e3.dynCall_viiijjjii = e3.asm.ub).apply(null, arguments);
        }, Ft = e3.dynCall_iij = function() {
          return (Ft = e3.dynCall_iij = e3.asm.vb).apply(null, arguments);
        }, Nt = e3.dynCall_ji = function() {
          return (Nt = e3.dynCall_ji = e3.asm.wb).apply(null, arguments);
        }, Lt = e3.dynCall_iiiiiij = function() {
          return (Lt = e3.dynCall_iiiiiij = e3.asm.xb).apply(null, arguments);
        }, Rt = e3.dynCall_iiij = function() {
          return (Rt = e3.dynCall_iiij = e3.asm.yb).apply(null, arguments);
        };
        function jt() {
          function t4() {
            if (!mt && (mt = true, e3.calledRun = true, !I2)) {
              if (Z2(R2), r3(e3), e3.onRuntimeInitialized && e3.onRuntimeInitialized(), e3.postRun) for ("function" == typeof e3.postRun && (e3.postRun = [e3.postRun]); e3.postRun.length; ) {
                var t5 = e3.postRun.shift();
                M2.unshift(t5);
              }
              Z2(M2);
            }
          }
          if (!(0 < z2)) {
            if (e3.preRun) for ("function" == typeof e3.preRun && (e3.preRun = [e3.preRun]); e3.preRun.length; ) V2();
            Z2(L2), 0 < z2 || (e3.setStatus ? (e3.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                e3.setStatus("");
              }, 1), t4();
            }, 1)) : t4());
          }
        }
        if (e3.UTF8ToString = $, e3.stringToUTF8 = function(t4, e4, n3) {
          return k2(t4, O2, e4, n3);
        }, e3.lengthBytesUTF8 = C2, e3.stackSave = Tt, e3.stackRestore = St, e3.stackAlloc = Ot, H2 = function t4() {
          mt || jt(), mt || (H2 = t4);
        }, e3.preInit) for ("function" == typeof e3.preInit && (e3.preInit = [e3.preInit]); 0 < e3.preInit.length; ) e3.preInit.pop()();
        return jt(), t3.ready;
      });
      t2.exports = r2;
    }, 4537: (t2) => {
      t2.exports = function(t3, e2) {
        for (var n2 = new Array(arguments.length - 1), r2 = 0, i = 2, o = true; i < arguments.length; ) n2[r2++] = arguments[i++];
        return new Promise(function(i2, a) {
          n2[r2] = function(t4) {
            if (o) if (o = false, t4) a(t4);
            else {
              for (var e3 = new Array(arguments.length - 1), n3 = 0; n3 < e3.length; ) e3[n3++] = arguments[n3];
              i2.apply(null, e3);
            }
          };
          try {
            t3.apply(e2 || null, n2);
          } catch (t4) {
            o && (o = false, a(t4));
          }
        });
      };
    }, 7419: (t2, e2) => {
      var n2 = e2;
      n2.length = function(t3) {
        var e3 = t3.length;
        if (!e3) return 0;
        for (var n3 = 0; --e3 % 4 > 1 && "=" === t3.charAt(e3); ) ++n3;
        return Math.ceil(3 * t3.length) / 4 - n3;
      };
      for (var r2 = new Array(64), i = new Array(123), o = 0; o < 64; ) i[r2[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;
      n2.encode = function(t3, e3, n3) {
        for (var i2, o2 = null, a2 = [], s = 0, u2 = 0; e3 < n3; ) {
          var c2 = t3[e3++];
          switch (u2) {
            case 0:
              a2[s++] = r2[c2 >> 2], i2 = (3 & c2) << 4, u2 = 1;
              break;
            case 1:
              a2[s++] = r2[i2 | c2 >> 4], i2 = (15 & c2) << 2, u2 = 2;
              break;
            case 2:
              a2[s++] = r2[i2 | c2 >> 6], a2[s++] = r2[63 & c2], u2 = 0;
          }
          s > 8191 && ((o2 || (o2 = [])).push(String.fromCharCode.apply(String, a2)), s = 0);
        }
        return u2 && (a2[s++] = r2[i2], a2[s++] = 61, 1 === u2 && (a2[s++] = 61)), o2 ? (s && o2.push(String.fromCharCode.apply(String, a2.slice(0, s))), o2.join("")) : String.fromCharCode.apply(String, a2.slice(0, s));
      };
      var a = "invalid encoding";
      n2.decode = function(t3, e3, n3) {
        for (var r3, o2 = n3, s = 0, u2 = 0; u2 < t3.length; ) {
          var c2 = t3.charCodeAt(u2++);
          if (61 === c2 && s > 1) break;
          if (void 0 === (c2 = i[c2])) throw Error(a);
          switch (s) {
            case 0:
              r3 = c2, s = 1;
              break;
            case 1:
              e3[n3++] = r3 << 2 | (48 & c2) >> 4, r3 = c2, s = 2;
              break;
            case 2:
              e3[n3++] = (15 & r3) << 4 | (60 & c2) >> 2, r3 = c2, s = 3;
              break;
            case 3:
              e3[n3++] = (3 & r3) << 6 | c2, s = 0;
          }
        }
        if (1 === s) throw Error(a);
        return n3 - o2;
      }, n2.test = function(t3) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t3);
      };
    }, 9211: (t2) => {
      function e2() {
        this._listeners = {};
      }
      t2.exports = e2, e2.prototype.on = function(t3, e3, n2) {
        return (this._listeners[t3] || (this._listeners[t3] = [])).push({ fn: e3, ctx: n2 || this }), this;
      }, e2.prototype.off = function(t3, e3) {
        if (void 0 === t3) this._listeners = {};
        else if (void 0 === e3) this._listeners[t3] = [];
        else for (var n2 = this._listeners[t3], r2 = 0; r2 < n2.length; ) n2[r2].fn === e3 ? n2.splice(r2, 1) : ++r2;
        return this;
      }, e2.prototype.emit = function(t3) {
        var e3 = this._listeners[t3];
        if (e3) {
          for (var n2 = [], r2 = 1; r2 < arguments.length; ) n2.push(arguments[r2++]);
          for (r2 = 0; r2 < e3.length; ) e3[r2].fn.apply(e3[r2++].ctx, n2);
        }
        return this;
      };
    }, 945: (t2) => {
      function e2(t3) {
        return "undefined" != typeof Float32Array ? function() {
          var e3 = new Float32Array([-0]), n3 = new Uint8Array(e3.buffer), r3 = 128 === n3[3];
          function i2(t4, r4, i3) {
            e3[0] = t4, r4[i3] = n3[0], r4[i3 + 1] = n3[1], r4[i3 + 2] = n3[2], r4[i3 + 3] = n3[3];
          }
          function o2(t4, r4, i3) {
            e3[0] = t4, r4[i3] = n3[3], r4[i3 + 1] = n3[2], r4[i3 + 2] = n3[1], r4[i3 + 3] = n3[0];
          }
          function a(t4, r4) {
            return n3[0] = t4[r4], n3[1] = t4[r4 + 1], n3[2] = t4[r4 + 2], n3[3] = t4[r4 + 3], e3[0];
          }
          function s(t4, r4) {
            return n3[3] = t4[r4], n3[2] = t4[r4 + 1], n3[1] = t4[r4 + 2], n3[0] = t4[r4 + 3], e3[0];
          }
          t3.writeFloatLE = r3 ? i2 : o2, t3.writeFloatBE = r3 ? o2 : i2, t3.readFloatLE = r3 ? a : s, t3.readFloatBE = r3 ? s : a;
        }() : function() {
          function e3(t4, e4, n3, r3) {
            var i2 = e4 < 0 ? 1 : 0;
            if (i2 && (e4 = -e4), 0 === e4) t4(1 / e4 > 0 ? 0 : 2147483648, n3, r3);
            else if (isNaN(e4)) t4(2143289344, n3, r3);
            else if (e4 > 34028234663852886e22) t4((i2 << 31 | 2139095040) >>> 0, n3, r3);
            else if (e4 < 11754943508222875e-54) t4((i2 << 31 | Math.round(e4 / 1401298464324817e-60)) >>> 0, n3, r3);
            else {
              var o2 = Math.floor(Math.log(e4) / Math.LN2);
              t4((i2 << 31 | o2 + 127 << 23 | 8388607 & Math.round(e4 * Math.pow(2, -o2) * 8388608)) >>> 0, n3, r3);
            }
          }
          function a(t4, e4, n3) {
            var r3 = t4(e4, n3), i2 = 2 * (r3 >> 31) + 1, o2 = r3 >>> 23 & 255, a2 = 8388607 & r3;
            return 255 === o2 ? a2 ? NaN : i2 * (1 / 0) : 0 === o2 ? 1401298464324817e-60 * i2 * a2 : i2 * Math.pow(2, o2 - 150) * (a2 + 8388608);
          }
          t3.writeFloatLE = e3.bind(null, n2), t3.writeFloatBE = e3.bind(null, r2), t3.readFloatLE = a.bind(null, i), t3.readFloatBE = a.bind(null, o);
        }(), "undefined" != typeof Float64Array ? function() {
          var e3 = new Float64Array([-0]), n3 = new Uint8Array(e3.buffer), r3 = 128 === n3[7];
          function i2(t4, r4, i3) {
            e3[0] = t4, r4[i3] = n3[0], r4[i3 + 1] = n3[1], r4[i3 + 2] = n3[2], r4[i3 + 3] = n3[3], r4[i3 + 4] = n3[4], r4[i3 + 5] = n3[5], r4[i3 + 6] = n3[6], r4[i3 + 7] = n3[7];
          }
          function o2(t4, r4, i3) {
            e3[0] = t4, r4[i3] = n3[7], r4[i3 + 1] = n3[6], r4[i3 + 2] = n3[5], r4[i3 + 3] = n3[4], r4[i3 + 4] = n3[3], r4[i3 + 5] = n3[2], r4[i3 + 6] = n3[1], r4[i3 + 7] = n3[0];
          }
          function a(t4, r4) {
            return n3[0] = t4[r4], n3[1] = t4[r4 + 1], n3[2] = t4[r4 + 2], n3[3] = t4[r4 + 3], n3[4] = t4[r4 + 4], n3[5] = t4[r4 + 5], n3[6] = t4[r4 + 6], n3[7] = t4[r4 + 7], e3[0];
          }
          function s(t4, r4) {
            return n3[7] = t4[r4], n3[6] = t4[r4 + 1], n3[5] = t4[r4 + 2], n3[4] = t4[r4 + 3], n3[3] = t4[r4 + 4], n3[2] = t4[r4 + 5], n3[1] = t4[r4 + 6], n3[0] = t4[r4 + 7], e3[0];
          }
          t3.writeDoubleLE = r3 ? i2 : o2, t3.writeDoubleBE = r3 ? o2 : i2, t3.readDoubleLE = r3 ? a : s, t3.readDoubleBE = r3 ? s : a;
        }() : function() {
          function e3(t4, e4, n3, r3, i2, o2) {
            var a2 = r3 < 0 ? 1 : 0;
            if (a2 && (r3 = -r3), 0 === r3) t4(0, i2, o2 + e4), t4(1 / r3 > 0 ? 0 : 2147483648, i2, o2 + n3);
            else if (isNaN(r3)) t4(0, i2, o2 + e4), t4(2146959360, i2, o2 + n3);
            else if (r3 > 17976931348623157e292) t4(0, i2, o2 + e4), t4((a2 << 31 | 2146435072) >>> 0, i2, o2 + n3);
            else {
              var s;
              if (r3 < 22250738585072014e-324) t4((s = r3 / 5e-324) >>> 0, i2, o2 + e4), t4((a2 << 31 | s / 4294967296) >>> 0, i2, o2 + n3);
              else {
                var u2 = Math.floor(Math.log(r3) / Math.LN2);
                1024 === u2 && (u2 = 1023), t4(4503599627370496 * (s = r3 * Math.pow(2, -u2)) >>> 0, i2, o2 + e4), t4((a2 << 31 | u2 + 1023 << 20 | 1048576 * s & 1048575) >>> 0, i2, o2 + n3);
              }
            }
          }
          function a(t4, e4, n3, r3, i2) {
            var o2 = t4(r3, i2 + e4), a2 = t4(r3, i2 + n3), s = 2 * (a2 >> 31) + 1, u2 = a2 >>> 20 & 2047, c2 = 4294967296 * (1048575 & a2) + o2;
            return 2047 === u2 ? c2 ? NaN : s * (1 / 0) : 0 === u2 ? 5e-324 * s * c2 : s * Math.pow(2, u2 - 1075) * (c2 + 4503599627370496);
          }
          t3.writeDoubleLE = e3.bind(null, n2, 0, 4), t3.writeDoubleBE = e3.bind(null, r2, 4, 0), t3.readDoubleLE = a.bind(null, i, 0, 4), t3.readDoubleBE = a.bind(null, o, 4, 0);
        }(), t3;
      }
      function n2(t3, e3, n3) {
        e3[n3] = 255 & t3, e3[n3 + 1] = t3 >>> 8 & 255, e3[n3 + 2] = t3 >>> 16 & 255, e3[n3 + 3] = t3 >>> 24;
      }
      function r2(t3, e3, n3) {
        e3[n3] = t3 >>> 24, e3[n3 + 1] = t3 >>> 16 & 255, e3[n3 + 2] = t3 >>> 8 & 255, e3[n3 + 3] = 255 & t3;
      }
      function i(t3, e3) {
        return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16 | t3[e3 + 3] << 24) >>> 0;
      }
      function o(t3, e3) {
        return (t3[e3] << 24 | t3[e3 + 1] << 16 | t3[e3 + 2] << 8 | t3[e3 + 3]) >>> 0;
      }
      t2.exports = e2(e2);
    }, 7199: (module) => {
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length)) return mod;
        } catch (t2) {
        }
        return null;
      }
      module.exports = inquire;
    }, 6662: (t2) => {
      t2.exports = function(t3, e2, n2) {
        var r2 = n2 || 8192, i = r2 >>> 1, o = null, a = r2;
        return function(n3) {
          if (n3 < 1 || n3 > i) return t3(n3);
          a + n3 > r2 && (o = t3(r2), a = 0);
          var s = e2.call(o, a, a += n3);
          return 7 & a && (a = 1 + (7 | a)), s;
        };
      };
    }, 4997: (t2, e2) => {
      var n2 = e2;
      n2.length = function(t3) {
        for (var e3 = 0, n3 = 0, r2 = 0; r2 < t3.length; ++r2) (n3 = t3.charCodeAt(r2)) < 128 ? e3 += 1 : n3 < 2048 ? e3 += 2 : 55296 == (64512 & n3) && 56320 == (64512 & t3.charCodeAt(r2 + 1)) ? (++r2, e3 += 4) : e3 += 3;
        return e3;
      }, n2.read = function(t3, e3, n3) {
        if (n3 - e3 < 1) return "";
        for (var r2, i = null, o = [], a = 0; e3 < n3; ) (r2 = t3[e3++]) < 128 ? o[a++] = r2 : r2 > 191 && r2 < 224 ? o[a++] = (31 & r2) << 6 | 63 & t3[e3++] : r2 > 239 && r2 < 365 ? (r2 = ((7 & r2) << 18 | (63 & t3[e3++]) << 12 | (63 & t3[e3++]) << 6 | 63 & t3[e3++]) - 65536, o[a++] = 55296 + (r2 >> 10), o[a++] = 56320 + (1023 & r2)) : o[a++] = (15 & r2) << 12 | (63 & t3[e3++]) << 6 | 63 & t3[e3++], a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), a = 0);
        return i ? (a && i.push(String.fromCharCode.apply(String, o.slice(0, a))), i.join("")) : String.fromCharCode.apply(String, o.slice(0, a));
      }, n2.write = function(t3, e3, n3) {
        for (var r2, i, o = n3, a = 0; a < t3.length; ++a) (r2 = t3.charCodeAt(a)) < 128 ? e3[n3++] = r2 : r2 < 2048 ? (e3[n3++] = r2 >> 6 | 192, e3[n3++] = 63 & r2 | 128) : 55296 == (64512 & r2) && 56320 == (64512 & (i = t3.charCodeAt(a + 1))) ? (r2 = 65536 + ((1023 & r2) << 10) + (1023 & i), ++a, e3[n3++] = r2 >> 18 | 240, e3[n3++] = r2 >> 12 & 63 | 128, e3[n3++] = r2 >> 6 & 63 | 128, e3[n3++] = 63 & r2 | 128) : (e3[n3++] = r2 >> 12 | 224, e3[n3++] = r2 >> 6 & 63 | 128, e3[n3++] = 63 & r2 | 128);
        return n3 - o;
      };
    }, 3442: (t2, e2) => {
      e2.__esModule = true;
      var n2 = function() {
        function t3(e3) {
          if (!e3) throw new TypeError("Invalid argument; `value` has no value.");
          this.value = t3.EMPTY, e3 && t3.isGuid(e3) && (this.value = e3);
        }
        return t3.isGuid = function(e3) {
          var n3 = e3.toString();
          return e3 && (e3 instanceof t3 || t3.validator.test(n3));
        }, t3.create = function() {
          return new t3([t3.gen(2), t3.gen(1), t3.gen(1), t3.gen(1), t3.gen(3)].join("-"));
        }, t3.createEmpty = function() {
          return new t3("emptyguid");
        }, t3.parse = function(e3) {
          return new t3(e3);
        }, t3.raw = function() {
          return [t3.gen(2), t3.gen(1), t3.gen(1), t3.gen(1), t3.gen(3)].join("-");
        }, t3.gen = function(t4) {
          for (var e3 = "", n3 = 0; n3 < t4; n3++) e3 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
          return e3;
        }, t3.prototype.equals = function(e3) {
          return t3.isGuid(e3) && this.value === e3.toString();
        }, t3.prototype.isEmpty = function() {
          return this.value === t3.EMPTY;
        }, t3.prototype.toString = function() {
          return this.value;
        }, t3.prototype.toJSON = function() {
          return { value: this.value };
        }, t3.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), t3.EMPTY = "00000000-0000-0000-0000-000000000000", t3;
      }();
      e2.Guid = n2;
    }, 3720: (t2) => {
      t2.exports = n2;
      var e2 = null;
      try {
        e2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (t3) {
      }
      function n2(t3, e3, n3) {
        this.low = 0 | t3, this.high = 0 | e3, this.unsigned = !!n3;
      }
      function r2(t3) {
        return true === (t3 && t3.__isLong__);
      }
      n2.prototype.__isLong__, Object.defineProperty(n2.prototype, "__isLong__", { value: true }), n2.isLong = r2;
      var i = {}, o = {};
      function a(t3, e3) {
        var n3, r3, a2;
        return e3 ? (a2 = 0 <= (t3 >>>= 0) && t3 < 256) && (r3 = o[t3]) ? r3 : (n3 = u2(t3, (0 | t3) < 0 ? -1 : 0, true), a2 && (o[t3] = n3), n3) : (a2 = -128 <= (t3 |= 0) && t3 < 128) && (r3 = i[t3]) ? r3 : (n3 = u2(t3, t3 < 0 ? -1 : 0, false), a2 && (i[t3] = n3), n3);
      }
      function s(t3, e3) {
        if (isNaN(t3)) return e3 ? m2 : b2;
        if (e3) {
          if (t3 < 0) return m2;
          if (t3 >= d2) return x2;
        } else {
          if (t3 <= -9223372036854776e3) return T2;
          if (t3 + 1 >= h2) return w2;
        }
        return t3 < 0 ? s(-t3, e3).neg() : u2(t3 % f2 | 0, t3 / f2 | 0, e3);
      }
      function u2(t3, e3, r3) {
        return new n2(t3, e3, r3);
      }
      n2.fromInt = a, n2.fromNumber = s, n2.fromBits = u2;
      var c2 = Math.pow;
      function l2(t3, e3, n3) {
        if (0 === t3.length) throw Error("empty string");
        if ("NaN" === t3 || "Infinity" === t3 || "+Infinity" === t3 || "-Infinity" === t3) return b2;
        if ("number" == typeof e3 ? (n3 = e3, e3 = false) : e3 = !!e3, (n3 = n3 || 10) < 2 || 36 < n3) throw RangeError("radix");
        var r3;
        if ((r3 = t3.indexOf("-")) > 0) throw Error("interior hyphen");
        if (0 === r3) return l2(t3.substring(1), e3, n3).neg();
        for (var i2 = s(c2(n3, 8)), o2 = b2, a2 = 0; a2 < t3.length; a2 += 8) {
          var u3 = Math.min(8, t3.length - a2), p3 = parseInt(t3.substring(a2, a2 + u3), n3);
          if (u3 < 8) {
            var f3 = s(c2(n3, u3));
            o2 = o2.mul(f3).add(s(p3));
          } else o2 = (o2 = o2.mul(i2)).add(s(p3));
        }
        return o2.unsigned = e3, o2;
      }
      function p2(t3, e3) {
        return "number" == typeof t3 ? s(t3, e3) : "string" == typeof t3 ? l2(t3, e3) : u2(t3.low, t3.high, "boolean" == typeof e3 ? e3 : t3.unsigned);
      }
      n2.fromString = l2, n2.fromValue = p2;
      var f2 = 4294967296, d2 = f2 * f2, h2 = d2 / 2, g2 = a(1 << 24), b2 = a(0);
      n2.ZERO = b2;
      var m2 = a(0, true);
      n2.UZERO = m2;
      var y2 = a(1);
      n2.ONE = y2;
      var _ = a(1, true);
      n2.UONE = _;
      var v2 = a(-1);
      n2.NEG_ONE = v2;
      var w2 = u2(-1, 2147483647, false);
      n2.MAX_VALUE = w2;
      var x2 = u2(-1, -1, true);
      n2.MAX_UNSIGNED_VALUE = x2;
      var T2 = u2(0, -2147483648, false);
      n2.MIN_VALUE = T2;
      var S2 = n2.prototype;
      S2.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }, S2.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * f2 + (this.low >>> 0) : this.high * f2 + (this.low >>> 0);
      }, S2.toString = function(t3) {
        if ((t3 = t3 || 10) < 2 || 36 < t3) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(T2)) {
            var e3 = s(t3), n3 = this.div(e3), r3 = n3.mul(e3).sub(this);
            return n3.toString(t3) + r3.toInt().toString(t3);
          }
          return "-" + this.neg().toString(t3);
        }
        for (var i2 = s(c2(t3, 6), this.unsigned), o2 = this, a2 = ""; ; ) {
          var u3 = o2.div(i2), l3 = (o2.sub(u3.mul(i2)).toInt() >>> 0).toString(t3);
          if ((o2 = u3).isZero()) return l3 + a2;
          for (; l3.length < 6; ) l3 = "0" + l3;
          a2 = "" + l3 + a2;
        }
      }, S2.getHighBits = function() {
        return this.high;
      }, S2.getHighBitsUnsigned = function() {
        return this.high >>> 0;
      }, S2.getLowBits = function() {
        return this.low;
      }, S2.getLowBitsUnsigned = function() {
        return this.low >>> 0;
      }, S2.getNumBitsAbs = function() {
        if (this.isNegative()) return this.eq(T2) ? 64 : this.neg().getNumBitsAbs();
        for (var t3 = 0 != this.high ? this.high : this.low, e3 = 31; e3 > 0 && 0 == (t3 & 1 << e3); e3--) ;
        return 0 != this.high ? e3 + 33 : e3 + 1;
      }, S2.isZero = function() {
        return 0 === this.high && 0 === this.low;
      }, S2.eqz = S2.isZero, S2.isNegative = function() {
        return !this.unsigned && this.high < 0;
      }, S2.isPositive = function() {
        return this.unsigned || this.high >= 0;
      }, S2.isOdd = function() {
        return 1 == (1 & this.low);
      }, S2.isEven = function() {
        return 0 == (1 & this.low);
      }, S2.equals = function(t3) {
        return r2(t3) || (t3 = p2(t3)), (this.unsigned === t3.unsigned || this.high >>> 31 != 1 || t3.high >>> 31 != 1) && this.high === t3.high && this.low === t3.low;
      }, S2.eq = S2.equals, S2.notEquals = function(t3) {
        return !this.eq(t3);
      }, S2.neq = S2.notEquals, S2.ne = S2.notEquals, S2.lessThan = function(t3) {
        return this.comp(t3) < 0;
      }, S2.lt = S2.lessThan, S2.lessThanOrEqual = function(t3) {
        return this.comp(t3) <= 0;
      }, S2.lte = S2.lessThanOrEqual, S2.le = S2.lessThanOrEqual, S2.greaterThan = function(t3) {
        return this.comp(t3) > 0;
      }, S2.gt = S2.greaterThan, S2.greaterThanOrEqual = function(t3) {
        return this.comp(t3) >= 0;
      }, S2.gte = S2.greaterThanOrEqual, S2.ge = S2.greaterThanOrEqual, S2.compare = function(t3) {
        if (r2(t3) || (t3 = p2(t3)), this.eq(t3)) return 0;
        var e3 = this.isNegative(), n3 = t3.isNegative();
        return e3 && !n3 ? -1 : !e3 && n3 ? 1 : this.unsigned ? t3.high >>> 0 > this.high >>> 0 || t3.high === this.high && t3.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t3).isNegative() ? -1 : 1;
      }, S2.comp = S2.compare, S2.negate = function() {
        return !this.unsigned && this.eq(T2) ? T2 : this.not().add(y2);
      }, S2.neg = S2.negate, S2.add = function(t3) {
        r2(t3) || (t3 = p2(t3));
        var e3 = this.high >>> 16, n3 = 65535 & this.high, i2 = this.low >>> 16, o2 = 65535 & this.low, a2 = t3.high >>> 16, s2 = 65535 & t3.high, c3 = t3.low >>> 16, l3 = 0, f3 = 0, d3 = 0, h3 = 0;
        return d3 += (h3 += o2 + (65535 & t3.low)) >>> 16, f3 += (d3 += i2 + c3) >>> 16, l3 += (f3 += n3 + s2) >>> 16, l3 += e3 + a2, u2((d3 &= 65535) << 16 | (h3 &= 65535), (l3 &= 65535) << 16 | (f3 &= 65535), this.unsigned);
      }, S2.subtract = function(t3) {
        return r2(t3) || (t3 = p2(t3)), this.add(t3.neg());
      }, S2.sub = S2.subtract, S2.multiply = function(t3) {
        if (this.isZero()) return b2;
        if (r2(t3) || (t3 = p2(t3)), e2) return u2(e2.mul(this.low, this.high, t3.low, t3.high), e2.get_high(), this.unsigned);
        if (t3.isZero()) return b2;
        if (this.eq(T2)) return t3.isOdd() ? T2 : b2;
        if (t3.eq(T2)) return this.isOdd() ? T2 : b2;
        if (this.isNegative()) return t3.isNegative() ? this.neg().mul(t3.neg()) : this.neg().mul(t3).neg();
        if (t3.isNegative()) return this.mul(t3.neg()).neg();
        if (this.lt(g2) && t3.lt(g2)) return s(this.toNumber() * t3.toNumber(), this.unsigned);
        var n3 = this.high >>> 16, i2 = 65535 & this.high, o2 = this.low >>> 16, a2 = 65535 & this.low, c3 = t3.high >>> 16, l3 = 65535 & t3.high, f3 = t3.low >>> 16, d3 = 65535 & t3.low, h3 = 0, m3 = 0, y3 = 0, _2 = 0;
        return y3 += (_2 += a2 * d3) >>> 16, m3 += (y3 += o2 * d3) >>> 16, y3 &= 65535, m3 += (y3 += a2 * f3) >>> 16, h3 += (m3 += i2 * d3) >>> 16, m3 &= 65535, h3 += (m3 += o2 * f3) >>> 16, m3 &= 65535, h3 += (m3 += a2 * l3) >>> 16, h3 += n3 * d3 + i2 * f3 + o2 * l3 + a2 * c3, u2((y3 &= 65535) << 16 | (_2 &= 65535), (h3 &= 65535) << 16 | (m3 &= 65535), this.unsigned);
      }, S2.mul = S2.multiply, S2.divide = function(t3) {
        if (r2(t3) || (t3 = p2(t3)), t3.isZero()) throw Error("division by zero");
        var n3, i2, o2;
        if (e2) return this.unsigned || -2147483648 !== this.high || -1 !== t3.low || -1 !== t3.high ? u2((this.unsigned ? e2.div_u : e2.div_s)(this.low, this.high, t3.low, t3.high), e2.get_high(), this.unsigned) : this;
        if (this.isZero()) return this.unsigned ? m2 : b2;
        if (this.unsigned) {
          if (t3.unsigned || (t3 = t3.toUnsigned()), t3.gt(this)) return m2;
          if (t3.gt(this.shru(1))) return _;
          o2 = m2;
        } else {
          if (this.eq(T2)) return t3.eq(y2) || t3.eq(v2) ? T2 : t3.eq(T2) ? y2 : (n3 = this.shr(1).div(t3).shl(1)).eq(b2) ? t3.isNegative() ? y2 : v2 : (i2 = this.sub(t3.mul(n3)), o2 = n3.add(i2.div(t3)));
          if (t3.eq(T2)) return this.unsigned ? m2 : b2;
          if (this.isNegative()) return t3.isNegative() ? this.neg().div(t3.neg()) : this.neg().div(t3).neg();
          if (t3.isNegative()) return this.div(t3.neg()).neg();
          o2 = b2;
        }
        for (i2 = this; i2.gte(t3); ) {
          n3 = Math.max(1, Math.floor(i2.toNumber() / t3.toNumber()));
          for (var a2 = Math.ceil(Math.log(n3) / Math.LN2), l3 = a2 <= 48 ? 1 : c2(2, a2 - 48), f3 = s(n3), d3 = f3.mul(t3); d3.isNegative() || d3.gt(i2); ) d3 = (f3 = s(n3 -= l3, this.unsigned)).mul(t3);
          f3.isZero() && (f3 = y2), o2 = o2.add(f3), i2 = i2.sub(d3);
        }
        return o2;
      }, S2.div = S2.divide, S2.modulo = function(t3) {
        return r2(t3) || (t3 = p2(t3)), e2 ? u2((this.unsigned ? e2.rem_u : e2.rem_s)(this.low, this.high, t3.low, t3.high), e2.get_high(), this.unsigned) : this.sub(this.div(t3).mul(t3));
      }, S2.mod = S2.modulo, S2.rem = S2.modulo, S2.not = function() {
        return u2(~this.low, ~this.high, this.unsigned);
      }, S2.and = function(t3) {
        return r2(t3) || (t3 = p2(t3)), u2(this.low & t3.low, this.high & t3.high, this.unsigned);
      }, S2.or = function(t3) {
        return r2(t3) || (t3 = p2(t3)), u2(this.low | t3.low, this.high | t3.high, this.unsigned);
      }, S2.xor = function(t3) {
        return r2(t3) || (t3 = p2(t3)), u2(this.low ^ t3.low, this.high ^ t3.high, this.unsigned);
      }, S2.shiftLeft = function(t3) {
        return r2(t3) && (t3 = t3.toInt()), 0 == (t3 &= 63) ? this : t3 < 32 ? u2(this.low << t3, this.high << t3 | this.low >>> 32 - t3, this.unsigned) : u2(0, this.low << t3 - 32, this.unsigned);
      }, S2.shl = S2.shiftLeft, S2.shiftRight = function(t3) {
        return r2(t3) && (t3 = t3.toInt()), 0 == (t3 &= 63) ? this : t3 < 32 ? u2(this.low >>> t3 | this.high << 32 - t3, this.high >> t3, this.unsigned) : u2(this.high >> t3 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }, S2.shr = S2.shiftRight, S2.shiftRightUnsigned = function(t3) {
        if (r2(t3) && (t3 = t3.toInt()), 0 == (t3 &= 63)) return this;
        var e3 = this.high;
        return t3 < 32 ? u2(this.low >>> t3 | e3 << 32 - t3, e3 >>> t3, this.unsigned) : u2(32 === t3 ? e3 : e3 >>> t3 - 32, 0, this.unsigned);
      }, S2.shru = S2.shiftRightUnsigned, S2.shr_u = S2.shiftRightUnsigned, S2.toSigned = function() {
        return this.unsigned ? u2(this.low, this.high, false) : this;
      }, S2.toUnsigned = function() {
        return this.unsigned ? this : u2(this.low, this.high, true);
      }, S2.toBytes = function(t3) {
        return t3 ? this.toBytesLE() : this.toBytesBE();
      }, S2.toBytesLE = function() {
        var t3 = this.high, e3 = this.low;
        return [255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24, 255 & t3, t3 >>> 8 & 255, t3 >>> 16 & 255, t3 >>> 24];
      }, S2.toBytesBE = function() {
        var t3 = this.high, e3 = this.low;
        return [t3 >>> 24, t3 >>> 16 & 255, t3 >>> 8 & 255, 255 & t3, e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
      }, n2.fromBytes = function(t3, e3, r3) {
        return r3 ? n2.fromBytesLE(t3, e3) : n2.fromBytesBE(t3, e3);
      }, n2.fromBytesLE = function(t3, e3) {
        return new n2(t3[0] | t3[1] << 8 | t3[2] << 16 | t3[3] << 24, t3[4] | t3[5] << 8 | t3[6] << 16 | t3[7] << 24, e3);
      }, n2.fromBytesBE = function(t3, e3) {
        return new n2(t3[4] << 24 | t3[5] << 16 | t3[6] << 8 | t3[7], t3[0] << 24 | t3[1] << 16 | t3[2] << 8 | t3[3], e3);
      };
    }, 1446: (t2, e2, n2) => {
      var r2, i, o, a = n2(2100), s = a.Reader, u2 = a.Writer, c2 = a.util, l2 = a.roots.default || (a.roots.default = {});
      l2.onnx = ((o = {}).Version = (r2 = {}, (i = Object.create(r2))[r2[0] = "_START_VERSION"] = 0, i[r2[1] = "IR_VERSION_2017_10_10"] = 1, i[r2[2] = "IR_VERSION_2017_10_30"] = 2, i[r2[3] = "IR_VERSION_2017_11_3"] = 3, i[r2[4] = "IR_VERSION_2019_1_22"] = 4, i[r2[5] = "IR_VERSION"] = 5, i), o.AttributeProto = function() {
        function t3(t4) {
          if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.name = "", t3.prototype.refAttrName = "", t3.prototype.docString = "", t3.prototype.type = 0, t3.prototype.f = 0, t3.prototype.i = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t3.prototype.s = c2.newBuffer([]), t3.prototype.t = null, t3.prototype.g = null, t3.prototype.floats = c2.emptyArray, t3.prototype.ints = c2.emptyArray, t3.prototype.strings = c2.emptyArray, t3.prototype.tensors = c2.emptyArray, t3.prototype.graphs = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.name && t4.hasOwnProperty("name") && e3.uint32(10).string(t4.name), null != t4.f && t4.hasOwnProperty("f") && e3.uint32(21).float(t4.f), null != t4.i && t4.hasOwnProperty("i") && e3.uint32(24).int64(t4.i), null != t4.s && t4.hasOwnProperty("s") && e3.uint32(34).bytes(t4.s), null != t4.t && t4.hasOwnProperty("t") && l2.onnx.TensorProto.encode(t4.t, e3.uint32(42).fork()).ldelim(), null != t4.g && t4.hasOwnProperty("g") && l2.onnx.GraphProto.encode(t4.g, e3.uint32(50).fork()).ldelim(), null != t4.floats && t4.floats.length) {
            e3.uint32(58).fork();
            for (var n3 = 0; n3 < t4.floats.length; ++n3) e3.float(t4.floats[n3]);
            e3.ldelim();
          }
          if (null != t4.ints && t4.ints.length) {
            for (e3.uint32(66).fork(), n3 = 0; n3 < t4.ints.length; ++n3) e3.int64(t4.ints[n3]);
            e3.ldelim();
          }
          if (null != t4.strings && t4.strings.length) for (n3 = 0; n3 < t4.strings.length; ++n3) e3.uint32(74).bytes(t4.strings[n3]);
          if (null != t4.tensors && t4.tensors.length) for (n3 = 0; n3 < t4.tensors.length; ++n3) l2.onnx.TensorProto.encode(t4.tensors[n3], e3.uint32(82).fork()).ldelim();
          if (null != t4.graphs && t4.graphs.length) for (n3 = 0; n3 < t4.graphs.length; ++n3) l2.onnx.GraphProto.encode(t4.graphs[n3], e3.uint32(90).fork()).ldelim();
          return null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(106).string(t4.docString), null != t4.type && t4.hasOwnProperty("type") && e3.uint32(160).int32(t4.type), null != t4.refAttrName && t4.hasOwnProperty("refAttrName") && e3.uint32(170).string(t4.refAttrName), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.AttributeProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.name = t4.string();
                break;
              case 21:
                r3.refAttrName = t4.string();
                break;
              case 13:
                r3.docString = t4.string();
                break;
              case 20:
                r3.type = t4.int32();
                break;
              case 2:
                r3.f = t4.float();
                break;
              case 3:
                r3.i = t4.int64();
                break;
              case 4:
                r3.s = t4.bytes();
                break;
              case 5:
                r3.t = l2.onnx.TensorProto.decode(t4, t4.uint32());
                break;
              case 6:
                r3.g = l2.onnx.GraphProto.decode(t4, t4.uint32());
                break;
              case 7:
                if (r3.floats && r3.floats.length || (r3.floats = []), 2 == (7 & i2)) for (var o2 = t4.uint32() + t4.pos; t4.pos < o2; ) r3.floats.push(t4.float());
                else r3.floats.push(t4.float());
                break;
              case 8:
                if (r3.ints && r3.ints.length || (r3.ints = []), 2 == (7 & i2)) for (o2 = t4.uint32() + t4.pos; t4.pos < o2; ) r3.ints.push(t4.int64());
                else r3.ints.push(t4.int64());
                break;
              case 9:
                r3.strings && r3.strings.length || (r3.strings = []), r3.strings.push(t4.bytes());
                break;
              case 10:
                r3.tensors && r3.tensors.length || (r3.tensors = []), r3.tensors.push(l2.onnx.TensorProto.decode(t4, t4.uint32()));
                break;
              case 11:
                r3.graphs && r3.graphs.length || (r3.graphs = []), r3.graphs.push(l2.onnx.GraphProto.decode(t4, t4.uint32()));
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.refAttrName && t4.hasOwnProperty("refAttrName") && !c2.isString(t4.refAttrName)) return "refAttrName: string expected";
          if (null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString)) return "docString: string expected";
          if (null != t4.type && t4.hasOwnProperty("type")) switch (t4.type) {
            default:
              return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
          }
          if (null != t4.f && t4.hasOwnProperty("f") && "number" != typeof t4.f) return "f: number expected";
          if (null != t4.i && t4.hasOwnProperty("i") && !(c2.isInteger(t4.i) || t4.i && c2.isInteger(t4.i.low) && c2.isInteger(t4.i.high))) return "i: integer|Long expected";
          if (null != t4.s && t4.hasOwnProperty("s") && !(t4.s && "number" == typeof t4.s.length || c2.isString(t4.s))) return "s: buffer expected";
          if (null != t4.t && t4.hasOwnProperty("t") && (n3 = l2.onnx.TensorProto.verify(t4.t))) return "t." + n3;
          if (null != t4.g && t4.hasOwnProperty("g") && (n3 = l2.onnx.GraphProto.verify(t4.g))) return "g." + n3;
          if (null != t4.floats && t4.hasOwnProperty("floats")) {
            if (!Array.isArray(t4.floats)) return "floats: array expected";
            for (var e3 = 0; e3 < t4.floats.length; ++e3) if ("number" != typeof t4.floats[e3]) return "floats: number[] expected";
          }
          if (null != t4.ints && t4.hasOwnProperty("ints")) {
            if (!Array.isArray(t4.ints)) return "ints: array expected";
            for (e3 = 0; e3 < t4.ints.length; ++e3) if (!(c2.isInteger(t4.ints[e3]) || t4.ints[e3] && c2.isInteger(t4.ints[e3].low) && c2.isInteger(t4.ints[e3].high))) return "ints: integer|Long[] expected";
          }
          if (null != t4.strings && t4.hasOwnProperty("strings")) {
            if (!Array.isArray(t4.strings)) return "strings: array expected";
            for (e3 = 0; e3 < t4.strings.length; ++e3) if (!(t4.strings[e3] && "number" == typeof t4.strings[e3].length || c2.isString(t4.strings[e3]))) return "strings: buffer[] expected";
          }
          if (null != t4.tensors && t4.hasOwnProperty("tensors")) {
            if (!Array.isArray(t4.tensors)) return "tensors: array expected";
            for (e3 = 0; e3 < t4.tensors.length; ++e3) if (n3 = l2.onnx.TensorProto.verify(t4.tensors[e3])) return "tensors." + n3;
          }
          if (null != t4.graphs && t4.hasOwnProperty("graphs")) {
            if (!Array.isArray(t4.graphs)) return "graphs: array expected";
            for (e3 = 0; e3 < t4.graphs.length; ++e3) {
              var n3;
              if (n3 = l2.onnx.GraphProto.verify(t4.graphs[e3])) return "graphs." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.AttributeProto) return t4;
          var e3 = new l2.onnx.AttributeProto();
          switch (null != t4.name && (e3.name = String(t4.name)), null != t4.refAttrName && (e3.refAttrName = String(t4.refAttrName)), null != t4.docString && (e3.docString = String(t4.docString)), t4.type) {
            case "UNDEFINED":
            case 0:
              e3.type = 0;
              break;
            case "FLOAT":
            case 1:
              e3.type = 1;
              break;
            case "INT":
            case 2:
              e3.type = 2;
              break;
            case "STRING":
            case 3:
              e3.type = 3;
              break;
            case "TENSOR":
            case 4:
              e3.type = 4;
              break;
            case "GRAPH":
            case 5:
              e3.type = 5;
              break;
            case "FLOATS":
            case 6:
              e3.type = 6;
              break;
            case "INTS":
            case 7:
              e3.type = 7;
              break;
            case "STRINGS":
            case 8:
              e3.type = 8;
              break;
            case "TENSORS":
            case 9:
              e3.type = 9;
              break;
            case "GRAPHS":
            case 10:
              e3.type = 10;
          }
          if (null != t4.f && (e3.f = Number(t4.f)), null != t4.i && (c2.Long ? (e3.i = c2.Long.fromValue(t4.i)).unsigned = false : "string" == typeof t4.i ? e3.i = parseInt(t4.i, 10) : "number" == typeof t4.i ? e3.i = t4.i : "object" == typeof t4.i && (e3.i = new c2.LongBits(t4.i.low >>> 0, t4.i.high >>> 0).toNumber())), null != t4.s && ("string" == typeof t4.s ? c2.base64.decode(t4.s, e3.s = c2.newBuffer(c2.base64.length(t4.s)), 0) : t4.s.length && (e3.s = t4.s)), null != t4.t) {
            if ("object" != typeof t4.t) throw TypeError(".onnx.AttributeProto.t: object expected");
            e3.t = l2.onnx.TensorProto.fromObject(t4.t);
          }
          if (null != t4.g) {
            if ("object" != typeof t4.g) throw TypeError(".onnx.AttributeProto.g: object expected");
            e3.g = l2.onnx.GraphProto.fromObject(t4.g);
          }
          if (t4.floats) {
            if (!Array.isArray(t4.floats)) throw TypeError(".onnx.AttributeProto.floats: array expected");
            e3.floats = [];
            for (var n3 = 0; n3 < t4.floats.length; ++n3) e3.floats[n3] = Number(t4.floats[n3]);
          }
          if (t4.ints) {
            if (!Array.isArray(t4.ints)) throw TypeError(".onnx.AttributeProto.ints: array expected");
            for (e3.ints = [], n3 = 0; n3 < t4.ints.length; ++n3) c2.Long ? (e3.ints[n3] = c2.Long.fromValue(t4.ints[n3])).unsigned = false : "string" == typeof t4.ints[n3] ? e3.ints[n3] = parseInt(t4.ints[n3], 10) : "number" == typeof t4.ints[n3] ? e3.ints[n3] = t4.ints[n3] : "object" == typeof t4.ints[n3] && (e3.ints[n3] = new c2.LongBits(t4.ints[n3].low >>> 0, t4.ints[n3].high >>> 0).toNumber());
          }
          if (t4.strings) {
            if (!Array.isArray(t4.strings)) throw TypeError(".onnx.AttributeProto.strings: array expected");
            for (e3.strings = [], n3 = 0; n3 < t4.strings.length; ++n3) "string" == typeof t4.strings[n3] ? c2.base64.decode(t4.strings[n3], e3.strings[n3] = c2.newBuffer(c2.base64.length(t4.strings[n3])), 0) : t4.strings[n3].length && (e3.strings[n3] = t4.strings[n3]);
          }
          if (t4.tensors) {
            if (!Array.isArray(t4.tensors)) throw TypeError(".onnx.AttributeProto.tensors: array expected");
            for (e3.tensors = [], n3 = 0; n3 < t4.tensors.length; ++n3) {
              if ("object" != typeof t4.tensors[n3]) throw TypeError(".onnx.AttributeProto.tensors: object expected");
              e3.tensors[n3] = l2.onnx.TensorProto.fromObject(t4.tensors[n3]);
            }
          }
          if (t4.graphs) {
            if (!Array.isArray(t4.graphs)) throw TypeError(".onnx.AttributeProto.graphs: array expected");
            for (e3.graphs = [], n3 = 0; n3 < t4.graphs.length; ++n3) {
              if ("object" != typeof t4.graphs[n3]) throw TypeError(".onnx.AttributeProto.graphs: object expected");
              e3.graphs[n3] = l2.onnx.GraphProto.fromObject(t4.graphs[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.floats = [], n3.ints = [], n3.strings = [], n3.tensors = [], n3.graphs = []), e3.defaults) {
            if (n3.name = "", n3.f = 0, c2.Long) {
              var r3 = new c2.Long(0, 0, false);
              n3.i = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3;
            } else n3.i = e3.longs === String ? "0" : 0;
            e3.bytes === String ? n3.s = "" : (n3.s = [], e3.bytes !== Array && (n3.s = c2.newBuffer(n3.s))), n3.t = null, n3.g = null, n3.docString = "", n3.type = e3.enums === String ? "UNDEFINED" : 0, n3.refAttrName = "";
          }
          if (null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), null != t4.f && t4.hasOwnProperty("f") && (n3.f = e3.json && !isFinite(t4.f) ? String(t4.f) : t4.f), null != t4.i && t4.hasOwnProperty("i") && ("number" == typeof t4.i ? n3.i = e3.longs === String ? String(t4.i) : t4.i : n3.i = e3.longs === String ? c2.Long.prototype.toString.call(t4.i) : e3.longs === Number ? new c2.LongBits(t4.i.low >>> 0, t4.i.high >>> 0).toNumber() : t4.i), null != t4.s && t4.hasOwnProperty("s") && (n3.s = e3.bytes === String ? c2.base64.encode(t4.s, 0, t4.s.length) : e3.bytes === Array ? Array.prototype.slice.call(t4.s) : t4.s), null != t4.t && t4.hasOwnProperty("t") && (n3.t = l2.onnx.TensorProto.toObject(t4.t, e3)), null != t4.g && t4.hasOwnProperty("g") && (n3.g = l2.onnx.GraphProto.toObject(t4.g, e3)), t4.floats && t4.floats.length) {
            n3.floats = [];
            for (var i2 = 0; i2 < t4.floats.length; ++i2) n3.floats[i2] = e3.json && !isFinite(t4.floats[i2]) ? String(t4.floats[i2]) : t4.floats[i2];
          }
          if (t4.ints && t4.ints.length) for (n3.ints = [], i2 = 0; i2 < t4.ints.length; ++i2) "number" == typeof t4.ints[i2] ? n3.ints[i2] = e3.longs === String ? String(t4.ints[i2]) : t4.ints[i2] : n3.ints[i2] = e3.longs === String ? c2.Long.prototype.toString.call(t4.ints[i2]) : e3.longs === Number ? new c2.LongBits(t4.ints[i2].low >>> 0, t4.ints[i2].high >>> 0).toNumber() : t4.ints[i2];
          if (t4.strings && t4.strings.length) for (n3.strings = [], i2 = 0; i2 < t4.strings.length; ++i2) n3.strings[i2] = e3.bytes === String ? c2.base64.encode(t4.strings[i2], 0, t4.strings[i2].length) : e3.bytes === Array ? Array.prototype.slice.call(t4.strings[i2]) : t4.strings[i2];
          if (t4.tensors && t4.tensors.length) for (n3.tensors = [], i2 = 0; i2 < t4.tensors.length; ++i2) n3.tensors[i2] = l2.onnx.TensorProto.toObject(t4.tensors[i2], e3);
          if (t4.graphs && t4.graphs.length) for (n3.graphs = [], i2 = 0; i2 < t4.graphs.length; ++i2) n3.graphs[i2] = l2.onnx.GraphProto.toObject(t4.graphs[i2], e3);
          return null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), null != t4.type && t4.hasOwnProperty("type") && (n3.type = e3.enums === String ? l2.onnx.AttributeProto.AttributeType[t4.type] : t4.type), null != t4.refAttrName && t4.hasOwnProperty("refAttrName") && (n3.refAttrName = t4.refAttrName), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3.AttributeType = function() {
          var t4 = {}, e3 = Object.create(t4);
          return e3[t4[0] = "UNDEFINED"] = 0, e3[t4[1] = "FLOAT"] = 1, e3[t4[2] = "INT"] = 2, e3[t4[3] = "STRING"] = 3, e3[t4[4] = "TENSOR"] = 4, e3[t4[5] = "GRAPH"] = 5, e3[t4[6] = "FLOATS"] = 6, e3[t4[7] = "INTS"] = 7, e3[t4[8] = "STRINGS"] = 8, e3[t4[9] = "TENSORS"] = 9, e3[t4[10] = "GRAPHS"] = 10, e3;
        }(), t3;
      }(), o.ValueInfoProto = function() {
        function t3(t4) {
          if (t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.name = "", t3.prototype.type = null, t3.prototype.docString = "", t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          return e3 || (e3 = u2.create()), null != t4.name && t4.hasOwnProperty("name") && e3.uint32(10).string(t4.name), null != t4.type && t4.hasOwnProperty("type") && l2.onnx.TypeProto.encode(t4.type, e3.uint32(18).fork()).ldelim(), null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(26).string(t4.docString), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.ValueInfoProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.name = t4.string();
                break;
              case 2:
                r3.type = l2.onnx.TypeProto.decode(t4, t4.uint32());
                break;
              case 3:
                r3.docString = t4.string();
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.type && t4.hasOwnProperty("type")) {
            var e3 = l2.onnx.TypeProto.verify(t4.type);
            if (e3) return "type." + e3;
          }
          return null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString) ? "docString: string expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.ValueInfoProto) return t4;
          var e3 = new l2.onnx.ValueInfoProto();
          if (null != t4.name && (e3.name = String(t4.name)), null != t4.type) {
            if ("object" != typeof t4.type) throw TypeError(".onnx.ValueInfoProto.type: object expected");
            e3.type = l2.onnx.TypeProto.fromObject(t4.type);
          }
          return null != t4.docString && (e3.docString = String(t4.docString)), e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          return e3.defaults && (n3.name = "", n3.type = null, n3.docString = ""), null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), null != t4.type && t4.hasOwnProperty("type") && (n3.type = l2.onnx.TypeProto.toObject(t4.type, e3)), null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3;
      }(), o.NodeProto = function() {
        function t3(t4) {
          if (this.input = [], this.output = [], this.attribute = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.input = c2.emptyArray, t3.prototype.output = c2.emptyArray, t3.prototype.name = "", t3.prototype.opType = "", t3.prototype.domain = "", t3.prototype.attribute = c2.emptyArray, t3.prototype.docString = "", t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.input && t4.input.length) for (var n3 = 0; n3 < t4.input.length; ++n3) e3.uint32(10).string(t4.input[n3]);
          if (null != t4.output && t4.output.length) for (n3 = 0; n3 < t4.output.length; ++n3) e3.uint32(18).string(t4.output[n3]);
          if (null != t4.name && t4.hasOwnProperty("name") && e3.uint32(26).string(t4.name), null != t4.opType && t4.hasOwnProperty("opType") && e3.uint32(34).string(t4.opType), null != t4.attribute && t4.attribute.length) for (n3 = 0; n3 < t4.attribute.length; ++n3) l2.onnx.AttributeProto.encode(t4.attribute[n3], e3.uint32(42).fork()).ldelim();
          return null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(50).string(t4.docString), null != t4.domain && t4.hasOwnProperty("domain") && e3.uint32(58).string(t4.domain), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.NodeProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.input && r3.input.length || (r3.input = []), r3.input.push(t4.string());
                break;
              case 2:
                r3.output && r3.output.length || (r3.output = []), r3.output.push(t4.string());
                break;
              case 3:
                r3.name = t4.string();
                break;
              case 4:
                r3.opType = t4.string();
                break;
              case 7:
                r3.domain = t4.string();
                break;
              case 5:
                r3.attribute && r3.attribute.length || (r3.attribute = []), r3.attribute.push(l2.onnx.AttributeProto.decode(t4, t4.uint32()));
                break;
              case 6:
                r3.docString = t4.string();
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.input && t4.hasOwnProperty("input")) {
            if (!Array.isArray(t4.input)) return "input: array expected";
            for (var e3 = 0; e3 < t4.input.length; ++e3) if (!c2.isString(t4.input[e3])) return "input: string[] expected";
          }
          if (null != t4.output && t4.hasOwnProperty("output")) {
            if (!Array.isArray(t4.output)) return "output: array expected";
            for (e3 = 0; e3 < t4.output.length; ++e3) if (!c2.isString(t4.output[e3])) return "output: string[] expected";
          }
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.opType && t4.hasOwnProperty("opType") && !c2.isString(t4.opType)) return "opType: string expected";
          if (null != t4.domain && t4.hasOwnProperty("domain") && !c2.isString(t4.domain)) return "domain: string expected";
          if (null != t4.attribute && t4.hasOwnProperty("attribute")) {
            if (!Array.isArray(t4.attribute)) return "attribute: array expected";
            for (e3 = 0; e3 < t4.attribute.length; ++e3) {
              var n3 = l2.onnx.AttributeProto.verify(t4.attribute[e3]);
              if (n3) return "attribute." + n3;
            }
          }
          return null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString) ? "docString: string expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.NodeProto) return t4;
          var e3 = new l2.onnx.NodeProto();
          if (t4.input) {
            if (!Array.isArray(t4.input)) throw TypeError(".onnx.NodeProto.input: array expected");
            e3.input = [];
            for (var n3 = 0; n3 < t4.input.length; ++n3) e3.input[n3] = String(t4.input[n3]);
          }
          if (t4.output) {
            if (!Array.isArray(t4.output)) throw TypeError(".onnx.NodeProto.output: array expected");
            for (e3.output = [], n3 = 0; n3 < t4.output.length; ++n3) e3.output[n3] = String(t4.output[n3]);
          }
          if (null != t4.name && (e3.name = String(t4.name)), null != t4.opType && (e3.opType = String(t4.opType)), null != t4.domain && (e3.domain = String(t4.domain)), t4.attribute) {
            if (!Array.isArray(t4.attribute)) throw TypeError(".onnx.NodeProto.attribute: array expected");
            for (e3.attribute = [], n3 = 0; n3 < t4.attribute.length; ++n3) {
              if ("object" != typeof t4.attribute[n3]) throw TypeError(".onnx.NodeProto.attribute: object expected");
              e3.attribute[n3] = l2.onnx.AttributeProto.fromObject(t4.attribute[n3]);
            }
          }
          return null != t4.docString && (e3.docString = String(t4.docString)), e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.input = [], n3.output = [], n3.attribute = []), e3.defaults && (n3.name = "", n3.opType = "", n3.docString = "", n3.domain = ""), t4.input && t4.input.length) {
            n3.input = [];
            for (var r3 = 0; r3 < t4.input.length; ++r3) n3.input[r3] = t4.input[r3];
          }
          if (t4.output && t4.output.length) for (n3.output = [], r3 = 0; r3 < t4.output.length; ++r3) n3.output[r3] = t4.output[r3];
          if (null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), null != t4.opType && t4.hasOwnProperty("opType") && (n3.opType = t4.opType), t4.attribute && t4.attribute.length) for (n3.attribute = [], r3 = 0; r3 < t4.attribute.length; ++r3) n3.attribute[r3] = l2.onnx.AttributeProto.toObject(t4.attribute[r3], e3);
          return null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), null != t4.domain && t4.hasOwnProperty("domain") && (n3.domain = t4.domain), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3;
      }(), o.ModelProto = function() {
        function t3(t4) {
          if (this.opsetImport = [], this.metadataProps = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.irVersion = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t3.prototype.opsetImport = c2.emptyArray, t3.prototype.producerName = "", t3.prototype.producerVersion = "", t3.prototype.domain = "", t3.prototype.modelVersion = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t3.prototype.docString = "", t3.prototype.graph = null, t3.prototype.metadataProps = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.irVersion && t4.hasOwnProperty("irVersion") && e3.uint32(8).int64(t4.irVersion), null != t4.producerName && t4.hasOwnProperty("producerName") && e3.uint32(18).string(t4.producerName), null != t4.producerVersion && t4.hasOwnProperty("producerVersion") && e3.uint32(26).string(t4.producerVersion), null != t4.domain && t4.hasOwnProperty("domain") && e3.uint32(34).string(t4.domain), null != t4.modelVersion && t4.hasOwnProperty("modelVersion") && e3.uint32(40).int64(t4.modelVersion), null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(50).string(t4.docString), null != t4.graph && t4.hasOwnProperty("graph") && l2.onnx.GraphProto.encode(t4.graph, e3.uint32(58).fork()).ldelim(), null != t4.opsetImport && t4.opsetImport.length) for (var n3 = 0; n3 < t4.opsetImport.length; ++n3) l2.onnx.OperatorSetIdProto.encode(t4.opsetImport[n3], e3.uint32(66).fork()).ldelim();
          if (null != t4.metadataProps && t4.metadataProps.length) for (n3 = 0; n3 < t4.metadataProps.length; ++n3) l2.onnx.StringStringEntryProto.encode(t4.metadataProps[n3], e3.uint32(114).fork()).ldelim();
          return e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.ModelProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.irVersion = t4.int64();
                break;
              case 8:
                r3.opsetImport && r3.opsetImport.length || (r3.opsetImport = []), r3.opsetImport.push(l2.onnx.OperatorSetIdProto.decode(t4, t4.uint32()));
                break;
              case 2:
                r3.producerName = t4.string();
                break;
              case 3:
                r3.producerVersion = t4.string();
                break;
              case 4:
                r3.domain = t4.string();
                break;
              case 5:
                r3.modelVersion = t4.int64();
                break;
              case 6:
                r3.docString = t4.string();
                break;
              case 7:
                r3.graph = l2.onnx.GraphProto.decode(t4, t4.uint32());
                break;
              case 14:
                r3.metadataProps && r3.metadataProps.length || (r3.metadataProps = []), r3.metadataProps.push(l2.onnx.StringStringEntryProto.decode(t4, t4.uint32()));
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.irVersion && t4.hasOwnProperty("irVersion") && !(c2.isInteger(t4.irVersion) || t4.irVersion && c2.isInteger(t4.irVersion.low) && c2.isInteger(t4.irVersion.high))) return "irVersion: integer|Long expected";
          if (null != t4.opsetImport && t4.hasOwnProperty("opsetImport")) {
            if (!Array.isArray(t4.opsetImport)) return "opsetImport: array expected";
            for (var e3 = 0; e3 < t4.opsetImport.length; ++e3) if (n3 = l2.onnx.OperatorSetIdProto.verify(t4.opsetImport[e3])) return "opsetImport." + n3;
          }
          if (null != t4.producerName && t4.hasOwnProperty("producerName") && !c2.isString(t4.producerName)) return "producerName: string expected";
          if (null != t4.producerVersion && t4.hasOwnProperty("producerVersion") && !c2.isString(t4.producerVersion)) return "producerVersion: string expected";
          if (null != t4.domain && t4.hasOwnProperty("domain") && !c2.isString(t4.domain)) return "domain: string expected";
          if (null != t4.modelVersion && t4.hasOwnProperty("modelVersion") && !(c2.isInteger(t4.modelVersion) || t4.modelVersion && c2.isInteger(t4.modelVersion.low) && c2.isInteger(t4.modelVersion.high))) return "modelVersion: integer|Long expected";
          if (null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString)) return "docString: string expected";
          if (null != t4.graph && t4.hasOwnProperty("graph") && (n3 = l2.onnx.GraphProto.verify(t4.graph))) return "graph." + n3;
          if (null != t4.metadataProps && t4.hasOwnProperty("metadataProps")) {
            if (!Array.isArray(t4.metadataProps)) return "metadataProps: array expected";
            for (e3 = 0; e3 < t4.metadataProps.length; ++e3) {
              var n3;
              if (n3 = l2.onnx.StringStringEntryProto.verify(t4.metadataProps[e3])) return "metadataProps." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.ModelProto) return t4;
          var e3 = new l2.onnx.ModelProto();
          if (null != t4.irVersion && (c2.Long ? (e3.irVersion = c2.Long.fromValue(t4.irVersion)).unsigned = false : "string" == typeof t4.irVersion ? e3.irVersion = parseInt(t4.irVersion, 10) : "number" == typeof t4.irVersion ? e3.irVersion = t4.irVersion : "object" == typeof t4.irVersion && (e3.irVersion = new c2.LongBits(t4.irVersion.low >>> 0, t4.irVersion.high >>> 0).toNumber())), t4.opsetImport) {
            if (!Array.isArray(t4.opsetImport)) throw TypeError(".onnx.ModelProto.opsetImport: array expected");
            e3.opsetImport = [];
            for (var n3 = 0; n3 < t4.opsetImport.length; ++n3) {
              if ("object" != typeof t4.opsetImport[n3]) throw TypeError(".onnx.ModelProto.opsetImport: object expected");
              e3.opsetImport[n3] = l2.onnx.OperatorSetIdProto.fromObject(t4.opsetImport[n3]);
            }
          }
          if (null != t4.producerName && (e3.producerName = String(t4.producerName)), null != t4.producerVersion && (e3.producerVersion = String(t4.producerVersion)), null != t4.domain && (e3.domain = String(t4.domain)), null != t4.modelVersion && (c2.Long ? (e3.modelVersion = c2.Long.fromValue(t4.modelVersion)).unsigned = false : "string" == typeof t4.modelVersion ? e3.modelVersion = parseInt(t4.modelVersion, 10) : "number" == typeof t4.modelVersion ? e3.modelVersion = t4.modelVersion : "object" == typeof t4.modelVersion && (e3.modelVersion = new c2.LongBits(t4.modelVersion.low >>> 0, t4.modelVersion.high >>> 0).toNumber())), null != t4.docString && (e3.docString = String(t4.docString)), null != t4.graph) {
            if ("object" != typeof t4.graph) throw TypeError(".onnx.ModelProto.graph: object expected");
            e3.graph = l2.onnx.GraphProto.fromObject(t4.graph);
          }
          if (t4.metadataProps) {
            if (!Array.isArray(t4.metadataProps)) throw TypeError(".onnx.ModelProto.metadataProps: array expected");
            for (e3.metadataProps = [], n3 = 0; n3 < t4.metadataProps.length; ++n3) {
              if ("object" != typeof t4.metadataProps[n3]) throw TypeError(".onnx.ModelProto.metadataProps: object expected");
              e3.metadataProps[n3] = l2.onnx.StringStringEntryProto.fromObject(t4.metadataProps[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.opsetImport = [], n3.metadataProps = []), e3.defaults) {
            if (c2.Long) {
              var r3 = new c2.Long(0, 0, false);
              n3.irVersion = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3;
            } else n3.irVersion = e3.longs === String ? "0" : 0;
            n3.producerName = "", n3.producerVersion = "", n3.domain = "", c2.Long ? (r3 = new c2.Long(0, 0, false), n3.modelVersion = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3) : n3.modelVersion = e3.longs === String ? "0" : 0, n3.docString = "", n3.graph = null;
          }
          if (null != t4.irVersion && t4.hasOwnProperty("irVersion") && ("number" == typeof t4.irVersion ? n3.irVersion = e3.longs === String ? String(t4.irVersion) : t4.irVersion : n3.irVersion = e3.longs === String ? c2.Long.prototype.toString.call(t4.irVersion) : e3.longs === Number ? new c2.LongBits(t4.irVersion.low >>> 0, t4.irVersion.high >>> 0).toNumber() : t4.irVersion), null != t4.producerName && t4.hasOwnProperty("producerName") && (n3.producerName = t4.producerName), null != t4.producerVersion && t4.hasOwnProperty("producerVersion") && (n3.producerVersion = t4.producerVersion), null != t4.domain && t4.hasOwnProperty("domain") && (n3.domain = t4.domain), null != t4.modelVersion && t4.hasOwnProperty("modelVersion") && ("number" == typeof t4.modelVersion ? n3.modelVersion = e3.longs === String ? String(t4.modelVersion) : t4.modelVersion : n3.modelVersion = e3.longs === String ? c2.Long.prototype.toString.call(t4.modelVersion) : e3.longs === Number ? new c2.LongBits(t4.modelVersion.low >>> 0, t4.modelVersion.high >>> 0).toNumber() : t4.modelVersion), null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), null != t4.graph && t4.hasOwnProperty("graph") && (n3.graph = l2.onnx.GraphProto.toObject(t4.graph, e3)), t4.opsetImport && t4.opsetImport.length) {
            n3.opsetImport = [];
            for (var i2 = 0; i2 < t4.opsetImport.length; ++i2) n3.opsetImport[i2] = l2.onnx.OperatorSetIdProto.toObject(t4.opsetImport[i2], e3);
          }
          if (t4.metadataProps && t4.metadataProps.length) for (n3.metadataProps = [], i2 = 0; i2 < t4.metadataProps.length; ++i2) n3.metadataProps[i2] = l2.onnx.StringStringEntryProto.toObject(t4.metadataProps[i2], e3);
          return n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3;
      }(), o.StringStringEntryProto = function() {
        function t3(t4) {
          if (t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.key = "", t3.prototype.value = "", t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          return e3 || (e3 = u2.create()), null != t4.key && t4.hasOwnProperty("key") && e3.uint32(10).string(t4.key), null != t4.value && t4.hasOwnProperty("value") && e3.uint32(18).string(t4.value), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.StringStringEntryProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.key = t4.string();
                break;
              case 2:
                r3.value = t4.string();
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          return "object" != typeof t4 || null === t4 ? "object expected" : null != t4.key && t4.hasOwnProperty("key") && !c2.isString(t4.key) ? "key: string expected" : null != t4.value && t4.hasOwnProperty("value") && !c2.isString(t4.value) ? "value: string expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.StringStringEntryProto) return t4;
          var e3 = new l2.onnx.StringStringEntryProto();
          return null != t4.key && (e3.key = String(t4.key)), null != t4.value && (e3.value = String(t4.value)), e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          return e3.defaults && (n3.key = "", n3.value = ""), null != t4.key && t4.hasOwnProperty("key") && (n3.key = t4.key), null != t4.value && t4.hasOwnProperty("value") && (n3.value = t4.value), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3;
      }(), o.TensorAnnotation = function() {
        function t3(t4) {
          if (this.quantParameterTensorNames = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.tensorName = "", t3.prototype.quantParameterTensorNames = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.tensorName && t4.hasOwnProperty("tensorName") && e3.uint32(10).string(t4.tensorName), null != t4.quantParameterTensorNames && t4.quantParameterTensorNames.length) for (var n3 = 0; n3 < t4.quantParameterTensorNames.length; ++n3) l2.onnx.StringStringEntryProto.encode(t4.quantParameterTensorNames[n3], e3.uint32(18).fork()).ldelim();
          return e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.TensorAnnotation(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.tensorName = t4.string();
                break;
              case 2:
                r3.quantParameterTensorNames && r3.quantParameterTensorNames.length || (r3.quantParameterTensorNames = []), r3.quantParameterTensorNames.push(l2.onnx.StringStringEntryProto.decode(t4, t4.uint32()));
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.tensorName && t4.hasOwnProperty("tensorName") && !c2.isString(t4.tensorName)) return "tensorName: string expected";
          if (null != t4.quantParameterTensorNames && t4.hasOwnProperty("quantParameterTensorNames")) {
            if (!Array.isArray(t4.quantParameterTensorNames)) return "quantParameterTensorNames: array expected";
            for (var e3 = 0; e3 < t4.quantParameterTensorNames.length; ++e3) {
              var n3 = l2.onnx.StringStringEntryProto.verify(t4.quantParameterTensorNames[e3]);
              if (n3) return "quantParameterTensorNames." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.TensorAnnotation) return t4;
          var e3 = new l2.onnx.TensorAnnotation();
          if (null != t4.tensorName && (e3.tensorName = String(t4.tensorName)), t4.quantParameterTensorNames) {
            if (!Array.isArray(t4.quantParameterTensorNames)) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
            e3.quantParameterTensorNames = [];
            for (var n3 = 0; n3 < t4.quantParameterTensorNames.length; ++n3) {
              if ("object" != typeof t4.quantParameterTensorNames[n3]) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
              e3.quantParameterTensorNames[n3] = l2.onnx.StringStringEntryProto.fromObject(t4.quantParameterTensorNames[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.quantParameterTensorNames = []), e3.defaults && (n3.tensorName = ""), null != t4.tensorName && t4.hasOwnProperty("tensorName") && (n3.tensorName = t4.tensorName), t4.quantParameterTensorNames && t4.quantParameterTensorNames.length) {
            n3.quantParameterTensorNames = [];
            for (var r3 = 0; r3 < t4.quantParameterTensorNames.length; ++r3) n3.quantParameterTensorNames[r3] = l2.onnx.StringStringEntryProto.toObject(t4.quantParameterTensorNames[r3], e3);
          }
          return n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3;
      }(), o.GraphProto = function() {
        function t3(t4) {
          if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.node = c2.emptyArray, t3.prototype.name = "", t3.prototype.initializer = c2.emptyArray, t3.prototype.docString = "", t3.prototype.input = c2.emptyArray, t3.prototype.output = c2.emptyArray, t3.prototype.valueInfo = c2.emptyArray, t3.prototype.quantizationAnnotation = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.node && t4.node.length) for (var n3 = 0; n3 < t4.node.length; ++n3) l2.onnx.NodeProto.encode(t4.node[n3], e3.uint32(10).fork()).ldelim();
          if (null != t4.name && t4.hasOwnProperty("name") && e3.uint32(18).string(t4.name), null != t4.initializer && t4.initializer.length) for (n3 = 0; n3 < t4.initializer.length; ++n3) l2.onnx.TensorProto.encode(t4.initializer[n3], e3.uint32(42).fork()).ldelim();
          if (null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(82).string(t4.docString), null != t4.input && t4.input.length) for (n3 = 0; n3 < t4.input.length; ++n3) l2.onnx.ValueInfoProto.encode(t4.input[n3], e3.uint32(90).fork()).ldelim();
          if (null != t4.output && t4.output.length) for (n3 = 0; n3 < t4.output.length; ++n3) l2.onnx.ValueInfoProto.encode(t4.output[n3], e3.uint32(98).fork()).ldelim();
          if (null != t4.valueInfo && t4.valueInfo.length) for (n3 = 0; n3 < t4.valueInfo.length; ++n3) l2.onnx.ValueInfoProto.encode(t4.valueInfo[n3], e3.uint32(106).fork()).ldelim();
          if (null != t4.quantizationAnnotation && t4.quantizationAnnotation.length) for (n3 = 0; n3 < t4.quantizationAnnotation.length; ++n3) l2.onnx.TensorAnnotation.encode(t4.quantizationAnnotation[n3], e3.uint32(114).fork()).ldelim();
          return e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.GraphProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.node && r3.node.length || (r3.node = []), r3.node.push(l2.onnx.NodeProto.decode(t4, t4.uint32()));
                break;
              case 2:
                r3.name = t4.string();
                break;
              case 5:
                r3.initializer && r3.initializer.length || (r3.initializer = []), r3.initializer.push(l2.onnx.TensorProto.decode(t4, t4.uint32()));
                break;
              case 10:
                r3.docString = t4.string();
                break;
              case 11:
                r3.input && r3.input.length || (r3.input = []), r3.input.push(l2.onnx.ValueInfoProto.decode(t4, t4.uint32()));
                break;
              case 12:
                r3.output && r3.output.length || (r3.output = []), r3.output.push(l2.onnx.ValueInfoProto.decode(t4, t4.uint32()));
                break;
              case 13:
                r3.valueInfo && r3.valueInfo.length || (r3.valueInfo = []), r3.valueInfo.push(l2.onnx.ValueInfoProto.decode(t4, t4.uint32()));
                break;
              case 14:
                r3.quantizationAnnotation && r3.quantizationAnnotation.length || (r3.quantizationAnnotation = []), r3.quantizationAnnotation.push(l2.onnx.TensorAnnotation.decode(t4, t4.uint32()));
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.node && t4.hasOwnProperty("node")) {
            if (!Array.isArray(t4.node)) return "node: array expected";
            for (var e3 = 0; e3 < t4.node.length; ++e3) if (n3 = l2.onnx.NodeProto.verify(t4.node[e3])) return "node." + n3;
          }
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.initializer && t4.hasOwnProperty("initializer")) {
            if (!Array.isArray(t4.initializer)) return "initializer: array expected";
            for (e3 = 0; e3 < t4.initializer.length; ++e3) if (n3 = l2.onnx.TensorProto.verify(t4.initializer[e3])) return "initializer." + n3;
          }
          if (null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString)) return "docString: string expected";
          if (null != t4.input && t4.hasOwnProperty("input")) {
            if (!Array.isArray(t4.input)) return "input: array expected";
            for (e3 = 0; e3 < t4.input.length; ++e3) if (n3 = l2.onnx.ValueInfoProto.verify(t4.input[e3])) return "input." + n3;
          }
          if (null != t4.output && t4.hasOwnProperty("output")) {
            if (!Array.isArray(t4.output)) return "output: array expected";
            for (e3 = 0; e3 < t4.output.length; ++e3) if (n3 = l2.onnx.ValueInfoProto.verify(t4.output[e3])) return "output." + n3;
          }
          if (null != t4.valueInfo && t4.hasOwnProperty("valueInfo")) {
            if (!Array.isArray(t4.valueInfo)) return "valueInfo: array expected";
            for (e3 = 0; e3 < t4.valueInfo.length; ++e3) if (n3 = l2.onnx.ValueInfoProto.verify(t4.valueInfo[e3])) return "valueInfo." + n3;
          }
          if (null != t4.quantizationAnnotation && t4.hasOwnProperty("quantizationAnnotation")) {
            if (!Array.isArray(t4.quantizationAnnotation)) return "quantizationAnnotation: array expected";
            for (e3 = 0; e3 < t4.quantizationAnnotation.length; ++e3) {
              var n3;
              if (n3 = l2.onnx.TensorAnnotation.verify(t4.quantizationAnnotation[e3])) return "quantizationAnnotation." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.GraphProto) return t4;
          var e3 = new l2.onnx.GraphProto();
          if (t4.node) {
            if (!Array.isArray(t4.node)) throw TypeError(".onnx.GraphProto.node: array expected");
            e3.node = [];
            for (var n3 = 0; n3 < t4.node.length; ++n3) {
              if ("object" != typeof t4.node[n3]) throw TypeError(".onnx.GraphProto.node: object expected");
              e3.node[n3] = l2.onnx.NodeProto.fromObject(t4.node[n3]);
            }
          }
          if (null != t4.name && (e3.name = String(t4.name)), t4.initializer) {
            if (!Array.isArray(t4.initializer)) throw TypeError(".onnx.GraphProto.initializer: array expected");
            for (e3.initializer = [], n3 = 0; n3 < t4.initializer.length; ++n3) {
              if ("object" != typeof t4.initializer[n3]) throw TypeError(".onnx.GraphProto.initializer: object expected");
              e3.initializer[n3] = l2.onnx.TensorProto.fromObject(t4.initializer[n3]);
            }
          }
          if (null != t4.docString && (e3.docString = String(t4.docString)), t4.input) {
            if (!Array.isArray(t4.input)) throw TypeError(".onnx.GraphProto.input: array expected");
            for (e3.input = [], n3 = 0; n3 < t4.input.length; ++n3) {
              if ("object" != typeof t4.input[n3]) throw TypeError(".onnx.GraphProto.input: object expected");
              e3.input[n3] = l2.onnx.ValueInfoProto.fromObject(t4.input[n3]);
            }
          }
          if (t4.output) {
            if (!Array.isArray(t4.output)) throw TypeError(".onnx.GraphProto.output: array expected");
            for (e3.output = [], n3 = 0; n3 < t4.output.length; ++n3) {
              if ("object" != typeof t4.output[n3]) throw TypeError(".onnx.GraphProto.output: object expected");
              e3.output[n3] = l2.onnx.ValueInfoProto.fromObject(t4.output[n3]);
            }
          }
          if (t4.valueInfo) {
            if (!Array.isArray(t4.valueInfo)) throw TypeError(".onnx.GraphProto.valueInfo: array expected");
            for (e3.valueInfo = [], n3 = 0; n3 < t4.valueInfo.length; ++n3) {
              if ("object" != typeof t4.valueInfo[n3]) throw TypeError(".onnx.GraphProto.valueInfo: object expected");
              e3.valueInfo[n3] = l2.onnx.ValueInfoProto.fromObject(t4.valueInfo[n3]);
            }
          }
          if (t4.quantizationAnnotation) {
            if (!Array.isArray(t4.quantizationAnnotation)) throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
            for (e3.quantizationAnnotation = [], n3 = 0; n3 < t4.quantizationAnnotation.length; ++n3) {
              if ("object" != typeof t4.quantizationAnnotation[n3]) throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
              e3.quantizationAnnotation[n3] = l2.onnx.TensorAnnotation.fromObject(t4.quantizationAnnotation[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.node = [], n3.initializer = [], n3.input = [], n3.output = [], n3.valueInfo = [], n3.quantizationAnnotation = []), e3.defaults && (n3.name = "", n3.docString = ""), t4.node && t4.node.length) {
            n3.node = [];
            for (var r3 = 0; r3 < t4.node.length; ++r3) n3.node[r3] = l2.onnx.NodeProto.toObject(t4.node[r3], e3);
          }
          if (null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), t4.initializer && t4.initializer.length) for (n3.initializer = [], r3 = 0; r3 < t4.initializer.length; ++r3) n3.initializer[r3] = l2.onnx.TensorProto.toObject(t4.initializer[r3], e3);
          if (null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), t4.input && t4.input.length) for (n3.input = [], r3 = 0; r3 < t4.input.length; ++r3) n3.input[r3] = l2.onnx.ValueInfoProto.toObject(t4.input[r3], e3);
          if (t4.output && t4.output.length) for (n3.output = [], r3 = 0; r3 < t4.output.length; ++r3) n3.output[r3] = l2.onnx.ValueInfoProto.toObject(t4.output[r3], e3);
          if (t4.valueInfo && t4.valueInfo.length) for (n3.valueInfo = [], r3 = 0; r3 < t4.valueInfo.length; ++r3) n3.valueInfo[r3] = l2.onnx.ValueInfoProto.toObject(t4.valueInfo[r3], e3);
          if (t4.quantizationAnnotation && t4.quantizationAnnotation.length) for (n3.quantizationAnnotation = [], r3 = 0; r3 < t4.quantizationAnnotation.length; ++r3) n3.quantizationAnnotation[r3] = l2.onnx.TensorAnnotation.toObject(t4.quantizationAnnotation[r3], e3);
          return n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3;
      }(), o.TensorProto = function() {
        function t3(t4) {
          if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.dims = c2.emptyArray, t3.prototype.dataType = 0, t3.prototype.segment = null, t3.prototype.floatData = c2.emptyArray, t3.prototype.int32Data = c2.emptyArray, t3.prototype.stringData = c2.emptyArray, t3.prototype.int64Data = c2.emptyArray, t3.prototype.name = "", t3.prototype.docString = "", t3.prototype.rawData = c2.newBuffer([]), t3.prototype.externalData = c2.emptyArray, t3.prototype.dataLocation = 0, t3.prototype.doubleData = c2.emptyArray, t3.prototype.uint64Data = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.dims && t4.dims.length) {
            e3.uint32(10).fork();
            for (var n3 = 0; n3 < t4.dims.length; ++n3) e3.int64(t4.dims[n3]);
            e3.ldelim();
          }
          if (null != t4.dataType && t4.hasOwnProperty("dataType") && e3.uint32(16).int32(t4.dataType), null != t4.segment && t4.hasOwnProperty("segment") && l2.onnx.TensorProto.Segment.encode(t4.segment, e3.uint32(26).fork()).ldelim(), null != t4.floatData && t4.floatData.length) {
            for (e3.uint32(34).fork(), n3 = 0; n3 < t4.floatData.length; ++n3) e3.float(t4.floatData[n3]);
            e3.ldelim();
          }
          if (null != t4.int32Data && t4.int32Data.length) {
            for (e3.uint32(42).fork(), n3 = 0; n3 < t4.int32Data.length; ++n3) e3.int32(t4.int32Data[n3]);
            e3.ldelim();
          }
          if (null != t4.stringData && t4.stringData.length) for (n3 = 0; n3 < t4.stringData.length; ++n3) e3.uint32(50).bytes(t4.stringData[n3]);
          if (null != t4.int64Data && t4.int64Data.length) {
            for (e3.uint32(58).fork(), n3 = 0; n3 < t4.int64Data.length; ++n3) e3.int64(t4.int64Data[n3]);
            e3.ldelim();
          }
          if (null != t4.name && t4.hasOwnProperty("name") && e3.uint32(66).string(t4.name), null != t4.rawData && t4.hasOwnProperty("rawData") && e3.uint32(74).bytes(t4.rawData), null != t4.doubleData && t4.doubleData.length) {
            for (e3.uint32(82).fork(), n3 = 0; n3 < t4.doubleData.length; ++n3) e3.double(t4.doubleData[n3]);
            e3.ldelim();
          }
          if (null != t4.uint64Data && t4.uint64Data.length) {
            for (e3.uint32(90).fork(), n3 = 0; n3 < t4.uint64Data.length; ++n3) e3.uint64(t4.uint64Data[n3]);
            e3.ldelim();
          }
          if (null != t4.docString && t4.hasOwnProperty("docString") && e3.uint32(98).string(t4.docString), null != t4.externalData && t4.externalData.length) for (n3 = 0; n3 < t4.externalData.length; ++n3) l2.onnx.StringStringEntryProto.encode(t4.externalData[n3], e3.uint32(106).fork()).ldelim();
          return null != t4.dataLocation && t4.hasOwnProperty("dataLocation") && e3.uint32(112).int32(t4.dataLocation), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.TensorProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                if (r3.dims && r3.dims.length || (r3.dims = []), 2 == (7 & i2)) for (var o2 = t4.uint32() + t4.pos; t4.pos < o2; ) r3.dims.push(t4.int64());
                else r3.dims.push(t4.int64());
                break;
              case 2:
                r3.dataType = t4.int32();
                break;
              case 3:
                r3.segment = l2.onnx.TensorProto.Segment.decode(t4, t4.uint32());
                break;
              case 4:
                if (r3.floatData && r3.floatData.length || (r3.floatData = []), 2 == (7 & i2)) for (o2 = t4.uint32() + t4.pos; t4.pos < o2; ) r3.floatData.push(t4.float());
                else r3.floatData.push(t4.float());
                break;
              case 5:
                if (r3.int32Data && r3.int32Data.length || (r3.int32Data = []), 2 == (7 & i2)) for (o2 = t4.uint32() + t4.pos; t4.pos < o2; ) r3.int32Data.push(t4.int32());
                else r3.int32Data.push(t4.int32());
                break;
              case 6:
                r3.stringData && r3.stringData.length || (r3.stringData = []), r3.stringData.push(t4.bytes());
                break;
              case 7:
                if (r3.int64Data && r3.int64Data.length || (r3.int64Data = []), 2 == (7 & i2)) for (o2 = t4.uint32() + t4.pos; t4.pos < o2; ) r3.int64Data.push(t4.int64());
                else r3.int64Data.push(t4.int64());
                break;
              case 8:
                r3.name = t4.string();
                break;
              case 12:
                r3.docString = t4.string();
                break;
              case 9:
                r3.rawData = t4.bytes();
                break;
              case 13:
                r3.externalData && r3.externalData.length || (r3.externalData = []), r3.externalData.push(l2.onnx.StringStringEntryProto.decode(t4, t4.uint32()));
                break;
              case 14:
                r3.dataLocation = t4.int32();
                break;
              case 10:
                if (r3.doubleData && r3.doubleData.length || (r3.doubleData = []), 2 == (7 & i2)) for (o2 = t4.uint32() + t4.pos; t4.pos < o2; ) r3.doubleData.push(t4.double());
                else r3.doubleData.push(t4.double());
                break;
              case 11:
                if (r3.uint64Data && r3.uint64Data.length || (r3.uint64Data = []), 2 == (7 & i2)) for (o2 = t4.uint32() + t4.pos; t4.pos < o2; ) r3.uint64Data.push(t4.uint64());
                else r3.uint64Data.push(t4.uint64());
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.dims && t4.hasOwnProperty("dims")) {
            if (!Array.isArray(t4.dims)) return "dims: array expected";
            for (var e3 = 0; e3 < t4.dims.length; ++e3) if (!(c2.isInteger(t4.dims[e3]) || t4.dims[e3] && c2.isInteger(t4.dims[e3].low) && c2.isInteger(t4.dims[e3].high))) return "dims: integer|Long[] expected";
          }
          if (null != t4.dataType && t4.hasOwnProperty("dataType") && !c2.isInteger(t4.dataType)) return "dataType: integer expected";
          if (null != t4.segment && t4.hasOwnProperty("segment") && (n3 = l2.onnx.TensorProto.Segment.verify(t4.segment))) return "segment." + n3;
          if (null != t4.floatData && t4.hasOwnProperty("floatData")) {
            if (!Array.isArray(t4.floatData)) return "floatData: array expected";
            for (e3 = 0; e3 < t4.floatData.length; ++e3) if ("number" != typeof t4.floatData[e3]) return "floatData: number[] expected";
          }
          if (null != t4.int32Data && t4.hasOwnProperty("int32Data")) {
            if (!Array.isArray(t4.int32Data)) return "int32Data: array expected";
            for (e3 = 0; e3 < t4.int32Data.length; ++e3) if (!c2.isInteger(t4.int32Data[e3])) return "int32Data: integer[] expected";
          }
          if (null != t4.stringData && t4.hasOwnProperty("stringData")) {
            if (!Array.isArray(t4.stringData)) return "stringData: array expected";
            for (e3 = 0; e3 < t4.stringData.length; ++e3) if (!(t4.stringData[e3] && "number" == typeof t4.stringData[e3].length || c2.isString(t4.stringData[e3]))) return "stringData: buffer[] expected";
          }
          if (null != t4.int64Data && t4.hasOwnProperty("int64Data")) {
            if (!Array.isArray(t4.int64Data)) return "int64Data: array expected";
            for (e3 = 0; e3 < t4.int64Data.length; ++e3) if (!(c2.isInteger(t4.int64Data[e3]) || t4.int64Data[e3] && c2.isInteger(t4.int64Data[e3].low) && c2.isInteger(t4.int64Data[e3].high))) return "int64Data: integer|Long[] expected";
          }
          if (null != t4.name && t4.hasOwnProperty("name") && !c2.isString(t4.name)) return "name: string expected";
          if (null != t4.docString && t4.hasOwnProperty("docString") && !c2.isString(t4.docString)) return "docString: string expected";
          if (null != t4.rawData && t4.hasOwnProperty("rawData") && !(t4.rawData && "number" == typeof t4.rawData.length || c2.isString(t4.rawData))) return "rawData: buffer expected";
          if (null != t4.externalData && t4.hasOwnProperty("externalData")) {
            if (!Array.isArray(t4.externalData)) return "externalData: array expected";
            for (e3 = 0; e3 < t4.externalData.length; ++e3) {
              var n3;
              if (n3 = l2.onnx.StringStringEntryProto.verify(t4.externalData[e3])) return "externalData." + n3;
            }
          }
          if (null != t4.dataLocation && t4.hasOwnProperty("dataLocation")) switch (t4.dataLocation) {
            default:
              return "dataLocation: enum value expected";
            case 0:
            case 1:
          }
          if (null != t4.doubleData && t4.hasOwnProperty("doubleData")) {
            if (!Array.isArray(t4.doubleData)) return "doubleData: array expected";
            for (e3 = 0; e3 < t4.doubleData.length; ++e3) if ("number" != typeof t4.doubleData[e3]) return "doubleData: number[] expected";
          }
          if (null != t4.uint64Data && t4.hasOwnProperty("uint64Data")) {
            if (!Array.isArray(t4.uint64Data)) return "uint64Data: array expected";
            for (e3 = 0; e3 < t4.uint64Data.length; ++e3) if (!(c2.isInteger(t4.uint64Data[e3]) || t4.uint64Data[e3] && c2.isInteger(t4.uint64Data[e3].low) && c2.isInteger(t4.uint64Data[e3].high))) return "uint64Data: integer|Long[] expected";
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.TensorProto) return t4;
          var e3 = new l2.onnx.TensorProto();
          if (t4.dims) {
            if (!Array.isArray(t4.dims)) throw TypeError(".onnx.TensorProto.dims: array expected");
            e3.dims = [];
            for (var n3 = 0; n3 < t4.dims.length; ++n3) c2.Long ? (e3.dims[n3] = c2.Long.fromValue(t4.dims[n3])).unsigned = false : "string" == typeof t4.dims[n3] ? e3.dims[n3] = parseInt(t4.dims[n3], 10) : "number" == typeof t4.dims[n3] ? e3.dims[n3] = t4.dims[n3] : "object" == typeof t4.dims[n3] && (e3.dims[n3] = new c2.LongBits(t4.dims[n3].low >>> 0, t4.dims[n3].high >>> 0).toNumber());
          }
          if (null != t4.dataType && (e3.dataType = 0 | t4.dataType), null != t4.segment) {
            if ("object" != typeof t4.segment) throw TypeError(".onnx.TensorProto.segment: object expected");
            e3.segment = l2.onnx.TensorProto.Segment.fromObject(t4.segment);
          }
          if (t4.floatData) {
            if (!Array.isArray(t4.floatData)) throw TypeError(".onnx.TensorProto.floatData: array expected");
            for (e3.floatData = [], n3 = 0; n3 < t4.floatData.length; ++n3) e3.floatData[n3] = Number(t4.floatData[n3]);
          }
          if (t4.int32Data) {
            if (!Array.isArray(t4.int32Data)) throw TypeError(".onnx.TensorProto.int32Data: array expected");
            for (e3.int32Data = [], n3 = 0; n3 < t4.int32Data.length; ++n3) e3.int32Data[n3] = 0 | t4.int32Data[n3];
          }
          if (t4.stringData) {
            if (!Array.isArray(t4.stringData)) throw TypeError(".onnx.TensorProto.stringData: array expected");
            for (e3.stringData = [], n3 = 0; n3 < t4.stringData.length; ++n3) "string" == typeof t4.stringData[n3] ? c2.base64.decode(t4.stringData[n3], e3.stringData[n3] = c2.newBuffer(c2.base64.length(t4.stringData[n3])), 0) : t4.stringData[n3].length && (e3.stringData[n3] = t4.stringData[n3]);
          }
          if (t4.int64Data) {
            if (!Array.isArray(t4.int64Data)) throw TypeError(".onnx.TensorProto.int64Data: array expected");
            for (e3.int64Data = [], n3 = 0; n3 < t4.int64Data.length; ++n3) c2.Long ? (e3.int64Data[n3] = c2.Long.fromValue(t4.int64Data[n3])).unsigned = false : "string" == typeof t4.int64Data[n3] ? e3.int64Data[n3] = parseInt(t4.int64Data[n3], 10) : "number" == typeof t4.int64Data[n3] ? e3.int64Data[n3] = t4.int64Data[n3] : "object" == typeof t4.int64Data[n3] && (e3.int64Data[n3] = new c2.LongBits(t4.int64Data[n3].low >>> 0, t4.int64Data[n3].high >>> 0).toNumber());
          }
          if (null != t4.name && (e3.name = String(t4.name)), null != t4.docString && (e3.docString = String(t4.docString)), null != t4.rawData && ("string" == typeof t4.rawData ? c2.base64.decode(t4.rawData, e3.rawData = c2.newBuffer(c2.base64.length(t4.rawData)), 0) : t4.rawData.length && (e3.rawData = t4.rawData)), t4.externalData) {
            if (!Array.isArray(t4.externalData)) throw TypeError(".onnx.TensorProto.externalData: array expected");
            for (e3.externalData = [], n3 = 0; n3 < t4.externalData.length; ++n3) {
              if ("object" != typeof t4.externalData[n3]) throw TypeError(".onnx.TensorProto.externalData: object expected");
              e3.externalData[n3] = l2.onnx.StringStringEntryProto.fromObject(t4.externalData[n3]);
            }
          }
          switch (t4.dataLocation) {
            case "DEFAULT":
            case 0:
              e3.dataLocation = 0;
              break;
            case "EXTERNAL":
            case 1:
              e3.dataLocation = 1;
          }
          if (t4.doubleData) {
            if (!Array.isArray(t4.doubleData)) throw TypeError(".onnx.TensorProto.doubleData: array expected");
            for (e3.doubleData = [], n3 = 0; n3 < t4.doubleData.length; ++n3) e3.doubleData[n3] = Number(t4.doubleData[n3]);
          }
          if (t4.uint64Data) {
            if (!Array.isArray(t4.uint64Data)) throw TypeError(".onnx.TensorProto.uint64Data: array expected");
            for (e3.uint64Data = [], n3 = 0; n3 < t4.uint64Data.length; ++n3) c2.Long ? (e3.uint64Data[n3] = c2.Long.fromValue(t4.uint64Data[n3])).unsigned = true : "string" == typeof t4.uint64Data[n3] ? e3.uint64Data[n3] = parseInt(t4.uint64Data[n3], 10) : "number" == typeof t4.uint64Data[n3] ? e3.uint64Data[n3] = t4.uint64Data[n3] : "object" == typeof t4.uint64Data[n3] && (e3.uint64Data[n3] = new c2.LongBits(t4.uint64Data[n3].low >>> 0, t4.uint64Data[n3].high >>> 0).toNumber(true));
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.dims = [], n3.floatData = [], n3.int32Data = [], n3.stringData = [], n3.int64Data = [], n3.doubleData = [], n3.uint64Data = [], n3.externalData = []), e3.defaults && (n3.dataType = 0, n3.segment = null, n3.name = "", e3.bytes === String ? n3.rawData = "" : (n3.rawData = [], e3.bytes !== Array && (n3.rawData = c2.newBuffer(n3.rawData))), n3.docString = "", n3.dataLocation = e3.enums === String ? "DEFAULT" : 0), t4.dims && t4.dims.length) {
            n3.dims = [];
            for (var r3 = 0; r3 < t4.dims.length; ++r3) "number" == typeof t4.dims[r3] ? n3.dims[r3] = e3.longs === String ? String(t4.dims[r3]) : t4.dims[r3] : n3.dims[r3] = e3.longs === String ? c2.Long.prototype.toString.call(t4.dims[r3]) : e3.longs === Number ? new c2.LongBits(t4.dims[r3].low >>> 0, t4.dims[r3].high >>> 0).toNumber() : t4.dims[r3];
          }
          if (null != t4.dataType && t4.hasOwnProperty("dataType") && (n3.dataType = t4.dataType), null != t4.segment && t4.hasOwnProperty("segment") && (n3.segment = l2.onnx.TensorProto.Segment.toObject(t4.segment, e3)), t4.floatData && t4.floatData.length) for (n3.floatData = [], r3 = 0; r3 < t4.floatData.length; ++r3) n3.floatData[r3] = e3.json && !isFinite(t4.floatData[r3]) ? String(t4.floatData[r3]) : t4.floatData[r3];
          if (t4.int32Data && t4.int32Data.length) for (n3.int32Data = [], r3 = 0; r3 < t4.int32Data.length; ++r3) n3.int32Data[r3] = t4.int32Data[r3];
          if (t4.stringData && t4.stringData.length) for (n3.stringData = [], r3 = 0; r3 < t4.stringData.length; ++r3) n3.stringData[r3] = e3.bytes === String ? c2.base64.encode(t4.stringData[r3], 0, t4.stringData[r3].length) : e3.bytes === Array ? Array.prototype.slice.call(t4.stringData[r3]) : t4.stringData[r3];
          if (t4.int64Data && t4.int64Data.length) for (n3.int64Data = [], r3 = 0; r3 < t4.int64Data.length; ++r3) "number" == typeof t4.int64Data[r3] ? n3.int64Data[r3] = e3.longs === String ? String(t4.int64Data[r3]) : t4.int64Data[r3] : n3.int64Data[r3] = e3.longs === String ? c2.Long.prototype.toString.call(t4.int64Data[r3]) : e3.longs === Number ? new c2.LongBits(t4.int64Data[r3].low >>> 0, t4.int64Data[r3].high >>> 0).toNumber() : t4.int64Data[r3];
          if (null != t4.name && t4.hasOwnProperty("name") && (n3.name = t4.name), null != t4.rawData && t4.hasOwnProperty("rawData") && (n3.rawData = e3.bytes === String ? c2.base64.encode(t4.rawData, 0, t4.rawData.length) : e3.bytes === Array ? Array.prototype.slice.call(t4.rawData) : t4.rawData), t4.doubleData && t4.doubleData.length) for (n3.doubleData = [], r3 = 0; r3 < t4.doubleData.length; ++r3) n3.doubleData[r3] = e3.json && !isFinite(t4.doubleData[r3]) ? String(t4.doubleData[r3]) : t4.doubleData[r3];
          if (t4.uint64Data && t4.uint64Data.length) for (n3.uint64Data = [], r3 = 0; r3 < t4.uint64Data.length; ++r3) "number" == typeof t4.uint64Data[r3] ? n3.uint64Data[r3] = e3.longs === String ? String(t4.uint64Data[r3]) : t4.uint64Data[r3] : n3.uint64Data[r3] = e3.longs === String ? c2.Long.prototype.toString.call(t4.uint64Data[r3]) : e3.longs === Number ? new c2.LongBits(t4.uint64Data[r3].low >>> 0, t4.uint64Data[r3].high >>> 0).toNumber(true) : t4.uint64Data[r3];
          if (null != t4.docString && t4.hasOwnProperty("docString") && (n3.docString = t4.docString), t4.externalData && t4.externalData.length) for (n3.externalData = [], r3 = 0; r3 < t4.externalData.length; ++r3) n3.externalData[r3] = l2.onnx.StringStringEntryProto.toObject(t4.externalData[r3], e3);
          return null != t4.dataLocation && t4.hasOwnProperty("dataLocation") && (n3.dataLocation = e3.enums === String ? l2.onnx.TensorProto.DataLocation[t4.dataLocation] : t4.dataLocation), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3.DataType = function() {
          var t4 = {}, e3 = Object.create(t4);
          return e3[t4[0] = "UNDEFINED"] = 0, e3[t4[1] = "FLOAT"] = 1, e3[t4[2] = "UINT8"] = 2, e3[t4[3] = "INT8"] = 3, e3[t4[4] = "UINT16"] = 4, e3[t4[5] = "INT16"] = 5, e3[t4[6] = "INT32"] = 6, e3[t4[7] = "INT64"] = 7, e3[t4[8] = "STRING"] = 8, e3[t4[9] = "BOOL"] = 9, e3[t4[10] = "FLOAT16"] = 10, e3[t4[11] = "DOUBLE"] = 11, e3[t4[12] = "UINT32"] = 12, e3[t4[13] = "UINT64"] = 13, e3[t4[14] = "COMPLEX64"] = 14, e3[t4[15] = "COMPLEX128"] = 15, e3[t4[16] = "BFLOAT16"] = 16, e3;
        }(), t3.Segment = function() {
          function t4(t5) {
            if (t5) for (var e3 = Object.keys(t5), n3 = 0; n3 < e3.length; ++n3) null != t5[e3[n3]] && (this[e3[n3]] = t5[e3[n3]]);
          }
          return t4.prototype.begin = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t4.prototype.end = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t4.create = function(e3) {
            return new t4(e3);
          }, t4.encode = function(t5, e3) {
            return e3 || (e3 = u2.create()), null != t5.begin && t5.hasOwnProperty("begin") && e3.uint32(8).int64(t5.begin), null != t5.end && t5.hasOwnProperty("end") && e3.uint32(16).int64(t5.end), e3;
          }, t4.encodeDelimited = function(t5, e3) {
            return this.encode(t5, e3).ldelim();
          }, t4.decode = function(t5, e3) {
            t5 instanceof s || (t5 = s.create(t5));
            for (var n3 = void 0 === e3 ? t5.len : t5.pos + e3, r3 = new l2.onnx.TensorProto.Segment(); t5.pos < n3; ) {
              var i2 = t5.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r3.begin = t5.int64();
                  break;
                case 2:
                  r3.end = t5.int64();
                  break;
                default:
                  t5.skipType(7 & i2);
              }
            }
            return r3;
          }, t4.decodeDelimited = function(t5) {
            return t5 instanceof s || (t5 = new s(t5)), this.decode(t5, t5.uint32());
          }, t4.verify = function(t5) {
            return "object" != typeof t5 || null === t5 ? "object expected" : null != t5.begin && t5.hasOwnProperty("begin") && !(c2.isInteger(t5.begin) || t5.begin && c2.isInteger(t5.begin.low) && c2.isInteger(t5.begin.high)) ? "begin: integer|Long expected" : null != t5.end && t5.hasOwnProperty("end") && !(c2.isInteger(t5.end) || t5.end && c2.isInteger(t5.end.low) && c2.isInteger(t5.end.high)) ? "end: integer|Long expected" : null;
          }, t4.fromObject = function(t5) {
            if (t5 instanceof l2.onnx.TensorProto.Segment) return t5;
            var e3 = new l2.onnx.TensorProto.Segment();
            return null != t5.begin && (c2.Long ? (e3.begin = c2.Long.fromValue(t5.begin)).unsigned = false : "string" == typeof t5.begin ? e3.begin = parseInt(t5.begin, 10) : "number" == typeof t5.begin ? e3.begin = t5.begin : "object" == typeof t5.begin && (e3.begin = new c2.LongBits(t5.begin.low >>> 0, t5.begin.high >>> 0).toNumber())), null != t5.end && (c2.Long ? (e3.end = c2.Long.fromValue(t5.end)).unsigned = false : "string" == typeof t5.end ? e3.end = parseInt(t5.end, 10) : "number" == typeof t5.end ? e3.end = t5.end : "object" == typeof t5.end && (e3.end = new c2.LongBits(t5.end.low >>> 0, t5.end.high >>> 0).toNumber())), e3;
          }, t4.toObject = function(t5, e3) {
            e3 || (e3 = {});
            var n3 = {};
            if (e3.defaults) {
              if (c2.Long) {
                var r3 = new c2.Long(0, 0, false);
                n3.begin = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3;
              } else n3.begin = e3.longs === String ? "0" : 0;
              c2.Long ? (r3 = new c2.Long(0, 0, false), n3.end = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3) : n3.end = e3.longs === String ? "0" : 0;
            }
            return null != t5.begin && t5.hasOwnProperty("begin") && ("number" == typeof t5.begin ? n3.begin = e3.longs === String ? String(t5.begin) : t5.begin : n3.begin = e3.longs === String ? c2.Long.prototype.toString.call(t5.begin) : e3.longs === Number ? new c2.LongBits(t5.begin.low >>> 0, t5.begin.high >>> 0).toNumber() : t5.begin), null != t5.end && t5.hasOwnProperty("end") && ("number" == typeof t5.end ? n3.end = e3.longs === String ? String(t5.end) : t5.end : n3.end = e3.longs === String ? c2.Long.prototype.toString.call(t5.end) : e3.longs === Number ? new c2.LongBits(t5.end.low >>> 0, t5.end.high >>> 0).toNumber() : t5.end), n3;
          }, t4.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, t4;
        }(), t3.DataLocation = function() {
          var t4 = {}, e3 = Object.create(t4);
          return e3[t4[0] = "DEFAULT"] = 0, e3[t4[1] = "EXTERNAL"] = 1, e3;
        }(), t3;
      }(), o.TensorShapeProto = function() {
        function t3(t4) {
          if (this.dim = [], t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.dim = c2.emptyArray, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          if (e3 || (e3 = u2.create()), null != t4.dim && t4.dim.length) for (var n3 = 0; n3 < t4.dim.length; ++n3) l2.onnx.TensorShapeProto.Dimension.encode(t4.dim[n3], e3.uint32(10).fork()).ldelim();
          return e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.TensorShapeProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            i2 >>> 3 == 1 ? (r3.dim && r3.dim.length || (r3.dim = []), r3.dim.push(l2.onnx.TensorShapeProto.Dimension.decode(t4, t4.uint32()))) : t4.skipType(7 & i2);
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.dim && t4.hasOwnProperty("dim")) {
            if (!Array.isArray(t4.dim)) return "dim: array expected";
            for (var e3 = 0; e3 < t4.dim.length; ++e3) {
              var n3 = l2.onnx.TensorShapeProto.Dimension.verify(t4.dim[e3]);
              if (n3) return "dim." + n3;
            }
          }
          return null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.TensorShapeProto) return t4;
          var e3 = new l2.onnx.TensorShapeProto();
          if (t4.dim) {
            if (!Array.isArray(t4.dim)) throw TypeError(".onnx.TensorShapeProto.dim: array expected");
            e3.dim = [];
            for (var n3 = 0; n3 < t4.dim.length; ++n3) {
              if ("object" != typeof t4.dim[n3]) throw TypeError(".onnx.TensorShapeProto.dim: object expected");
              e3.dim[n3] = l2.onnx.TensorShapeProto.Dimension.fromObject(t4.dim[n3]);
            }
          }
          return e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if ((e3.arrays || e3.defaults) && (n3.dim = []), t4.dim && t4.dim.length) {
            n3.dim = [];
            for (var r3 = 0; r3 < t4.dim.length; ++r3) n3.dim[r3] = l2.onnx.TensorShapeProto.Dimension.toObject(t4.dim[r3], e3);
          }
          return n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3.Dimension = function() {
          function t4(t5) {
            if (t5) for (var e4 = Object.keys(t5), n3 = 0; n3 < e4.length; ++n3) null != t5[e4[n3]] && (this[e4[n3]] = t5[e4[n3]]);
          }
          var e3;
          return t4.prototype.dimValue = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t4.prototype.dimParam = "", t4.prototype.denotation = "", Object.defineProperty(t4.prototype, "value", { get: c2.oneOfGetter(e3 = ["dimValue", "dimParam"]), set: c2.oneOfSetter(e3) }), t4.create = function(e4) {
            return new t4(e4);
          }, t4.encode = function(t5, e4) {
            return e4 || (e4 = u2.create()), null != t5.dimValue && t5.hasOwnProperty("dimValue") && e4.uint32(8).int64(t5.dimValue), null != t5.dimParam && t5.hasOwnProperty("dimParam") && e4.uint32(18).string(t5.dimParam), null != t5.denotation && t5.hasOwnProperty("denotation") && e4.uint32(26).string(t5.denotation), e4;
          }, t4.encodeDelimited = function(t5, e4) {
            return this.encode(t5, e4).ldelim();
          }, t4.decode = function(t5, e4) {
            t5 instanceof s || (t5 = s.create(t5));
            for (var n3 = void 0 === e4 ? t5.len : t5.pos + e4, r3 = new l2.onnx.TensorShapeProto.Dimension(); t5.pos < n3; ) {
              var i2 = t5.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r3.dimValue = t5.int64();
                  break;
                case 2:
                  r3.dimParam = t5.string();
                  break;
                case 3:
                  r3.denotation = t5.string();
                  break;
                default:
                  t5.skipType(7 & i2);
              }
            }
            return r3;
          }, t4.decodeDelimited = function(t5) {
            return t5 instanceof s || (t5 = new s(t5)), this.decode(t5, t5.uint32());
          }, t4.verify = function(t5) {
            if ("object" != typeof t5 || null === t5) return "object expected";
            var e4 = {};
            if (null != t5.dimValue && t5.hasOwnProperty("dimValue") && (e4.value = 1, !(c2.isInteger(t5.dimValue) || t5.dimValue && c2.isInteger(t5.dimValue.low) && c2.isInteger(t5.dimValue.high)))) return "dimValue: integer|Long expected";
            if (null != t5.dimParam && t5.hasOwnProperty("dimParam")) {
              if (1 === e4.value) return "value: multiple values";
              if (e4.value = 1, !c2.isString(t5.dimParam)) return "dimParam: string expected";
            }
            return null != t5.denotation && t5.hasOwnProperty("denotation") && !c2.isString(t5.denotation) ? "denotation: string expected" : null;
          }, t4.fromObject = function(t5) {
            if (t5 instanceof l2.onnx.TensorShapeProto.Dimension) return t5;
            var e4 = new l2.onnx.TensorShapeProto.Dimension();
            return null != t5.dimValue && (c2.Long ? (e4.dimValue = c2.Long.fromValue(t5.dimValue)).unsigned = false : "string" == typeof t5.dimValue ? e4.dimValue = parseInt(t5.dimValue, 10) : "number" == typeof t5.dimValue ? e4.dimValue = t5.dimValue : "object" == typeof t5.dimValue && (e4.dimValue = new c2.LongBits(t5.dimValue.low >>> 0, t5.dimValue.high >>> 0).toNumber())), null != t5.dimParam && (e4.dimParam = String(t5.dimParam)), null != t5.denotation && (e4.denotation = String(t5.denotation)), e4;
          }, t4.toObject = function(t5, e4) {
            e4 || (e4 = {});
            var n3 = {};
            return e4.defaults && (n3.denotation = ""), null != t5.dimValue && t5.hasOwnProperty("dimValue") && ("number" == typeof t5.dimValue ? n3.dimValue = e4.longs === String ? String(t5.dimValue) : t5.dimValue : n3.dimValue = e4.longs === String ? c2.Long.prototype.toString.call(t5.dimValue) : e4.longs === Number ? new c2.LongBits(t5.dimValue.low >>> 0, t5.dimValue.high >>> 0).toNumber() : t5.dimValue, e4.oneofs && (n3.value = "dimValue")), null != t5.dimParam && t5.hasOwnProperty("dimParam") && (n3.dimParam = t5.dimParam, e4.oneofs && (n3.value = "dimParam")), null != t5.denotation && t5.hasOwnProperty("denotation") && (n3.denotation = t5.denotation), n3;
          }, t4.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, t4;
        }(), t3;
      }(), o.TypeProto = function() {
        function t3(t4) {
          if (t4) for (var e4 = Object.keys(t4), n3 = 0; n3 < e4.length; ++n3) null != t4[e4[n3]] && (this[e4[n3]] = t4[e4[n3]]);
        }
        var e3;
        return t3.prototype.tensorType = null, t3.prototype.denotation = "", Object.defineProperty(t3.prototype, "value", { get: c2.oneOfGetter(e3 = ["tensorType"]), set: c2.oneOfSetter(e3) }), t3.create = function(e4) {
          return new t3(e4);
        }, t3.encode = function(t4, e4) {
          return e4 || (e4 = u2.create()), null != t4.tensorType && t4.hasOwnProperty("tensorType") && l2.onnx.TypeProto.Tensor.encode(t4.tensorType, e4.uint32(10).fork()).ldelim(), null != t4.denotation && t4.hasOwnProperty("denotation") && e4.uint32(50).string(t4.denotation), e4;
        }, t3.encodeDelimited = function(t4, e4) {
          return this.encode(t4, e4).ldelim();
        }, t3.decode = function(t4, e4) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e4 ? t4.len : t4.pos + e4, r3 = new l2.onnx.TypeProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.tensorType = l2.onnx.TypeProto.Tensor.decode(t4, t4.uint32());
                break;
              case 6:
                r3.denotation = t4.string();
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          if ("object" != typeof t4 || null === t4) return "object expected";
          if (null != t4.tensorType && t4.hasOwnProperty("tensorType")) {
            var e4 = l2.onnx.TypeProto.Tensor.verify(t4.tensorType);
            if (e4) return "tensorType." + e4;
          }
          return null != t4.denotation && t4.hasOwnProperty("denotation") && !c2.isString(t4.denotation) ? "denotation: string expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.TypeProto) return t4;
          var e4 = new l2.onnx.TypeProto();
          if (null != t4.tensorType) {
            if ("object" != typeof t4.tensorType) throw TypeError(".onnx.TypeProto.tensorType: object expected");
            e4.tensorType = l2.onnx.TypeProto.Tensor.fromObject(t4.tensorType);
          }
          return null != t4.denotation && (e4.denotation = String(t4.denotation)), e4;
        }, t3.toObject = function(t4, e4) {
          e4 || (e4 = {});
          var n3 = {};
          return e4.defaults && (n3.denotation = ""), null != t4.tensorType && t4.hasOwnProperty("tensorType") && (n3.tensorType = l2.onnx.TypeProto.Tensor.toObject(t4.tensorType, e4), e4.oneofs && (n3.value = "tensorType")), null != t4.denotation && t4.hasOwnProperty("denotation") && (n3.denotation = t4.denotation), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3.Tensor = function() {
          function t4(t5) {
            if (t5) for (var e4 = Object.keys(t5), n3 = 0; n3 < e4.length; ++n3) null != t5[e4[n3]] && (this[e4[n3]] = t5[e4[n3]]);
          }
          return t4.prototype.elemType = 0, t4.prototype.shape = null, t4.create = function(e4) {
            return new t4(e4);
          }, t4.encode = function(t5, e4) {
            return e4 || (e4 = u2.create()), null != t5.elemType && t5.hasOwnProperty("elemType") && e4.uint32(8).int32(t5.elemType), null != t5.shape && t5.hasOwnProperty("shape") && l2.onnx.TensorShapeProto.encode(t5.shape, e4.uint32(18).fork()).ldelim(), e4;
          }, t4.encodeDelimited = function(t5, e4) {
            return this.encode(t5, e4).ldelim();
          }, t4.decode = function(t5, e4) {
            t5 instanceof s || (t5 = s.create(t5));
            for (var n3 = void 0 === e4 ? t5.len : t5.pos + e4, r3 = new l2.onnx.TypeProto.Tensor(); t5.pos < n3; ) {
              var i2 = t5.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r3.elemType = t5.int32();
                  break;
                case 2:
                  r3.shape = l2.onnx.TensorShapeProto.decode(t5, t5.uint32());
                  break;
                default:
                  t5.skipType(7 & i2);
              }
            }
            return r3;
          }, t4.decodeDelimited = function(t5) {
            return t5 instanceof s || (t5 = new s(t5)), this.decode(t5, t5.uint32());
          }, t4.verify = function(t5) {
            if ("object" != typeof t5 || null === t5) return "object expected";
            if (null != t5.elemType && t5.hasOwnProperty("elemType") && !c2.isInteger(t5.elemType)) return "elemType: integer expected";
            if (null != t5.shape && t5.hasOwnProperty("shape")) {
              var e4 = l2.onnx.TensorShapeProto.verify(t5.shape);
              if (e4) return "shape." + e4;
            }
            return null;
          }, t4.fromObject = function(t5) {
            if (t5 instanceof l2.onnx.TypeProto.Tensor) return t5;
            var e4 = new l2.onnx.TypeProto.Tensor();
            if (null != t5.elemType && (e4.elemType = 0 | t5.elemType), null != t5.shape) {
              if ("object" != typeof t5.shape) throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
              e4.shape = l2.onnx.TensorShapeProto.fromObject(t5.shape);
            }
            return e4;
          }, t4.toObject = function(t5, e4) {
            e4 || (e4 = {});
            var n3 = {};
            return e4.defaults && (n3.elemType = 0, n3.shape = null), null != t5.elemType && t5.hasOwnProperty("elemType") && (n3.elemType = t5.elemType), null != t5.shape && t5.hasOwnProperty("shape") && (n3.shape = l2.onnx.TensorShapeProto.toObject(t5.shape, e4)), n3;
          }, t4.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, t4;
        }(), t3;
      }(), o.OperatorSetIdProto = function() {
        function t3(t4) {
          if (t4) for (var e3 = Object.keys(t4), n3 = 0; n3 < e3.length; ++n3) null != t4[e3[n3]] && (this[e3[n3]] = t4[e3[n3]]);
        }
        return t3.prototype.domain = "", t3.prototype.version = c2.Long ? c2.Long.fromBits(0, 0, false) : 0, t3.create = function(e3) {
          return new t3(e3);
        }, t3.encode = function(t4, e3) {
          return e3 || (e3 = u2.create()), null != t4.domain && t4.hasOwnProperty("domain") && e3.uint32(10).string(t4.domain), null != t4.version && t4.hasOwnProperty("version") && e3.uint32(16).int64(t4.version), e3;
        }, t3.encodeDelimited = function(t4, e3) {
          return this.encode(t4, e3).ldelim();
        }, t3.decode = function(t4, e3) {
          t4 instanceof s || (t4 = s.create(t4));
          for (var n3 = void 0 === e3 ? t4.len : t4.pos + e3, r3 = new l2.onnx.OperatorSetIdProto(); t4.pos < n3; ) {
            var i2 = t4.uint32();
            switch (i2 >>> 3) {
              case 1:
                r3.domain = t4.string();
                break;
              case 2:
                r3.version = t4.int64();
                break;
              default:
                t4.skipType(7 & i2);
            }
          }
          return r3;
        }, t3.decodeDelimited = function(t4) {
          return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
        }, t3.verify = function(t4) {
          return "object" != typeof t4 || null === t4 ? "object expected" : null != t4.domain && t4.hasOwnProperty("domain") && !c2.isString(t4.domain) ? "domain: string expected" : null != t4.version && t4.hasOwnProperty("version") && !(c2.isInteger(t4.version) || t4.version && c2.isInteger(t4.version.low) && c2.isInteger(t4.version.high)) ? "version: integer|Long expected" : null;
        }, t3.fromObject = function(t4) {
          if (t4 instanceof l2.onnx.OperatorSetIdProto) return t4;
          var e3 = new l2.onnx.OperatorSetIdProto();
          return null != t4.domain && (e3.domain = String(t4.domain)), null != t4.version && (c2.Long ? (e3.version = c2.Long.fromValue(t4.version)).unsigned = false : "string" == typeof t4.version ? e3.version = parseInt(t4.version, 10) : "number" == typeof t4.version ? e3.version = t4.version : "object" == typeof t4.version && (e3.version = new c2.LongBits(t4.version.low >>> 0, t4.version.high >>> 0).toNumber())), e3;
        }, t3.toObject = function(t4, e3) {
          e3 || (e3 = {});
          var n3 = {};
          if (e3.defaults) if (n3.domain = "", c2.Long) {
            var r3 = new c2.Long(0, 0, false);
            n3.version = e3.longs === String ? r3.toString() : e3.longs === Number ? r3.toNumber() : r3;
          } else n3.version = e3.longs === String ? "0" : 0;
          return null != t4.domain && t4.hasOwnProperty("domain") && (n3.domain = t4.domain), null != t4.version && t4.hasOwnProperty("version") && ("number" == typeof t4.version ? n3.version = e3.longs === String ? String(t4.version) : t4.version : n3.version = e3.longs === String ? c2.Long.prototype.toString.call(t4.version) : e3.longs === Number ? new c2.LongBits(t4.version.low >>> 0, t4.version.high >>> 0).toNumber() : t4.version), n3;
        }, t3.prototype.toJSON = function() {
          return this.constructor.toObject(this, a.util.toJSONOptions);
        }, t3;
      }(), o), t2.exports = l2;
    }, 2100: (t2, e2, n2) => {
      t2.exports = n2(9482);
    }, 9482: (t2, e2, n2) => {
      var r2 = e2;
      function i() {
        r2.util._configure(), r2.Writer._configure(r2.BufferWriter), r2.Reader._configure(r2.BufferReader);
      }
      r2.build = "minimal", r2.Writer = n2(1173), r2.BufferWriter = n2(3155), r2.Reader = n2(1408), r2.BufferReader = n2(593), r2.util = n2(9693), r2.rpc = n2(5994), r2.roots = n2(5054), r2.configure = i, i();
    }, 1408: (t2, e2, n2) => {
      t2.exports = u2;
      var r2, i = n2(9693), o = i.LongBits, a = i.utf8;
      function s(t3, e3) {
        return RangeError("index out of range: " + t3.pos + " + " + (e3 || 1) + " > " + t3.len);
      }
      function u2(t3) {
        this.buf = t3, this.pos = 0, this.len = t3.length;
      }
      var c2, l2 = "undefined" != typeof Uint8Array ? function(t3) {
        if (t3 instanceof Uint8Array || Array.isArray(t3)) return new u2(t3);
        throw Error("illegal buffer");
      } : function(t3) {
        if (Array.isArray(t3)) return new u2(t3);
        throw Error("illegal buffer");
      }, p2 = function() {
        return i.Buffer ? function(t3) {
          return (u2.create = function(t4) {
            return i.Buffer.isBuffer(t4) ? new r2(t4) : l2(t4);
          })(t3);
        } : l2;
      };
      function f2() {
        var t3 = new o(0, 0), e3 = 0;
        if (!(this.len - this.pos > 4)) {
          for (; e3 < 3; ++e3) {
            if (this.pos >= this.len) throw s(this);
            if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 7 * e3) >>> 0, this.buf[this.pos++] < 128) return t3;
          }
          return t3.lo = (t3.lo | (127 & this.buf[this.pos++]) << 7 * e3) >>> 0, t3;
        }
        for (; e3 < 4; ++e3) if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 7 * e3) >>> 0, this.buf[this.pos++] < 128) return t3;
        if (t3.lo = (t3.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t3.hi = (t3.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return t3;
        if (e3 = 0, this.len - this.pos > 4) {
          for (; e3 < 5; ++e3) if (t3.hi = (t3.hi | (127 & this.buf[this.pos]) << 7 * e3 + 3) >>> 0, this.buf[this.pos++] < 128) return t3;
        } else for (; e3 < 5; ++e3) {
          if (this.pos >= this.len) throw s(this);
          if (t3.hi = (t3.hi | (127 & this.buf[this.pos]) << 7 * e3 + 3) >>> 0, this.buf[this.pos++] < 128) return t3;
        }
        throw Error("invalid varint encoding");
      }
      function d2(t3, e3) {
        return (t3[e3 - 4] | t3[e3 - 3] << 8 | t3[e3 - 2] << 16 | t3[e3 - 1] << 24) >>> 0;
      }
      function h2() {
        if (this.pos + 8 > this.len) throw s(this, 8);
        return new o(d2(this.buf, this.pos += 4), d2(this.buf, this.pos += 4));
      }
      u2.create = p2(), u2.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, u2.prototype.uint32 = (c2 = 4294967295, function() {
        if (c2 = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return c2;
        if (c2 = (c2 | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return c2;
        if (c2 = (c2 | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return c2;
        if (c2 = (c2 | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return c2;
        if (c2 = (c2 | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return c2;
        if ((this.pos += 5) > this.len) throw this.pos = this.len, s(this, 10);
        return c2;
      }), u2.prototype.int32 = function() {
        return 0 | this.uint32();
      }, u2.prototype.sint32 = function() {
        var t3 = this.uint32();
        return t3 >>> 1 ^ -(1 & t3) | 0;
      }, u2.prototype.bool = function() {
        return 0 !== this.uint32();
      }, u2.prototype.fixed32 = function() {
        if (this.pos + 4 > this.len) throw s(this, 4);
        return d2(this.buf, this.pos += 4);
      }, u2.prototype.sfixed32 = function() {
        if (this.pos + 4 > this.len) throw s(this, 4);
        return 0 | d2(this.buf, this.pos += 4);
      }, u2.prototype.float = function() {
        if (this.pos + 4 > this.len) throw s(this, 4);
        var t3 = i.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4, t3;
      }, u2.prototype.double = function() {
        if (this.pos + 8 > this.len) throw s(this, 4);
        var t3 = i.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8, t3;
      }, u2.prototype.bytes = function() {
        var t3 = this.uint32(), e3 = this.pos, n3 = this.pos + t3;
        if (n3 > this.len) throw s(this, t3);
        return this.pos += t3, Array.isArray(this.buf) ? this.buf.slice(e3, n3) : e3 === n3 ? new this.buf.constructor(0) : this._slice.call(this.buf, e3, n3);
      }, u2.prototype.string = function() {
        var t3 = this.bytes();
        return a.read(t3, 0, t3.length);
      }, u2.prototype.skip = function(t3) {
        if ("number" == typeof t3) {
          if (this.pos + t3 > this.len) throw s(this, t3);
          this.pos += t3;
        } else do {
          if (this.pos >= this.len) throw s(this);
        } while (128 & this.buf[this.pos++]);
        return this;
      }, u2.prototype.skipType = function(t3) {
        switch (t3) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            for (; 4 != (t3 = 7 & this.uint32()); ) this.skipType(t3);
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + t3 + " at offset " + this.pos);
        }
        return this;
      }, u2._configure = function(t3) {
        r2 = t3, u2.create = p2(), r2._configure();
        var e3 = i.Long ? "toLong" : "toNumber";
        i.merge(u2.prototype, { int64: function() {
          return f2.call(this)[e3](false);
        }, uint64: function() {
          return f2.call(this)[e3](true);
        }, sint64: function() {
          return f2.call(this).zzDecode()[e3](false);
        }, fixed64: function() {
          return h2.call(this)[e3](true);
        }, sfixed64: function() {
          return h2.call(this)[e3](false);
        } });
      };
    }, 593: (t2, e2, n2) => {
      t2.exports = o;
      var r2 = n2(1408);
      (o.prototype = Object.create(r2.prototype)).constructor = o;
      var i = n2(9693);
      function o(t3) {
        r2.call(this, t3);
      }
      o._configure = function() {
        i.Buffer && (o.prototype._slice = i.Buffer.prototype.slice);
      }, o.prototype.string = function() {
        var t3 = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t3, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t3, this.len));
      }, o._configure();
    }, 5054: (t2) => {
      t2.exports = {};
    }, 5994: (t2, e2, n2) => {
      e2.Service = n2(7948);
    }, 7948: (t2, e2, n2) => {
      t2.exports = i;
      var r2 = n2(9693);
      function i(t3, e3, n3) {
        if ("function" != typeof t3) throw TypeError("rpcImpl must be a function");
        r2.EventEmitter.call(this), this.rpcImpl = t3, this.requestDelimited = Boolean(e3), this.responseDelimited = Boolean(n3);
      }
      (i.prototype = Object.create(r2.EventEmitter.prototype)).constructor = i, i.prototype.rpcCall = function t3(e3, n3, i2, o, a) {
        if (!o) throw TypeError("request must be specified");
        var s = this;
        if (!a) return r2.asPromise(t3, s, e3, n3, i2, o);
        if (s.rpcImpl) try {
          return s.rpcImpl(e3, n3[s.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function(t4, n4) {
            if (t4) return s.emit("error", t4, e3), a(t4);
            if (null !== n4) {
              if (!(n4 instanceof i2)) try {
                n4 = i2[s.responseDelimited ? "decodeDelimited" : "decode"](n4);
              } catch (t5) {
                return s.emit("error", t5, e3), a(t5);
              }
              return s.emit("data", n4, e3), a(null, n4);
            }
            s.end(true);
          });
        } catch (t4) {
          return s.emit("error", t4, e3), void setTimeout(function() {
            a(t4);
          }, 0);
        }
        else setTimeout(function() {
          a(Error("already ended"));
        }, 0);
      }, i.prototype.end = function(t3) {
        return this.rpcImpl && (t3 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
      };
    }, 1945: (t2, e2, n2) => {
      t2.exports = i;
      var r2 = n2(9693);
      function i(t3, e3) {
        this.lo = t3 >>> 0, this.hi = e3 >>> 0;
      }
      var o = i.zero = new i(0, 0);
      o.toNumber = function() {
        return 0;
      }, o.zzEncode = o.zzDecode = function() {
        return this;
      }, o.length = function() {
        return 1;
      };
      var a = i.zeroHash = "\0\0\0\0\0\0\0\0";
      i.fromNumber = function(t3) {
        if (0 === t3) return o;
        var e3 = t3 < 0;
        e3 && (t3 = -t3);
        var n3 = t3 >>> 0, r3 = (t3 - n3) / 4294967296 >>> 0;
        return e3 && (r3 = ~r3 >>> 0, n3 = ~n3 >>> 0, ++n3 > 4294967295 && (n3 = 0, ++r3 > 4294967295 && (r3 = 0))), new i(n3, r3);
      }, i.from = function(t3) {
        if ("number" == typeof t3) return i.fromNumber(t3);
        if (r2.isString(t3)) {
          if (!r2.Long) return i.fromNumber(parseInt(t3, 10));
          t3 = r2.Long.fromString(t3);
        }
        return t3.low || t3.high ? new i(t3.low >>> 0, t3.high >>> 0) : o;
      }, i.prototype.toNumber = function(t3) {
        if (!t3 && this.hi >>> 31) {
          var e3 = 1 + ~this.lo >>> 0, n3 = ~this.hi >>> 0;
          return e3 || (n3 = n3 + 1 >>> 0), -(e3 + 4294967296 * n3);
        }
        return this.lo + 4294967296 * this.hi;
      }, i.prototype.toLong = function(t3) {
        return r2.Long ? new r2.Long(0 | this.lo, 0 | this.hi, Boolean(t3)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(t3) };
      };
      var s = String.prototype.charCodeAt;
      i.fromHash = function(t3) {
        return t3 === a ? o : new i((s.call(t3, 0) | s.call(t3, 1) << 8 | s.call(t3, 2) << 16 | s.call(t3, 3) << 24) >>> 0, (s.call(t3, 4) | s.call(t3, 5) << 8 | s.call(t3, 6) << 16 | s.call(t3, 7) << 24) >>> 0);
      }, i.prototype.toHash = function() {
        return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
      }, i.prototype.zzEncode = function() {
        var t3 = this.hi >> 31;
        return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t3) >>> 0, this.lo = (this.lo << 1 ^ t3) >>> 0, this;
      }, i.prototype.zzDecode = function() {
        var t3 = -(1 & this.lo);
        return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t3) >>> 0, this.hi = (this.hi >>> 1 ^ t3) >>> 0, this;
      }, i.prototype.length = function() {
        var t3 = this.lo, e3 = (this.lo >>> 28 | this.hi << 4) >>> 0, n3 = this.hi >>> 24;
        return 0 === n3 ? 0 === e3 ? t3 < 16384 ? t3 < 128 ? 1 : 2 : t3 < 2097152 ? 3 : 4 : e3 < 16384 ? e3 < 128 ? 5 : 6 : e3 < 2097152 ? 7 : 8 : n3 < 128 ? 9 : 10;
      };
    }, 9693: function(t2, e2, n2) {
      var r2 = e2;
      function i(t3, e3, n3) {
        for (var r3 = Object.keys(e3), i2 = 0; i2 < r3.length; ++i2) void 0 !== t3[r3[i2]] && n3 || (t3[r3[i2]] = e3[r3[i2]]);
        return t3;
      }
      function o(t3) {
        function e3(t4, n3) {
          if (!(this instanceof e3)) return new e3(t4, n3);
          Object.defineProperty(this, "message", { get: function() {
            return t4;
          } }), Error.captureStackTrace ? Error.captureStackTrace(this, e3) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n3 && i(this, n3);
        }
        return (e3.prototype = Object.create(Error.prototype)).constructor = e3, Object.defineProperty(e3.prototype, "name", { get: function() {
          return t3;
        } }), e3.prototype.toString = function() {
          return this.name + ": " + this.message;
        }, e3;
      }
      r2.asPromise = n2(4537), r2.base64 = n2(7419), r2.EventEmitter = n2(9211), r2.float = n2(945), r2.inquire = n2(7199), r2.utf8 = n2(4997), r2.pool = n2(6662), r2.LongBits = n2(1945), r2.isNode = Boolean(void 0 !== n2.g && n2.g && n2.g.process && n2.g.process.versions && n2.g.process.versions.node), r2.global = r2.isNode && n2.g || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r2.emptyArray = Object.freeze ? Object.freeze([]) : [], r2.emptyObject = Object.freeze ? Object.freeze({}) : {}, r2.isInteger = Number.isInteger || function(t3) {
        return "number" == typeof t3 && isFinite(t3) && Math.floor(t3) === t3;
      }, r2.isString = function(t3) {
        return "string" == typeof t3 || t3 instanceof String;
      }, r2.isObject = function(t3) {
        return t3 && "object" == typeof t3;
      }, r2.isset = r2.isSet = function(t3, e3) {
        var n3 = t3[e3];
        return !(null == n3 || !t3.hasOwnProperty(e3)) && ("object" != typeof n3 || (Array.isArray(n3) ? n3.length : Object.keys(n3).length) > 0);
      }, r2.Buffer = function() {
        try {
          var t3 = r2.inquire("buffer").Buffer;
          return t3.prototype.utf8Write ? t3 : null;
        } catch (t4) {
          return null;
        }
      }(), r2._Buffer_from = null, r2._Buffer_allocUnsafe = null, r2.newBuffer = function(t3) {
        return "number" == typeof t3 ? r2.Buffer ? r2._Buffer_allocUnsafe(t3) : new r2.Array(t3) : r2.Buffer ? r2._Buffer_from(t3) : "undefined" == typeof Uint8Array ? t3 : new Uint8Array(t3);
      }, r2.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r2.Long = r2.global.dcodeIO && r2.global.dcodeIO.Long || r2.global.Long || r2.inquire("long"), r2.key2Re = /^true|false|0|1$/, r2.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r2.longToHash = function(t3) {
        return t3 ? r2.LongBits.from(t3).toHash() : r2.LongBits.zeroHash;
      }, r2.longFromHash = function(t3, e3) {
        var n3 = r2.LongBits.fromHash(t3);
        return r2.Long ? r2.Long.fromBits(n3.lo, n3.hi, e3) : n3.toNumber(Boolean(e3));
      }, r2.merge = i, r2.lcFirst = function(t3) {
        return t3.charAt(0).toLowerCase() + t3.substring(1);
      }, r2.newError = o, r2.ProtocolError = o("ProtocolError"), r2.oneOfGetter = function(t3) {
        for (var e3 = {}, n3 = 0; n3 < t3.length; ++n3) e3[t3[n3]] = 1;
        return function() {
          for (var t4 = Object.keys(this), n4 = t4.length - 1; n4 > -1; --n4) if (1 === e3[t4[n4]] && void 0 !== this[t4[n4]] && null !== this[t4[n4]]) return t4[n4];
        };
      }, r2.oneOfSetter = function(t3) {
        return function(e3) {
          for (var n3 = 0; n3 < t3.length; ++n3) t3[n3] !== e3 && delete this[t3[n3]];
        };
      }, r2.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r2._configure = function() {
        var t3 = r2.Buffer;
        t3 ? (r2._Buffer_from = t3.from !== Uint8Array.from && t3.from || function(e3, n3) {
          return new t3(e3, n3);
        }, r2._Buffer_allocUnsafe = t3.allocUnsafe || function(e3) {
          return new t3(e3);
        }) : r2._Buffer_from = r2._Buffer_allocUnsafe = null;
      };
    }, 1173: (t2, e2, n2) => {
      t2.exports = p2;
      var r2, i = n2(9693), o = i.LongBits, a = i.base64, s = i.utf8;
      function u2(t3, e3, n3) {
        this.fn = t3, this.len = e3, this.next = void 0, this.val = n3;
      }
      function c2() {
      }
      function l2(t3) {
        this.head = t3.head, this.tail = t3.tail, this.len = t3.len, this.next = t3.states;
      }
      function p2() {
        this.len = 0, this.head = new u2(c2, 0, 0), this.tail = this.head, this.states = null;
      }
      var f2 = function() {
        return i.Buffer ? function() {
          return (p2.create = function() {
            return new r2();
          })();
        } : function() {
          return new p2();
        };
      };
      function d2(t3, e3, n3) {
        e3[n3] = 255 & t3;
      }
      function h2(t3, e3) {
        this.len = t3, this.next = void 0, this.val = e3;
      }
      function g2(t3, e3, n3) {
        for (; t3.hi; ) e3[n3++] = 127 & t3.lo | 128, t3.lo = (t3.lo >>> 7 | t3.hi << 25) >>> 0, t3.hi >>>= 7;
        for (; t3.lo > 127; ) e3[n3++] = 127 & t3.lo | 128, t3.lo = t3.lo >>> 7;
        e3[n3++] = t3.lo;
      }
      function b2(t3, e3, n3) {
        e3[n3] = 255 & t3, e3[n3 + 1] = t3 >>> 8 & 255, e3[n3 + 2] = t3 >>> 16 & 255, e3[n3 + 3] = t3 >>> 24;
      }
      p2.create = f2(), p2.alloc = function(t3) {
        return new i.Array(t3);
      }, i.Array !== Array && (p2.alloc = i.pool(p2.alloc, i.Array.prototype.subarray)), p2.prototype._push = function(t3, e3, n3) {
        return this.tail = this.tail.next = new u2(t3, e3, n3), this.len += e3, this;
      }, h2.prototype = Object.create(u2.prototype), h2.prototype.fn = function(t3, e3, n3) {
        for (; t3 > 127; ) e3[n3++] = 127 & t3 | 128, t3 >>>= 7;
        e3[n3] = t3;
      }, p2.prototype.uint32 = function(t3) {
        return this.len += (this.tail = this.tail.next = new h2((t3 >>>= 0) < 128 ? 1 : t3 < 16384 ? 2 : t3 < 2097152 ? 3 : t3 < 268435456 ? 4 : 5, t3)).len, this;
      }, p2.prototype.int32 = function(t3) {
        return t3 < 0 ? this._push(g2, 10, o.fromNumber(t3)) : this.uint32(t3);
      }, p2.prototype.sint32 = function(t3) {
        return this.uint32((t3 << 1 ^ t3 >> 31) >>> 0);
      }, p2.prototype.uint64 = function(t3) {
        var e3 = o.from(t3);
        return this._push(g2, e3.length(), e3);
      }, p2.prototype.int64 = p2.prototype.uint64, p2.prototype.sint64 = function(t3) {
        var e3 = o.from(t3).zzEncode();
        return this._push(g2, e3.length(), e3);
      }, p2.prototype.bool = function(t3) {
        return this._push(d2, 1, t3 ? 1 : 0);
      }, p2.prototype.fixed32 = function(t3) {
        return this._push(b2, 4, t3 >>> 0);
      }, p2.prototype.sfixed32 = p2.prototype.fixed32, p2.prototype.fixed64 = function(t3) {
        var e3 = o.from(t3);
        return this._push(b2, 4, e3.lo)._push(b2, 4, e3.hi);
      }, p2.prototype.sfixed64 = p2.prototype.fixed64, p2.prototype.float = function(t3) {
        return this._push(i.float.writeFloatLE, 4, t3);
      }, p2.prototype.double = function(t3) {
        return this._push(i.float.writeDoubleLE, 8, t3);
      };
      var m2 = i.Array.prototype.set ? function(t3, e3, n3) {
        e3.set(t3, n3);
      } : function(t3, e3, n3) {
        for (var r3 = 0; r3 < t3.length; ++r3) e3[n3 + r3] = t3[r3];
      };
      p2.prototype.bytes = function(t3) {
        var e3 = t3.length >>> 0;
        if (!e3) return this._push(d2, 1, 0);
        if (i.isString(t3)) {
          var n3 = p2.alloc(e3 = a.length(t3));
          a.decode(t3, n3, 0), t3 = n3;
        }
        return this.uint32(e3)._push(m2, e3, t3);
      }, p2.prototype.string = function(t3) {
        var e3 = s.length(t3);
        return e3 ? this.uint32(e3)._push(s.write, e3, t3) : this._push(d2, 1, 0);
      }, p2.prototype.fork = function() {
        return this.states = new l2(this), this.head = this.tail = new u2(c2, 0, 0), this.len = 0, this;
      }, p2.prototype.reset = function() {
        return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u2(c2, 0, 0), this.len = 0), this;
      }, p2.prototype.ldelim = function() {
        var t3 = this.head, e3 = this.tail, n3 = this.len;
        return this.reset().uint32(n3), n3 && (this.tail.next = t3.next, this.tail = e3, this.len += n3), this;
      }, p2.prototype.finish = function() {
        for (var t3 = this.head.next, e3 = this.constructor.alloc(this.len), n3 = 0; t3; ) t3.fn(t3.val, e3, n3), n3 += t3.len, t3 = t3.next;
        return e3;
      }, p2._configure = function(t3) {
        r2 = t3, p2.create = f2(), r2._configure();
      };
    }, 3155: (t2, e2, n2) => {
      t2.exports = o;
      var r2 = n2(1173);
      (o.prototype = Object.create(r2.prototype)).constructor = o;
      var i = n2(9693);
      function o() {
        r2.call(this);
      }
      function a(t3, e3, n3) {
        t3.length < 40 ? i.utf8.write(t3, e3, n3) : e3.utf8Write ? e3.utf8Write(t3, n3) : e3.write(t3, n3);
      }
      o._configure = function() {
        o.alloc = i._Buffer_allocUnsafe, o.writeBytesBuffer = i.Buffer && i.Buffer.prototype instanceof Uint8Array && "set" === i.Buffer.prototype.set.name ? function(t3, e3, n3) {
          e3.set(t3, n3);
        } : function(t3, e3, n3) {
          if (t3.copy) t3.copy(e3, n3, 0, t3.length);
          else for (var r3 = 0; r3 < t3.length; ) e3[n3++] = t3[r3++];
        };
      }, o.prototype.bytes = function(t3) {
        i.isString(t3) && (t3 = i._Buffer_from(t3, "base64"));
        var e3 = t3.length >>> 0;
        return this.uint32(e3), e3 && this._push(o.writeBytesBuffer, e3, t3), this;
      }, o.prototype.string = function(t3) {
        var e3 = i.Buffer.byteLength(t3);
        return this.uint32(e3), e3 && this._push(a, e3, t3), this;
      }, o._configure();
    }, 7714: (t2, e2, n2) => {
      e2.R = void 0;
      const r2 = n2(6919), i = n2(7448);
      e2.R = new class {
        async init() {
        }
        async createSessionHandler(t3, e3) {
          const n3 = new r2.Session(e3);
          return await n3.loadModel(t3), new i.OnnxjsSessionHandler(n3);
        }
      }();
    }, 4200: (t2, e2, n2) => {
      e2.c8 = e2.rX = void 0;
      const r2 = n2(1670), i = n2(5381), o = n2(2157), a = n2(2306);
      e2.rX = () => {
        if (("number" != typeof r2.env.wasm.initTimeout || r2.env.wasm.initTimeout < 0) && (r2.env.wasm.initTimeout = 0), "boolean" != typeof r2.env.wasm.simd && (r2.env.wasm.simd = true), "boolean" != typeof r2.env.wasm.proxy && (r2.env.wasm.proxy = false), "number" != typeof r2.env.wasm.numThreads || !Number.isInteger(r2.env.wasm.numThreads) || r2.env.wasm.numThreads <= 0) {
          const t3 = "undefined" == typeof navigator ? (0, i.cpus)().length : navigator.hardwareConcurrency;
          r2.env.wasm.numThreads = Math.min(4, Math.ceil((t3 || 1) / 2));
        }
      }, e2.c8 = new class {
        async init() {
          (0, e2.rX)(), await (0, o.initWasm)();
        }
        async createSessionHandler(t3, e3) {
          const n3 = new a.OnnxruntimeWebAssemblySessionHandler();
          return await n3.loadModel(t3, e3), Promise.resolve(n3);
        }
      }();
    }, 6018: function(t2, e2, n2) {
      var r2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i2 = Object.getOwnPropertyDescriptor(e3, n3);
        i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i2);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), i = this && this.__exportStar || function(t3, e3) {
        for (var n3 in t3) "default" === n3 || Object.prototype.hasOwnProperty.call(e3, n3) || r2(e3, t3, n3);
      };
      Object.defineProperty(e2, "__esModule", { value: true }), i(n2(1670), e2);
      const o = n2(1670);
      {
        const t3 = n2(7714).R;
        (0, o.registerBackend)("webgl", t3, -10);
      }
      {
        const t3 = n2(4200).c8;
        (0, o.registerBackend)("cpu", t3, 10), (0, o.registerBackend)("wasm", t3, 10), (0, o.registerBackend)("xnnpack", t3, 9);
      }
    }, 246: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createAttributeWithCacheKey = void 0;
      class n2 {
        constructor(t3) {
          Object.assign(this, t3);
        }
        get cacheKey() {
          return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((t3) => `${this[t3]}`).join(";")), this._cacheKey;
        }
      }
      e2.createAttributeWithCacheKey = (t3) => new n2(t3);
    }, 7778: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Attribute = void 0;
      const r2 = n2(1446), i = n2(9395), o = n2(9162), a = n2(2517);
      var s = i.onnxruntime.experimental.fbs;
      class u2 {
        constructor(t3) {
          if (this._attributes = /* @__PURE__ */ new Map(), null != t3) {
            for (const e3 of t3) e3 instanceof r2.onnx.AttributeProto ? this._attributes.set(e3.name, [u2.getValue(e3), u2.getType(e3)]) : e3 instanceof s.Attribute && this._attributes.set(e3.name(), [u2.getValue(e3), u2.getType(e3)]);
            if (this._attributes.size < t3.length) throw new Error("duplicated attribute names");
          }
        }
        set(t3, e3, n3) {
          this._attributes.set(t3, [n3, e3]);
        }
        delete(t3) {
          this._attributes.delete(t3);
        }
        getFloat(t3, e3) {
          return this.get(t3, "float", e3);
        }
        getInt(t3, e3) {
          return this.get(t3, "int", e3);
        }
        getString(t3, e3) {
          return this.get(t3, "string", e3);
        }
        getTensor(t3, e3) {
          return this.get(t3, "tensor", e3);
        }
        getFloats(t3, e3) {
          return this.get(t3, "floats", e3);
        }
        getInts(t3, e3) {
          return this.get(t3, "ints", e3);
        }
        getStrings(t3, e3) {
          return this.get(t3, "strings", e3);
        }
        getTensors(t3, e3) {
          return this.get(t3, "tensors", e3);
        }
        get(t3, e3, n3) {
          const r3 = this._attributes.get(t3);
          if (void 0 === r3) {
            if (void 0 !== n3) return n3;
            throw new Error(`required attribute not found: ${t3}`);
          }
          if (r3[1] !== e3) throw new Error(`type mismatch: expected ${e3} but got ${r3[1]}`);
          return r3[0];
        }
        static getType(t3) {
          const e3 = t3 instanceof r2.onnx.AttributeProto ? t3.type : t3.type();
          switch (e3) {
            case r2.onnx.AttributeProto.AttributeType.FLOAT:
              return "float";
            case r2.onnx.AttributeProto.AttributeType.INT:
              return "int";
            case r2.onnx.AttributeProto.AttributeType.STRING:
              return "string";
            case r2.onnx.AttributeProto.AttributeType.TENSOR:
              return "tensor";
            case r2.onnx.AttributeProto.AttributeType.FLOATS:
              return "floats";
            case r2.onnx.AttributeProto.AttributeType.INTS:
              return "ints";
            case r2.onnx.AttributeProto.AttributeType.STRINGS:
              return "strings";
            case r2.onnx.AttributeProto.AttributeType.TENSORS:
              return "tensors";
            default:
              throw new Error(`attribute type is not supported yet: ${r2.onnx.AttributeProto.AttributeType[e3]}`);
          }
        }
        static getValue(t3) {
          const e3 = t3 instanceof r2.onnx.AttributeProto ? t3.type : t3.type();
          if (e3 === r2.onnx.AttributeProto.AttributeType.GRAPH || e3 === r2.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error("graph attribute is not supported yet");
          const n3 = this.getValueNoCheck(t3);
          if (e3 === r2.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n3)) return a.LongUtil.longToNumber(n3);
          if (e3 === r2.onnx.AttributeProto.AttributeType.INTS) {
            const t4 = n3, e4 = new Array(t4.length);
            for (let n4 = 0; n4 < t4.length; n4++) {
              const r3 = t4[n4];
              e4[n4] = a.LongUtil.longToNumber(r3);
            }
            return e4;
          }
          if (e3 === r2.onnx.AttributeProto.AttributeType.TENSOR) return t3 instanceof r2.onnx.AttributeProto ? o.Tensor.fromProto(n3) : o.Tensor.fromOrtTensor(n3);
          if (e3 === r2.onnx.AttributeProto.AttributeType.TENSORS) {
            if (t3 instanceof r2.onnx.AttributeProto) return n3.map((t4) => o.Tensor.fromProto(t4));
            if (t3 instanceof s.Attribute) return n3.map((t4) => o.Tensor.fromOrtTensor(t4));
          }
          if (e3 === r2.onnx.AttributeProto.AttributeType.STRING && t3 instanceof r2.onnx.AttributeProto) {
            const t4 = n3;
            return (0, a.decodeUtf8String)(t4);
          }
          return e3 === r2.onnx.AttributeProto.AttributeType.STRINGS && t3 instanceof r2.onnx.AttributeProto ? n3.map(a.decodeUtf8String) : n3;
        }
        static getValueNoCheck(t3) {
          return t3 instanceof r2.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(t3) : this.getValueNoCheckFromOrtFormat(t3);
        }
        static getValueNoCheckFromOnnxFormat(t3) {
          switch (t3.type) {
            case r2.onnx.AttributeProto.AttributeType.FLOAT:
              return t3.f;
            case r2.onnx.AttributeProto.AttributeType.INT:
              return t3.i;
            case r2.onnx.AttributeProto.AttributeType.STRING:
              return t3.s;
            case r2.onnx.AttributeProto.AttributeType.TENSOR:
              return t3.t;
            case r2.onnx.AttributeProto.AttributeType.GRAPH:
              return t3.g;
            case r2.onnx.AttributeProto.AttributeType.FLOATS:
              return t3.floats;
            case r2.onnx.AttributeProto.AttributeType.INTS:
              return t3.ints;
            case r2.onnx.AttributeProto.AttributeType.STRINGS:
              return t3.strings;
            case r2.onnx.AttributeProto.AttributeType.TENSORS:
              return t3.tensors;
            case r2.onnx.AttributeProto.AttributeType.GRAPHS:
              return t3.graphs;
            default:
              throw new Error(`unsupported attribute type: ${r2.onnx.AttributeProto.AttributeType[t3.type]}`);
          }
        }
        static getValueNoCheckFromOrtFormat(t3) {
          switch (t3.type()) {
            case s.AttributeType.FLOAT:
              return t3.f();
            case s.AttributeType.INT:
              return t3.i();
            case s.AttributeType.STRING:
              return t3.s();
            case s.AttributeType.TENSOR:
              return t3.t();
            case s.AttributeType.GRAPH:
              return t3.g();
            case s.AttributeType.FLOATS:
              return t3.floatsArray();
            case s.AttributeType.INTS: {
              const e3 = [];
              for (let n3 = 0; n3 < t3.intsLength(); n3++) e3.push(t3.ints(n3));
              return e3;
            }
            case s.AttributeType.STRINGS: {
              const e3 = [];
              for (let n3 = 0; n3 < t3.stringsLength(); n3++) e3.push(t3.strings(n3));
              return e3;
            }
            case s.AttributeType.TENSORS: {
              const e3 = [];
              for (let n3 = 0; n3 < t3.tensorsLength(); n3++) e3.push(t3.tensors(n3));
              return e3;
            }
            default:
              throw new Error(`unsupported attribute type: ${s.AttributeType[t3.type()]}`);
          }
        }
      }
      e2.Attribute = u2;
    }, 7091: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.resolveBackend = e2.backend = void 0;
      const r2 = n2(5038), i = /* @__PURE__ */ new Map();
      async function o(t3) {
        const n3 = e2.backend;
        if (void 0 !== n3[t3] && function(t4) {
          const e3 = t4;
          return "initialize" in e3 && "function" == typeof e3.initialize && "createSessionHandler" in e3 && "function" == typeof e3.createSessionHandler && "dispose" in e3 && "function" == typeof e3.dispose;
        }(n3[t3])) {
          const e3 = n3[t3];
          let r3 = e3.initialize();
          if ("object" == typeof r3 && "then" in r3 && (r3 = await r3), r3) return i.set(t3, e3), e3;
        }
      }
      e2.backend = { webgl: new r2.WebGLBackend() }, e2.resolveBackend = async function t3(e3) {
        if (!e3) return t3(["webgl"]);
        {
          const t4 = "string" == typeof e3 ? [e3] : e3;
          for (const e4 of t4) {
            const t5 = i.get(e4);
            if (t5) return t5;
            const n3 = await o(e4);
            if (n3) return n3;
          }
        }
        throw new Error("no available backend to use");
      };
    }, 5038: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebGLBackend = void 0;
      const r2 = n2(1670), i = n2(6231), o = n2(6416), a = n2(7305);
      e2.WebGLBackend = class {
        get contextId() {
          return r2.env.webgl.contextId;
        }
        set contextId(t3) {
          r2.env.webgl.contextId = t3;
        }
        get matmulMaxBatchSize() {
          return r2.env.webgl.matmulMaxBatchSize;
        }
        set matmulMaxBatchSize(t3) {
          r2.env.webgl.matmulMaxBatchSize = t3;
        }
        get textureCacheMode() {
          return r2.env.webgl.textureCacheMode;
        }
        set textureCacheMode(t3) {
          r2.env.webgl.textureCacheMode = t3;
        }
        get pack() {
          return r2.env.webgl.pack;
        }
        set pack(t3) {
          r2.env.webgl.pack = t3;
        }
        get async() {
          return r2.env.webgl.async;
        }
        set async(t3) {
          r2.env.webgl.async = t3;
        }
        initialize() {
          try {
            return this.glContext = (0, a.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), i.Logger.setWithEnv(r2.env), i.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
          } catch (t3) {
            return i.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${t3}`), false;
          }
        }
        createSessionHandler(t3) {
          return new o.WebGLSessionHandler(this, t3);
        }
        dispose() {
          this.glContext.dispose();
        }
      };
    }, 5107: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.CoordsGlslLib = void 0;
      const r2 = n2(2517), i = n2(8520), o = n2(5060), a = n2(7859), s = n2(9390);
      class u2 extends i.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getFunctions() {
          return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
        }
        getCustomTypes() {
          return {};
        }
        offsetToCoords() {
          return { offsetToCoords: new i.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
        }
        coordsToOffset() {
          return { coordsToOffset: new i.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
        }
        getOutputSamplingSnippet() {
          const t3 = this.context.outputTextureLayout;
          return t3.isPacked ? this.getPackedOutputSamplingSnippet(t3) : this.getUnpackedOutputSamplingSnippet(t3);
        }
        getPackedOutputSamplingSnippet(t3) {
          const e3 = t3.unpackedShape, n3 = [t3.width, t3.height], r3 = {}, a2 = "getOutputCoords";
          switch (e3.length) {
            case 0:
              r3[a2] = this.getOutputScalarCoords();
              break;
            case 1:
              r3[a2] = this.getOutputPacked1DCoords(e3, n3);
              break;
            case 2:
              r3[a2] = this.getOutputPacked2DCoords(e3, n3);
              break;
            case 3:
              r3[a2] = this.getOutputPacked3DCoords(e3, n3);
              break;
            default:
              r3[a2] = this.getOutputPackedNDCoords(e3, n3);
          }
          const s2 = `
      void setOutput(vec4 val) {
        ${(0, o.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
          return r3.floatTextureSetRGBA = new i.GlslLibRoutine(s2), r3;
        }
        getUnpackedOutputSamplingSnippet(t3) {
          const e3 = t3.unpackedShape, n3 = [t3.width, t3.height], r3 = {}, a2 = "getOutputCoords";
          switch (e3.length) {
            case 0:
              r3[a2] = this.getOutputScalarCoords();
              break;
            case 1:
              r3[a2] = this.getOutputUnpacked1DCoords(e3, n3);
              break;
            case 2:
              r3[a2] = this.getOutputUnpacked2DCoords(e3, n3);
              break;
            case 3:
              r3[a2] = this.getOutputUnpacked3DCoords(e3, n3);
              break;
            case 4:
              r3[a2] = this.getOutputUnpacked4DCoords(e3, n3);
              break;
            case 5:
              r3[a2] = this.getOutputUnpacked5DCoords(e3, n3);
              break;
            case 6:
              r3[a2] = this.getOutputUnpacked6DCoords(e3, n3);
              break;
            default:
              throw new Error(`Unsupported output dimensionality: ${e3.length}`);
          }
          const s2 = `
        void setOutput(float val) {
          ${(0, o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
          return r3.floatTextureSetR = new i.GlslLibRoutine(s2), r3;
        }
        getOutputScalarCoords() {
          return new i.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
        }
        getOutputPacked1DCoords(t3, e3) {
          const n3 = e3;
          let r3 = "";
          return 1 === n3[0] ? (r3 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n3[1]}.0);
          }
        `, new i.GlslLibRoutine(r3)) : 1 === n3[1] ? (r3 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n3[0]}.0);
          }
        `, new i.GlslLibRoutine(r3)) : (r3 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n3[0]}, ${n3[1]}));
          return 2 * (resTexRC.y * ${n3[0]} + resTexRC.x);
        }
      `, new i.GlslLibRoutine(r3));
        }
        getOutputPacked2DCoords(t3, e3) {
          let n3 = "";
          if (r2.ArrayUtil.arraysEqual(t3, e3)) return n3 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${e3[0]}, ${e3[1]}));
        }
      `, new i.GlslLibRoutine(n3);
          const o2 = e3, a2 = Math.ceil(t3[1] / 2);
          return n3 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o2[0]}, ${o2[1]}));

          int index = resTexRC.y * ${o2[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${a2}) * 2;
          int c = 2 * (index / ${a2});

          return ivec2(r, c);
        }
      `, new i.GlslLibRoutine(n3);
        }
        getOutputPacked3DCoords(t3, e3) {
          const n3 = [e3[0], e3[1]], r3 = Math.ceil(t3[2] / 2), o2 = r3 * Math.ceil(t3[1] / 2), a2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n3[0]}, ${n3[1]}));
          int index = resTexRC.y * ${n3[0]} + resTexRC.x;

          int b = index / ${o2};
          index -= b * ${o2};

          // reverse r and c order for packed texture
          int r = imod(index, ${r3}) * 2;
          int c = 2 * (index / ${r3});

          return ivec3(b, r, c);
        }
      `;
          return new i.GlslLibRoutine(a2);
        }
        getOutputPackedNDCoords(t3, e3) {
          const n3 = [e3[0], e3[1]], r3 = Math.ceil(t3[t3.length - 1] / 2), o2 = r3 * Math.ceil(t3[t3.length - 2] / 2);
          let a2 = o2, s2 = "", u3 = "b, r, c";
          for (let e4 = 2; e4 < t3.length - 1; e4++) a2 *= t3[t3.length - e4 - 1], s2 = `
      int b${e4} = index / ${a2};
      index -= b${e4} * ${a2};
    ` + s2, u3 = `b${e4}, ` + u3;
          const c2 = `
      ivec${t3.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n3[0]}, ${n3[1]}));
        int index = resTexRC.y * ${n3[0]} + resTexRC.x;

        ${s2}

        int b = index / ${o2};
        index -= b * ${o2};

        // reverse r and c order for packed texture
        int r = imod(index, ${r3}) * 2;
        int c = 2 * (index / ${r3});

        return ivec${t3.length}(${u3});
      }
    `;
          return new i.GlslLibRoutine(c2);
        }
        getOutputUnpacked1DCoords(t3, e3) {
          const n3 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          return resTexRC.y * ${e3[0]} + resTexRC.x;
        }
      `;
          return new i.GlslLibRoutine(n3);
        }
        getOutputUnpacked2DCoords(t3, e3) {
          const n3 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          int index = resTexRC.y * ${e3[0]} + resTexRC.x;
          int r = index / ${t3[1]};
          int c = index - r * ${t3[1]};
          return ivec2(r, c);
        }
      `;
          return new i.GlslLibRoutine(n3);
        }
        getOutputUnpacked3DCoords(t3, e3) {
          let n3 = "";
          const r3 = t3.length;
          let o2 = null;
          r3 < 2 && (o2 = []), o2 = new Array(r3 - 1), o2[r3 - 2] = t3[r3 - 1];
          for (let e4 = r3 - 3; e4 >= 0; --e4) o2[e4] = o2[e4 + 1] * t3[e4 + 1];
          const a2 = ["r", "c", "d"], s2 = o2.map((t4, e4) => `int ${a2[e4]} = index / ${t4}; ${e4 === o2.length - 1 ? `int ${a2[e4 + 1]} = index - ${a2[e4]} * ${t4}` : `index -= ${a2[e4]} * ${t4}`};`).join("");
          return n3 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          int index = resTexRC.y * ${e3[0]} + resTexRC.x;
          ${s2}
          return ivec3(r, c, d);
        }
      `, new i.GlslLibRoutine(n3);
        }
        getOutputUnpacked4DCoords(t3, e3) {
          let n3 = "";
          const r3 = t3.length;
          let o2 = null;
          r3 < 2 && (o2 = []), o2 = new Array(r3 - 1), o2[r3 - 2] = t3[r3 - 1];
          for (let e4 = r3 - 3; e4 >= 0; --e4) o2[e4] = o2[e4 + 1] * t3[e4 + 1];
          const a2 = ["r", "c", "d", "d2"], s2 = o2.map((t4, e4) => `int ${a2[e4]} = index / ${t4}; ${e4 === o2.length - 1 ? `int ${a2[e4 + 1]} = index - ${a2[e4]} * ${t4}` : `index -= ${a2[e4]} * ${t4}`};`).join("");
          return n3 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          int index = resTexRC.y * ${e3[0]} + resTexRC.x;
          ${s2}
          return ivec4(r, c, d, d2);
        }
      `, new i.GlslLibRoutine(n3);
        }
        getOutputUnpacked5DCoords(t3, e3) {
          let n3 = "";
          const r3 = t3.length;
          let o2 = null;
          r3 < 2 && (o2 = []), o2 = new Array(r3 - 1), o2[r3 - 2] = t3[r3 - 1];
          for (let e4 = r3 - 3; e4 >= 0; --e4) o2[e4] = o2[e4 + 1] * t3[e4 + 1];
          const a2 = ["r", "c", "d", "d2", "d3"], s2 = o2.map((t4, e4) => `int ${a2[e4]} = index / ${t4}; ${e4 === o2.length - 1 ? `int ${a2[e4 + 1]} = index - ${a2[e4]} * ${t4}` : `index -= ${a2[e4]} * ${t4}`};`).join("");
          return n3 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e3[0]}, ${e3[1]}));
          int index = resTexRC.y * ${e3[0]} + resTexRC.x;
          ${s2}
          return ivec5(r, c, d, d2, d3);
        }
      `, new i.GlslLibRoutine(n3);
        }
        getOutputUnpacked6DCoords(t3, e3) {
          let n3 = "";
          const r3 = t3.length;
          let o2 = null;
          r3 < 2 && (o2 = []), o2 = new Array(r3 - 1), o2[r3 - 2] = t3[r3 - 1];
          for (let e4 = r3 - 3; e4 >= 0; --e4) o2[e4] = o2[e4 + 1] * t3[e4 + 1];
          const a2 = ["r", "c", "d", "d2", "d3", "d4"], s2 = o2.map((t4, e4) => `int ${a2[e4]} = index / ${t4}; ${e4 === o2.length - 1 ? `int ${a2[e4 + 1]} = index - ${a2[e4]} * ${t4}` : `index -= ${a2[e4]} * ${t4}`};`).join("");
          return n3 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${e3[0]}, ${e3[1]}));
         int index = resTexRC.y * ${e3[0]} + resTexRC.x;
         ${s2}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new i.GlslLibRoutine(n3);
        }
        getCommonUtilFuncs() {
          const t3 = {};
          let e3 = "uvFromFlat";
          t3[e3] = new i.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), e3 = "packedUVfrom1D", t3[e3] = new i.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e3 = "packedUVfrom2D", t3[e3] = new i.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e3 = "packedUVfrom3D", t3[e3] = new i.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e3 = "sampleTexture";
          const n3 = (0, o.getGlsl)(this.context.glContext.version);
          return t3[e3] = new i.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n3.texture2D}(textureSampler, uv).r;
        }`), t3;
        }
        getInputsSamplingSnippets() {
          const t3 = {}, e3 = this.context.outputTextureLayout;
          return this.context.programInfo.inputNames.forEach((n3, r3) => {
            const i2 = this.context.inputTextureLayouts[r3], o2 = (0, s.generateShaderFuncNameFromInputSamplerName)(n3);
            i2.isPacked ? t3[o2] = this.getPackedSamplerFromInput(o2, n3, i2) : t3[o2] = this.getUnpackedSamplerFromInput(o2, n3, i2);
            const a2 = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n3);
            i2.unpackedShape.length <= e3.unpackedShape.length && (i2.isPacked ? t3[a2] = this.getPackedSamplerAtOutputCoords(a2, i2, e3, n3) : t3[a2] = this.getUnpackedSamplerAtOutputCoords(a2, i2, e3, n3));
          }), t3;
        }
        getPackedSamplerAtOutputCoords(t3, e3, n3, o2) {
          const a2 = e3.unpackedShape, u3 = n3.unpackedShape, c2 = o2, l2 = (0, s.generateShaderFuncNameFromInputSamplerName)(c2), p2 = a2.length, f2 = u3.length, d2 = r2.BroadcastUtil.getBroadcastDims(a2, u3), h2 = (0, s.getCoordsDataType)(f2), g2 = f2 - p2;
          let b2;
          const m2 = (0, s.getGlChannels)();
          b2 = 0 === p2 ? "" : f2 < 2 && d2.length >= 1 ? "coords = 0;" : d2.map((t4) => `coords.${m2[t4 + g2]} = 0;`).join("\n");
          let y2 = "";
          y2 = f2 < 2 && p2 > 0 ? "coords" : a2.map((t4, e4) => `coords.${m2[e4 + g2]}`).join(", ");
          let _ = "return outputValue;";
          const v2 = 1 === r2.ShapeUtil.size(a2), w2 = 1 === r2.ShapeUtil.size(u3);
          if (1 !== p2 || v2 || w2) {
            if (v2 && !w2) _ = 1 === f2 ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
            else if (d2.length) {
              const t4 = p2 - 2, e4 = p2 - 1;
              d2.indexOf(t4) > -1 && d2.indexOf(e4) > -1 ? _ = "return vec4(outputValue.x);" : d2.indexOf(t4) > -1 ? _ = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : d2.indexOf(e4) > -1 && (_ = "return vec4(outputValue.xx, outputValue.zz);");
            }
          } else _ = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
          const x2 = `
      vec4 ${t3}() {
        ${h2} coords = getOutputCoords();
        
        int lastDim = coords.${m2[f2 - 1]};
        coords.${m2[f2 - 1]} = coords.${m2[f2 - 2]};
        coords.${m2[f2 - 2]} = lastDim;
      
        ${b2}
        vec4 outputValue = ${l2}(${y2});
        ${_}
      }
    `;
          return new i.GlslLibRoutine(x2, ["coordinates.getOutputCoords"]);
        }
        getUnpackedSamplerAtOutputCoords(t3, e3, n3, o2) {
          const a2 = [n3.width, n3.height], u3 = [e3.width, e3.height], c2 = e3.unpackedShape.length, l2 = n3.unpackedShape.length, p2 = e3.unpackedShape, f2 = n3.unpackedShape, d2 = (0, s.generateShaderFuncNameFromInputSamplerName)(o2);
          if (c2 === l2 && r2.ArrayUtil.arraysEqual(u3, a2)) {
            const e4 = `
          float ${t3}() {
            return sampleTexture(${o2}, TexCoords);
          }
        `;
            return new i.GlslLibRoutine(e4, ["coordinates.sampleTexture"]);
          }
          const h2 = (0, s.getCoordsDataType)(l2), g2 = r2.BroadcastUtil.getBroadcastDims(p2, f2), b2 = l2 - c2;
          let m2;
          const y2 = (0, s.getGlChannels)();
          m2 = 0 === c2 ? "" : l2 < 2 && g2.length >= 1 ? "coords = 0;" : g2.map((t4) => `coords.${y2[t4 + b2]} = 0;`).join("\n");
          let _ = "";
          _ = l2 < 2 && c2 > 0 ? "coords" : e3.unpackedShape.map((t4, e4) => `coords.${y2[e4 + b2]}`).join(", ");
          const v2 = `
        float ${t3}() {
          ${h2} coords = getOutputCoords();
          ${m2}
          return ${d2}(${_});
        }
      `;
          return new i.GlslLibRoutine(v2, ["coordinates.getOutputCoords"]);
        }
        getPackedSamplerFromInput(t3, e3, n3) {
          switch (n3.unpackedShape.length) {
            case 0:
              return this.getPackedSamplerScalar(t3, e3);
            case 1:
              return this.getPackedSampler1D(t3, e3, n3);
            case 2:
              return this.getPackedSampler2D(t3, e3, n3);
            case 3:
              return this.getPackedSampler3D(t3, e3, n3);
            default:
              return this.getPackedSamplerND(t3, e3, n3);
          }
        }
        getUnpackedSamplerFromInput(t3, e3, n3) {
          const r3 = n3.unpackedShape;
          switch (r3.length) {
            case 0:
              return this.getUnpackedSamplerScalar(t3, e3, n3);
            case 1:
              return this.getUnpackedSampler1D(t3, e3, n3);
            case 2:
              return this.getUnpackedSampler2D(t3, e3, n3);
            case 3:
              return this.getUnpackedSampler3D(t3, e3, n3);
            case 4:
              return this.getUnpackedSampler4D(t3, e3, n3);
            case 5:
              return this.getUnpackedSampler5D(t3, e3, n3);
            case 6:
              return this.getUnpackedSampler6D(t3, e3, n3);
            default:
              throw new Error(`Unsupported dimension ${r3.length}-D`);
          }
        }
        getPackedSamplerScalar(t3, e3) {
          const n3 = `
          vec4 ${t3}() {
            return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${e3}, halfCR);
          }
        `;
          return new i.GlslLibRoutine(n3);
        }
        getPackedSampler1D(t3, e3, n3) {
          const r3 = [n3.width, n3.height], a2 = [r3[1], r3[0]], s2 = (0, o.getGlsl)(this.context.glContext.version), u3 = `vec4 ${t3}(int index) {
      vec2 uv = packedUVfrom1D(
      ${a2[0]}, ${a2[1]}, index);
      return ${s2.texture2D}(${e3}, uv);
    }`;
          return new i.GlslLibRoutine(u3, ["coordinates.packedUVfrom1D"]);
        }
        getPackedSampler2D(t3, e3, n3) {
          const a2 = n3.unpackedShape, s2 = [n3.width, n3.height], u3 = (0, o.getGlsl)(this.context.glContext.version), c2 = s2[0], l2 = s2[1];
          if (null != s2 && r2.ArrayUtil.arraysEqual(a2, s2)) {
            const n4 = `vec4 ${t3}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l2}.0, ${c2}.0);
        return ${u3.texture2D}(${e3}, uv);
      }`;
            return new i.GlslLibRoutine(n4);
          }
          const p2 = s2, f2 = Math.ceil(a2[1] / 2), d2 = `vec4 ${t3}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p2[1]}, ${p2[0]}, ${f2}, row, col);
      return ${u3.texture2D}(${e3}, uv);
    }`;
          return new i.GlslLibRoutine(d2, ["coordinates.packedUVfrom2D"]);
        }
        getPackedSampler3D(t3, e3, n3) {
          const r3 = n3.unpackedShape, a2 = [n3.width, n3.height], u3 = [a2[0], a2[1]], c2 = (0, o.getGlsl)(this.context.glContext.version);
          if (1 === r3[0]) {
            const o2 = r3.slice(1), a3 = [1, 2], u4 = (0, s.squeezeInputShape)(r3, o2), c3 = ["b", "row", "col"], l3 = JSON.parse(JSON.stringify(n3));
            l3.unpackedShape = u4;
            const p3 = this.getPackedSamplerFromInput(t3, e3, l3), f3 = `${p3.routineBody}
      vec4 ${t3}(int b, int row, int col) {
        return ${t3}(${(0, s.getSqueezedParams)(c3, a3)});
      } `;
            return new i.GlslLibRoutine(f3, p3.dependencies);
          }
          const l2 = u3[0], p2 = u3[1], f2 = Math.ceil(r3[2] / 2), d2 = `vec4 ${t3}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p2}, ${l2}, ${f2 * Math.ceil(r3[1] / 2)}, ${f2}, b, row, col);
      return ${c2.texture2D}(${e3}, uv);}`;
          return new i.GlslLibRoutine(d2, ["coordinates.packedUVfrom3D"]);
        }
        getPackedSamplerND(t3, e3, n3) {
          const r3 = n3.unpackedShape, a2 = r3.length, s2 = [n3.width, n3.height], u3 = (0, o.getGlsl)(this.context.glContext.version), c2 = [s2[0], s2[1]], l2 = c2[1], p2 = c2[0], f2 = Math.ceil(r3[a2 - 1] / 2);
          let d2 = f2 * Math.ceil(r3[a2 - 2] / 2), h2 = "int b, int row, int col", g2 = `b * ${d2} + (row / 2) * ${f2} + (col / 2)`;
          for (let t4 = 2; t4 < a2 - 1; t4++) h2 = `int b${t4}, ` + h2, d2 *= r3[a2 - t4 - 1], g2 = `b${t4} * ${d2} + ` + g2;
          const b2 = `vec4 ${t3}(${h2}) {
      int index = ${g2};
      int texR = index / ${p2};
      int texC = index - texR * ${p2};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p2}, ${l2});
      return ${u3.texture2D}(${e3}, uv);
    }`;
          return new i.GlslLibRoutine(b2);
        }
        getUnpackedSamplerScalar(t3, e3, n3) {
          const [r3, o2] = [n3.width, n3.height];
          if (1 === r3 && 1 === o2) {
            const n4 = `
          float ${t3}() {
            return sampleTexture(${e3}, halfCR);
          }
        `;
            return new i.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          const a2 = `
        float ${t3}() {
          int offset_${e3} = coordsToOffset(TexCoords, ${r3}, ${o2});
          vec2 uv = uvFromFlat(${r3}, ${o2}, offset_${e3});
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        getUnpackedSampler1D(t3, e3, n3) {
          const r3 = n3.width, o2 = n3.height;
          if (1 === o2 && 1 === r3) {
            const n4 = `
        float ${t3}(int index) {
          return sampleTexture(${e3}, halfCR);
        }
      `;
            return new i.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          if (1 === o2) {
            const n4 = `
          float ${t3}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r3}.0, 0.5);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          if (1 === r3) {
            const n4 = `
          float ${t3}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o2}.0);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          const a2 = `
        float ${t3}(int index) {
          vec2 uv = uvFromFlat(${r3}, ${o2}, index);
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
        }
        getUnpackedSampler2D(t3, e3, n3) {
          const o2 = n3.unpackedShape, u3 = [n3.height, n3.width];
          if (null != u3 && r2.ArrayUtil.arraysEqual(o2, u3)) {
            const n4 = `
          float ${t3}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u3[1]}.0, ${u3[0]}.0);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i.GlslLibRoutine(n4, ["coordinates.sampleTexture"]);
          }
          const { newShape: c2, keptDims: l2 } = (0, a.squeezeShape)(o2), p2 = c2;
          if (p2.length < o2.length) {
            const r3 = (0, s.squeezeInputShape)(o2, p2), a2 = JSON.parse(JSON.stringify(n3));
            a2.unpackedShape = r3;
            const u4 = ["col", "row"], c3 = `
          ${this.getUnpackedSamplerFromInput(t3, e3, a2).routineBody}
          float ${t3}(int row, int col) {
            return ${t3}(${(0, s.getSqueezedParams)(u4, l2)});
          }
        `;
            return new i.GlslLibRoutine(c3, ["coordinates.sampleTexture"]);
          }
          const f2 = u3[1], d2 = u3[0];
          if (1 === d2) {
            const n4 = `
          float ${t3}(int row, int col) {
            int offset_${e3} = coordsToOffset(TexCoords, ${f2}, ${d2});
            float index = dot(vec3(row, col, offset_${e3}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${f2}.0);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i.GlslLibRoutine(n4, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          if (1 === f2) {
            const n4 = `
          float ${t3}(int row, int col) {
            int offset_${e3} = coordsToOffset(TexCoords, ${f2}, ${d2});
            float index = dot(vec3(row, col, offset_${e3}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${d2}.0, 0.5);
            return sampleTexture(${e3}, uv);
          }
        `;
            return new i.GlslLibRoutine(n4, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          const h2 = `
        float ${t3}(int row, int col) {
          int index = col * ${o2[1]} + row;
          vec2 uv = uvFromFlat(${f2}, ${d2}, index);
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i.GlslLibRoutine(h2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        getUnpackedSampler3D(t3, e3, n3) {
          const r3 = n3.unpackedShape, o2 = r3[1] * r3[2], u3 = r3[2], { newShape: c2, keptDims: l2 } = (0, a.squeezeShape)(r3), p2 = c2;
          if (p2.length < r3.length) {
            const o3 = (0, s.squeezeInputShape)(r3, p2), a2 = ["batch", "col", "row"], u4 = JSON.parse(JSON.stringify(n3));
            u4.unpackedShape = o3;
            const c3 = this.getUnpackedSamplerFromInput(t3, e3, u4), f3 = l2.reverse(), d2 = `
          ${c3.routineBody}
          float ${t3}(int batch, int row, int col) {
            return ${t3}(${(0, s.getSqueezedParams)(a2, f3)});
          }
        `;
            return new i.GlslLibRoutine(d2, c3.dependencies);
          }
          const f2 = `
          float ${t3}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${o2} + col * ${u3} + row;
            vec2 uv = uvFromFlat(${n3.width}, ${n3.height}, index);
            return sampleTexture(${e3}, uv);
          }
      `;
          return new i.GlslLibRoutine(f2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        getUnpackedSampler4D(t3, e3, n3) {
          const r3 = n3.unpackedShape, o2 = r3[3], a2 = r3[2] * o2, s2 = `
        float ${t3}(int row, int col, int depth, int depth2) {
          int index = row * ${r3[1] * a2} + col * ${a2} +
              depth2 * ${o2} + depth;
          vec2 uv = uvFromFlat(${n3.width}, ${n3.height}, index);
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
        }
        getUnpackedSampler5D(t3, e3, n3) {
          const r3 = n3.unpackedShape, o2 = r3[4], u3 = r3[3] * o2, c2 = r3[2] * u3, l2 = r3[1] * c2, { newShape: p2, keptDims: f2 } = (0, a.squeezeShape)(r3);
          if (p2.length < r3.length) {
            const o3 = (0, s.squeezeInputShape)(r3, p2), a2 = ["row", "col", "depth", "depth2", "depth3"], u4 = JSON.parse(JSON.stringify(n3));
            u4.unpackedShape = o3;
            const c3 = `
          ${this.getUnpackedSamplerFromInput(t3, e3, u4).routineBody}
          float ${t3}(int row, int col, int depth, int depth2, int depth3) {
            return ${t3}(${(0, s.getSqueezedParams)(a2, f2)});
          }
        `;
            return new i.GlslLibRoutine(c3, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          const d2 = `
        float ${t3}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l2} + col * ${c2} + depth * ${u3} +
          depth3 * ${o2} + depth2;
          vec2 uv = uvFromFlat(${n3.width}, ${n3.height}, index);
          return sampleTexture(${e3}, uv);
        }
      `;
          return new i.GlslLibRoutine(d2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
        }
        getUnpackedSampler6D(t3, e3, n3) {
          const r3 = n3.unpackedShape, o2 = r3[5], u3 = r3[4] * o2, c2 = r3[3] * u3, l2 = r3[2] * c2, p2 = r3[1] * l2, { newShape: f2, keptDims: d2 } = (0, a.squeezeShape)(r3);
          if (f2.length < r3.length) {
            const o3 = (0, s.squeezeInputShape)(r3, f2), a2 = ["row", "col", "depth", "depth2", "depth3", "depth4"], u4 = JSON.parse(JSON.stringify(n3));
            u4.unpackedShape = o3;
            const c3 = `
            ${this.getUnpackedSamplerFromInput(t3, e3, u4).routineBody}
            float ${t3}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${t3}(${(0, s.getSqueezedParams)(a2, d2)});
            }
          `;
            return new i.GlslLibRoutine(c3, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          const h2 = `
          float ${t3}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p2} + col * ${l2} + depth * ${c2} +
            depth2 * ${u3} + depth3 * ${o2} + depth4;
            vec2 uv = uvFromFlat(${n3.width}, ${n3.height}, index);
            return sampleTexture(${e3}, uv);
          }
        `;
          return new i.GlslLibRoutine(h2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        toVec() {
          const t3 = this.context.outputTextureLayout, e3 = t3.shape.length, n3 = t3.strides, r3 = t3.width, o2 = t3.height, a2 = [];
          for (let t4 = 0; t4 < e3 - 1; ++t4) a2.push(`
        c[${t4}] = offset / ${n3[t4]};`), a2.push(`
        offset -= c[${t4}] * ${n3[t4]};`);
          a2.push(`
        c[${e3 - 1}] = offset;`);
          const s2 = `
      void toVec(vec2 texCoords, out int c[${e3}]) {
        int offset = coordsToOffset(texCoords, ${r3}, ${o2});
        ${a2.join("")}
      }
      void toVec(int offset, out int c[${e3}]) {
        ${a2.join("")}
      }
    `;
          return { toVec: new i.GlslLibRoutine(s2, ["coordinates.coordsToOffset"]) };
        }
        valueFrom() {
          const t3 = {};
          return this.context.programInfo.inputNames.forEach((e3, n3) => {
            const r3 = this.context.inputTextureLayouts[n3], o2 = (r3.unpackedShape.length > 0 ? r3.unpackedShape : r3.shape).length;
            let a2 = `_${e3}`;
            t3[a2] = new i.GlslLibRoutine(this.getValueFromSingle(e3, o2, r3.width, r3.height, false), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), a2 += "_T", t3[a2] = new i.GlslLibRoutine(this.getValueFromSingle(e3, o2, r3.width, r3.height, true), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
          }), t3;
        }
        getValueFromSingle(t3, e3, n3, r3, i2) {
          let a2 = `_${t3}`;
          return i2 && (a2 += "_T"), `
        float ${a2}(int m[${e3}]) {
          int offset = indicesToOffset${a2}(m);
          vec2 coords = offsetToCoords(offset, ${n3}, ${r3});
          float value = getColorAsFloat(${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t3}, coords));
          return value;
        }
        `;
        }
        getPackedValueFrom(t3, e3, n3, r3, i2) {
          let a2 = `_${t3}_Pack`;
          return i2 && (a2 += "_T"), `
        vec4 ${a2}(int m[${e3}]) {
          int offset = indicesToOffset_${t3}(m);
          vec2 coords = offsetToCoords(offset, ${n3}, ${r3});
          return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t3}, coords);
        }
        `;
        }
      }
      e2.CoordsGlslLib = u2;
    }, 8520: (t2, e2) => {
      var n2;
      Object.defineProperty(e2, "__esModule", { value: true }), e2.TopologicalSortGlslRoutines = e2.GlslLibRoutineNode = e2.GlslLibRoutine = e2.GlslLib = e2.GlslContext = e2.FunctionType = void 0, (n2 = e2.FunctionType || (e2.FunctionType = {}))[n2.ValueBased = 0] = "ValueBased", n2[n2.Positional = 1] = "Positional", e2.GlslContext = class {
        constructor(t3, e3, n3, r2) {
          this.glContext = t3, this.programInfo = e3, this.inputTextureLayouts = n3, this.outputTextureLayout = r2;
        }
      }, e2.GlslLib = class {
        constructor(t3) {
          this.context = t3;
        }
      }, e2.GlslLibRoutine = class {
        constructor(t3, e3) {
          this.routineBody = t3, this.dependencies = e3;
        }
      }, e2.GlslLibRoutineNode = class {
        constructor(t3, e3, n3) {
          this.name = t3, this.dependencies = n3 || [], e3 && (this.routineBody = e3);
        }
        addDependency(t3) {
          t3 && this.dependencies.push(t3);
        }
      }, e2.TopologicalSortGlslRoutines = class {
        static returnOrderedNodes(t3) {
          if (!t3 || 0 === t3.length) return [];
          if (1 === t3.length) return t3;
          const e3 = /* @__PURE__ */ new Set(), n3 = /* @__PURE__ */ new Set(), r2 = new Array();
          return this.createOrderedNodes(t3, e3, n3, r2), r2;
        }
        static createOrderedNodes(t3, e3, n3, r2) {
          for (let i = 0; i < t3.length; ++i) this.dfsTraverse(t3[i], e3, n3, r2);
        }
        static dfsTraverse(t3, e3, n3, r2) {
          if (!t3 || n3.has(t3.name)) return;
          if (e3.has(t3.name)) throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
          e3.add(t3.name);
          const i = t3.dependencies;
          if (i && i.length > 0) for (let t4 = 0; t4 < i.length; ++t4) this.dfsTraverse(i[t4], e3, n3, r2);
          r2.push(t3), n3.add(t3.name), e3.delete(t3.name);
        }
      };
    }, 7341: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.EncodingGlslLib = void 0;
      const r2 = n2(8520);
      class i extends r2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getFunctions() {
          return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
        }
        getCustomTypes() {
          return {};
        }
        encodeFloat32() {
          return { encode: new r2.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
        }
        decodeFloat32() {
          return { decode: new r2.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
        }
        encodeUint8() {
          const t3 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
          return { encode: new r2.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${t3}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
        }
        decodeUint8() {
          const t3 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
          return { decode: new r2.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${t3}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
        }
        static isLittleEndian() {
          const t3 = new ArrayBuffer(4), e3 = new Uint32Array(t3), n3 = new Uint8Array(t3);
          if (e3[0] = 3735928559, 239 === n3[0]) return true;
          if (222 === n3[0]) return false;
          throw new Error("unknown endianness");
        }
      }
      e2.EncodingGlslLib = i;
    }, 9894: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.FragColorGlslLib = void 0;
      const r2 = n2(8520), i = n2(5060);
      class o extends r2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getFunctions() {
          return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
        }
        getCustomTypes() {
          return {};
        }
        setFragColor() {
          const t3 = (0, i.getGlsl)(this.context.glContext.version);
          return { setFragColor: new r2.GlslLibRoutine(`
        void setFragColor(float value) {
            ${t3.output} = encode(value);
        }
        `, ["encoding.encode"]) };
        }
        getColorAsFloat() {
          return { getColorAsFloat: new r2.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
        }
      }
      e2.FragColorGlslLib = o;
    }, 2848: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.replaceInlines = void 0;
      const n2 = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
      e2.replaceInlines = function(t3) {
        const e3 = {};
        let r2;
        for (; null !== (r2 = n2.exec(t3)); ) {
          const t4 = r2[3].split(",").map((t5) => {
            const e4 = t5.trim().split(" ");
            return e4 && 2 === e4.length ? { type: e4[0], name: e4[1] } : null;
          }).filter((t5) => null !== t5);
          e3[r2[2]] = { params: t4, body: r2[4] };
        }
        for (const n3 in e3) {
          const i = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n3), o = new RegExp(i, "gm");
          for (; null !== (r2 = o.exec(t3)); ) {
            const i2 = r2[1], o2 = r2[2], a = r2[3].split(","), s = i2 ? `${i2} ${o2};` : "";
            let u2 = e3[n3].body, c2 = "";
            e3[n3].params.forEach((t4, e4) => {
              t4 && (c2 += `${t4.type} ${t4.name} = ${a[e4]};
`);
            }), u2 = `${c2}
 ${u2}`, u2 = u2.replace("return", `${o2} = `);
            const l2 = `
      ${s}
      {
        ${u2}
      }
      `;
            t3 = t3.replace(r2[0], l2);
          }
        }
        return t3.replace(n2, "");
      };
    }, 8879: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.GlslPreprocessor = void 0;
      const r2 = n2(8520), i = n2(2848), o = n2(5483), a = n2(5060);
      e2.GlslPreprocessor = class {
        constructor(t3, e3, n3, i2) {
          this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r2.GlslContext(t3, e3, n3, i2), Object.keys(o.glslRegistry).forEach((t4) => {
            const e4 = new o.glslRegistry[t4](this.context);
            this.libs[t4] = e4;
          });
          const a2 = this.glslLibRoutineDependencyGraph;
          for (const t4 in this.libs) {
            const e4 = this.libs[t4].getFunctions();
            for (const n4 in e4) {
              const i3 = t4 + "." + n4;
              let o2;
              a2[i3] ? (o2 = a2[i3], o2.routineBody = e4[n4].routineBody) : (o2 = new r2.GlslLibRoutineNode(i3, e4[n4].routineBody), a2[i3] = o2);
              const s = e4[n4].dependencies;
              if (s) for (let t5 = 0; t5 < s.length; ++t5) if (a2[s[t5]]) o2.addDependency(a2[s[t5]]);
              else {
                const e5 = new r2.GlslLibRoutineNode(s[t5]);
                a2[s[t5]] = e5, o2.addDependency(e5);
              }
            }
          }
        }
        preprocess() {
          const t3 = this.context.programInfo;
          let e3 = t3.shaderSource;
          return this.context.programInfo.hasMain || (e3 = `${e3}
      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), e3 = (0, i.replaceInlines)(e3), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(t3.inputNames, t3.variables)}
    ${this.getImports(e3)}
    ${e3}`;
        }
        getImports(t3) {
          const e3 = this.selectGlslLibRoutinesToBeIncluded(t3);
          if (0 === e3.length) return "";
          let n3 = "";
          for (let t4 = 0; t4 < e3.length; ++t4) {
            if (!e3[t4].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${e3[t4].name}`);
            n3 += e3[t4].routineBody + "\n";
          }
          return n3;
        }
        selectGlslLibRoutinesToBeIncluded(t3) {
          const e3 = [];
          return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n3) => {
            const r3 = n3.split(".")[1];
            -1 !== t3.indexOf(r3) && e3.push(this.glslLibRoutineDependencyGraph[n3]);
          }), r2.TopologicalSortGlslRoutines.returnOrderedNodes(e3);
        }
        getUniforms(t3, e3) {
          const n3 = [];
          if (t3) for (const e4 of t3) n3.push(`uniform sampler2D ${e4};`);
          if (e3) for (const t4 of e3) n3.push(`uniform ${t4.type} ${t4.name}${t4.arrayLength ? `[${t4.arrayLength}]` : ""};`);
          return n3.join("\n");
        }
      };
    }, 5483: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.glslRegistry = void 0;
      const r2 = n2(5107), i = n2(7341), o = n2(9894), a = n2(2655), s = n2(3891);
      e2.glslRegistry = { encoding: i.EncodingGlslLib, fragcolor: o.FragColorGlslLib, vec: s.VecGlslLib, shapeUtils: a.ShapeUtilsGlslLib, coordinates: r2.CoordsGlslLib };
    }, 2655: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.ShapeUtilsGlslLib = void 0;
      const r2 = n2(8520);
      class i extends r2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getFunctions() {
          return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
        }
        getCustomTypes() {
          return {};
        }
        bcastIndex() {
          const t3 = this.context.outputTextureLayout.shape.length, e3 = {};
          return this.context.programInfo.inputNames.forEach((n3, i2) => {
            const o = this.context.inputTextureLayouts[i2].unpackedShape;
            if (o.length <= t3) {
              const i3 = o.length, a = t3 - i3, s = `bcastIndices_${n3}`;
              let u2 = "";
              for (let t4 = 0; t4 < i3; ++t4) u2 += `
          realIndices[${t4}] = int( mod(float(bcastedIndices[${a + t4}]), ${o[t4]}.0) );
          `;
              const c2 = `
        void ${s} (int bcastedIndices[${t3}], out int realIndices[${i3}]) {
          ${u2}
        }
        `;
              e3[s] = new r2.GlslLibRoutine(c2);
            }
          }), e3;
        }
        bcastMatmulIndex() {
          const t3 = this.context.outputTextureLayout.shape.length, e3 = {};
          return this.context.programInfo.inputNames.forEach((n3, i2) => {
            const o = this.context.inputTextureLayouts[i2].shape;
            if (!(o.length < 2 || o.length > t3)) {
              const i3 = o.length, a = t3 - i3, s = `bcastMatmulIndices_${n3}`;
              let u2 = "";
              for (let t4 = 0; t4 < i3 - 2; ++t4) u2 += `
          realIndices[${t4}] = int( mod(float(bcastedIndices[${a + t4}]), ${o[t4]}.0) );
          `;
              const c2 = `
        void ${s}(int bcastedIndices[${t3}], out int realIndices[${i3}]) {
          ${u2}
          realIndices[${i3 - 1}] = bcastedIndices[${t3 - 1}];
          realIndices[${i3 - 2}] = bcastedIndices[${t3 - 2}];
        }
        `;
              e3[s] = new r2.GlslLibRoutine(c2);
            }
          }), e3;
        }
        indicesToOffset() {
          const t3 = {};
          return this.context.programInfo.inputNames.forEach((e3, n3) => {
            const o = this.context.inputTextureLayouts[n3].shape, a = this.context.inputTextureLayouts[n3].strides, s = o.length;
            let u2 = `indicesToOffset_${e3}`;
            t3[u2] = new r2.GlslLibRoutine(i.indexToOffsetSingle(u2, s, a)), u2 = `indicesToOffset_${e3}_T`, t3[u2] = new r2.GlslLibRoutine(i.indexToOffsetSingle(u2, s, a.slice().reverse()));
          }), t3;
        }
        static indexToOffsetSingle(t3, e3, n3) {
          let r3 = "";
          for (let t4 = e3 - 1; t4 >= 0; --t4) r3 += `
        offset += indices[${t4}] * ${n3[t4]};
        `;
          return `
      int ${t3}(int indices[${e3}]) {
        int offset = 0;
        ${r3}
        return offset;
      }
      `;
        }
        offsetToIndices() {
          const t3 = {};
          return this.context.programInfo.inputNames.forEach((e3, n3) => {
            const o = this.context.inputTextureLayouts[n3].shape, a = this.context.inputTextureLayouts[n3].strides, s = o.length;
            let u2 = `offsetToIndices_${e3}`;
            t3[u2] = new r2.GlslLibRoutine(i.offsetToIndicesSingle(u2, s, a)), u2 = `offsetToIndices_${e3}_T`, t3[u2] = new r2.GlslLibRoutine(i.offsetToIndicesSingle(u2, s, a.slice().reverse()));
          }), t3;
        }
        static offsetToIndicesSingle(t3, e3, n3) {
          const r3 = [];
          for (let t4 = 0; t4 < e3 - 1; ++t4) r3.push(`
      indices[${t4}] = offset / ${n3[t4]};`), r3.push(`
        offset -= indices[${t4}] * ${n3[t4]};`);
          return r3.push(`
      indices[${e3 - 1}] = offset;`), `
      void ${t3}(int offset, out int indices[${e3}]) {
        ${r3.join("")}
      }
      `;
        }
        incrementIndices() {
          const t3 = {};
          return this.context.programInfo.inputNames.forEach((e3, n3) => {
            const i2 = this.context.inputTextureLayouts[n3].shape, o = i2.length, a = `incrementIndices_${e3}`;
            let s = "";
            for (let t4 = 0; t4 < o; ++t4) s += `
        shape[${t4}] = ${i2[t4]};`;
            const u2 = `
        void ${a}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${s};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
            t3[a] = new r2.GlslLibRoutine(u2);
          }), t3;
        }
      }
      e2.ShapeUtilsGlslLib = i;
    }, 5060: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.getDefaultFragShaderMain = e2.getFragShaderPreamble = e2.getVertexShaderSource = e2.getGlsl = void 0;
      const n2 = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r2 = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
      function i(t3) {
        return 1 === t3 ? n2 : r2;
      }
      e2.getGlsl = i, e2.getVertexShaderSource = function(t3) {
        const e3 = i(t3);
        return `${e3.version}
      precision highp float;
      ${e3.attribute} vec3 position;
      ${e3.attribute} vec2 textureCoord;

      ${e3.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
      }, e2.getFragShaderPreamble = function(t3) {
        const e3 = i(t3);
        return `${e3.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e3.varyingFrag} vec2 TexCoords;
    ${e3.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
      }, e2.getDefaultFragShaderMain = function(t3, e3) {
        return `
  void main() {
    int indices[${e3}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i(t3).output} = result;
  }
  `;
      };
    }, 3891: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.VecGlslLib = void 0;
      const r2 = n2(8520);
      class i extends r2.GlslLib {
        constructor(t3) {
          super(t3);
        }
        getCustomTypes() {
          return {};
        }
        getFunctions() {
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
        }
        binaryVecFunctions() {
          const t3 = this.context.outputTextureLayout.shape.length, e3 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n3 = {};
          for (const i2 in e3) {
            const o = `${i2}Vec`;
            let a = "";
            for (let n4 = 0; n4 < t3; ++n4) a += `
          dest[${n4}] ${e3[i2]} src[${n4}];
          `;
            const s = `
        void ${o}(int src[${t3}], out int dest[${t3}]) {
          ${a}
        }
        `;
            n3[o] = new r2.GlslLibRoutine(s);
          }
          return n3;
        }
        copyVec() {
          const t3 = this.context.outputTextureLayout.shape.length;
          let e3 = "";
          for (let n4 = 0; n4 < t3; ++n4) e3 += `
        dest[${n4}] = src[${n4}];
        `;
          const n3 = `
      void copyVec(int src[${t3}], out int dest[${t3}]) {
        ${e3}
      }
      `;
          return { copyVec: new r2.GlslLibRoutine(n3) };
        }
        setVecItem() {
          const t3 = this.context.outputTextureLayout.shape.length;
          let e3 = `
        if(index < 0)
            index =${t3} + index;
        if (index == 0)
            m[0] = value;
        `;
          for (let n4 = 1; n4 < t3 - 1; ++n4) e3 += `
        else if (index == ${n4})
            m[${n4}] = value;
            `;
          e3 += `
        else
            m[${t3 - 1}] = value;
        `;
          const n3 = `
      void setVecItem(out int m[${t3}], int index, int value) {
        ${e3}
      }
        `;
          return { setVecItem: new r2.GlslLibRoutine(n3) };
        }
        getVecItem() {
          const t3 = this.context.outputTextureLayout.shape.length;
          let e3 = `
        if(index < 0)
            index = ${t3} + index;
        if (index == 0)
            return m[0];
      `;
          for (let n4 = 1; n4 < t3 - 1; ++n4) e3 += `
        else if (index == ${n4})
            return m[${n4}];
      `;
          e3 += `
        else
            return m[${t3 - 1}];
        `;
          const n3 = `
      int getVecItem(int m[${t3}], int index) {
        ${e3}
      }
    `;
          return { getVecItem: new r2.GlslLibRoutine(n3) };
        }
      }
      e2.VecGlslLib = i;
    }, 8316: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebGLInferenceHandler = void 0;
      const r2 = n2(6231), i = n2(9162), o = n2(2517), a = n2(2403), s = n2(7019), u2 = n2(8710), c2 = n2(5611), l2 = n2(4057), p2 = n2(2039);
      e2.WebGLInferenceHandler = class {
        constructor(t3) {
          this.session = t3, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        calculateTextureWidthAndHeight(t3, e3) {
          return (0, l2.calculateTextureWidthAndHeight)(this.session.layoutStrategy, t3, e3);
        }
        executeProgram(t3, e3) {
          if (e3.length < t3.inputNames.length) throw new Error(`Input size mustn't be less than ${t3.inputNames.length}.`);
          if (t3.inputNames.length !== t3.inputTypes.length) throw new Error("input names size does not match input types");
          const n3 = [];
          for (let r4 = 0; r4 < t3.inputNames.length; ++r4) n3[r4] = this.getOrCreateTextureData(e3[r4], t3.inputTypes[r4]);
          const r3 = ((t4, e4) => {
            const n4 = e4.map((t5) => `${t5.unpackedShape.join(",")};${t5.width}x${t5.height}`).join("_");
            let r4 = t4.name;
            return t4.cacheHint && (r4 += "[" + t4.cacheHint + "]"), r4 += ":" + n4, r4;
          })(t3, n3);
          let i2 = this.session.programManager.getArtifact(r3);
          const o2 = i2 ? i2.programInfo : "function" == typeof t3.get ? t3.get() : t3, a2 = (0, l2.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2.output.dims, o2.output.textureType), s2 = this.createTextureData(a2, o2.output.type);
          return i2 || (i2 = this.session.programManager.build(o2, n3, s2), this.session.programManager.setArtifact(r3, i2)), this.runProgram(i2, n3, s2), s2;
        }
        run(t3, e3) {
          return this.executeProgram(t3, e3).tensor;
        }
        runProgram(t3, e3, n3) {
          for (let n4 = 0; n4 < e3.length; ++n4) if (!!e3[n4].isPacked != (t3.programInfo.inputTypes[n4] === p2.TextureType.packed)) throw new Error(`input[${n4}] property packed inconsistent`);
          if (!!n3.isPacked != (t3.programInfo.output.textureType === p2.TextureType.packed)) throw new Error("output property packed inconsistent");
          this.session.programManager.run(t3, e3, n3);
        }
        getOrCreateTextureData(t3, e3) {
          let n3 = this.getTextureData(t3.dataId, e3 === p2.TextureType.packed);
          if (!n3 && (n3 = this.getTextureData(t3.dataId, e3 !== p2.TextureType.packed), n3)) return e3 === p2.TextureType.packed ? this.pack(n3) : this.unpack(n3);
          if (!n3) {
            const r3 = (0, l2.createTextureLayoutFromTextureType)(this.session.layoutStrategy, t3.dims, e3);
            if (e3 === p2.TextureType.packedLastDimension) {
              const n4 = 1, r4 = 4, i2 = t3.dims;
              if (4 === i2.length) {
                const o2 = [i2[0], Math.ceil(i2[1] * i2[2] * i2[3] / r4)], a2 = (0, l2.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2, e3);
                let s2 = t3.numberData;
                if (i2[1] * i2[2] * i2[3] % r4 != 0) {
                  const e4 = i2[0], o3 = i2[1] * i2[2] * i2[3], a3 = Math.ceil(o3 * n4 / r4) * r4;
                  s2 = new Float32Array(e4 * a3);
                  for (let r5 = 0; r5 < e4; ++r5) {
                    const e5 = r5 * o3, i3 = r5 * a3 + r5 % n4 * o3;
                    s2.set(t3.numberData.subarray(e5, e5 + o3), i3);
                  }
                }
                return this.createTextureData(a2, t3.type, s2, t3, 1);
              }
            }
            if (e3 === p2.TextureType.packed) {
              const e4 = (0, l2.createTextureLayoutFromShape)(this.session.layoutStrategy, t3.dims, 1, [], { reverseWH: true }), r4 = this.createTextureData(e4, t3.type, t3.numberData, t3, 1);
              n3 = this.pack(r4);
            } else n3 = this.createTextureData(r3, t3.type, t3.numberData, t3, 1);
          }
          return n3;
        }
        createTextureDataFromLayoutBindTensor(t3, e3, n3, r3) {
          return this.createTextureData(t3, e3, n3, r3, 1);
        }
        createTextureData(t3, e3, n3, i2, o2) {
          r2.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(t3)}]`);
          const a2 = this.session.textureManager.createTextureFromLayout(e3, t3, n3, o2);
          return this.createTextureDataFromTexture(t3, e3, a2, i2);
        }
        reshapeUnpacked(t3, e3) {
          const n3 = this.getOrCreateTextureData(t3, p2.TextureType.unpacked), r3 = { channels: n3.channels, height: n3.height, width: n3.width, shape: 0 !== e3.length ? e3 : [1], strides: o.ShapeUtil.computeStrides(e3), unpackedShape: e3 };
          return this.createTextureDataFromTexture(r3, t3.type, n3.texture).tensor;
        }
        reshapePacked(t3, e3) {
          const n3 = this.getOrCreateTextureData(t3, p2.TextureType.packed);
          if ((0, s.isReshapeCheap)(t3.dims, e3)) {
            const r4 = { channels: n3.channels, height: n3.height, width: n3.width, shape: 0 !== e3.length ? e3 : [1], strides: o.ShapeUtil.computeStrides(e3), unpackedShape: e3, isPacked: true };
            return this.createTextureDataFromTexture(r4, t3.type, n3.texture).tensor;
          }
          const r3 = (0, s.processDims3D)(t3.dims), i2 = (0, s.processDims3D)(e3), a2 = this.reshapePacked(t3, r3), u3 = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a2, i2), [a2]);
          return this.reshapePacked(u3, e3);
        }
        cast(t3, e3) {
          const n3 = this.getOrCreateTextureData(t3, p2.TextureType.unpacked);
          return this.createTextureDataFromTexture(n3, e3, n3.texture).tensor;
        }
        createTextureDataFromTexture(t3, e3, n3, r3, o2) {
          const a2 = Object.assign(Object.assign({}, t3), { tensor: r3 || new i.Tensor(t3.unpackedShape, e3, (t4) => this.readTexture(a2), async (t4) => this.readTextureAsync(a2), void 0, o2), texture: n3 });
          return this.setTextureData(a2.tensor.dataId, a2, t3.isPacked), a2;
        }
        getTextureData(t3, e3 = false) {
          return this.session.isInitializer(t3) ? this.session.getTextureData(t3, e3) : e3 ? this.packedTextureDataCache.get(t3) : this.unpackedTextureDataCache.get(t3);
        }
        setTextureData(t3, e3, n3 = false) {
          this.session.isInitializer(t3) ? this.session.setTextureData(t3, e3, n3) : (n3 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(t3, e3);
        }
        isTextureLayoutCached(t3, e3 = false) {
          return !!this.getTextureData(t3.dataId, e3);
        }
        dispose() {
          this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t3) => this.session.textureManager.releaseTexture(t3)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t3) => this.session.textureManager.releaseTexture(t3)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        readTexture(t3) {
          return t3.isPacked ? this.readTexture(this.unpack(t3)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(t3, t3.tensor.type, t3.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u2.encodeAsUint8)(this, t3));
        }
        async readTextureAsync(t3) {
          return t3.isPacked ? this.readTextureAsync(this.unpack(t3)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(t3, t3.tensor.type, t3.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u2.encodeAsUint8)(this, t3));
        }
        pack(t3) {
          return this.executeProgram((0, a.createPackProgramInfoLoader)(this, t3.tensor), [t3.tensor]);
        }
        unpack(t3) {
          return this.executeProgram((0, c2.createUnpackProgramInfoLoader)(this, t3.tensor), [t3.tensor]);
        }
      };
    }, 1640: function(t2, e2, n2) {
      var r2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i2 = Object.getOwnPropertyDescriptor(e3, n3);
        i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i2);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), i = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
        Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
      } : function(t3, e3) {
        t3.default = e3;
      }), o = this && this.__importStar || function(t3) {
        if (t3 && t3.__esModule) return t3;
        var e3 = {};
        if (null != t3) for (var n3 in t3) "default" !== n3 && Object.prototype.hasOwnProperty.call(t3, n3) && r2(e3, t3, n3);
        return i(e3, t3), e3;
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WEBGL_OP_RESOLVE_RULES = void 0;
      const a = n2(2898), s = o(n2(7839)), u2 = n2(4196), c2 = n2(2069), l2 = n2(8138), p2 = n2(9663), f2 = n2(5193), d2 = n2(7992), h2 = n2(1253), g2 = n2(4776), b2 = n2(6572), m2 = n2(3346), y2 = n2(5623), _ = n2(2870), v2 = n2(2143), w2 = n2(4939), x2 = n2(718), T2 = n2(2268), S2 = n2(8117), O2 = n2(2278), A2 = n2(5524), E2 = n2(5975), I2 = n2(3933), P2 = n2(6558), D2 = n2(5723), $ = n2(3738), k2 = o(n2(4909)), C2 = n2(8428), F2 = n2(9793);
      e2.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", k2.abs], ["Acos", "", "7+", k2.acos], ["Add", "", "7+", s.add], ["And", "", "7+", s.and], ["Asin", "", "7+", k2.asin], ["Atan", "", "7+", k2.atan], ["AveragePool", "", "7+", v2.averagePool, v2.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", a.batchNormalization, a.parseBatchNormalizationAttributes], ["Cast", "", "6+", u2.cast, u2.parseCastAttributes], ["Ceil", "", "6+", k2.ceil], ["Clip", "", "6-10", k2.clip, k2.parseClipAttributes], ["Clip", "", "11+", k2.clipV11], ["Concat", "", "4+", c2.concat, c2.parseConcatAttributes], ["Conv", "", "1+", l2.conv, l2.parseConvAttributes], ["ConvTranspose", "", "1+", p2.convTranspose, p2.parseConvTransposeAttributes], ["Cos", "", "7+", k2.cos], ["Div", "", "7+", s.div], ["Dropout", "", "7+", k2.identity], ["DepthToSpace", "", "1+", f2.depthToSpace, f2.parseDepthToSpaceAttributes], ["Equal", "", "7+", s.equal], ["Elu", "", "6+", k2.elu, k2.parseEluAttributes], ["Exp", "", "6+", k2.exp], ["Flatten", "", "1+", d2.flatten, d2.parseFlattenAttributes], ["Floor", "", "6+", k2.floor], ["FusedConv", "com.microsoft", "1+", l2.conv, l2.parseConvAttributes], ["Gather", "", "1+", h2.gather, h2.parseGatherAttributes], ["Gemm", "", "7-10", g2.gemm, g2.parseGemmAttributesV7], ["Gemm", "", "11+", g2.gemm, g2.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", v2.globalAveragePool, v2.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", v2.globalMaxPool], ["Greater", "", "7+", s.greater], ["Identity", "", "1+", k2.identity], ["ImageScaler", "", "1+", b2.imageScaler, b2.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", m2.instanceNormalization, m2.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", k2.leakyRelu, k2.parseLeakyReluAttributes], ["Less", "", "7+", s.less], ["Log", "", "6+", k2.log], ["MatMul", "", "1+", y2.matMul, y2.parseMatMulAttributes], ["MaxPool", "", "1+", v2.maxPool, v2.parseMaxPoolAttributes], ["Mul", "", "7+", s.mul], ["Neg", "", "6+", k2.neg], ["Not", "", "1+", k2.not], ["Or", "", "7+", s.or], ["Pad", "", "2-10", _.padV2, _.parsePadAttributesV2], ["Pad", "", "11+", _.padV11, _.parsePadAttributesV11], ["Pow", "", "7+", s.pow], ["PRelu", "", "7+", s.pRelu], ["ReduceLogSum", "", "1+", w2.reduceLogSum, w2.parseReduceAttributes], ["ReduceMax", "", "1+", w2.reduceMax, w2.parseReduceAttributes], ["ReduceMean", "", "1+", w2.reduceMean, w2.parseReduceAttributes], ["ReduceMin", "", "1+", w2.reduceMin, w2.parseReduceAttributes], ["ReduceProd", "", "1+", w2.reduceProd, w2.parseReduceAttributes], ["ReduceSum", "", "1-12", w2.reduceSum, w2.parseReduceAttributes], ["ReduceSumSquare", "", "1+", w2.reduceLogSumSquare, w2.parseReduceAttributes], ["Relu", "", "6+", k2.relu], ["Reshape", "", "5+", x2.reshape], ["Resize", "", "10", T2.resize, T2.parseResizeAttributesV10], ["Resize", "", "11+", T2.resize, T2.parseResizeAttributesV11], ["Shape", "", "1+", S2.shape], ["Sigmoid", "", "6+", k2.sigmoid], ["Sin", "", "7+", k2.sin], ["Slice", "", "10+", O2.sliceV10], ["Slice", "", "1-9", O2.slice, O2.parseSliceAttributes], ["Softmax", "", "1-12", A2.softmax, A2.parseSoftmaxAttributes], ["Softmax", "", "13+", A2.softmaxV13, A2.parseSoftmaxAttributesV13], ["Split", "", "2-12", E2.split, E2.parseSplitAttributes], ["Sqrt", "", "6+", k2.sqrt], ["Squeeze", "", "1-12", I2.squeeze, I2.parseSqueezeAttributes], ["Squeeze", "", "13+", I2.squeezeV13], ["Sub", "", "7+", s.sub], ["Sum", "", "6+", P2.sum], ["Tan", "", "7+", k2.tan], ["Tanh", "", "6+", k2.tanh], ["Tile", "", "6+", D2.tile], ["Transpose", "", "1+", $.transpose, $.parseTransposeAttributes], ["Upsample", "", "7-8", F2.upsample, F2.parseUpsampleAttributesV7], ["Upsample", "", "9", F2.upsample, F2.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", C2.unsqueeze, C2.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", C2.unsqueezeV13], ["Xor", "", "7+", s.xor]];
    }, 2898: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseBatchNormalizationAttributes = e2.batchNormalization = void 0;
      const r2 = n2(246), i = n2(5060), o = n2(2039), a = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] };
      e2.batchNormalization = (t3, e3, n3) => (u2(e3), [t3.run(Object.assign(Object.assign({}, a), { cacheHint: n3.cacheKey, get: () => s(t3, e3, n3) }), e3)]), e2.parseBatchNormalizationAttributes = (t3) => {
        const e3 = t3.attributes.getFloat("epsilon", 1e-5), n3 = t3.attributes.getFloat("momentum", 0.9), i2 = t3.attributes.getInt("spatial", 1);
        return (0, r2.createAttributeWithCacheKey)({ epsilon: e3, momentum: n3, spatial: i2 });
      };
      const s = (t3, e3, n3) => {
        const r3 = (0, i.getGlsl)(t3.session.backend.glContext.version), s2 = e3[0].dims.length, [u3, c2] = t3.calculateTextureWidthAndHeight(e3[1].dims, o.TextureType.unpacked), l2 = `
  float process(int[${s2}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u3}, ${c2});
    float scale = getColorAsFloat(${r3.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r3.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r3.texture2D}(Variance, position));
    float b = getColorAsFloat(${r3.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n3.epsilon})) ) + b;
  }`;
        return Object.assign(Object.assign({}, a), { output: { dims: e3[0].dims, type: e3[0].type, textureType: o.TextureType.unpacked }, shaderSource: l2 });
      }, u2 = (t3) => {
        if (!t3 || 5 !== t3.length) throw new Error("BatchNormalization requires 5 inputs.");
        const e3 = t3[0], n3 = t3[1], r3 = t3[2], i2 = t3[3], o2 = t3[4];
        if (e3.dims.length < 3 || 1 !== n3.dims.length || 1 !== r3.dims.length || 1 !== i2.dims.length || 1 !== o2.dims.length) throw new Error("invalid input shape.");
        if (n3.dims[0] !== e3.dims[1] || r3.dims[0] !== e3.dims[1] || i2.dims[0] !== e3.dims[1] || o2.dims[0] !== e3.dims[1]) throw new Error("invalid input shape.");
        if ("float32" !== e3.type && "float64" !== e3.type || "float32" !== n3.type && "float64" !== n3.type || "float32" !== r3.type && "float64" !== r3.type || "float32" !== i2.type && "float64" !== i2.type || "float32" !== o2.type && "float64" !== o2.type) throw new Error("invalid input tensor types.");
      };
    }, 7839: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.xor = e2.sub = e2.pRelu = e2.pow = e2.or = e2.mul = e2.less = e2.greater = e2.equal = e2.div = e2.and = e2.add = e2.glslPRelu = e2.glslPow = e2.glslXor = e2.glslOr = e2.glslAnd = e2.glslLess = e2.glslGreater = e2.glslEqual = e2.glslSub = e2.glslMul = e2.glslDiv = e2.glslAdd = void 0;
      const r2 = n2(2517), i = n2(8520), o = n2(5060), a = n2(2039);
      function s() {
        const t3 = "add_";
        return { body: `
  float ${t3}(float a, float b) {
    return a + b;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function u2() {
        const t3 = "div_";
        return { body: `
  float ${t3}(float a, float b) {
    return a / b;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function c2() {
        const t3 = "mul_";
        return { body: `
  float ${t3}(float a, float b) {
    return a * b;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function l2() {
        const t3 = "sub_";
        return { body: `
  float ${t3}(float a, float b) {
    return a - b;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function p2() {
        const t3 = "equal_";
        return { body: `
  float ${t3}(float a, float b) {
    return float(a == b);
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function f2() {
        const t3 = "greater_";
        return { body: `
  float ${t3}(float a, float b) {
    return float(a > b);
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function d2() {
        const t3 = "less_";
        return { body: `
  float ${t3}(float a, float b) {
    return float(a < b);
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function h2() {
        const t3 = "and_";
        return { body: `
  float ${t3}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function g2() {
        const t3 = "or_";
        return { body: `
  float ${t3}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function b2() {
        const t3 = "xor_";
        return { body: `
  float ${t3}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      function m2() {
        return function(t3) {
          const e3 = `${t3}_`;
          return { body: `
  float ${e3}(float a, float b) {
    return ${t3}(a, b);
  }
  vec4 ${e3}(vec4 v1, vec4 v2) {
    return ${t3}(v1, v2);
  }
  `, name: e3, type: i.FunctionType.ValueBased };
        }("pow");
      }
      function y2() {
        const t3 = "prelu_";
        return { body: `
  float ${t3}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${t3}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: t3, type: i.FunctionType.ValueBased };
      }
      e2.glslAdd = s, e2.glslDiv = u2, e2.glslMul = c2, e2.glslSub = l2, e2.glslEqual = p2, e2.glslGreater = f2, e2.glslLess = d2, e2.glslAnd = h2, e2.glslOr = g2, e2.glslXor = b2, e2.glslPow = m2, e2.glslPRelu = y2;
      const _ = (t3, e3, n3, r3 = e3[0].type, i2) => {
        const o2 = t3.session.pack ? a.TextureType.packed : a.TextureType.unpacked;
        return { name: n3.name, inputNames: ["A", "B"], inputTypes: [o2, o2], cacheHint: i2, get: () => v2(t3, e3, n3, r3) };
      }, v2 = (t3, e3, n3, i2 = e3[0].type) => {
        const s2 = t3.session.pack ? a.TextureType.packed : a.TextureType.unpacked, u3 = !r2.ShapeUtil.areEqual(e3[0].dims, e3[1].dims);
        let c3 = e3[0].dims;
        const l3 = t3.session.pack;
        if (u3) {
          const a2 = r2.BroadcastUtil.calcShape(e3[0].dims, e3[1].dims, false);
          if (!a2) throw new Error("Can't perform binary op on the given tensors");
          c3 = a2;
          const u4 = c3.length, p4 = 0 !== e3[0].dims.length ? e3[0].dims.length : 1, f4 = 0 !== e3[1].dims.length ? e3[1].dims.length : 1, d3 = 0 !== e3[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h3 = 0 !== e3[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g3 = (0, o.getGlsl)(t3.session.backend.glContext.version), b3 = l3 ? `
      ${n3.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n3.name}(a, b);
        ${g3.output} = result;
      }` : `
      ${n3.body}
      float process(int indices[${u4}]) {
        int aindices[${p4}];
        int bindices[${f4}];
        ${d3}
        ${h3}
        return ${n3.name}(_A(aindices), _B(bindices));
      }`;
          return { name: n3.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: c3, type: i2, textureType: s2 }, shaderSource: b3, hasMain: l3 };
        }
        const p3 = (0, o.getGlsl)(t3.session.backend.glContext.version), f3 = `
    ${n3.body}
    void main() {
      vec4 v1 = ${p3.texture2D}(A, TexCoords);
      vec4 v2 = ${p3.texture2D}(B, TexCoords);
      vec4 result = ${n3.name}(v1, v2);
      ${p3.output} = result;
    }
    `;
        return { name: n3.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: e3[0].dims, type: i2, textureType: s2 }, shaderSource: f3, hasMain: true };
      };
      e2.add = (t3, e3) => [t3.run(_(t3, e3, s()), e3)], e2.and = (t3, e3) => [t3.run(_(t3, e3, h2(), "bool"), e3)], e2.div = (t3, e3) => [t3.run(_(t3, e3, u2()), e3)], e2.equal = (t3, e3) => [t3.run(_(t3, e3, p2(), "bool"), e3)], e2.greater = (t3, e3) => [t3.run(_(t3, e3, f2(), "bool"), e3)], e2.less = (t3, e3) => [t3.run(_(t3, e3, d2(), "bool"), e3)], e2.mul = (t3, e3) => [t3.run(_(t3, e3, c2()), e3)], e2.or = (t3, e3) => [t3.run(_(t3, e3, g2(), "bool"), e3)], e2.pow = (t3, e3) => [t3.run(_(t3, e3, m2()), e3)], e2.pRelu = (t3, e3) => [t3.run(_(t3, e3, y2()), e3)], e2.sub = (t3, e3) => [t3.run(_(t3, e3, l2()), e3)], e2.xor = (t3, e3) => [t3.run(_(t3, e3, b2(), "bool"), e3)];
    }, 4196: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseCastAttributes = e2.cast = void 0;
      const r2 = n2(2517);
      e2.cast = (t3, e3, n3) => (i(e3), [t3.cast(e3[0], n3)]), e2.parseCastAttributes = (t3) => r2.ProtoUtil.tensorDataTypeFromProto(t3.attributes.getInt("to"));
      const i = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Cast requires 1 input.");
        if ("string" === t3[0].type) throw new Error("Invalid input type.");
      };
    }, 1163: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createPackedConcatProgramInfoLoader = void 0;
      const r2 = n2(5060), i = n2(2039), o = n2(9390), a = n2(2827);
      e2.createPackedConcatProgramInfoLoader = (t3, e3, n3) => {
        const u2 = (c2 = e3.length, l2 = n3.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: c2 }, (t4, e4) => `X${e4}`), inputTypes: Array(c2).fill(i.TextureType.packed), cacheHint: l2 });
        var c2, l2;
        return Object.assign(Object.assign({}, u2), { get: () => ((t4, e4, n4, u3) => {
          const c3 = n4[0].dims.slice();
          if (u3 >= c3.length || u3 < -1 * c3.length) throw new Error("axis specified for concat doesn't match input dimensionality");
          u3 < 0 && (u3 = c3.length + u3);
          const l3 = c3.slice(0);
          for (let t5 = 1; t5 < n4.length; t5++) {
            const e5 = n4[t5].dims.slice();
            for (let t6 = 0; t6 < c3.length; t6++) if (t6 === u3) l3[u3] += e5[t6];
            else if (c3[t6] !== e5[t6]) throw new Error("non concat dimensions must match");
          }
          const p2 = l3.length, f2 = (0, a.getChannels)("coords", p2), d2 = (0, o.getCoordsDataType)(p2), h2 = (0, a.unpackFromChannel)(), g2 = n4.map((t5) => t5.dims), b2 = (0, o.getGlChannels)(p2), m2 = new Array(g2.length - 1);
          m2[0] = g2[0][u3];
          for (let t5 = 1; t5 < m2.length; t5++) m2[t5] = m2[t5 - 1] + g2[t5][u3];
          const y2 = b2[u3], _ = b2.slice(-2), v2 = b2.join();
          let w2 = `if (${y2} < ${m2[0]}) {
        return getChannel(
            getX0(${v2}), vec2(${_.join()}));
        }`;
          for (let t5 = 1; t5 < m2.length; t5++) {
            const e5 = m2[t5 - 1];
            w2 += `
            if (${y2} < ${m2[t5]}  && ${y2} >= ${m2[t5 - 1]}) {
              return getChannel(
                getX${t5}(${s(b2, y2, e5)}),
                vec2(${s(_, y2, e5)}));
            }`;
          }
          const x2 = m2.length, T2 = m2[m2.length - 1];
          w2 += `
            return getChannel(
              getX${x2}(${s(b2, y2, T2)}),
              vec2(${s(_, y2, T2)}));`;
          const S2 = (0, r2.getGlsl)(t4.session.backend.glContext.version), O2 = `
          ${h2}
          float getValue(${b2.map((t5) => "int " + t5)}) {
            ${w2}
          }

          void main() {
            ${d2} coords = getOutputCoords();
            int lastDim = coords.${b2[p2 - 1]};
            coords.${b2[p2 - 1]} = coords.${b2[p2 - 2]};
            coords.${b2[p2 - 2]} = lastDim;

            vec4 result = vec4(getValue(${f2}), 0., 0., 0.);

            ${f2[p2 - 1]} = ${f2[p2 - 1]} + 1;
            if (${f2[p2 - 1]} < ${l3[p2 - 1]}) {
              result.g = getValue(${f2});
            }

            ${f2[p2 - 2]} = ${f2[p2 - 2]} + 1;
            if (${f2[p2 - 2]} < ${l3[p2 - 2]}) {
              result.a = getValue(${f2});
            }

            ${f2[p2 - 1]} = ${f2[p2 - 1]} - 1;
            if (${f2[p2 - 2]} < ${l3[p2 - 2]} &&
                ${f2[p2 - 1]} < ${l3[p2 - 1]}) {
              result.b = getValue(${f2});
            }
            ${S2.output} = result;
          }
        `;
          return Object.assign(Object.assign({}, e4), { output: { dims: l3, type: n4[0].type, textureType: i.TextureType.packed }, shaderSource: O2, hasMain: true });
        })(t3, u2, e3, n3.axis) });
      };
      const s = (t3, e3, n3) => {
        const r3 = t3.indexOf(e3);
        return t3.map((t4, e4) => e4 === r3 ? `${t4} - ${n3}` : t4).join();
      };
    }, 2069: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseConcatAttributes = e2.concat = void 0;
      const r2 = n2(246), i = n2(2039), o = n2(1163);
      e2.concat = (t3, e3, n3) => (p2(e3), t3.session.pack && e3[0].dims.length > 1 ? [t3.run((0, o.createPackedConcatProgramInfoLoader)(t3, e3, n3), e3)] : [t3.run(a(t3, e3, n3), e3)]);
      const a = (t3, e3, n3) => {
        const r3 = (o2 = e3.length, a2 = n3.cacheKey, { name: "Concat", inputNames: Array.from({ length: o2 }, (t4, e4) => `X${e4}`), inputTypes: Array(o2).fill(i.TextureType.unpacked), cacheHint: a2 });
        var o2, a2;
        return Object.assign(Object.assign({}, r3), { get: () => ((t4, e4, n4, r4) => {
          const o3 = n4[0].dims.slice();
          if (r4 >= o3.length || r4 < -1 * o3.length) throw new Error("axis specified for concat doesn't match input dimensionality");
          r4 < 0 && (r4 = o3.length + r4);
          const a3 = o3.slice(0);
          for (let t5 = 1; t5 < n4.length; t5++) {
            const e5 = n4[t5].dims.slice();
            for (let t6 = 0; t6 < o3.length; t6++) if (t6 === r4) a3[r4] += e5[t6];
            else if (o3[t6] !== e5[t6]) throw new Error("non concat dimensions must match");
          }
          const p3 = a3.length, f2 = new Array(n4.length);
          let d2 = 0;
          for (let t5 = 0; t5 < f2.length; ++t5) d2 += n4[t5].dims[r4], f2[t5] = d2;
          let h2 = "";
          h2 = n4.length < 5 ? s(f2) : u2(f2);
          const g2 = `
        ${c2(n4.length, p3)}
        ${l2(f2)}
        ${h2}
        float process(int indices[${p3}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r4}]);

          if(textureIndex != 0) {
            indices[${r4}] = indices[${r4}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: a3, type: n4[0].type, textureType: i.TextureType.unpacked }, shaderSource: g2 });
        })(0, r3, e3, n3.axis) });
      }, s = (t3) => `int getTextureWhereDataResides(int index) {
      ${t3.map((t4, e3) => `if(index<${t4}) {return ${e3};}
`).join("")}
    }`, u2 = (t3) => s(t3), c2 = (t3, e3) => {
        const n3 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e3}]) {`];
        for (let e4 = 0; e4 < t3; ++e4) 0 === e4 ? n3.push(`	if (textureIndex == ${e4}) { return _X${e4}(indices); }`) : e4 === t3 - 1 ? n3.push(`	else { return _X${e4}(indices); }`) : n3.push(`	else if (textureIndex == ${e4}) { return _X${e4}(indices); }`);
        return n3.push("	}"), n3.join("\n");
      }, l2 = (t3) => {
        const e3 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
        for (let n3 = 0; n3 < t3.length; ++n3) 0 === n3 ? e3.push(`	if (index == ${n3}) { return ${t3[n3]}; }`) : n3 === t3.length - 1 ? e3.push(`	else { return ${t3[n3]}; }`) : e3.push(`	else if (index == ${n3}) { return ${t3[n3]}; }`);
        return e3.push("	}"), e3.join("\n");
      };
      e2.parseConcatAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ axis: t3.attributes.getInt("axis") });
      const p2 = (t3) => {
        if (!t3 || t3.length < 1) throw new Error("too few inputs");
        const e3 = t3[0].type, n3 = t3[0].dims.length;
        if ("string" === e3) throw new Error("string tensor is not supported yet");
        for (const r3 of t3) {
          if (r3.type !== e3) throw new Error("input tensors should be one type");
          if (r3.dims.length !== n3) throw new Error("input tensors should have the same shape");
        }
      };
    }, 4770: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createUnpackedGroupedConvProgramInfoLoader = void 0;
      const r2 = n2(6231), i = n2(5060), o = n2(2039), a = n2(8138), s = n2(2823);
      e2.createUnpackedGroupedConvProgramInfoLoader = (t3, e3, n3) => {
        const u2 = (c2 = e3.length > 2, l2 = n3.cacheKey, { name: "GroupedConv", inputNames: c2 ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: c2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: l2 });
        var c2, l2;
        return Object.assign(Object.assign({}, u2), { get: () => ((t4, e4, n4, u3) => {
          const c3 = e4.length > 2 ? "value += getBias(output_channel);" : "", l3 = e4[0].dims.slice(), p2 = e4[1].dims.slice(), f2 = p2[0] / u3.group;
          r2.Logger.verbose("GroupedConv", `autpPad:${u3.autoPad}, dilations:${u3.dilations}, group:${u3.group}, kernelShape:${u3.kernelShape}, pads:${u3.pads}, strides:${u3.strides}`);
          const d2 = (0, a.calculateOutputShape)(l3, p2, u3.dilations, u3.pads, u3.strides), h2 = (0, i.getGlsl)(t4.session.backend.glContext.version), { activationFunction: g2, applyActivation: b2 } = (0, s.getActivationSnippet)(u3), m2 = `
  const ivec2 strides = ivec2(${u3.strides[0]}, ${u3.strides[1]});
  const ivec2 pads = ivec2(${u3.pads[0]}, ${u3.pads[1]});
  ${g2}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${f2};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p2[1]}; wInChannel++) {
      int input_channel = group_id * ${p2[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p2[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${u3.dilations[0]};

        if (xHeight < 0 || xHeight >= ${l3[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p2[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${u3.dilations[1]};
          if (xWidth < 0 || xWidth >= ${l3[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${c3}
    ${b2}
    ${h2.output} = vec4(value, .0, .0, .0);
  }
`;
          return Object.assign(Object.assign({}, n4), { output: { dims: d2, type: e4[0].type, textureType: o.TextureType.unpacked }, shaderSource: m2, hasMain: true });
        })(t3, e3, u2, n3) });
      };
    }, 1386: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.conv2DPacked = e2.conv2DPackedPointwise = void 0;
      const r2 = n2(8138), i = n2(8555), o = n2(708);
      e2.conv2DPackedPointwise = (t3, e3, n3) => {
        const i2 = e3[0].dims, a = e3[1].dims, s = (0, r2.calculateOutputShape)(i2, a, n3.dilations, n3.pads, n3.strides), u2 = t3.reshapePacked(e3[0], [i2[1], i2[2] * i2[3]]), c2 = t3.reshapePacked(e3[1], [a[0], a[1]]), l2 = e3.length > 2 ? [c2, u2, e3[2]] : [c2, u2], p2 = t3.run((0, o.createPackedMatmulProgramInfoLoader)(t3, l2, n3), l2);
        return t3.reshapePacked(p2, s);
      }, e2.conv2DPacked = (t3, e3, n3) => {
        const a = e3[0].dims, s = e3[1].dims, u2 = (0, r2.calculateOutputShape)(a, s, n3.dilations, n3.pads, n3.strides), c2 = t3.run((0, i.createPackedIm2ColProgramInfoLoader)(t3, e3[0], e3[1], u2, n3), [e3[0]]), l2 = t3.reshapePacked(e3[1], [s[0], s[1] * s[2] * s[3]]), p2 = 3 === e3.length ? [l2, c2, e3[2]] : [l2, c2], f2 = t3.run((0, o.createPackedMatmulProgramInfoLoader)(t3, p2, n3), p2);
        return t3.reshapePacked(f2, u2);
      };
    }, 9663: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseConvTransposeAttributes = e2.convTranspose = void 0;
      const r2 = n2(246), i = n2(5060), o = n2(2039), a = n2(2823), s = (t3, e3, n3, r3, i2, o2) => (t3 - 1) * e3 + n3 + (r3 - 1) * i2 + 1 - o2, u2 = (t3, e3, n3, r3, i2) => {
        const o2 = Math.floor(t3 / 2);
        "SAME_UPPER" === e3 ? (n3[r3] = o2, n3[i2] = t3 - o2) : "SAME_LOWER" === e3 && (n3[r3] = t3 - o2, n3[i2] = o2);
      };
      e2.convTranspose = (t3, e3, n3) => (f2(e3, n3), c2(t3, e3, n3));
      const c2 = (t3, e3, n3) => {
        const r3 = p2(n3, e3);
        return [l2(t3, e3, r3)];
      }, l2 = (t3, e3, n3) => t3.run(((t4, e4, n4) => {
        const r3 = (s2 = e4.length > 2, u3 = n4.cacheKey, { name: "ConvTranspose", inputNames: s2 ? ["X", "W", "B"] : ["X", "W"], inputTypes: s2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: u3 });
        var s2, u3;
        return Object.assign(Object.assign({}, r3), { get: () => ((t5, e5, n5, r4) => {
          const s3 = e5.length > 2 ? "getB(output_channel)" : "0.0", u4 = e5[0].dims, c3 = e5[1].dims, l3 = c3[1], p3 = c3[0] / r4.group, f3 = [e5[0].dims[0], e5[1].dims[1] * r4.group, ...r4.outputShape], d2 = (0, i.getGlsl)(t5.session.backend.glContext.version), { activationFunction: h2, applyActivation: g2 } = (0, a.getActivationSnippet)(r4), b2 = `
  const ivec2 strides = ivec2(${r4.strides[0]}, ${r4.strides[1]});
  const ivec2 pads = ivec2(${r4.pads[0]}, ${r4.pads[1]});
  ${h2}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${l3};
    int wOutChannel = output_channel - group_id * ${l3};

    float value = ${s3};
    for (int inChannelOffset = 0; inChannelOffset < ${p3}; inChannelOffset++) {
      int input_channel = group_id * ${p3} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${c3[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${c3[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r4.dilations[0]}, wHOff * ${r4.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u4[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u4[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g2}
    ${d2.output} = vec4(value, .0, .0, .0);
  }
`;
          return Object.assign(Object.assign({}, n5), { output: { dims: f3, type: e5[0].type, textureType: o.TextureType.unpacked }, shaderSource: b2, hasMain: true });
        })(t4, e4, r3, n4) });
      })(t3, e3, n3), e3), p2 = (t3, e3) => {
        const n3 = t3.kernelShape.slice();
        if (0 === t3.kernelShape.length) for (let t4 = 2; t4 < e3[1].dims.length; ++t4) n3.push(e3[1].dims[t4]);
        const r3 = t3.pads.slice(), i2 = t3.outputShape.slice();
        ((t4, e4, n4, r4, i3, o3, a2, c3) => {
          const l3 = t4.length - 2, p3 = 0 === c3.length;
          for (let f3 = 0; f3 < l3; ++f3) {
            const d2 = p3 ? t4[f3 + 2] * o3[f3] : c3[f3], h2 = s(t4[f3 + 2], o3[f3], i3[f3], e4[f3], n4[f3], d2);
            u2(h2, r4, i3, f3, f3 + l3), p3 && c3.push(o3[f3] * (t4[f3 + 2] - 1) + a2[f3] + (e4[f3] - 1) * n4[f3] + 1 - i3[f3] - i3[f3 + l3]);
          }
        })(e3[0].dims, n3, t3.dilations, t3.autoPad, r3, t3.strides, t3.outputPadding, i2);
        const o2 = Object.assign({}, t3);
        return Object.assign(o2, { kernelShape: n3, pads: r3, outputShape: i2, cacheKey: t3.cacheKey }), o2;
      };
      e2.parseConvTransposeAttributes = (t3) => {
        const e3 = t3.attributes, n3 = (0, a.parseInternalActivationAttributes)(e3), i2 = e3.getString("auto_pad", "NOTSET"), o2 = e3.getInts("dilations", [1, 1]), s2 = e3.getInt("group", 1), u3 = e3.getInts("kernel_shape", []), c3 = e3.getInts("output_padding", [0, 0]), l3 = e3.getInts("output_shape", []), p3 = e3.getInts("pads", [0, 0, 0, 0]), f3 = e3.getInts("strides", [1, 1]);
        return (0, r2.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: s2, kernelShape: u3, outputPadding: c3, outputShape: l3, pads: p3, strides: f3 }, n3));
      };
      const f2 = (t3, e3) => {
        if (!t3 || 2 !== t3.length && 3 !== t3.length) throw new Error("Conv requires 2 or 3 inputs");
        if (4 !== t3[0].dims.length || 4 !== t3[1].dims.length) throw new Error("currently only support 2-dimensional conv");
        if (t3[0].dims[1] !== t3[1].dims[0]) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        const n3 = t3[1].dims[1] * e3.group;
        if (3 === t3.length && (1 !== t3[2].dims.length || t3[2].dims[0] !== n3)) throw new Error("invalid bias");
        const r3 = t3[0].dims.length - 2;
        if (e3.dilations.length !== r3) throw new Error(`dilations should be ${r3}D`);
        if (e3.strides.length !== r3) throw new Error(`strides should be ${r3}D`);
        if (e3.pads.length !== 2 * r3) throw new Error(`pads should be ${2 * r3}D`);
        if (e3.outputPadding.length !== r3) throw new Error(`output_padding should be ${r3}D`);
        if (0 !== e3.kernelShape.length && e3.kernelShape.length !== t3[1].dims.length - 2) throw new Error("invalid kernel shape");
        if (0 !== e3.outputShape.length && e3.outputShape.length !== t3[0].dims.length - 2) throw new Error("invalid output shape");
        if ("float32" !== t3[0].type || "float32" !== t3[1].type) throw new Error("ConvTranspose input(X,W) should be float tensor");
        if (3 === t3.length && "float32" !== t3[2].type) throw new Error("ConvTranspose input(bias) should be float tensor");
      };
    }, 8138: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseConvAttributes = e2.conv = e2.calculateOutputShape = void 0;
      const r2 = n2(246), i = n2(2517), o = n2(4770), a = n2(1386), s = n2(9828), u2 = n2(2823), c2 = n2(3248), l2 = n2(5623);
      e2.calculateOutputShape = (t3, e3, n3, r3, i2) => {
        const o2 = t3[0], a2 = t3.slice(2), s2 = a2.length, u3 = e3[0], c3 = e3.slice(2).map((t4, e4) => t4 + (t4 - 1) * (n3[e4] - 1)), l3 = a2.map((t4, e4) => t4 + r3[e4] + r3[e4 + s2]).map((t4, e4) => Math.floor((t4 - c3[e4] + i2[e4]) / i2[e4]));
        return [o2, u3].concat(...l3);
      }, e2.conv = (t3, e3, n3) => (g2(e3, n3), p2(t3, e3, n3));
      const p2 = (t3, e3, n3) => {
        const r3 = h2(n3, e3), i2 = t3.session.pack, s2 = 1 === r3.kernelShape[0] && 1 === r3.kernelShape[1];
        return r3.group > 1 ? [t3.run((0, o.createUnpackedGroupedConvProgramInfoLoader)(t3, e3, r3), e3)] : s2 && i2 ? [f2(t3, e3, r3)] : i2 && 4 === e3[0].dims.length && 1 === e3[0].dims[0] && !s2 ? [(0, a.conv2DPacked)(t3, e3, r3)] : [d2(t3, e3, r3)];
      }, f2 = (t3, n3, r3) => {
        const i2 = n3[0].dims, o2 = n3[1].dims, a2 = (0, e2.calculateOutputShape)(i2, o2, r3.dilations, r3.pads, r3.strides), s2 = t3.reshapeUnpacked(n3[0], [i2[1], i2[2] * i2[3]]), u3 = t3.reshapeUnpacked(n3[1], [o2[0], o2[1]]), c3 = n3.length > 2 ? [u3, s2, n3[2]] : [u3, s2], p3 = t3.run((0, l2.createMatmulProgramInfoLoader)(c3, r3), c3);
        return t3.reshapeUnpacked(p3, a2);
      }, d2 = (t3, n3, r3) => {
        const i2 = n3[0].dims, o2 = n3[1].dims, a2 = (0, e2.calculateOutputShape)(i2, o2, r3.dilations, r3.pads, r3.strides), u3 = t3.run((0, c2.createIm2ColProgramInfoLoader)(t3, n3[0], n3[1], a2, r3), [n3[0]]), l3 = 3 === n3.length ? [u3, n3[1], n3[2]] : [u3, n3[1]];
        return t3.run((0, s.createDotProductProgramInfoLoader)(t3, n3, a2, r3), l3);
      }, h2 = (t3, e3) => {
        const n3 = t3.kernelShape.slice();
        if (0 === t3.kernelShape.length) for (let t4 = 2; t4 < e3[1].dims.length; ++t4) n3.push(e3[1].dims[t4]);
        const r3 = t3.pads.slice();
        i.PoolConvUtil.adjustPadsBasedOnAutoPad(e3[0].dims, t3.strides, t3.dilations, n3, r3, t3.autoPad);
        const o2 = Object.assign({}, t3);
        return Object.assign(o2, { kernelShape: n3, pads: r3, cacheKey: t3.cacheKey }), o2;
      };
      e2.parseConvAttributes = (t3) => {
        const e3 = t3.attributes, n3 = (0, u2.parseInternalActivationAttributes)(e3), i2 = e3.getString("auto_pad", "NOTSET"), o2 = e3.getInts("dilations", [1, 1]), a2 = e3.getInt("group", 1), s2 = e3.getInts("kernel_shape", []), c3 = e3.getInts("pads", [0, 0, 0, 0]), l3 = e3.getInts("strides", [1, 1]);
        return (0, r2.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: a2, kernelShape: s2, pads: c3, strides: l3 }, n3));
      };
      const g2 = (t3, e3) => {
        if (!t3 || 2 !== t3.length && 3 !== t3.length) throw new Error("Conv requires 2 or 3 inputs");
        if (4 !== t3[0].dims.length || 4 !== t3[1].dims.length) throw new Error("currently only support 2-dimensional conv");
        if (t3[0].dims[1] !== t3[1].dims[1] * e3.group) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        if (3 === t3.length && (1 !== t3[2].dims.length || t3[1].dims[0] !== t3[2].dims[0])) throw new Error("invalid bias");
        const n3 = t3[0].dims.length - 2;
        if (e3.dilations.length !== n3) throw new Error(`dilations should be ${n3}D`);
        if (e3.strides.length !== n3) throw new Error(`strides should be ${n3}D`);
        if (e3.pads.length !== 2 * n3) throw new Error(`pads should be ${2 * n3}D`);
        if (0 !== e3.kernelShape.length && e3.kernelShape.length !== t3[1].dims.length - 2) throw new Error("invalid kernel shape");
        if ("float32" !== t3[0].type || "float32" !== t3[1].type) throw new Error("Conv input(X,W) should be float tensor");
        if (3 === t3.length && "float32" !== t3[2].type) throw new Error("Conv input(bias) should be float tensor");
      };
    }, 5193: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseDepthToSpaceAttributes = e2.depthToSpace = void 0;
      const r2 = n2(3738);
      e2.depthToSpace = (t3, e3, n3) => {
        i(e3);
        const o = n3.blocksize, a = o * o, s = "DCR" === n3.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], u2 = "DCR" === n3.mode ? [e3[0].dims[0], o, o, e3[0].dims[1] / a, e3[0].dims[2], e3[0].dims[3]] : [e3[0].dims[0], e3[0].dims[1] / a, o, o, e3[0].dims[2], e3[0].dims[3]], c2 = t3.reshapeUnpacked(e3[0], u2), l2 = { perm: s, cacheKey: `${s}` }, [p2] = (0, r2.transpose)(t3, [c2], l2), f2 = [e3[0].dims[0], e3[0].dims[1] / a, e3[0].dims[2] * o, e3[0].dims[3] * o];
        return [t3.reshapeUnpacked(p2, f2)];
      }, e2.parseDepthToSpaceAttributes = (t3) => {
        const e3 = t3.attributes.getInt("blocksize");
        if (e3 < 1) throw new Error(`blocksize must be >= 1, but got : ${e3} for DepthToSpace`);
        const n3 = t3.attributes.getString("mode", "DCR");
        if ("DCR" !== n3 && "CRD" !== n3) throw new Error(`unrecognized mode: ${n3} for DepthToSpace`);
        return { mode: n3, blocksize: e3 };
      };
      const i = (t3) => {
        if (1 !== t3.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${t3.length}`);
        if ("string" === t3[0].type || 4 !== t3[0].dims.length) throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
      };
    }, 9828: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createDotProductProgramInfoLoader = void 0;
      const r2 = n2(2517), i = n2(5060), o = n2(2039), a = n2(2823), s = n2(3248);
      e2.createDotProductProgramInfoLoader = (t3, e3, n3, u2) => {
        const c2 = ((t4, e4) => ({ name: "ConvDotProduct", inputNames: t4 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: t4 ? [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.packedLastDimension], cacheKey: e4.activationCacheKey }))(e3.length > 2, u2);
        return Object.assign(Object.assign({}, c2), { get: () => ((t4, e4, n4, u3, c3) => {
          const l2 = n4[0].dims, p2 = n4[1].dims, f2 = [p2[0], Math.ceil(l2[1] * p2[2] * p2[3] / 4)], d2 = (0, s.calculateIm2ColDims)(l2, p2, u3), [h2, g2] = t4.calculateTextureWidthAndHeight(f2, o.TextureType.packedLastDimension), b2 = r2.ShapeUtil.computeStrides(d2), [m2, y2] = t4.calculateTextureWidthAndHeight(d2, o.TextureType.packedLastDimension), _ = u3.length, v2 = n4.length < 3 ? "0.0" : "_B(b)", w2 = Math.ceil(l2[1] * p2[2] * p2[3] / 4), { activationFunction: x2, applyActivation: T2 } = (0, a.getActivationSnippet)(c3), S2 = (0, i.getGlsl)(t4.session.backend.glContext.version), O2 = `
${x2}
float process(int indices[${_}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${b2[0]} + im2col[1] * ${b2[1]} + im2col[2] * ${b2[2]};
  int kernelOffset = indices[1] * ${f2[1]};
  float value = ${v2};
  for (int i = 0; i < ${w2}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m2}, ${y2});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h2}, ${g2});
    value += dot(${S2.texture2D}(Im2Col, im2colCoords), ${S2.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${T2}
  return value;
}`;
          return Object.assign(Object.assign({}, e4), { output: { dims: u3, type: n4[0].type, textureType: o.TextureType.unpacked }, shaderSource: O2 });
        })(t3, c2, e3, n3, u2) });
      };
    }, 7992: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseFlattenAttributes = e2.flatten = void 0;
      const r2 = n2(2517);
      e2.flatten = (t3, e3, n3) => {
        i(e3, n3);
        const o = r2.ShapeUtil.flattenShape(e3[0].dims, n3);
        return [t3.reshapeUnpacked(e3[0], o)];
      }, e2.parseFlattenAttributes = (t3) => t3.attributes.getInt("axis", 1);
      const i = (t3, e3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Flatten requires 1 input.");
        const n3 = t3[0].dims.length;
        if (0 === n3) throw new Error("scalar tensor is not supported.");
        if (e3 < -n3 || e3 > n3) throw new Error("Invalid axis");
        if ("string" === t3[0].type) throw new Error("string tensor is not supported.");
      };
    }, 2823: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseInternalActivationAttributes = e2.getActivationSnippet = void 0;
      const r2 = n2(2517), i = n2(4909);
      e2.getActivationSnippet = function(t3) {
        let e3;
        switch (t3.activation) {
          case "Relu":
            e3 = (0, i.glslRelu)();
            break;
          case "Sigmoid":
            e3 = (0, i.glslSigmoid)();
            break;
          case "Clip":
            e3 = (0, i.glslClip)(t3.clipMin, t3.clipMax);
            break;
          default:
            return { activationFunction: "", applyActivation: "" };
        }
        const n3 = e3.name;
        return { activationFunction: e3.body, applyActivation: `value = ${n3}_(value);` };
      }, e2.parseInternalActivationAttributes = (t3) => {
        const e3 = t3.getString("activation", "");
        if ("Clip" === e3) {
          const [n3, i2] = t3.getFloats("activation_params", [r2.MIN_CLIP, r2.MAX_CLIP]);
          return { activation: e3, clipMax: i2, clipMin: n3, activationCacheKey: `${e3}:${n3},${i2}` };
        }
        return { activation: e3, activationCacheKey: e3 };
      };
    }, 1253: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseGatherAttributes = e2.gather = void 0;
      const r2 = n2(246), i = n2(782), o = n2(2517), a = n2(2039);
      e2.gather = (t3, e3, n3) => (c2(e3, n3.axis), [t3.run(u2(t3, e3, n3), e3)]), e2.parseGatherAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ axis: t3.attributes.getInt("axis", 0) });
      const s = { name: "Gather", inputNames: ["A", "B"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, u2 = (t3, e3, n3) => {
        const r3 = Object.assign(Object.assign({}, s), { cacheHint: n3.cacheKey });
        return Object.assign(Object.assign({}, r3), { get: () => ((t4, e4, n4, r4) => {
          const i2 = n4[0].dims.slice(), s2 = n4[1].dims.slice(), u3 = new Array(i2.length + s2.length - 1);
          r4 = o.ShapeUtil.normalizeAxis(r4, i2.length);
          const c3 = [];
          for (let t5 = 0; t5 < u3.length; t5++) t5 < r4 ? (u3[t5] = i2[t5], c3.push(`inputIdx[${t5}] = outputIdx[${t5}];`)) : t5 < r4 + s2.length ? (u3[t5] = s2[t5 - r4], c3.push(`indexDataIdx[${t5 - r4}] = outputIdx[${t5}];`)) : (u3[t5] = i2[t5 - s2.length + 1], c3.push(`inputIdx[${t5 - s2.length + 1}] = outputIdx[${t5}];`));
          const l2 = `
      float process(int outputIdx[${u3.length || 1}]) {
        int inputIdx[${i2.length}];
        int indexDataIdx[${s2.length || 1}];
        indexDataIdx[0] = 0;
        ${c3.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r4}] = idx < 0 ? idx + ${i2[r4]} : idx;
        return _A(inputIdx);
      }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: u3, type: n4[0].type, textureType: a.TextureType.unpacked }, shaderSource: l2 });
        })(0, r3, e3, n3.axis) });
      }, c2 = (t3, e3) => {
        if (!t3 || 2 !== t3.length) throw new Error("Gather requires 2 inputs.");
        const n3 = t3[0].dims.length;
        if (n3 < 1) throw new Error("Invalid input shape.");
        if (e3 < -n3 || e3 > n3 - 1) throw new Error("Invalid axis.");
        if (-1 === i.NUMBER_TYPES.indexOf(t3[0].type)) throw new Error("Invaid input type.");
        if ("int32" !== t3[1].type && "int16" !== t3[1].type) throw new Error("Invaid input type.");
      };
    }, 4776: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseGemmAttributesV11 = e2.parseGemmAttributesV7 = e2.gemm = void 0;
      const r2 = n2(246), i = n2(2517), o = n2(2039);
      e2.gemm = (t3, e3, n3) => (c2(e3, n3), [t3.run(s(e3, n3), e3)]);
      const a = (t3, e3) => {
        const n3 = 0 !== t3.attributes.getInt("transA", 0), i2 = 0 !== t3.attributes.getInt("transB", 0), o2 = t3.attributes.getFloat("alpha", 1), a2 = t3.attributes.getFloat("beta", 1);
        return (0, r2.createAttributeWithCacheKey)({ transA: n3, transB: i2, alpha: o2, beta: a2, isOptionalC: e3 });
      };
      e2.parseGemmAttributesV7 = (t3) => a(t3, false), e2.parseGemmAttributesV11 = (t3) => a(t3, true);
      const s = (t3, e3) => {
        const n3 = { name: "Gemm", inputNames: 3 === t3.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === t3.length ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], key: e3.cacheKey };
        return Object.assign(Object.assign({}, n3), { get: () => u2(n3, t3, e3) });
      }, u2 = (t3, e3, n3) => {
        const r3 = e3[0].dims.slice(), a2 = e3[1].dims.slice(), [s2, u3] = i.GemmUtil.getShapeOfGemmResult(r3, n3.transA, a2, n3.transB, 3 === e3.length ? e3[2].dims : void 0), c3 = [s2, u3];
        if (!c3) throw new Error("Can't use gemm on the given tensors");
        let l2 = r3[r3.length - 1], p2 = "";
        n3.transA && (l2 = r3[0]), n3.transA && n3.transB ? p2 = "value += _A_T(a) * _B_T(b);" : n3.transA && !n3.transB ? p2 = "value += _A_T(a) * _B(b);" : !n3.transA && n3.transB ? p2 = "value += _A(a) * _B_T(b);" : n3.transA || n3.transB || (p2 = "value += _A(a) * _B(b);");
        const f2 = c3.length, d2 = `
      float process(int indices[${f2}]) {
          int a[${f2}];
          int b[${f2}];
          ${3 === e3.length ? `int c[${e3[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === e3.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${l2}; ++k) {
              a[${f2 - 1}] = k;
              b[${f2 - 2}] = k;
              ${p2}
          }

          value = value * alpha;
          ${3 === e3.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
        return Object.assign(Object.assign({}, t3), { output: { dims: c3, type: e3[0].type, textureType: o.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n3.alpha }, { name: "beta", type: "float", data: n3.beta }], shaderSource: d2 });
      }, c2 = (t3, e3) => {
        if (!t3) throw new Error("Input is missing");
        if (e3.isOptionalC && (t3.length < 2 || t3.length > 3)) throw new Error("Invaid input shape.");
        if (!e3.isOptionalC && 3 !== t3.length) throw new Error("Gemm requires 3 inputs");
        if (3 === t3.length && 1 !== t3[2].dims.length && 2 !== t3[2].dims.length) throw new Error("Invalid input shape of C");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type || "float32" !== t3[1].type && "float64" !== t3[1].type || 3 === t3.length && "float32" !== t3[2].type && "float64" !== t3[2].type) throw new Error("Invalid input type.");
        if (t3[0].type !== t3[1].type || 3 === t3.length && t3[0].type !== t3[2].type) throw new Error("Input types are mismatched");
      };
    }, 8555: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createPackedIm2ColProgramInfoLoader = void 0;
      const r2 = n2(5060), i = n2(2039), o = n2(2827);
      e2.createPackedIm2ColProgramInfoLoader = (t3, e3, n3, a, s) => {
        const u2 = (c2 = s.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [i.TextureType.packed], cacheHint: c2 });
        var c2;
        return Object.assign(Object.assign({}, u2), { get: () => ((t4, e4, n4, a2, s2, u3) => {
          const c3 = n4.dims, l2 = a2.dims, p2 = s2.length, f2 = [l2[1] * l2[2] * l2[3], s2[2] * s2[3]], d2 = l2[2] * l2[3], h2 = (0, o.unpackFromChannel)(), g2 = (0, r2.getGlsl)(t4.session.backend.glContext.version);
          let b2 = "";
          for (let t5 = 0; t5 <= 1; t5++) for (let e5 = 0; e5 <= 1; e5++) b2 += `
            blockIndex = rc.x + ${e5};
            pos = rc.y + ${t5};

            if(blockIndex < ${f2[1]} && pos < ${f2[0]}) {
              offsetY = int(blockIndex / (${s2[p2 - 1]})) * ${u3.strides[0]} -
                ${u3.pads[0]};
              d0 = offsetY + ${u3.dilations[0]} * (imod(pos, ${d2}) / ${l2[2]});

              if(d0 < ${c3[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${s2[p2 - 1]}) * ${u3.strides[1]} -
                  ${u3.pads[1]};
                d1 = offsetX + ${u3.dilations[1]} * imod(imod(pos, ${d2}), ${l2[2]});

                if(d1 < ${c3[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d2}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * t5 + e5}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
          const m2 = `
      ${h2}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b2}
          ${g2.output} = result;
      }
            `;
          return Object.assign(Object.assign({}, e4), { output: { dims: f2, type: n4.type, textureType: i.TextureType.packed }, shaderSource: m2, hasMain: true });
        })(t3, u2, e3, n3, a, s) });
      };
    }, 3248: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.calculateIm2ColDims = e2.createIm2ColProgramInfoLoader = void 0;
      const r2 = n2(2039);
      e2.createIm2ColProgramInfoLoader = (t3, n3, i, o, a) => {
        const s = (u2 = a.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r2.TextureType.unpacked], cacheHint: u2 });
        var u2;
        return Object.assign(Object.assign({}, s), { get: () => ((t4, n4, i2, o2, a2, s2) => {
          const u3 = i2.dims, c2 = o2.dims, l2 = a2.length, p2 = (0, e2.calculateIm2ColDims)(u3, c2, a2, 4), f2 = `
        const int XC = ${u3[1]};
        const int XH = ${u3[2]};
        const int XW = ${u3[3]};
        const int KH = ${s2.kernelShape[0]};
        const int KW = ${s2.kernelShape[1]};
        const int dilationH = ${s2.dilations[0]};
        const int dilationW = ${s2.dilations[1]};
        const int strideH = ${s2.strides[0]};
        const int strideW = ${s2.strides[1]};
        const int padH = ${s2.pads[0]};
        const int padW = ${s2.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${l2}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u3.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
          return Object.assign(Object.assign({}, n4), { output: { dims: p2, type: i2.type, textureType: r2.TextureType.packedLastDimension }, shaderSource: f2 });
        })(0, s, n3, i, o, a) });
      }, e2.calculateIm2ColDims = (t3, e3, n3, r3 = 4) => [n3[0], n3[2], n3[3], Math.ceil(t3[1] * e3[2] * e3[3] / r3)];
    }, 6572: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseImageScalerAttributes = e2.imageScaler = void 0;
      const r2 = n2(246), i = n2(2039);
      e2.imageScaler = (t3, e3, n3) => (u2(e3), [t3.run(a(t3, e3, n3), e3)]), e2.parseImageScalerAttributes = (t3) => {
        const e3 = t3.attributes.getFloat("scale"), n3 = t3.attributes.getFloats("bias");
        return (0, r2.createAttributeWithCacheKey)({ scale: e3, bias: n3 });
      };
      const o = { name: "ImageScaler", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (t3, e3, n3) => {
        const r3 = Object.assign(Object.assign({}, o), { cacheHint: n3.cacheKey });
        return Object.assign(Object.assign({}, r3), { get: () => ((t4, e4, n4, r4) => {
          const o2 = n4[0].dims.slice(), a2 = o2.length, u3 = `
      ${s(r4.bias.length)}
      float process(int indices[${a2}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: o2, type: n4[0].type, textureType: i.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r4.bias.length, data: r4.bias }, { name: "scale", type: "float", data: r4.scale }], shaderSource: u3 });
        })(0, r3, e3, n3) });
      }, s = (t3) => {
        const e3 = [`float getBias(float bias[${t3}], int channel) {`];
        for (let n3 = 0; n3 < t3; ++n3) 0 === n3 ? e3.push(`	if (channel == ${n3}) { return bias[${n3}]; }`) : n3 === t3 - 1 ? e3.push(`	else { return bias[${n3}]; }`) : e3.push(`	else if (channel == ${n3}) { return bias[${n3}]; }`);
        return e3.push("	}"), e3.join("\n");
      }, u2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("ImageScaler requires 1 input.");
        if (4 !== t3[0].dims.length) throw new Error("Invalid input shape.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type.");
      };
    }, 3346: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseInstanceNormalizationAttributes = e2.instanceNormalization = void 0;
      const r2 = n2(5060), i = n2(2039);
      e2.instanceNormalization = (t3, e3, n3) => {
        c2(e3);
        const r3 = t3.run(a(e3[0]), e3);
        return [t3.run(u2(t3, e3[0], n3, r3.dims), [e3[0], r3, e3[1], e3[2]])];
      }, e2.parseInstanceNormalizationAttributes = (t3) => t3.attributes.getFloat("epsilon", 1e-5);
      const o = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (t3) => Object.assign(Object.assign({}, o), { get: () => ((t4, e3) => {
        const n3 = e3.dims.slice(), r3 = n3[1], o2 = n3[2] * n3[3], a2 = [n3[0], r3], s2 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n3[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n3[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o2});
        temp = 0.0;
        for(int a2=0; a2<${n3[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n3[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o2});

        return v;
      }`;
        return Object.assign(Object.assign({}, t4), { output: { dims: a2, type: e3.type, textureType: i.TextureType.packedLastDimension }, shaderSource: s2 });
      })(o, t3) }), s = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked, i.TextureType.unpacked] }, u2 = (t3, e3, n3, o2) => {
        const a2 = Object.assign(Object.assign({}, s), { cacheHint: `${n3}` });
        return Object.assign(Object.assign({}, a2), { get: () => ((t4, e4, n4, o3, a3) => {
          const s2 = (0, r2.getGlsl)(t4.session.backend.glContext.version), [u3, c3] = t4.calculateTextureWidthAndHeight(a3, i.TextureType.packedLastDimension), [l2, p2] = [u3 / 4, c3], f2 = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${l2}, ${p2});
        return ${s2.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: n4.dims, type: n4.type, textureType: i.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: o3 }], shaderSource: f2 });
        })(t3, a2, e3, n3, o2) });
      }, c2 = (t3) => {
        if (!t3 || 3 !== t3.length) throw new Error("InstanceNormalization requires 3 inputs.");
        const e3 = t3[0], n3 = t3[1], r3 = t3[2];
        if (e3.dims.length < 3 || 1 !== n3.dims.length || 1 !== r3.dims.length) throw new Error("Invalid input shape.");
        if (n3.dims[0] !== e3.dims[1] || r3.dims[0] !== e3.dims[1]) throw new Error("Input shapes are mismatched.");
        if ("float32" !== e3.type && "float64" !== e3.type || "float32" !== n3.type && "float64" !== n3.type || "float32" !== r3.type && "float64" !== r3.type) throw new Error("Invalid input type.");
        if (4 !== t3[0].dims.length) throw new Error("Only support 4-D input shape.");
      };
    }, 708: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createPackedMatmulProgramInfoLoader = void 0;
      const r2 = n2(2517), i = n2(5060), o = n2(2039), a = n2(9390), s = n2(2823), u2 = n2(5623);
      e2.createPackedMatmulProgramInfoLoader = (t3, e3, n3) => {
        const c2 = (l2 = e3.length > 2, p2 = n3.activationCacheKey, { name: "MatMul (packed)", inputNames: l2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: l2 ? [o.TextureType.packed, o.TextureType.packed, o.TextureType.packed] : [o.TextureType.packed, o.TextureType.packed], cacheHint: p2 });
        var l2, p2;
        return Object.assign(Object.assign({}, c2), { get: () => ((t4, e4, n4, c3) => {
          const l3 = n4.length > 2, p3 = l3 ? "value += getBiasForMatmul();" : "", f2 = n4[0].dims, d2 = n4[1].dims, h2 = r2.BroadcastUtil.calcShape(f2, d2, true), g2 = !r2.ShapeUtil.areEqual(n4[0].dims, n4[1].dims);
          if (!h2) throw new Error("Can't use matmul on the given tensors");
          const b2 = f2[f2.length - 1], m2 = Math.ceil(b2 / 2), y2 = f2.length, _ = d2.length, v2 = (0, i.getGlsl)(t4.session.backend.glContext.version), w2 = (0, a.getCoordsDataType)(h2.length), x2 = h2.length, T2 = (0, a.getGlChannels)(), { activationFunction: S2, applyActivation: O2 } = (0, s.getActivationSnippet)(c3), A2 = l3 ? `${(0, u2.getBiasForMatmul)(w2, T2, n4[2].dims, h2, true)}` : "", E2 = g2 ? `${function(t5, e5, n5, i2) {
            let o2 = [], a2 = [];
            const s2 = n5[0].dims, u3 = n5[1].dims, c4 = s2.length, l4 = u3.length, p4 = i2.length, f3 = p4 - c4, d3 = p4 - l4;
            o2 = s2.map((t6, n6) => `coords.${e5[n6 + f3]}`), o2[c4 - 1] = "i*2", o2.join(", "), a2 = u3.map((t6, n6) => `coords.${e5[n6 + d3]}`), a2[l4 - 2] = "i*2", a2.join(", ");
            const h3 = r2.BroadcastUtil.getBroadcastDims(s2, i2), g3 = r2.BroadcastUtil.getBroadcastDims(u3, i2), b3 = h3.map((t6) => `coords.${e5[t6 + f3]} = 0;`).join("\n"), m3 = g3.map((t6) => `coords.${e5[t6 + d3]} = 0;`).join("\n"), y3 = `int lastDim = coords.${e5[p4 - 1]};
  coords.${e5[p4 - 1]} = coords.${e5[p4 - 2]};
  coords.${e5[p4 - 2]} = lastDim;`;
            return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${t5} coords = getOutputCoords();
  ${y3}
  ${b3}
  vec4 outputValue = getA(${o2});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${t5} coords = getOutputCoords();
  ${y3}
  ${m3}
  vec4 outputValue = getB(${a2});
  return outputValue;
}`;
          }(w2, T2, n4, h2)}` : "", I2 = g2 ? "getAAtOutCoordsMatmul(i)" : `getA(${function(t5, e5) {
            let n5 = "";
            for (let r3 = 0; r3 < e5 - 2; r3++) n5 += `rc.${t5[r3]}, `;
            return n5 += `rc.${t5[e5 - 2]}, i*2`, n5;
          }(T2, y2)})`, P2 = g2 ? "getBAtOutCoordsMatmul(i)" : `getB(${function(t5, e5) {
            let n5 = "";
            for (let r3 = 0; r3 < e5 - 2; r3++) n5 += `rc.${t5[r3]}, `;
            return n5 += `i*2, rc.${t5[e5 - 1]}`, n5;
          }(T2, _)})`, D2 = `
            ${E2}
            ${A2}
            ${S2}
            void main() {
              ${g2 ? "" : `${w2} rc =
          getOutputCoords(); int lastDim = rc.${T2[x2 - 1]}; rc.${T2[x2 - 1]} =
          rc.${T2[x2 - 2]}; rc.${T2[x2 - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${m2}; i++) {
                vec4 a = ${I2};
                vec4 b = ${P2};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p3}
              ${O2}
              ${v2.output} = value;
            }`;
          return Object.assign(Object.assign({}, e4), { output: { dims: h2, type: n4[0].type, textureType: o.TextureType.packed }, shaderSource: D2, hasMain: true });
        })(t3, c2, e3, n3) });
      };
    }, 5623: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.getBiasForMatmul = e2.createMatmulProgramInfoLoader = e2.parseMatMulAttributes = e2.matMul = void 0;
      const r2 = n2(2517), i = n2(2039), o = n2(9390), a = n2(2823), s = n2(708);
      function u2(t3, e3) {
        const n3 = (s2 = t3.length > 2, u3 = e3.activationCacheKey, { name: "MatMul", inputNames: s2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: s2 ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: u3 });
        var s2, u3;
        return Object.assign(Object.assign({}, n3), { get: () => function(t4, e4, n4) {
          const s3 = e4[0].dims, u4 = e4[1].dims, c3 = r2.BroadcastUtil.calcShape(s3, u4, true);
          if (!c3) throw new Error("Can't use matmul on the given tensors");
          const p2 = (0, o.getCoordsDataType)(c3.length), f2 = (0, o.getGlChannels)(), { activationFunction: d2, applyActivation: h2 } = (0, a.getActivationSnippet)(n4), g2 = e4.length > 2, b2 = g2 ? "value += getBiasForMatmul();" : "", m2 = g2 ? `${l2(p2, f2, e4[2].dims, c3, false)}` : "", y2 = c3.length, _ = s3.length, v2 = u4.length, w2 = `
    ${d2}
    ${m2}
    float process(int indices[${y2}]) {
        int a[${_}];
        int b[${v2}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${s3[s3.length - 1]}; ++k) {
            a[${_ - 1}] = k;
            b[${v2 - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${b2}
        ${h2}
        return value;
    }`;
          return Object.assign(Object.assign({}, t4), { output: { dims: c3, type: e4[0].type, textureType: i.TextureType.unpacked }, shaderSource: w2 });
        }(n3, t3, e3) });
      }
      e2.matMul = (t3, e3, n3) => (c2(e3), t3.session.pack ? [t3.run((0, s.createPackedMatmulProgramInfoLoader)(t3, e3, n3), e3)] : [t3.run(u2(e3, n3), e3)]), e2.parseMatMulAttributes = (t3) => (0, a.parseInternalActivationAttributes)(t3.attributes), e2.createMatmulProgramInfoLoader = u2;
      const c2 = (t3) => {
        if (!t3 || 2 !== t3.length) throw new Error("MatMul requires 2 inputs.");
        if (t3[0].dims[t3[0].dims.length - 1] !== t3[1].dims[t3[1].dims.length - 2]) throw new Error("shared dimension does not match.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type || "float32" !== t3[1].type && "float64" !== t3[1].type) throw new Error("inputs should be float type");
        if (t3[0].type !== t3[1].type) throw new Error("inputs types should match");
      };
      function l2(t3, e3, n3, i2, o2) {
        let a2 = "";
        const s2 = n3.length, u3 = i2.length, c3 = u3 - s2;
        a2 = u3 < 2 && s2 > 0 ? "coords" : n3.map((t4, n4) => `coords.${e3[n4 + c3]}`).join(", ");
        const l3 = r2.BroadcastUtil.getBroadcastDims(n3, i2).map((t4) => `coords.${e3[t4 + c3]} = 0;`).join("\n");
        let p2 = "vec4(outputValue.xx, outputValue.yy)";
        return 1 === r2.ShapeUtil.size(n3) && (p2 = "vec4(outputValue.x)"), o2 ? `
vec4 getBiasForMatmul() {
  ${t3} coords = getOutputCoords();
  ${l3}
  vec4 outputValue = getBias(${a2});
  return ${p2};
}` : `
float getBiasForMatmul() {
  ${t3} coords = getOutputCoords();
  ${l3}
  return getBias(coords.x);
}`;
      }
      e2.getBiasForMatmul = l2;
    }, 2403: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createPackProgramInfoLoader = void 0;
      const r2 = n2(5060), i = n2(2039), o = n2(9390), a = n2(2827), s = { name: "pack", inputNames: ["A"], inputTypes: [i.TextureType.unpackedReversed] };
      e2.createPackProgramInfoLoader = (t3, e3) => Object.assign(Object.assign({}, s), { get: () => ((t4, e4) => {
        const n3 = (0, r2.getGlsl)(t4.session.backend.glContext.version), u2 = e4.dims, c2 = u2.length, l2 = e4.dims.length, p2 = (0, o.getCoordsDataType)(l2), f2 = (0, a.getChannels)("rc", l2), d2 = (h2 = l2, g2 = f2, b2 = u2[u2.length - 2], m2 = u2[u2.length - 1], 0 === h2 || 1 === h2 ? "" : `
    int r = ${g2[h2 - 2]};
    int c = ${g2[h2 - 1]};
    int rp1 = ${g2[h2 - 2]} + 1;
    int cp1 = ${g2[h2 - 1]} + 1;
    bool rEdge = rp1 >= ${m2};
    bool cEdge = cp1 >= ${b2};
    `);
        var h2, g2, b2, m2;
        let y2;
        y2 = 0 === c2 ? [1, 1] : 1 === c2 ? [u2[0], 1] : [u2[l2 - 1], u2[l2 - 2]];
        const _ = function(t5, e5, n4) {
          if (0 === t5) return "false";
          if (1 === t5) return `rc > ${e5[0]}`;
          let r3 = "";
          for (let i2 = t5 - 2; i2 < t5; i2++) r3 += `${n4[i2]} >= ${e5[i2 - t5 + 2]}`, i2 < t5 - 1 && (r3 += "||");
          return r3;
        }(l2, y2, f2), v2 = function(t5, e5) {
          const n4 = t5.length;
          if (0 === n4) return "getA(), 0, 0, 0";
          if (1 === n4) return `getA(rc),
            rc + 1 >= ${t5[0]} ? 0. : getA(rc + 1),
            0, 0`;
          let r3 = "";
          if (n4 > 2) for (let t6 = 0; t6 < n4 - 2; ++t6) r3 += `${e5[t6]},`;
          return `getA(${r3}r, c),
          rEdge ? 0. : getA(${r3}rp1, c),
          cEdge ? 0. : getA(${r3}r, cp1),
          rEdge || cEdge ? 0. : getA(${r3}rp1, cp1)`;
        }(u2, f2), w2 = `
        void main() {
          ${p2} rc = getOutputCoords();

          if(${_}) {
            ${n3.output} = vec4(0);
          } else {
            ${d2}

            ${n3.output} = vec4(${v2});
          }
        }
      `;
        return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: e4.dims, type: e4.type, textureType: i.TextureType.packed }, shaderSource: w2 });
      })(t3, e3) });
    }, 2827: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.unpackFromChannel = e2.getChannels = e2.getVecChannels = void 0;
      const r2 = n2(9390);
      function i(t3, e3) {
        return (0, r2.getGlChannels)(e3).map((e4) => `${t3}.${e4}`);
      }
      e2.getVecChannels = i, e2.getChannels = function(t3, e3) {
        return 1 === e3 ? [t3] : i(t3, e3);
      }, e2.unpackFromChannel = function() {
        return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
      };
    }, 2870: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parsePadAttributesV11 = e2.padV11 = e2.parsePadAttributesV2 = e2.padV2 = void 0;
      const r2 = n2(246), i = n2(2517), o = n2(5060), a = n2(2039), s = { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
      e2.padV2 = (t3, e3, n3) => (l2(e3), [t3.run(Object.assign(Object.assign({}, s), { cacheHint: n3.cacheKey, get: () => c2(t3, e3[0], n3) }), e3)]), e2.parsePadAttributesV2 = (t3) => {
        const e3 = t3.attributes.getString("mode", "constant"), n3 = t3.attributes.getFloat("value", 0), i2 = t3.attributes.getInts("pads");
        return (0, r2.createAttributeWithCacheKey)({ mode: e3, value: n3, pads: i2 });
      }, e2.padV11 = (t3, n3, r3) => {
        p2(n3);
        const i2 = u2(t3, n3, r3);
        return (0, e2.padV2)(t3, [n3[0]], i2);
      }, e2.parsePadAttributesV11 = (t3) => t3.attributes.getString("mode", "constant");
      const u2 = (t3, e3, n3) => {
        if (!t3.session.isInitializer(e3[1].dataId) || e3.length >= 3 && !t3.session.isInitializer(e3[2].dataId)) throw new Error("dynamic pad attributes are not allowed");
        const i2 = Array.from(e3[1].integerData), o2 = e3.length >= 3 ? e3[2].floatData[0] : 0;
        return (0, r2.createAttributeWithCacheKey)({ mode: n3, pads: i2, value: o2 });
      }, c2 = (t3, e3, n3) => {
        const r3 = i.ShapeUtil.padShape(e3.dims.slice(), n3.pads), o2 = r3.length, s2 = `
      ${f2(t3, e3, n3)}
      float process(int[${o2}] indices) {
          return padA(indices);
      }`;
        return { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked], output: { dims: r3, type: e3.type, textureType: a.TextureType.unpacked }, shaderSource: s2 };
      }, l2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Pad requires 1 input");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type.");
      }, p2 = (t3) => {
        if (!t3 || 2 !== t3.length && 3 !== t3.length) throw new Error("Pad requires 2 or 3 inputs");
        if ("int32" !== t3[1].type) throw new Error("Invalid input type.");
        if (t3.length >= 3 && "string" === t3[2].type) throw new Error("Invalid input type.");
      }, f2 = (t3, e3, n3) => {
        const r3 = (0, o.getGlsl)(t3.session.backend.glContext.version), [s2, u3] = t3.calculateTextureWidthAndHeight(e3.dims, a.TextureType.unpacked), c3 = i.ShapeUtil.computeStrides(e3.dims);
        switch (n3.mode) {
          case "constant":
            return d2(r3, e3.dims, c3, s2, u3, n3.pads, n3.value);
          case "reflect":
            return h2(r3, e3.dims, c3, s2, u3, n3.pads);
          case "edge":
            return g2(r3, e3.dims, c3, s2, u3, n3.pads);
          default:
            throw new Error("Invalid mode");
        }
      }, d2 = (t3, e3, n3, r3, i2, o2, a2) => {
        const s2 = e3.length;
        let u3 = "";
        for (let t4 = s2 - 1; t4 >= 0; --t4) u3 += `
        k = m[${t4}] - ${o2[t4]};
        if (k < 0)  return constant;
        if (k >= ${e3[t4]}) return constant;
        offset += k * ${n3[t4]};
        `;
        return `
      float padA(int m[${s2}]) {
        const float constant = float(${a2});
        int offset = 0;
        int k = 0;
        ${u3}
        vec2 coords = offsetToCoords(offset, ${r3}, ${i2});
        float value = getColorAsFloat(${t3.texture2D}(A, coords));
        return value;
      }
      `;
      }, h2 = (t3, e3, n3, r3, i2, o2) => {
        const a2 = e3.length;
        let s2 = "";
        for (let t4 = a2 - 1; t4 >= 0; --t4) s2 += `
        k = m[${t4}] - ${o2[t4]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (e3[t4] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e3[t4]}) { k = _2n_1 - k; }
        }
        offset += k * ${n3[t4]};
        `;
        return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r3}, ${i2});
        float value = getColorAsFloat(${t3.texture2D}(A, coords));
        return value;
      }
      `;
      }, g2 = (t3, e3, n3, r3, i2, o2) => {
        const a2 = e3.length;
        let s2 = "";
        for (let t4 = a2 - 1; t4 >= 0; --t4) s2 += `
        k = m[${t4}] - ${o2[t4]};
        if (k < 0)  k = 0;
        if (k >= ${e3[t4]}) k = ${e3[t4] - 1};
        offset += k * ${n3[t4]};
      `;
        return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r3}, ${i2});
        float value = getColorAsFloat(${t3.texture2D}(A, coords));
        return value;
      }
      `;
      };
    }, 2143: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.globalMaxPool = e2.parseMaxPoolAttributes = e2.maxPool = e2.parseGlobalAveragePoolAttributes = e2.globalAveragePool = e2.parseAveragePoolAttributes = e2.averagePool = void 0;
      const r2 = n2(246), i = n2(2517), o = n2(2039);
      e2.averagePool = (t3, e3, n3) => {
        p2(e3);
        const r3 = { name: "AveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n3.cacheKey };
        return [t3.run(Object.assign(Object.assign({}, r3), { get: () => a(e3, r3, false, n3) }), e3)];
      }, e2.parseAveragePoolAttributes = (t3) => {
        const e3 = t3.attributes.getString("auto_pad", "NOTSET"), n3 = t3.attributes.getInt("ceil_mode", 0), i2 = 0 !== t3.attributes.getInt("count_include_pad", 0), o2 = t3.attributes.getInts("kernel_shape"), a2 = t3.attributes.getInts("strides", []), s2 = t3.attributes.getInts("pads", []);
        if (0 !== n3) throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
        return (0, r2.createAttributeWithCacheKey)({ autoPad: e3, ceilMode: n3, countIncludePad: i2, kernelShape: o2, strides: a2, pads: s2 });
      };
      const a = (t3, e3, n3, r3) => {
        const [a2, s2] = u2(t3, r3, n3), c3 = i.ShapeUtil.size(a2.kernelShape);
        let l3 = "";
        a2.countIncludePad ? l3 += `value /= float(${c3});` : l3 += `value /= float(${c3} - pad);`;
        const p3 = `
        ${f2(t3[0].dims, a2, "value += _X(x);", l3, "0.0")}
      `;
        return Object.assign(Object.assign({}, e3), { output: { dims: s2, type: t3[0].type, textureType: o.TextureType.unpacked }, shaderSource: p3 });
      };
      e2.globalAveragePool = (t3, e3, n3) => {
        p2(e3);
        const r3 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: `${n3.countIncludePad}` };
        return [t3.run(Object.assign(Object.assign({}, r3), { get: () => a(e3, r3, true, n3) }), e3)];
      }, e2.parseGlobalAveragePoolAttributes = (t3) => {
        const e3 = 0 !== t3.attributes.getInt("count_include_pad", 0);
        return (0, r2.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: e3, kernelShape: [], strides: [], pads: [] });
      }, e2.maxPool = (t3, e3, n3) => {
        p2(e3);
        const r3 = { name: "MaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n3.cacheKey };
        return [t3.run(Object.assign(Object.assign({}, r3), { get: () => s(e3, r3, false, n3) }), e3)];
      }, e2.parseMaxPoolAttributes = (t3) => {
        const e3 = t3.attributes.getString("auto_pad", "NOTSET"), n3 = t3.attributes.getInt("ceil_mode", 0), i2 = t3.attributes.getInts("kernel_shape"), o2 = t3.attributes.getInts("strides", []), a2 = t3.attributes.getInts("pads", []), s2 = t3.attributes.getInt("storage_order", 0), u3 = t3.attributes.getInts("dilations", []);
        if (0 !== s2) throw new Error("column major storage order is not yet supported for MaxPool");
        if (0 !== n3) throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
        return (0, r2.createAttributeWithCacheKey)({ autoPad: e3, ceilMode: n3, countIncludePad: false, kernelShape: i2, strides: o2, pads: a2, storageOrder: s2, dilations: u3 });
      };
      const s = (t3, e3, n3, r3) => {
        const [i2, a2] = u2(t3, r3, n3), s2 = `
      ${f2(t3[0].dims, i2, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
        return Object.assign(Object.assign({}, e3), { output: { dims: a2, type: t3[0].type, textureType: o.TextureType.unpacked }, shaderSource: s2 });
      }, u2 = (t3, e3, n3) => {
        const r3 = t3[0].dims.slice(), o2 = Object.hasOwnProperty.call(e3, "dilations"), a2 = e3.kernelShape.slice(), s2 = e3.strides.slice(), u3 = o2 ? e3.dilations.slice() : [], c3 = e3.pads.slice();
        i.PoolConvUtil.adjustPoolAttributes(n3, r3, a2, s2, u3, c3);
        const l3 = i.PoolConvUtil.computePoolOutputShape(n3, r3, s2, u3, a2, c3, e3.autoPad), p3 = Object.assign({}, e3);
        return o2 ? Object.assign(p3, { kernelShape: a2, strides: s2, pads: c3, dilations: u3, cacheKey: e3.cacheKey }) : Object.assign(p3, { kernelShape: a2, strides: s2, pads: c3, cacheKey: e3.cacheKey }), [p3, l3];
      }, c2 = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, l2 = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
      e2.globalMaxPool = (t3, e3) => (p2(e3), [t3.run(Object.assign(Object.assign({}, l2), { get: () => s(e3, l2, true, c2) }), e3)]);
      const p2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Pool ops requires 1 input.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type.");
      }, f2 = (t3, e3, n3, r3, o2) => {
        const a2 = t3.length;
        if (e3.kernelShape.length <= 2) {
          const i2 = e3.kernelShape[e3.kernelShape.length - 1], s2 = e3.strides[e3.strides.length - 1], u3 = e3.pads[e3.pads.length / 2 - 1], c3 = e3.pads[e3.pads.length - 1], l3 = t3[a2 - 1];
          let p3 = "", f3 = "", d3 = "";
          if (p3 = u3 + c3 !== 0 ? `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u3} + i;
            if (x[${a2} - 1] < 0 || x[${a2} - 1] >= ${l3}) {
              pad++;
              continue;
            }
            ${n3}
          }` : `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u3} + i;
            ${n3}
          }`, 2 === e3.kernelShape.length) {
            const n4 = e3.kernelShape[e3.kernelShape.length - 2], r4 = e3.strides[e3.strides.length - 2], o3 = e3.pads[e3.pads.length / 2 - 2], s3 = e3.pads[e3.pads.length - 2], u4 = t3[a2 - 2];
            f3 = o3 + s3 !== 0 ? `
            for (int j = 0; j < ${n4}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r4} - ${o3} + j;
              if (x[${a2} - 2] < 0 || x[${a2} - 2] >= ${u4}) {
                pad+= ${i2};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n4}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r4} - ${o3} + j;
            `, d3 = "\n          }\n        ";
          }
          return `
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);

          float value = ${o2};
          int pad = 0;
          ${f3}
          ${p3}
          ${d3}
          ${r3}
          return value;
        }
      `;
        }
        {
          const s2 = i.ShapeUtil.size(e3.kernelShape), u3 = i.ShapeUtil.computeStrides(e3.kernelShape), c3 = u3.length, l3 = e3.pads.length, p3 = h2(c3), f3 = d2(t3, "inputDims"), g2 = d2(e3.pads, "pads"), b2 = d2(u3, "kernelStrides"), m2 = d2(e3.strides, "strides");
          let y2 = "";
          return y2 = e3.pads.reduce((t4, e4) => t4 + e4) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n3}
          }` : `
          }
          ${n3}
        `, `
        ${p3}
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);
          int offset[${c3}];
          int pads[${l3}];
          int inputDims[${a2}];
          int kernelStrides[${c3}];
          int strides[${c3}];
          ${g2}
          ${f3}
          ${m2}
          ${b2}

          float value = ${o2};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s2}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a2} - ${c3}; j < ${a2}; j++) {
              x[j] = indices[j] * strides[j - ${a2} + ${c3}]
                + offset[j - ${a2} + ${c3}] - pads[j - 2];
              ${y2}
          }
          ${r3}

          return value;
        }
      `;
        }
      }, d2 = (t3, e3) => {
        let n3 = "";
        for (let r3 = 0; r3 < t3.length; r3++) n3 += `
      ${e3}[${r3}] = ${t3[r3]};
    `;
        return n3;
      }, h2 = (t3) => `
  void offsetToIndices(int offset, int[${t3}] strides, out int[${t3}] indices) {
    if (${t3} == 0) {
      return;
    }
    for (int i = 0; i < ${t3} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${t3} - 1] = offset;
  }`;
    }, 4939: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.reduceLogSumSquare = e2.reduceLogSum = e2.reduceProd = e2.reduceMin = e2.reduceMax = e2.reduceMean = e2.reduceSum = e2.parseReduceAttributes = void 0;
      const r2 = n2(246), i = n2(782), o = n2(2517), a = n2(2039), s = (t3, e3, n3, r3, i2) => {
        c2(e3);
        const o2 = { name: r3, inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
        return [t3.run(Object.assign(Object.assign({}, o2), { cacheHint: n3.cacheKey, get: () => u2(t3, e3, n3, r3, i2, o2) }), e3)];
      };
      e2.parseReduceAttributes = (t3) => {
        const e3 = t3.attributes.getInts("axes", []), n3 = 1 === t3.attributes.getInt("keepdims", 1);
        return (0, r2.createAttributeWithCacheKey)({ axes: e3, keepDims: n3 });
      };
      const u2 = (t3, e3, n3, r3, i2, s2) => {
        const u3 = [], c3 = e3[0].dims.length || 1, l2 = [], p2 = o.ShapeUtil.normalizeAxes(n3.axes, e3[0].dims.length), f2 = i2(e3, p2);
        let d2 = f2[1];
        for (let t4 = 0; t4 < e3[0].dims.length; t4++) p2.indexOf(t4) >= 0 || 0 === p2.length ? (n3.keepDims && u3.push(1), d2 = `
          for(int j${t4} = 0; j${t4} < ${e3[0].dims[t4]}; j${t4}++) {
            inputIdx[${t4}] = j${t4};
            ${d2}
          }`) : (l2.push(`inputIdx[${t4}] = outputIdx[${u3.length}];`), u3.push(e3[0].dims[t4]));
        const h2 = `
      float process(int outputIdx[${u3.length || 1}]) {
        float value;                 // final result
        int inputIdx[${c3}];      // addressing input data
        ${l2.join("\n")}
        ${f2[0]}       // init ops for reduce max/min
        ${d2}
        ${f2[2]}       // final computation for reduce mean
        return value;
      }`;
        return Object.assign(Object.assign({}, s2), { output: { dims: u3, type: e3[0].type, textureType: a.TextureType.unpacked }, shaderSource: h2 });
      }, c2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Reduce op requires 1 input.");
        if (-1 === i.NUMBER_TYPES.indexOf(t3[0].type)) throw new Error("Invalid input type.");
      };
      e2.reduceSum = (t3, e3, n3) => s(t3, e3, n3, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), e2.reduceMean = (t3, e3, n3) => s(t3, e3, n3, "ReduceMean", (t4, e4) => {
        let n4 = 1;
        for (let r3 = 0; r3 < t4[0].dims.length; r3++) (e4.indexOf(r3) >= 0 || 0 === e4.length) && (n4 *= t4[0].dims[r3]);
        return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n4}.;`];
      }), e2.reduceMax = (t3, e3, n3) => s(t3, e3, n3, "ReduceMax", (t4, e4) => {
        const n4 = [];
        for (let r3 = 0; r3 < t4[0].dims.length; r3++) (e4.indexOf(r3) >= 0 || 0 === e4.length) && n4.push(`inputIdx[${r3}] = 0;`);
        return [`${n4.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
      }), e2.reduceMin = (t3, e3, n3) => s(t3, e3, n3, "ReduceMin", (t4, e4) => {
        const n4 = [];
        for (let r3 = 0; r3 < t4[0].dims.length; r3++) (e4.indexOf(r3) >= 0 || 0 === e4.length) && n4.push(`inputIdx[${r3}] = 0;`);
        return [`${n4.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
      }), e2.reduceProd = (t3, e3, n3) => s(t3, e3, n3, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), e2.reduceLogSum = (t3, e3, n3) => s(t3, e3, n3, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), e2.reduceLogSumSquare = (t3, e3, n3) => s(t3, e3, n3, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
    }, 7019: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.isReshapeCheap = e2.processDims3D = e2.createPackedReshape3DProgramInfoLoader = void 0;
      const r2 = n2(2517), i = n2(5060), o = n2(2039), a = n2(2827);
      e2.createPackedReshape3DProgramInfoLoader = (t3, e3, n3) => {
        const s = ((t4) => ({ name: "Reshape (packed)", inputTypes: [o.TextureType.packed], inputNames: ["A"], cacheHint: `${t4}` }))(n3);
        return Object.assign(Object.assign({}, s), { get: () => ((t4, e4, n4, s2) => {
          const u2 = e4.dims, c2 = s2;
          let l2 = "";
          for (let t5 = 0; t5 < 4; t5++) {
            let e5 = "";
            switch (t5) {
              case 0:
                e5 = "outputCoords = rc;";
                break;
              case 1:
                e5 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                break;
              case 2:
                e5 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                break;
              case 3:
                e5 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                break;
              default:
                throw new Error();
            }
            l2 += `
        ${e5}
        ${t5 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${t5}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${t5 > 0 ? "}" : ""}
      `;
          }
          const p2 = (0, i.getGlsl)(t4.session.backend.glContext.version), f2 = `
      ${function(t5) {
            const e5 = r2.ShapeUtil.computeStrides(t5), n5 = ["b", "r", "c"], i2 = "index";
            return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e5.map((t6, r3) => `int ${n5[r3]} = ${i2} / ${t6}; ${r3 === e5.length - 1 ? `int ${n5[r3 + 1]} = ${i2} - ${n5[r3]} * ${t6}` : `index -= ${n5[r3]} * ${t6}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
          }(u2)}
      ${function(t5) {
            const e5 = r2.ShapeUtil.computeStrides(t5);
            return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e5[0]} + coords.z * ${e5[1]} + coords.y;
  }
`;
          }(c2)}
      ${(0, a.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c2[2]};
        int cols = ${c2[1]};

        ${l2}
        ${p2.output} = result;
      }
    `;
          return Object.assign(Object.assign({}, n4), { output: { dims: c2, type: e4.type, textureType: o.TextureType.packed }, shaderSource: f2, hasMain: true });
        })(t3, e3, s, n3) });
      }, e2.processDims3D = function(t3) {
        if (0 === t3.length) return [1, 1, 1];
        let e3 = 1;
        for (let n3 = 0; n3 < t3.length - 2; ++n3) e3 *= t3[n3];
        return [e3, t3.length > 1 ? t3[t3.length - 2] : 1, t3[t3.length - 1]];
      }, e2.isReshapeCheap = function(t3, e3) {
        let n3 = false;
        return n3 = 0 === t3.length || 0 === e3.length || (t3.length < 2 || e3.length < 2 ? t3[t3.length - 1] === e3[e3.length - 1] : t3[t3.length - 1] === e3[e3.length - 1] && t3[t3.length - 2] === e3[e3.length - 2]), n3;
      };
    }, 718: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.reshape = void 0;
      const r2 = n2(2517);
      e2.reshape = (t3, e3) => {
        const n3 = r2.ShapeUtil.calculateReshapedDims(e3[0].dims, e3[1].integerData);
        return t3.session.pack ? [t3.reshapePacked(e3[0], n3)] : [t3.reshapeUnpacked(e3[0], n3)];
      };
    }, 2268: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseResizeAttributesV11 = e2.parseResizeAttributesV10 = e2.resize = void 0;
      const r2 = n2(5060), i = n2(2039), o = n2(9390), a = n2(2827), s = n2(9793), u2 = { name: "Resize", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
      e2.resize = (t3, e3, n3) => ((0, s.validateInputs)(e3, n3), [t3.run(Object.assign(Object.assign({}, u2), { cacheHint: n3.cacheKey, get: () => c2(t3, e3, n3) }), e3)]), e2.parseResizeAttributesV10 = (t3) => (0, s.parseUpsampleAttributes)(t3, 10), e2.parseResizeAttributesV11 = (t3) => (0, s.parseUpsampleAttributes)(t3, 11);
      const c2 = (t3, e3, n3) => {
        const s2 = (0, r2.getGlsl)(t3.session.backend.glContext.version), [c3, p3] = l2(e3, n3);
        if (c3.every((t4) => 1 === t4) && "tf_crop_and_resize" !== n3.coordinateTransformMode) return Object.assign(Object.assign({}, u2), { output: { dims: p3, type: e3[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${s2.texture2D}(X, TexCoords);
                    ${s2.output} = v;
                }` });
        const f3 = p3.length;
        if (f3 < 2) throw new Error(`output dimension should be at least 2, but got ${f3}`);
        const d2 = p3[f3 - 2], h2 = p3[f3 - 1], g2 = e3[0].dims;
        if (f3 !== g2.length) throw new Error(`output dimension should match input ${g2.length}, but got ${f3}`);
        const b2 = g2[f3 - 2], m2 = g2[f3 - 1], y2 = c3[f3 - 2], _ = c3[f3 - 1];
        let v2 = "";
        if ("linear" !== n3.mode) throw new Error(`resize (packed) does not support mode: '${n3.mode}'`);
        switch (n3.coordinateTransformMode) {
          case "asymmetric":
            v2 = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
            break;
          case "half_pixel":
            v2 = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
            break;
          case "pytorch_half_pixel":
            v2 = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h2}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${d2}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h2}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${d2}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
            break;
          case "align_corners":
            v2 = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h2}.0 - 1.0, ${d2}.0 - 1.0, ${h2}.0 - 1.0,
                            ${d2}.0 - 1.0);
                        vec4 original = vec4(${m2}.0 - 1.0, ${b2}.0 - 1.0, ${m2}.0 - 1.0,
                            ${b2}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
            break;
          default:
            throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n3.coordinateTransformMode}'`);
        }
        const w2 = (0, o.getCoordsDataType)(f3), x2 = `
            const vec2 inputWH = vec2(${b2}.0, ${m2}.0);
            const vec4 scaleWHWH = vec4(float(${y2}), float(${_}), float(${y2}), float(${_}));
            ${(0, a.unpackFromChannel)()}
            ${v2}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${w2} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${d2 - 1};
                bool hasNextCol = rc.z < ${h2 - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s2.output} = vec4(newValue);
            }
        `;
        return Object.assign(Object.assign({}, u2), { output: { dims: p3, type: e3[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: x2 });
      }, l2 = (t3, e3) => {
        const n3 = t3[0].dims;
        let r3, i2 = e3.scales;
        if (0 === i2.length) {
          const o3 = t3[e3.scalesInputIdx];
          if (o3 && 0 !== o3.size) {
            if (t3[e3.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
            i2 = p2(o3, e3.mode, e3.isResize);
          } else {
            const o4 = t3[e3.sizesInputIdx];
            if (!o4 || 0 === o4.size) throw new Error("Either scales or sizes MUST be provided as input.");
            r3 = Array.from(o4.integerData), i2 = f2(r3, n3, e3.mode, e3.isResize);
          }
        } else if (t3[e3.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
        const o2 = r3 || n3.map((t4, e4) => Math.floor(t4 * i2[e4]));
        return [i2, o2];
      }, p2 = (t3, e3, n3) => {
        const r3 = Array.from(t3.floatData);
        return (0, s.scalesValidation)(r3, e3, n3), r3;
      }, f2 = (t3, e3, n3, r3) => {
        const i2 = e3.length, o2 = new Array(i2);
        for (let n4 = 0, r4 = i2; n4 < r4; n4++) if (0 === e3[n4]) {
          if (0 !== t3[n4]) throw new Error("Input dim is zero but required output dim is non-zero.");
          o2[n4] = 1;
        } else o2[n4] = t3[n4] / e3[n4];
        return (0, s.scalesValidation)(o2, n3, r3), o2;
      };
    }, 8117: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.shape = void 0;
      const r2 = n2(9162);
      e2.shape = (t3, e3) => (i(e3), [new r2.Tensor([e3[0].dims.length], "int32", void 0, void 0, new Int32Array(e3[0].dims))]);
      const i = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Shape requires 1 input.");
      };
    }, 2278: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.sliceV10 = e2.parseSliceAttributes = e2.slice = void 0;
      const r2 = n2(246), i = n2(782), o = n2(2517), a = n2(2039), s = { name: "Slice", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
      e2.slice = (t3, e3, n3) => (c2(e3), [t3.run(Object.assign(Object.assign({}, s), { cacheHint: n3.cacheKey, get: () => u2(t3, e3[0], n3) }), e3)]), e2.parseSliceAttributes = (t3) => {
        const e3 = t3.attributes.getInts("starts"), n3 = t3.attributes.getInts("ends"), i2 = t3.attributes.getInts("axes", []);
        return (0, r2.createAttributeWithCacheKey)({ starts: e3, ends: n3, axes: i2 });
      };
      const u2 = (t3, e3, n3) => {
        const r3 = 0 === n3.axes.length ? e3.dims.slice(0).map((t4, e4) => e4) : n3.axes, i2 = o.ShapeUtil.normalizeAxes(r3, e3.dims.length), u3 = n3.starts.map((t4, n4) => t4 > e3.dims[i2[n4]] - 1 ? e3.dims[i2[n4]] : o.ShapeUtil.normalizeAxis(t4, e3.dims[i2[n4]])), c3 = n3.ends.map((t4, n4) => t4 > e3.dims[i2[n4]] - 1 ? e3.dims[i2[n4]] : o.ShapeUtil.normalizeAxis(t4, e3.dims[i2[n4]])), l3 = e3.dims.slice(), p3 = [];
        for (let t4 = 0; t4 < i2.length; t4++) l3[i2[t4]] = c3[t4] - u3[t4], u3[t4] > 0 && p3.push(`outputIdx[${i2[t4]}] += ${u3[t4]};`);
        const f2 = `
      float process(int outputIdx[${l3.length}]) {
        ${p3.join("\n      ")}
        return _A(outputIdx);
      }`;
        return Object.assign(Object.assign({}, s), { output: { dims: l3, type: e3.type, textureType: a.TextureType.unpacked }, shaderSource: f2 });
      }, c2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Slice requires 1 input.");
        if (-1 === i.NUMBER_TYPES.indexOf(t3[0].type)) throw new Error("Invalid input type.");
      };
      e2.sliceV10 = (t3, e3) => {
        p2(e3);
        const n3 = l2(t3, e3);
        return [t3.run(Object.assign(Object.assign({}, s), { cacheHint: n3.cacheKey, get: () => u2(t3, e3[0], n3) }), [e3[0]])];
      };
      const l2 = (t3, e3) => {
        if (!t3.session.isInitializer(e3[1].dataId) || !t3.session.isInitializer(e3[2].dataId) || e3.length >= 4 && !t3.session.isInitializer(e3[3].dataId) || e3.length >= 5 && !t3.session.isInitializer(e3[4].dataId)) throw new Error("dynamic slice attributes are not allowed");
        if (e3.length >= 5 && e3[4].integerData.some((t4) => 1 !== t4)) throw new Error("currently non-1 steps is not supported for Slice");
        const n3 = Array.from(e3[1].integerData), r3 = Array.from(e3[2].integerData), i2 = e3.length >= 4 ? Array.from(e3[3].integerData) : [];
        return { starts: n3, ends: r3, axes: i2, cacheKey: `${i2};${n3};${r3}` };
      }, p2 = (t3) => {
        if (!t3 || t3.length < 3 || t3.length > 5) throw new Error("Invalid input number.");
        if ("int32" !== t3[1].type || 1 !== t3[1].dims.length) throw new Error("Invalid input type.");
        if ("int32" !== t3[2].type || 1 !== t3[2].dims.length) throw new Error("Invalid input type.");
        if (t3.length >= 4 && ("int32" !== t3[3].type || 1 !== t3[3].dims.length)) throw new Error("Invalid input type.");
        if (t3.length >= 5 && ("int32" !== t3[4].type || 1 !== t3[4].dims.length)) throw new Error("Invalid input type.");
      };
    }, 5524: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.softmaxV13 = e2.parseSoftmaxAttributesV13 = e2.parseSoftmaxAttributes = e2.softmax = void 0;
      const r2 = n2(246), i = n2(2517), o = n2(5060), a = n2(2039), s = n2(3738), u2 = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] }, c2 = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, l2 = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked] };
      e2.softmax = (t3, e3, n3) => {
        g2(e3);
        const r3 = e3[0].dims.slice(), o2 = i.ShapeUtil.normalizeAxis(n3.axis, r3.length), a2 = i.ShapeUtil.sizeToDimension(r3, o2), s2 = i.ShapeUtil.sizeFromDimension(r3, o2);
        return p2(t3, e3, n3, a2, s2);
      }, e2.parseSoftmaxAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ axis: t3.attributes.getInt("axis", 1) }), e2.parseSoftmaxAttributesV13 = (t3) => (0, r2.createAttributeWithCacheKey)({ axis: t3.attributes.getInt("axis", -1) }), e2.softmaxV13 = (t3, e3, n3) => {
        g2(e3);
        const o2 = e3[0].dims.slice(), a2 = i.ShapeUtil.normalizeAxis(n3.axis, o2.length), u3 = o2.length, c3 = a2 !== u3 - 1, l3 = [];
        let f3, d3 = [], h3 = [];
        c3 && (d3 = Array.from({ length: u3 }).map((t4, e4) => e4), d3[a2] = u3 - 1, d3[u3 - 1] = a2, d3.map((t4) => l3.push(o2[t4])), f3 = (0, r2.createAttributeWithCacheKey)({ perm: d3 }), h3 = (0, s.transpose)(t3, e3, f3));
        const b2 = c3 ? i.ShapeUtil.sizeToDimension(l3, u3 - 1) : i.ShapeUtil.sizeToDimension(o2, u3 - 1), m2 = c3 ? i.ShapeUtil.sizeFromDimension(l3, u3 - 1) : i.ShapeUtil.sizeFromDimension(o2, u3 - 1), y2 = p2(t3, c3 ? h3 : e3, n3, b2, m2);
        return c3 ? (0, s.transpose)(t3, y2, f3) : y2;
      };
      const p2 = (t3, e3, n3, r3, i2) => {
        const o2 = f2(t3, e3[0], r3, i2, [r3]), a2 = t3.run(Object.assign(Object.assign({}, u2), { cacheHint: n3.cacheKey, get: () => o2 }), e3), s2 = d2(t3, e3[0], r3, i2, o2.output.dims, [r3]), p3 = t3.run(Object.assign(Object.assign({}, c2), { cacheHint: n3.cacheKey, get: () => s2 }), [e3[0], a2]), g3 = h2(t3, e3[0], r3, i2, o2.output.dims, s2.output.dims);
        return [t3.run(Object.assign(Object.assign({}, l2), { cacheHint: n3.cacheKey, get: () => g3 }), [e3[0], a2, p3])];
      }, f2 = (t3, e3, n3, r3, i2) => {
        const [s2, c3] = t3.calculateTextureWidthAndHeight(e3.dims, a.TextureType.unpacked), l3 = i2.length;
        if (n3 < 1 || r3 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        if (1 !== i2.length) throw new Error("Dimensionality of the output should be 1");
        if (i2[0] !== n3) throw new Error("Shape of the output should be equal to logical row count");
        const p3 = (0, o.getGlsl)(t3.session.backend.glContext.version), f3 = `
      float process(int[${l3}] indices) {
        int logical_row_start_offset = indices[0] * ${r3};

        float max = getColorAsFloat(${p3.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s2},
        ${c3} )));
        for(int i=1; i<${r3}; ++i)
        {
          float current = getColorAsFloat(${p3.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s2}, ${c3})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
        return Object.assign(Object.assign({}, u2), { output: { dims: i2, type: e3.type, textureType: a.TextureType.unpacked }, shaderSource: f3 });
      }, d2 = (t3, e3, n3, r3, i2, s2) => {
        const [u3, l3] = t3.calculateTextureWidthAndHeight(e3.dims, a.TextureType.unpacked), p3 = s2.length;
        if (n3 < 1 || r3 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        if (1 !== s2.length) throw new Error("Dimensionality of the output should be 1");
        if (s2[0] !== n3) throw new Error("Shape of the output should be equal to logical row count");
        if (1 !== i2.length) throw new Error("Dimensionality of the intermediate results should be 1");
        if (i2[0] !== n3) throw new Error("Shape of the intermediate results should be equal to logical row count");
        const f3 = `
      float process(int[${p3}] indices) {
        int logical_row_start_offset = indices[0] * ${r3};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r3}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, o.getGlsl)(t3.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u3}, ${l3}))) - max);
        }

        return norm_factor;
      }`;
        return Object.assign(Object.assign({}, c2), { output: { dims: s2, type: e3.type, textureType: a.TextureType.unpacked }, shaderSource: f3 });
      }, h2 = (t3, e3, n3, r3, i2, o2) => {
        const [s2, u3] = t3.calculateTextureWidthAndHeight(e3.dims, a.TextureType.unpacked), c3 = e3.dims.length;
        if (n3 < 1 || r3 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
        if (1 !== i2.length || 1 !== o2.length) throw new Error("Dimensionality of the intermediate results should be 1");
        if (i2[0] !== n3 || o2[0] !== n3) throw new Error("Shape of the intermediate results should be equal to logical row count");
        const p3 = `
      float process(int[${c3}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s2}, ${u3});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r3};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
        return Object.assign(Object.assign({}, l2), { output: { dims: e3.dims, type: e3.type, textureType: a.TextureType.unpacked }, shaderSource: p3 });
      }, g2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Softmax requires 1 input.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type");
      };
    }, 5975: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseSplitAttributes = e2.split = void 0;
      const r2 = n2(246), i = n2(2517), o = n2(2039), a = { name: "Split", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
      e2.split = (t3, e3, n3) => {
        c2(e3);
        const r3 = i.ShapeUtil.normalizeAxis(n3.axis, e3[0].dims.length), o2 = s(t3, e3, r3, n3), l2 = [];
        for (let i2 = 0; i2 < o2; ++i2) l2.push(t3.run(Object.assign(Object.assign({}, a), { cacheHint: `${n3.cacheKey};${i2}`, get: () => u2(t3, e3[0], n3, r3, i2) }), e3));
        return l2;
      }, e2.parseSplitAttributes = (t3) => {
        const e3 = t3.attributes.getInt("axis", 0), n3 = t3.attributes.getInts("split", []), i2 = t3.outputs.length;
        return (0, r2.createAttributeWithCacheKey)({ axis: e3, split: n3, numOutputs: i2 });
      };
      const s = (t3, e3, n3, r3) => {
        const [, o2] = i.SplitUtil.splitShape(e3[0].dims, n3, r3.split, r3.numOutputs);
        return o2.length;
      }, u2 = (t3, e3, n3, r3, s2) => {
        const [u3, c3] = i.SplitUtil.splitShape(e3.dims, r3, n3.split, n3.numOutputs), l2 = c3[s2], p2 = u3[s2], f2 = `
      float process(int indices[${p2.length}]) {
        indices[${r3}] += ${l2};
        return _A(indices);
      }
    `;
        return Object.assign(Object.assign({}, a), { cacheHint: `${n3.cacheKey}:${s2}`, output: { dims: p2, type: e3.type, textureType: o.TextureType.unpacked }, shaderSource: f2 });
      }, c2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Split requires one input.");
        if ("int8" !== t3[0].type && "uint8" !== t3[0].type && "int16" !== t3[0].type && "uint16" !== t3[0].type && "int32" !== t3[0].type && "uint32" !== t3[0].type && "float32" !== t3[0].type && "float64" !== t3[0].type && "bool" !== t3[0].type) throw new Error("Invalid input type.");
      };
    }, 3933: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseSqueezeAttributes = e2.squeezeV13 = e2.squeeze = void 0;
      const r2 = n2(2517);
      e2.squeeze = (t3, e3, n3) => {
        i(e3);
        const o2 = r2.ShapeUtil.squeezeShape(e3[0].dims, n3);
        return [t3.reshapeUnpacked(e3[0], o2)];
      }, e2.squeezeV13 = (t3, n3) => (o(n3), (0, e2.squeeze)(t3, [n3[0]], Array.from(n3[1].integerData))), e2.parseSqueezeAttributes = (t3) => t3.attributes.getInts("axes");
      const i = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Squeeze requires 1 input.");
        if ("string" === t3[0].type) throw new Error("invalid input tensor types.");
      }, o = (t3) => {
        if (!t3 || 2 !== t3.length) throw new Error("Squeeze requires 2 inputs.");
        if ("int32" !== t3[1].type) throw new Error("Invalid input type.");
      };
    }, 6558: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.sum = void 0;
      const r2 = n2(5060), i = n2(2039);
      e2.sum = (t3, e3) => {
        a(e3);
        const n3 = { name: "Sum", inputNames: e3.map((t4, e4) => `X${e4}`), inputTypes: new Array(e3.length).fill(i.TextureType.unpacked) };
        return [t3.run(Object.assign(Object.assign({}, n3), { get: () => o(t3, e3, n3) }), e3)];
      };
      const o = (t3, e3, n3) => {
        const o2 = (0, r2.getGlsl)(t3.session.backend.glContext.version), a2 = e3[0].dims.slice(), s = `
      void main() {
        vec4 result = ${e3.map((t4, e4) => `${o2.texture2D}(X${e4},TexCoords)`).join(" + ")};
        ${o2.output} = result;
      }
    `;
        return Object.assign(Object.assign({}, n3), { output: { dims: a2, type: e3[0].type, textureType: i.TextureType.unpacked }, hasMain: true, shaderSource: s });
      }, a = (t3) => {
        if (!t3 || 0 === t3.length) throw new Error("Sum requires inputs.");
        const e3 = t3[0].dims.length;
        for (let n3 = 1; n3 < t3.length; n3++) {
          if (e3 !== t3[n3].dims.length) throw new Error("Input shapes are mismatched.");
          for (let r3 = 0; r3 < e3; r3++) if (t3[0].dims[r3] !== t3[n3].dims[r3]) throw new Error("Input shapes are not matched.");
        }
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("Invalid input type.");
        for (let e4 = 1; e4 < t3.length; e4++) if (t3[0].type !== t3[e4].type) throw new Error("Input types are not matched.");
      };
    }, 5723: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.tile = void 0;
      const r2 = n2(782), i = n2(2039);
      e2.tile = (t3, e3) => {
        a(e3);
        const n3 = { name: "Tile", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
        return [t3.run(Object.assign(Object.assign({}, n3), { get: () => o(t3, e3, n3) }), e3)];
      };
      const o = (t3, e3, n3) => {
        const r3 = e3[0].dims.slice(), o2 = new Array(r3.length), a2 = [];
        for (let t4 = 0; t4 < r3.length; t4++) o2[t4] = r3[t4] * e3[1].numberData[t4], a2.push(`inputIdx[${t4}] = int(mod(float(outputIdx[${t4}]), ${r3[t4]}.));`);
        const s = o2.length, u2 = `
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${a2.join("\n")}
        return _A(inputIdx);
      }
    `;
        return Object.assign(Object.assign({}, n3), { output: { dims: o2, type: e3[0].type, textureType: i.TextureType.unpacked }, shaderSource: u2 });
      }, a = (t3) => {
        if (!t3 || 2 !== t3.length) throw new Error("Tile requires 2 input.");
        if (1 !== t3[1].dims.length) throw new Error("The second input shape must 1 dimension.");
        if (t3[1].dims[0] !== t3[0].dims.length) throw new Error("Invalid input shape.");
        if (-1 === r2.NUMBER_TYPES.indexOf(t3[0].type)) throw new Error("Invalid input type.");
        if ("int32" !== t3[1].type && "int16" !== t3[1].type) throw new Error("Invalid repeat type.");
      };
    }, 3738: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseTransposeAttributes = e2.transpose = void 0;
      const r2 = n2(246), i = n2(2517), o = n2(2039), a = { name: "Transpose", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
      e2.transpose = (t3, e3, n3) => (p2(e3), [t3.run(Object.assign(Object.assign({}, a), { cacheHint: n3.cacheKey, get: () => s(t3, e3[0], n3.perm) }), e3)]), e2.parseTransposeAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ perm: t3.attributes.getInts("perm", []) });
      const s = (t3, e3, n3) => {
        const r3 = e3.dims;
        n3 = u2(r3, n3);
        const i2 = c2(r3, n3), s2 = r3.length, p3 = `
      ${l2("perm", n3, s2)}
      float process(int indices[${s2}]) {
        int a[${s2}];
        perm(a, indices);
        return _A(a);
      }`;
        return Object.assign(Object.assign({}, a), { output: { dims: i2, type: e3.type, textureType: o.TextureType.unpacked }, shaderSource: p3 });
      }, u2 = (t3, e3) => (e3 && e3.length !== t3.length && (e3 = [...t3.keys()].reverse()), e3), c2 = (t3, e3) => (e3 = u2(t3, e3), i.ShapeUtil.sortBasedOnPerm(t3, e3)), l2 = (t3, e3, n3) => {
        const r3 = [];
        r3.push(`void ${t3}(out int a[${n3}], int src[${n3}]) {`);
        for (let t4 = 0; t4 < n3; ++t4) r3.push(`	a[${e3[t4]}]=src[${t4}];`);
        return r3.push("	}"), r3.join("\n");
      }, p2 = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Transpose requires 1 input.");
        if ("float32" !== t3[0].type && "float64" !== t3[0].type) throw new Error("input should be float tensor");
      };
    }, 8710: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.encodeAsUint8 = void 0;
      const r2 = n2(5060), i = n2(2039);
      e2.encodeAsUint8 = (t3, e3) => {
        const n3 = e3.shape, o = (0, r2.getGlsl)(t3.session.backend.glContext.version), a = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o.texture2D}(X,TexCoords).r;
      ${o.output} = encodeAsUint8(value);
    }`, s = { name: "Uint8Encode", inputTypes: [i.TextureType.unpacked], inputNames: ["X"], output: { dims: n3, type: e3.tensor.type, textureType: i.TextureType.downloadUint8AsFloat }, shaderSource: a, hasMain: true };
        return t3.executeProgram(s, [e3.tensor]);
      };
    }, 4909: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.tanh = e2.tan = e2.sqrt = e2.sin = e2.sigmoid = e2.relu = e2.not = e2.neg = e2.log = e2.parseLeakyReluAttributes = e2.leakyRelu = e2.identity = e2.floor = e2.exp = e2.parseEluAttributes = e2.elu = e2.cos = e2.ceil = e2.clipV11 = e2.parseClipAttributes = e2.clip = e2.atan = e2.asin = e2.acos = e2.abs = e2.glslTanh = e2.glslTan = e2.glslSqrt = e2.glslSigmoid = e2.glslRelu = e2.glslSin = e2.glslNot = e2.glslNeg = e2.glslLog = e2.glslLeakyRelu = e2.glslIdentity = e2.glslClip = e2.glslFloor = e2.glslExp = e2.glslElu = e2.glslCos = e2.glslCeil = e2.glslAtan = e2.glslAsin = e2.glslAcos = e2.glslAbs = void 0;
      const r2 = n2(246), i = n2(2517), o = n2(8520), a = n2(5060), s = n2(2039);
      function u2() {
        return P2("abs");
      }
      function c2() {
        return P2("acos");
      }
      function l2() {
        return P2("asin");
      }
      function p2() {
        return P2("atan");
      }
      function f2() {
        return P2("ceil");
      }
      function d2() {
        return P2("cos");
      }
      function h2(t3) {
        const e3 = "elu";
        return { body: `
  const float alpha = float(${t3});

  float ${e3}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e3}_(vec4 v) {
    return vec4(${e3}_(v.x), ${e3}_(v.y), ${e3}_(v.z), ${e3}_(v.w));
  }
  `, name: e3, type: o.FunctionType.ValueBased };
      }
      function g2() {
        return P2("exp");
      }
      function b2() {
        return P2("floor");
      }
      function m2(t3, e3) {
        const n3 = "clip";
        return { body: `
  const float min = float(${t3});
  const float max = float(${e3});

  float ${n3}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n3}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n3, type: o.FunctionType.ValueBased };
      }
      function y2() {
        const t3 = "indentity";
        return { body: `
  float ${t3}_(float a) {
    return a;
  }
  vec4 ${t3}_(vec4 v) {
    return v;
  }
  `, name: t3, type: o.FunctionType.ValueBased };
      }
      function _(t3) {
        const e3 = "leakyRelu";
        return { body: `
  const float alpha = float(${t3});

  float ${e3}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e3}_(vec4 v) {
    return vec4(${e3}_(v.x), ${e3}_(v.y), ${e3}_(v.z), ${e3}_(v.w));
  }
  `, name: e3, type: o.FunctionType.ValueBased };
      }
      function v2() {
        return P2("log");
      }
      function w2() {
        const t3 = "neg";
        return { body: `
  float ${t3}_(float a) {
    return -a;
  }
  vec4 ${t3}_(vec4 v) {
    return -v;
  }
  `, name: t3, type: o.FunctionType.ValueBased };
      }
      function x2() {
        const t3 = "not";
        return { body: `
  float ${t3}_(float a) {
    return float( ! bool(a) );
  }
  bool ${t3}_(bool a) {
    return !a;
  }
  vec4 ${t3}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${t3}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: t3, type: o.FunctionType.ValueBased };
      }
      function T2() {
        return P2("sin");
      }
      function S2() {
        const t3 = "relu";
        return { body: `
  float ${t3}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${t3}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: t3, type: o.FunctionType.ValueBased };
      }
      function O2() {
        const t3 = "sigmoid";
        return { body: `
  float ${t3}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${t3}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: t3, type: o.FunctionType.ValueBased };
      }
      function A2() {
        return P2("sqrt");
      }
      function E2() {
        return P2("tan");
      }
      function I2() {
        const t3 = "tanh";
        return { body: `
  float ${t3}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${t3}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: t3, type: o.FunctionType.ValueBased };
      }
      function P2(t3) {
        return { body: `
  float ${t3}_(float a) {
    return ${t3}(a);
  }
  vec4 ${t3}_(vec4 v) {
    return ${t3}(v);
  }
  `, name: t3, type: o.FunctionType.ValueBased };
      }
      e2.glslAbs = u2, e2.glslAcos = c2, e2.glslAsin = l2, e2.glslAtan = p2, e2.glslCeil = f2, e2.glslCos = d2, e2.glslElu = h2, e2.glslExp = g2, e2.glslFloor = b2, e2.glslClip = m2, e2.glslIdentity = y2, e2.glslLeakyRelu = _, e2.glslLog = v2, e2.glslNeg = w2, e2.glslNot = x2, e2.glslSin = T2, e2.glslRelu = S2, e2.glslSigmoid = O2, e2.glslSqrt = A2, e2.glslTan = E2, e2.glslTanh = I2;
      const D2 = (t3, e3, n3, r3) => {
        const i2 = t3.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o2 = { name: n3.name, inputTypes: [i2], inputNames: ["A"], cacheHint: r3 };
        return Object.assign(Object.assign({}, o2), { get: () => ((t4, e4, n4, r4) => {
          const i3 = t4.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o3 = (0, a.getGlsl)(t4.session.backend.glContext.version);
          return Object.assign(Object.assign({}, e4), { output: { dims: n4.dims, type: n4.type, textureType: i3 }, shaderSource: `
     ${r4.body}
     void main() {
       vec4 v = ${o3.texture2D}(A, TexCoords);
       v = ${r4.name}_(v);
       ${o3.output} = v;
     }
     `, hasMain: true });
        })(t3, o2, e3, n3) });
      };
      e2.abs = (t3, e3) => [t3.run(D2(t3, e3[0], u2()), e3)], e2.acos = (t3, e3) => [t3.run(D2(t3, e3[0], c2()), e3)], e2.asin = (t3, e3) => [t3.run(D2(t3, e3[0], l2()), e3)], e2.atan = (t3, e3) => [t3.run(D2(t3, e3[0], p2()), e3)], e2.clip = (t3, e3, n3) => [t3.run(D2(t3, e3[0], m2(n3.min, n3.max), n3.cacheKey), e3)], e2.parseClipAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ min: t3.attributes.getFloat("min", i.MIN_CLIP), max: t3.attributes.getFloat("max", i.MAX_CLIP) }), e2.clipV11 = (t3, n3) => {
        const r3 = $(t3, n3);
        return (0, e2.clip)(t3, [n3[0]], r3);
      };
      const $ = (t3, e3) => {
        if (e3.length >= 3 && (!t3.session.isInitializer(e3[1].dataId) || !t3.session.isInitializer(e3[2].dataId))) throw new Error("dynamic clip attributes are not allowed");
        const n3 = e3.length >= 3 ? e3[1].numberData[0] : i.MIN_CLIP, o2 = e3.length >= 3 ? e3[2].numberData[0] : i.MAX_CLIP;
        return (0, r2.createAttributeWithCacheKey)({ min: n3, max: o2 });
      };
      e2.ceil = (t3, e3) => [t3.run(D2(t3, e3[0], f2()), e3)], e2.cos = (t3, e3) => [t3.run(D2(t3, e3[0], d2()), e3)], e2.elu = (t3, e3, n3) => [t3.run(D2(t3, e3[0], h2(n3.alpha), n3.cacheKey), e3)], e2.parseEluAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ alpha: t3.attributes.getFloat("alpha", 1) }), e2.exp = (t3, e3) => [t3.run(D2(t3, e3[0], g2()), e3)], e2.floor = (t3, e3) => [t3.run(D2(t3, e3[0], b2()), e3)], e2.identity = (t3, e3) => [t3.run(D2(t3, e3[0], y2()), e3)], e2.leakyRelu = (t3, e3, n3) => [t3.run(D2(t3, e3[0], _(n3.alpha), n3.cacheKey), e3)], e2.parseLeakyReluAttributes = (t3) => (0, r2.createAttributeWithCacheKey)({ alpha: t3.attributes.getFloat("alpha", 0.01) }), e2.log = (t3, e3) => [t3.run(D2(t3, e3[0], v2()), e3)], e2.neg = (t3, e3) => [t3.run(D2(t3, e3[0], w2()), e3)], e2.not = (t3, e3) => [t3.run(D2(t3, e3[0], x2()), e3)], e2.relu = (t3, e3) => [t3.run(D2(t3, e3[0], S2()), e3)], e2.sigmoid = (t3, e3) => [t3.run(D2(t3, e3[0], O2()), e3)], e2.sin = (t3, e3) => [t3.run(D2(t3, e3[0], T2()), e3)], e2.sqrt = (t3, e3) => [t3.run(D2(t3, e3[0], A2()), e3)], e2.tan = (t3, e3) => [t3.run(D2(t3, e3[0], E2()), e3)], e2.tanh = (t3, e3) => [t3.run(D2(t3, e3[0], I2()), e3)];
    }, 5611: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createUnpackProgramInfoLoader = e2.createUnpackProgramInfo = void 0;
      const r2 = n2(5060), i = n2(2039), o = n2(9390), a = n2(2827), s = { name: "unpack", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
      e2.createUnpackProgramInfo = (t3, e3) => {
        const n3 = e3.dims.length, u2 = (0, a.getChannels)("rc", n3), c2 = u2.slice(-2), l2 = (0, o.getCoordsDataType)(n3), p2 = (0, a.unpackFromChannel)(), f2 = 0 === e3.dims.length ? "" : function(t4, e4) {
          if (1 === t4) return "rc";
          let n4 = "";
          for (let r3 = 0; r3 < t4; r3++) n4 += e4[r3], r3 < t4 - 1 && (n4 += ",");
          return n4;
        }(n3, u2), d2 = n3 <= 1 ? "rc" : `vec2(${c2.join(",")})`, h2 = `
    ${p2}
    void main() {
      ${l2} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${f2});

       ${(0, r2.getGlsl)(t3.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d2}), 0, 0, 0);
     }
   `;
        return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: e3.dims, type: e3.type, textureType: i.TextureType.unpacked }, shaderSource: h2 });
      }, e2.createUnpackProgramInfoLoader = (t3, n3) => Object.assign(Object.assign({}, s), { get: () => (0, e2.createUnpackProgramInfo)(t3, n3) });
    }, 8428: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.parseUnsqueezeAttributes = e2.unsqueezeV13 = e2.unsqueeze = void 0;
      const r2 = n2(2517);
      e2.unsqueeze = (t3, e3, n3) => {
        i(e3);
        const o2 = r2.ShapeUtil.unsqueezeShape(e3[0].dims, n3);
        return [t3.reshapeUnpacked(e3[0], o2)];
      }, e2.unsqueezeV13 = (t3, n3) => (o(n3), (0, e2.unsqueeze)(t3, [n3[0]], Array.from(n3[1].integerData))), e2.parseUnsqueezeAttributes = (t3) => t3.attributes.getInts("axes");
      const i = (t3) => {
        if (!t3 || 1 !== t3.length) throw new Error("Unsqueeze requires 1 input.");
        if ("string" === t3[0].type) throw new Error("invalid input tensor types.");
      }, o = (t3) => {
        if (!t3 || 2 !== t3.length) throw new Error("Unsqueeze requires 2 inputs.");
        if ("int32" !== t3[1].type) throw new Error("Invalid input type.");
      };
    }, 9793: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.scalesValidation = e2.validateInputs = e2.parseUpsampleAttributes = e2.parseUpsampleAttributesV9 = e2.parseUpsampleAttributesV7 = e2.upsample = void 0;
      const r2 = n2(246), i = n2(5060), o = n2(2039), a = { name: "Upsample", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
      e2.upsample = (t3, n3, r3) => ((0, e2.validateInputs)(n3, r3), [t3.run(Object.assign(Object.assign({}, a), { cacheHint: r3.cacheKey, get: () => s(t3, n3, r3) }), n3)]), e2.parseUpsampleAttributesV7 = (t3) => (0, e2.parseUpsampleAttributes)(t3, 7), e2.parseUpsampleAttributesV9 = (t3) => (0, e2.parseUpsampleAttributes)(t3, 9), e2.parseUpsampleAttributes = (t3, n3) => {
        const i2 = n3 >= 10, o2 = t3.attributes.getString("mode", "nearest");
        if ("nearest" !== o2 && "linear" !== o2 && (n3 < 11 || "cubic" !== o2)) throw new Error(`unrecognized mode: ${o2}`);
        let a2 = [];
        n3 < 9 && (a2 = t3.attributes.getFloats("scales"), (0, e2.scalesValidation)(a2, o2, i2));
        const s2 = t3.attributes.getFloat("extrapolation_value", 0), u2 = n3 > 10 ? t3.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
        if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(u2)) throw new Error(`coordinate_transform_mode '${u2}' is not supported`);
        const c2 = "tf_crop_and_resize" === u2, l2 = c2, p2 = "nearest" === o2 && n3 >= 11 ? t3.attributes.getString("nearest_mode", "round_prefer_floor") : "";
        if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p2)) throw new Error(`nearest_mode '${p2}' is not supported`);
        const f2 = t3.attributes.getFloat("cubic_coeff_a", -0.75), d2 = 0 !== t3.attributes.getInt("exclude_outside", 0);
        if (d2 && "cubic" !== o2) throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
        const h2 = n3 < 11 || "nearest" === o2 && "asymmetric" === u2 && "floor" === p2;
        let g2 = 0, b2 = 0, m2 = 0;
        return n3 > 10 ? t3.inputs.length > 2 ? (g2 = 1, b2 = 2, m2 = 3) : (b2 = 1, m2 = 2) : 9 === n3 && (b2 = 1), (0, r2.createAttributeWithCacheKey)({ opset: n3, isResize: i2, mode: o2, scales: a2, extrapolationValue: s2, coordinateTransformMode: u2, useExtrapolation: l2, needRoiInput: c2, nearestMode: p2, cubicCoefficientA: f2, excludeOutside: d2, useNearest2xOptimization: h2, roiInputIdx: g2, scalesInputIdx: b2, sizesInputIdx: m2 });
      };
      const s = (t3, e3, n3) => {
        const r3 = (0, i.getGlsl)(t3.session.backend.glContext.version), [s2, u2] = t3.calculateTextureWidthAndHeight(e3[0].dims, o.TextureType.unpacked), c2 = e3[0].dims.map((t4, e4) => Math.floor(t4 * n3.scales[e4])), [l2, p2] = t3.calculateTextureWidthAndHeight(c2, o.TextureType.unpacked), f2 = c2.length, d2 = new Array(f2), h2 = new Array(f2);
        let g2 = `
      int output_pitches[${f2}];
      int input_pitches[${f2}];
      `;
        for (let t4 = f2 - 1; t4 >= 0; t4--) d2[t4] = t4 === f2 - 1 ? 1 : d2[t4 + 1] * c2[t4 + 1], h2[t4] = t4 === f2 - 1 ? 1 : h2[t4 + 1] * e3[0].dims[t4 + 1], g2 += `
        output_pitches[${t4}] = ${d2[t4]};
        input_pitches[${t4}] = ${h2[t4]};
        `;
        const b2 = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s2}, ${u2});
        float value = getColorAsFloat(${r3.texture2D}(X, coords));
        return value;
      }
      `, m2 = "nearest" === n3.mode ? `
    ${b2}
    float process(int indices[${f2}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l2}, ${p2});

      ${g2}

      int d, m;
      for (int dim = 0; dim < ${f2}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === f2 ? `
    ${b2}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l2}, ${p2});

      ${g2}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e3[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${b2}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l2}, ${p2});

      ${g2}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e3[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
        return Object.assign(Object.assign({}, a), { output: { dims: c2, type: e3[0].type, textureType: o.TextureType.unpacked }, shaderSource: m2, variables: [{ name: "scales", type: "int", arrayLength: n3.scales.length, data: n3.scales.map((t4) => Math.ceil(t4)) }] });
      };
      e2.validateInputs = (t3, e3) => {
        if (!t3 || e3.opset < 9 && 1 !== t3.length || e3.opset >= 9 && e3.opset < 11 && 2 !== t3.length || e3.opset >= 11 && t3.length < 2) throw new Error("invalid inputs.");
        if (e3.scales.length > 0 && t3[0].dims.length !== e3.scales.length) throw new Error("Invalid input shape.");
        if ("string" === t3[0].type) throw new Error("Invalid input tensor types.");
      }, e2.scalesValidation = (t3, e3, n3) => {
        if (n3) {
          for (const e4 of t3) if (e4 <= 0) throw new Error("Scale value should be greater than 0.");
        } else for (const e4 of t3) if (e4 < 1) throw new Error("Scale value should be greater than or equal to 1.");
        if (!("linear" !== e3 && "cubic" !== e3 || 2 === t3.length || 4 === t3.length && 1 === t3[0] && 1 === t3[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n3 ? "Resize" : "Upsample"} opeartor.`);
      };
    }, 1958: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.ProgramManager = void 0;
      const r2 = n2(1670), i = n2(6231), o = n2(8879), a = n2(5060);
      e2.ProgramManager = class {
        constructor(t3, e3, n3) {
          this.profiler = t3, this.glContext = e3, this.textureLayoutStrategy = n3, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
        }
        getArtifact(t3) {
          return this.repo.get(t3);
        }
        setArtifact(t3, e3) {
          this.repo.set(t3, e3);
        }
        run(t3, e3, n3) {
          var r3;
          this.profiler.event("op", `ProgramManager.run ${null !== (r3 = t3.programInfo.name) && void 0 !== r3 ? r3 : "unknown kernel"}`, () => {
            var r4;
            const o2 = this.glContext.gl, a2 = t3.program;
            o2.useProgram(a2);
            try {
              this.bindOutput(n3), this.attributesBound || this.bindAttributes(t3.attribLocations), this.bindUniforms(t3.uniformLocations, null !== (r4 = t3.programInfo.variables) && void 0 !== r4 ? r4 : [], e3);
            } catch (e4) {
              throw i.Logger.error("ProgramManager", t3.programInfo.shaderSource), e4;
            }
            this.profiler.event("backend", "GlContext.draw()", () => {
              this.glContext.draw();
            });
          }, this.glContext);
        }
        dispose() {
          this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((t3) => this.glContext.deleteProgram(t3.program));
        }
        build(t3, e3, n3) {
          return this.profiler.event("backend", "ProgramManager.build", () => {
            const r3 = new o.GlslPreprocessor(this.glContext, t3, e3, n3), i2 = r3.preprocess(), a2 = this.compile(i2);
            return { programInfo: t3, program: a2, uniformLocations: this.getUniformLocations(a2, r3.context.programInfo.inputNames, r3.context.programInfo.variables), attribLocations: this.getAttribLocations(a2) };
          });
        }
        compile(t3) {
          if (!this.vertexShader) {
            i.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
            const t4 = (0, a.getVertexShaderSource)(this.glContext.version);
            this.vertexShader = this.glContext.compileShader(t4, this.glContext.gl.VERTEX_SHADER);
          }
          r2.env.debug && i.Logger.verbose("ProrgramManager", `FragShader:
${t3}
`);
          const e3 = this.glContext.compileShader(t3, this.glContext.gl.FRAGMENT_SHADER), n3 = this.glContext.createProgram(this.vertexShader, e3);
          return this.glContext.deleteShader(e3), n3;
        }
        bindOutput(t3) {
          const e3 = t3.width, n3 = t3.height;
          i.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${e3}/${n3}, shape=${t3.shape}, type=${t3.tensor.type}`), this.glContext.attachFramebuffer(t3.texture, e3, n3);
        }
        bindAttributes(t3) {
          const e3 = t3.position, n3 = t3.textureCoord;
          this.glContext.setVertexAttributes(e3, n3), this.attributesBound = true;
        }
        bindUniforms(t3, e3, n3) {
          var r3;
          const i2 = this.glContext.gl;
          let o2 = 0;
          for (const { name: a2, type: s, location: u2, arrayLength: c2 } of t3) {
            const t4 = null === (r3 = e3.find((t5) => t5.name === a2)) || void 0 === r3 ? void 0 : r3.data;
            if ("sampler2D" !== s && !t4) throw new Error(`variable '${a2}' does not have data defined in program info`);
            switch (s) {
              case "sampler2D":
                this.bindTexture(n3[o2], u2, o2), o2++;
                break;
              case "float":
                c2 ? i2.uniform1fv(u2, t4) : i2.uniform1f(u2, t4);
                break;
              case "int":
                c2 ? i2.uniform1iv(u2, t4) : i2.uniform1i(u2, t4);
                break;
              default:
                throw new Error(`Uniform not implemented: ${s}`);
            }
          }
        }
        bindTexture(t3, e3, n3) {
          this.glContext.bindTextureToUniform(t3.texture, n3, e3);
        }
        getAttribLocations(t3) {
          return { position: this.getAttribLocation(t3, "position"), textureCoord: this.getAttribLocation(t3, "textureCoord") };
        }
        getUniformLocations(t3, e3, n3) {
          const r3 = [];
          if (e3) for (const n4 of e3) r3.push({ name: n4, type: "sampler2D", location: this.getUniformLocation(t3, n4) });
          if (n3) for (const e4 of n3) r3.push(Object.assign(Object.assign({}, e4), { location: this.getUniformLocation(t3, e4.name) }));
          return r3;
        }
        getUniformLocation(t3, e3) {
          const n3 = this.glContext.gl.getUniformLocation(t3, e3);
          if (null === n3) throw new Error(`Uniform ${e3} not found.`);
          return n3;
        }
        getAttribLocation(t3, e3) {
          return this.glContext.gl.getAttribLocation(t3, e3);
        }
      };
    }, 6416: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebGLSessionHandler = void 0;
      const r2 = n2(6231), i = n2(1047), o = n2(8316), a = n2(1640), s = n2(1958), u2 = n2(7859), c2 = n2(5702);
      e2.WebGLSessionHandler = class {
        constructor(t3, e3) {
          this.backend = t3, this.context = e3, this.layoutStrategy = new u2.PreferLogicalStrategy(t3.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, t3.glContext, this.layoutStrategy), this.textureManager = new c2.TextureManager(t3.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === t3.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = t3.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
        }
        createInferenceHandler() {
          return new o.WebGLInferenceHandler(this);
        }
        onGraphInitialized(t3) {
          const e3 = t3.getValues().filter((t4) => -1 === t4.from && t4.tensor).map((t4) => t4.tensor.dataId);
          this.initializers = new Set(e3);
        }
        isInitializer(t3) {
          return !!this.initializers && this.initializers.has(t3);
        }
        addInitializer(t3) {
          this.initializers.add(t3);
        }
        getTextureData(t3, e3) {
          return e3 ? this.packedTextureDataCache.get(t3) : this.unpackedTextureDataCache.get(t3);
        }
        setTextureData(t3, e3, n3 = false) {
          r2.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n3 ? this.packedTextureDataCache.set(t3, e3) : this.unpackedTextureDataCache.set(t3, e3);
        }
        dispose() {
          this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t3) => this.textureManager.releaseTexture(t3, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t3) => this.textureManager.releaseTexture(t3, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        }
        resolve(t3, e3, n3) {
          const r3 = (0, i.resolveOperator)(t3, e3, a.WEBGL_OP_RESOLVE_RULES);
          return { impl: r3.opImpl, context: r3.opInit ? r3.opInit(t3, n3) : t3 };
        }
      };
    }, 7769: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Uint8DataEncoder = e2.RGBAFloatDataEncoder = e2.RedFloat32DataEncoder = void 0;
      const r2 = n2(6231);
      e2.RedFloat32DataEncoder = class {
        constructor(t3, e3 = 1) {
          if (1 === e3) this.internalFormat = t3.R32F, this.format = t3.RED, this.textureType = t3.FLOAT, this.channelSize = e3;
          else {
            if (4 !== e3) throw new Error(`Invalid number of channels: ${e3}`);
            this.internalFormat = t3.RGBA32F, this.format = t3.RGBA, this.textureType = t3.FLOAT, this.channelSize = e3;
          }
        }
        encode(t3, e3) {
          let n3, i;
          return t3.constructor !== Float32Array && (r2.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), i = new Float32Array(t3)), e3 * this.channelSize > t3.length ? (r2.Logger.warning("Encoder", "Source data too small. Allocating larger array"), i = t3, n3 = this.allocate(e3 * this.channelSize), i.forEach((t4, e4) => n3[e4] = t4)) : (i = t3, n3 = i), n3;
        }
        allocate(t3) {
          return new Float32Array(4 * t3);
        }
        decode(t3, e3) {
          return 1 === this.channelSize ? t3.filter((t4, e4) => e4 % 4 == 0).subarray(0, e3) : t3.subarray(0, e3);
        }
      }, e2.RGBAFloatDataEncoder = class {
        constructor(t3, e3 = 1, n3) {
          if (1 !== e3 && 4 !== e3) throw new Error(`Invalid number of channels: ${e3}`);
          this.internalFormat = t3.RGBA, this.format = t3.RGBA, this.channelSize = e3, this.textureType = n3 || t3.FLOAT;
        }
        encode(t3, e3) {
          let n3 = t3;
          return 1 === this.channelSize && (r2.Logger.verbose("Encoder", "Exploding into a larger array"), n3 = this.allocate(e3), t3.forEach((t4, e4) => n3[4 * e4] = t4)), n3;
        }
        allocate(t3) {
          return new Float32Array(4 * t3);
        }
        decode(t3, e3) {
          return 1 === this.channelSize ? t3.filter((t4, e4) => e4 % 4 == 0).subarray(0, e3) : t3.subarray(0, e3);
        }
      }, e2.Uint8DataEncoder = class {
        constructor(t3, e3 = 1) {
          if (this.channelSize = 4, 1 === e3) this.internalFormat = t3.ALPHA, this.format = t3.ALPHA, this.textureType = t3.UNSIGNED_BYTE, this.channelSize = e3;
          else {
            if (4 !== e3) throw new Error(`Invalid number of channels: ${e3}`);
            this.internalFormat = t3.RGBA, this.format = t3.RGBA, this.textureType = t3.UNSIGNED_BYTE, this.channelSize = e3;
          }
        }
        encode(t3, e3) {
          return new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
        }
        allocate(t3) {
          return new Uint8Array(t3 * this.channelSize);
        }
        decode(t3, e3) {
          if (t3 instanceof Uint8Array) return t3.subarray(0, e3);
          throw new Error(`Invalid array type: ${t3.constructor}`);
        }
      };
    }, 7859: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.getBatchDim = e2.sizeToSquarishShape = e2.getRowsCols = e2.sizeFromShape = e2.isInt = e2.parseAxisParam = e2.squeezeShape = e2.PreferLogicalStrategy = e2.AlwaysKeepOriginalSizeStrategy = void 0;
      const r2 = n2(6231), i = n2(2517);
      function o(t3, e3) {
        const n3 = [], r3 = [], i2 = null != e3 && Array.isArray(e3) && 0 === e3.length, o2 = null == e3 || i2 ? null : a(e3, t3).sort();
        let s2 = 0;
        for (let e4 = 0; e4 < t3.length; ++e4) {
          if (null != o2) {
            if (o2[s2] === e4 && 1 !== t3[e4]) throw new Error(`Can't squeeze axis ${e4} since its dim '${t3[e4]}' is not 1`);
            (null == o2[s2] || o2[s2] > e4) && 1 === t3[e4] && (n3.push(t3[e4]), r3.push(e4)), o2[s2] <= e4 && s2++;
          }
          1 !== t3[e4] && (n3.push(t3[e4]), r3.push(e4));
        }
        return { newShape: n3, keptDims: r3 };
      }
      function a(t3, e3) {
        const n3 = e3.length;
        return t3 = null == t3 ? e3.map((t4, e4) => e4) : [].concat(t3), (0, i.assert)(t3.every((t4) => t4 >= -n3 && t4 < n3), () => `All values in axis param must be in range [-${n3}, ${n3}) but got axis ${t3}`), (0, i.assert)(t3.every(s), () => `All values in axis param must be integers but got axis ${t3}`), t3.map((t4) => t4 < 0 ? n3 + t4 : t4);
      }
      function s(t3) {
        return t3 % 1 == 0;
      }
      function u2(t3) {
        if (0 === t3.length) return 1;
        let e3 = t3[0];
        for (let n3 = 1; n3 < t3.length; n3++) e3 *= t3[n3];
        return e3;
      }
      function c2(t3) {
        const e3 = Math.ceil(Math.sqrt(t3));
        return [e3, Math.ceil(t3 / e3)];
      }
      e2.AlwaysKeepOriginalSizeStrategy = class {
        constructor(t3) {
          this.maxTextureSize = t3;
        }
        computeTextureWH(t3, e3) {
          if (0 === t3.length) return [1, 1];
          const n3 = this.maxTextureSize;
          if (e3 && void 0 !== e3.breakAxis) {
            const i3 = e3.breakAxis >= t3.length ? 1 : t3.slice(e3.breakAxis).reduce((t4, e4) => t4 * e4), o3 = e3.breakAxis <= 0 ? 1 : t3.slice(0, e3.breakAxis).reduce((t4, e4) => t4 * e4);
            if (!(i3 > n3 || o3 > n3)) return [i3, o3];
            r2.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t3}, breakAxis:${e3.breakAxis}`);
          }
          const i2 = t3.reduce((t4, e4) => t4 * e4);
          let o2 = Math.floor(Math.sqrt(i2));
          for (; o2 < n3 && o2 < i2 && i2 % o2 != 0; o2++) ;
          if (o2 >= n3 || i2 % o2 != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${t3}`);
          return [o2, i2 / o2];
        }
      }, e2.PreferLogicalStrategy = class {
        constructor(t3) {
          this.maxTextureSize = t3;
        }
        computeTextureWH(t3, e3) {
          const n3 = this.computeTexture(t3, e3);
          return e3 && e3.isPacked && (n3[0] /= 2, n3[1] /= 2), e3 && e3.reverseWH ? [n3[1], n3[0]] : n3;
        }
        computeTexture(t3, e3) {
          const n3 = e3 && e3.isPacked;
          if (0 === t3.length) return n3 ? [2, 2] : [1, 1];
          let i2 = this.maxTextureSize;
          if (e3 && void 0 !== e3.breakAxis) {
            const n4 = e3.breakAxis >= t3.length ? 1 : t3.slice(e3.breakAxis).reduce((t4, e4) => t4 * e4), o2 = e3.breakAxis <= 0 ? 1 : t3.slice(0, e3.breakAxis).reduce((t4, e4) => t4 * e4);
            if (!(n4 > i2 || o2 > i2)) return [n4, o2];
            r2.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t3}, breakAxis:${e3.breakAxis}`);
          }
          let a2 = t3.slice(0);
          if (n3 && (i2 *= 2, a2 = a2.map((t4, e4) => e4 >= a2.length - 2 ? a2[e4] % 2 == 0 ? a2[e4] : a2[e4] + 1 : a2[e4]), 1 === a2.length && (a2 = [2, a2[0]])), 2 !== a2.length) {
            const t4 = o(a2);
            a2 = t4.newShape;
          }
          const s2 = u2(a2);
          return a2.length <= 1 && s2 <= i2 ? [1, s2] : 2 === a2.length && a2[0] <= i2 && a2[1] <= i2 ? a2 : 3 === a2.length && a2[0] * a2[1] <= i2 && a2[2] <= i2 ? [a2[0] * a2[1], a2[2]] : 3 === a2.length && a2[0] <= i2 && a2[1] * a2[2] <= i2 ? [a2[0], a2[1] * a2[2]] : 4 === a2.length && a2[0] * a2[1] * a2[2] <= i2 && a2[3] <= i2 ? [a2[0] * a2[1] * a2[2], a2[3]] : 4 === a2.length && a2[0] <= i2 && a2[1] * a2[2] * a2[3] <= i2 ? [a2[0], a2[1] * a2[2] * a2[3]] : n3 ? c2(s2 / 4).map((t4) => 2 * t4) : c2(s2);
        }
      }, e2.squeezeShape = o, e2.parseAxisParam = a, e2.isInt = s, e2.sizeFromShape = u2, e2.getRowsCols = function(t3) {
        if (0 === t3.length) throw Error("Cannot get rows and columns of an empty shape array.");
        return [t3.length > 1 ? t3[t3.length - 2] : 1, t3[t3.length - 1]];
      }, e2.sizeToSquarishShape = c2, e2.getBatchDim = function(t3, e3 = 2) {
        return u2(t3.slice(0, t3.length - e3));
      };
    }, 4057: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createTextureLayoutFromShape = e2.calculateTextureWidthAndHeight = e2.createTextureLayoutFromTextureType = void 0;
      const r2 = n2(2517), i = n2(2039);
      e2.createTextureLayoutFromTextureType = (t3, n3, r3) => {
        const o = r3 === i.TextureType.unpacked || r3 === i.TextureType.unpackedReversed ? 1 : 4, a = r3 === i.TextureType.packed, s = r3 === i.TextureType.unpackedReversed || r3 === i.TextureType.packed, u2 = r3 === i.TextureType.packedLastDimension ? n3.length - 1 : void 0, c2 = r3 === i.TextureType.packedLastDimension ? n3.map((t4, e3) => e3 === n3.length - 1 ? 4 * t4 : t4) : void 0;
        return (0, e2.createTextureLayoutFromShape)(t3, n3, o, c2, { isPacked: a, reverseWH: s, breakAxis: u2 });
      }, e2.calculateTextureWidthAndHeight = (t3, n3, r3) => {
        const i2 = (0, e2.createTextureLayoutFromTextureType)(t3, n3, r3);
        return [i2.width, i2.height];
      }, e2.createTextureLayoutFromShape = (t3, e3, n3 = 1, i2, o) => {
        const a = !(!o || !o.isPacked), [s, u2] = t3.computeTextureWH(a && i2 || e3, o), c2 = e3.length;
        let l2 = e3.slice(0);
        if (0 === c2 && (l2 = [1]), 1 === n3) i2 = e3;
        else if (a) {
          if (4 !== n3) throw new Error("a packed texture must be 4-channel");
          i2 = e3, c2 > 0 && (l2[c2 - 1] = Math.ceil(l2[c2 - 1] / 2)), c2 > 1 && (l2[c2 - 2] = Math.ceil(l2[c2 - 2] / 2));
        } else if (!i2) throw new Error("Unpacked shape is needed when using channels > 1");
        return { width: s, height: u2, channels: n3, isPacked: a, shape: l2, strides: r2.ShapeUtil.computeStrides(l2), unpackedShape: i2, reversedWH: o && o.reverseWH };
      };
    }, 5702: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.TextureManager = void 0;
      const r2 = n2(6231);
      e2.TextureManager = class {
        constructor(t3, e3, n3, r3) {
          this.glContext = t3, this.layoutStrategy = e3, this.profiler = n3, this.config = r3, this.pendingRead = /* @__PURE__ */ new Map(), r3.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
        }
        createTextureFromLayout(t3, e3, n3, i) {
          const o = this.toEncoderType(t3), a = this.glContext.getEncoder(o, e3.channels || 1, i);
          if (e3.isPacked && 1 === i) throw new Error("not implemented");
          const s = e3.width, u2 = e3.height;
          let c2, l2;
          if (this.config.reuseTextures) {
            c2 = `${s}x${u2}_${a.format}_${a.internalFormat}_${a.textureType}`, l2 = this.inUseTextures.get(c2), l2 || (l2 = [], this.inUseTextures.set(c2, l2));
            const e4 = this.idleTextures.get(c2);
            if (e4 && e4.length > 0) {
              const r3 = e4.pop();
              return l2.push(r3), 1 === i && this.glContext.updateTexture(r3, s, u2, a, this.toTextureData(t3, n3)), r3;
            }
          }
          r2.Logger.verbose("TextureManager", `Creating new texture of size ${e3.width}x${e3.height}`);
          const p2 = this.glContext.allocateTexture(s, u2, a, this.toTextureData(t3, n3));
          return this.config.reuseTextures && (l2.push(p2), this.textureLookup.set(p2, c2)), p2;
        }
        readTexture(t3, e3, n3) {
          return n3 || (n3 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
            const r3 = t3.shape.reduce((t4, e4) => t4 * e4) * n3, i = this.glContext.readTexture(t3.texture, t3.width, t3.height, r3, this.toEncoderType(e3), n3);
            return this.toTensorData(e3, i);
          });
        }
        async readTextureAsync(t3, e3, n3) {
          const r3 = t3.tensor.dataId;
          if (n3 || (n3 = 1), this.pendingRead.has(r3)) {
            const t4 = this.pendingRead.get(r3);
            return new Promise((e4) => null == t4 ? void 0 : t4.push(e4));
          }
          return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
            this.pendingRead.set(r3, []);
            const i = t3.shape.reduce((t4, e4) => t4 * e4) * n3;
            await this.glContext.createAndWaitForFence();
            const o = this.glContext.readTexture(t3.texture, t3.width, t3.height, i, this.toEncoderType(e3), n3), a = this.toTensorData(e3, o), s = this.pendingRead.get(r3);
            return this.pendingRead.delete(r3), null == s || s.forEach((t4) => t4(a)), a;
          });
        }
        readUint8TextureAsFloat(t3) {
          return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
            const e3 = t3.shape.reduce((t4, e4) => t4 * e4), n3 = this.glContext.readTexture(t3.texture, t3.width, t3.height, 4 * e3, "byte", 4);
            return new Float32Array(n3.buffer, n3.byteOffset, e3);
          });
        }
        releaseTexture(t3, e3) {
          let n3;
          if (this.config.reuseTextures && (n3 = this.textureLookup.get(t3.texture), n3)) {
            e3 && this.textureLookup.delete(n3);
            const r3 = this.inUseTextures.get(n3);
            if (r3) {
              const e4 = r3.indexOf(t3.texture);
              if (-1 !== e4) {
                r3.splice(e4, 1);
                let i = this.idleTextures.get(n3);
                i || (i = [], this.idleTextures.set(n3, i)), i.push(t3.texture);
              }
            }
          }
          n3 && !e3 || (r2.Logger.verbose("TextureManager", `Deleting texture of size ${t3.width}x${t3.height}`), this.glContext.deleteTexture(t3.texture));
        }
        toTensorData(t3, e3) {
          switch (t3) {
            case "int16":
              return e3 instanceof Int16Array ? e3 : Int16Array.from(e3);
            case "int32":
              return e3 instanceof Int32Array ? e3 : Int32Array.from(e3);
            case "int8":
              return e3 instanceof Int8Array ? e3 : Int8Array.from(e3);
            case "uint16":
              return e3 instanceof Uint16Array ? e3 : Uint16Array.from(e3);
            case "uint32":
              return e3 instanceof Uint32Array ? e3 : Uint32Array.from(e3);
            case "uint8":
            case "bool":
              return e3 instanceof Uint8Array ? e3 : Uint8Array.from(e3);
            case "float32":
              return e3 instanceof Float32Array ? e3 : Float32Array.from(e3);
            case "float64":
              return e3 instanceof Float64Array ? e3 : Float64Array.from(e3);
            default:
              throw new Error(`TensorData type ${t3} is not supported`);
          }
        }
        toTextureData(t3, e3) {
          if (e3) return e3 instanceof Float32Array ? e3 : new Float32Array(e3);
        }
        toEncoderType(t3) {
          return "float";
        }
        clearActiveTextures() {
          this.glContext.clearActiveTextures();
        }
      };
    }, 2039: (t2, e2) => {
      var n2;
      Object.defineProperty(e2, "__esModule", { value: true }), e2.TextureType = void 0, (n2 = e2.TextureType || (e2.TextureType = {}))[n2.unpacked = 0] = "unpacked", n2[n2.unpackedReversed = 1] = "unpackedReversed", n2[n2.packed = 2] = "packed", n2[n2.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n2[n2.packedLastDimension = 4] = "packedLastDimension";
    }, 9390: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.getGlChannels = e2.getCoordsDataType = e2.getSqueezedParams = e2.squeezeInputShape = e2.generateShaderFuncNameFromInputSamplerNameAtOutCoords = e2.generateShaderFuncNameFromInputSamplerName = e2.repeatedTry = e2.getPackedShape = void 0;
      const r2 = n2(2517);
      e2.getPackedShape = function(t3) {
        const e3 = t3.length;
        return t3.slice(0, e3 - 1).concat(t3[e3 - 1] / 4);
      }, e2.repeatedTry = async function(t3, e3 = (t4) => 0, n3) {
        return new Promise((r3, i) => {
          let o = 0;
          const a = () => {
            if (t3()) return void r3();
            o++;
            const s = e3(o);
            null != n3 && o >= n3 ? i() : setTimeout(a, s);
          };
          a();
        });
      }, e2.generateShaderFuncNameFromInputSamplerName = function(t3) {
        return (0, r2.assert)(void 0 !== t3 && 0 !== t3.length, () => "empty string found for sampler name"), "get" + t3.charAt(0).toUpperCase() + t3.slice(1);
      }, e2.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(t3) {
        return (0, r2.assert)(void 0 !== t3 && 0 !== t3.length, () => "empty string found for sampler name"), "get" + t3.charAt(0).toUpperCase() + t3.slice(1) + "AtOutCoords";
      }, e2.squeezeInputShape = function(t3, e3) {
        let n3 = JSON.parse(JSON.stringify(t3));
        return n3 = e3, n3;
      }, e2.getSqueezedParams = function(t3, e3) {
        return e3.map((e4) => t3[e4]).join(", ");
      }, e2.getCoordsDataType = function(t3) {
        if (t3 <= 1) return "int";
        if (2 === t3) return "ivec2";
        if (3 === t3) return "ivec3";
        if (4 === t3) return "ivec4";
        if (5 === t3) return "ivec5";
        if (6 === t3) return "ivec6";
        throw Error(`GPU for rank ${t3} is not yet supported`);
      }, e2.getGlChannels = function(t3 = 6) {
        return ["x", "y", "z", "w", "u", "v"].slice(0, t3);
      };
    }, 7305: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.createNewWebGLContext = e2.createWebGLContext = void 0;
      const r2 = n2(6231), i = n2(1713), o = {};
      function a(t3) {
        const e3 = function() {
          if ("undefined" == typeof document) {
            if ("undefined" == typeof OffscreenCanvas) throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");
            return new OffscreenCanvas(1, 1);
          }
          const t4 = document.createElement("canvas");
          return t4.width = 1, t4.height = 1, t4;
        }();
        let n3;
        const o2 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
        if ((!t3 || "webgl2" === t3) && (n3 = e3.getContext("webgl2", o2), n3)) try {
          return new i.WebGLContext(n3, 2);
        } catch (t4) {
          r2.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${t4}`);
        }
        if ((!t3 || "webgl" === t3) && (n3 = e3.getContext("webgl", o2) || e3.getContext("experimental-webgl", o2), n3)) try {
          return new i.WebGLContext(n3, 1);
        } catch (t4) {
          r2.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t4}`);
        }
        throw new Error("WebGL is not supported");
      }
      e2.createWebGLContext = function t3(e3) {
        let n3;
        e3 && "webgl2" !== e3 || !("webgl2" in o) ? e3 && "webgl" !== e3 || !("webgl" in o) || (n3 = o.webgl) : n3 = o.webgl2, n3 = n3 || a(e3), e3 = e3 || 1 === n3.version ? "webgl" : "webgl2";
        const r3 = n3.gl;
        return o[e3] = n3, r3.isContextLost() ? (delete o[e3], t3(e3)) : (r3.disable(r3.DEPTH_TEST), r3.disable(r3.STENCIL_TEST), r3.disable(r3.BLEND), r3.disable(r3.DITHER), r3.disable(r3.POLYGON_OFFSET_FILL), r3.disable(r3.SAMPLE_COVERAGE), r3.enable(r3.SCISSOR_TEST), r3.enable(r3.CULL_FACE), r3.cullFace(r3.BACK), n3);
      }, e2.createNewWebGLContext = a;
    }, 1713: function(t2, e2, n2) {
      var r2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i2 = Object.getOwnPropertyDescriptor(e3, n3);
        i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i2);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), i = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
        Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
      } : function(t3, e3) {
        t3.default = e3;
      }), o = this && this.__importStar || function(t3) {
        if (t3 && t3.__esModule) return t3;
        var e3 = {};
        if (null != t3) for (var n3 in t3) "default" !== n3 && Object.prototype.hasOwnProperty.call(t3, n3) && r2(e3, t3, n3);
        return i(e3, t3), e3;
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.WebGLContext = e2.linearSearchLastTrue = void 0;
      const a = n2(1670), s = o(n2(7769)), u2 = n2(9390);
      function c2(t3) {
        let e3 = 0;
        for (; e3 < t3.length && t3[e3](); ++e3) ;
        return e3 - 1;
      }
      e2.linearSearchLastTrue = c2, e2.WebGLContext = class {
        constructor(t3, e3) {
          this.frameBufferBound = false, this.itemsToPoll = [], this.gl = t3, this.version = e3, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
        }
        allocateTexture(t3, e3, n3, r3) {
          const i2 = this.gl, o2 = i2.createTexture();
          i2.bindTexture(i2.TEXTURE_2D, o2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, i2.CLAMP_TO_EDGE), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, i2.CLAMP_TO_EDGE);
          const a2 = r3 ? n3.encode(r3, t3 * e3) : null;
          return i2.texImage2D(i2.TEXTURE_2D, 0, n3.internalFormat, t3, e3, 0, n3.format, n3.textureType, a2), this.checkError(), o2;
        }
        updateTexture(t3, e3, n3, r3, i2) {
          const o2 = this.gl;
          o2.bindTexture(o2.TEXTURE_2D, t3);
          const a2 = r3.encode(i2, e3 * n3);
          o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, e3, n3, r3.format, r3.textureType, a2), this.checkError();
        }
        attachFramebuffer(t3, e3, n3) {
          const r3 = this.gl;
          r3.bindTexture(r3.TEXTURE_2D, t3), r3.bindFramebuffer(r3.FRAMEBUFFER, this.framebuffer), r3.framebufferTexture2D(r3.FRAMEBUFFER, r3.COLOR_ATTACHMENT0, r3.TEXTURE_2D, t3, 0), this.checkError(), r3.viewport(0, 0, e3, n3), r3.scissor(0, 0, e3, n3);
        }
        readTexture(t3, e3, n3, r3, i2, o2) {
          const a2 = this.gl;
          o2 || (o2 = 1), this.frameBufferBound || this.attachFramebuffer(t3, e3, n3);
          const s2 = this.getEncoder(i2, o2), u3 = s2.allocate(e3 * n3);
          return a2.bindTexture(a2.TEXTURE_2D, t3), a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_2D, t3, 0), a2.readPixels(0, 0, e3, n3, a2.RGBA, s2.textureType, u3), this.checkError(), s2.decode(u3, r3);
        }
        isFramebufferReady() {
          return true;
        }
        getActiveTexture() {
          const t3 = this.gl;
          return "TEXTURE" + (t3.getParameter(this.gl.ACTIVE_TEXTURE) - t3.TEXTURE0);
        }
        getTextureBinding() {
          return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
        }
        getFramebufferBinding() {
          return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
        }
        setVertexAttributes(t3, e3) {
          const n3 = this.gl;
          n3.vertexAttribPointer(t3, 3, n3.FLOAT, false, 20, 0), n3.enableVertexAttribArray(t3), -1 !== e3 && (n3.vertexAttribPointer(e3, 2, n3.FLOAT, false, 20, 12), n3.enableVertexAttribArray(e3)), this.checkError();
        }
        createProgram(t3, e3) {
          const n3 = this.gl, r3 = n3.createProgram();
          return n3.attachShader(r3, t3), n3.attachShader(r3, e3), n3.linkProgram(r3), r3;
        }
        compileShader(t3, e3) {
          const n3 = this.gl, r3 = n3.createShader(e3);
          if (!r3) throw new Error(`createShader() returned null with type ${e3}`);
          if (n3.shaderSource(r3, t3), n3.compileShader(r3), false === n3.getShaderParameter(r3, n3.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n3.getShaderInfoLog(r3)}
Shader source:
${t3}`);
          return r3;
        }
        deleteShader(t3) {
          this.gl.deleteShader(t3);
        }
        bindTextureToUniform(t3, e3, n3) {
          const r3 = this.gl;
          r3.activeTexture(r3.TEXTURE0 + e3), this.checkError(), r3.bindTexture(r3.TEXTURE_2D, t3), this.checkError(), r3.uniform1i(n3, e3), this.checkError();
        }
        draw() {
          this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
        }
        checkError() {
          if (a.env.debug) {
            const t3 = this.gl, e3 = t3.getError();
            let n3 = "";
            switch (e3) {
              case t3.NO_ERROR:
                return;
              case t3.INVALID_ENUM:
                n3 = "INVALID_ENUM";
                break;
              case t3.INVALID_VALUE:
                n3 = "INVALID_VALUE";
                break;
              case t3.INVALID_OPERATION:
                n3 = "INVALID_OPERATION";
                break;
              case t3.INVALID_FRAMEBUFFER_OPERATION:
                n3 = "INVALID_FRAMEBUFFER_OPERATION";
                break;
              case t3.OUT_OF_MEMORY:
                n3 = "OUT_OF_MEMORY";
                break;
              case t3.CONTEXT_LOST_WEBGL:
                n3 = "CONTEXT_LOST_WEBGL";
                break;
              default:
                n3 = `Unknown WebGL Error: ${e3.toString(16)}`;
            }
            throw new Error(n3);
          }
        }
        deleteTexture(t3) {
          this.gl.deleteTexture(t3);
        }
        deleteProgram(t3) {
          this.gl.deleteProgram(t3);
        }
        getEncoder(t3, e3, n3 = 0) {
          if (2 === this.version) return new s.RedFloat32DataEncoder(this.gl, e3);
          switch (t3) {
            case "float":
              return 1 === n3 || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, e3) : new s.RGBAFloatDataEncoder(this.gl, e3, this.textureHalfFloatExtension.HALF_FLOAT_OES);
            case "int":
              throw new Error("not implemented");
            case "byte":
              return new s.Uint8DataEncoder(this.gl, e3);
            default:
              throw new Error(`Invalid dataType: ${t3}`);
          }
        }
        clearActiveTextures() {
          const t3 = this.gl;
          for (let e3 = 0; e3 < this.maxTextureImageUnits; ++e3) t3.activeTexture(t3.TEXTURE0 + e3), t3.bindTexture(t3.TEXTURE_2D, null);
        }
        dispose() {
          if (this.disposed) return;
          const t3 = this.gl;
          t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteFramebuffer(this.framebuffer), t3.bindBuffer(t3.ARRAY_BUFFER, null), t3.deleteBuffer(this.vertexbuffer), t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, null), t3.finish(), this.disposed = true;
        }
        createDefaultGeometry() {
          return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
        }
        createVertexbuffer() {
          const t3 = this.gl, e3 = t3.createBuffer();
          if (!e3) throw new Error("createBuffer() returned null");
          const n3 = this.createDefaultGeometry();
          return t3.bindBuffer(t3.ARRAY_BUFFER, e3), t3.bufferData(t3.ARRAY_BUFFER, n3, t3.STATIC_DRAW), this.checkError(), e3;
        }
        createFramebuffer() {
          const t3 = this.gl.createFramebuffer();
          if (!t3) throw new Error("createFramebuffer returned null");
          return t3;
        }
        queryVitalParameters() {
          const t3 = this.gl;
          if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error("both float32 and float16 TextureType are not supported");
          this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = t3.getParameter(t3.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = t3.getParameter(t3.MAX_TEXTURE_IMAGE_UNITS), this.version;
        }
        getExtensions() {
          2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
        }
        checkFloatTextureAttachableToFrameBuffer() {
          const t3 = this.gl, e3 = t3.createTexture();
          t3.bindTexture(t3.TEXTURE_2D, e3);
          const n3 = 2 === this.version ? t3.RGBA32F : t3.RGBA;
          t3.texImage2D(t3.TEXTURE_2D, 0, n3, 1, 1, 0, t3.RGBA, t3.FLOAT, null);
          const r3 = t3.createFramebuffer();
          t3.bindFramebuffer(t3.FRAMEBUFFER, r3), t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e3, 0);
          const i2 = t3.checkFramebufferStatus(t3.FRAMEBUFFER) === t3.FRAMEBUFFER_COMPLETE;
          return t3.bindTexture(t3.TEXTURE_2D, null), t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteTexture(e3), t3.deleteFramebuffer(r3), i2;
        }
        checkRenderFloat32() {
          if (2 === this.version) {
            if (!this.colorBufferFloatExtension) return false;
          } else if (!this.textureFloatExtension) return false;
          return this.isFloatTextureAttachableToFrameBuffer;
        }
        checkFloat32Download() {
          if (2 === this.version) {
            if (!this.colorBufferFloatExtension) return false;
          } else {
            if (!this.textureFloatExtension) return false;
            if (!this.gl.getExtension("WEBGL_color_buffer_float")) return false;
          }
          return this.isFloatTextureAttachableToFrameBuffer;
        }
        checkFloat32Blend() {
          const t3 = this.gl;
          let e3, n3, r3, i2, o2;
          try {
            e3 = t3.createTexture(), n3 = t3.createFramebuffer(), t3.bindTexture(t3.TEXTURE_2D, e3);
            const a2 = 2 === this.version ? t3.RGBA32F : t3.RGBA;
            return t3.texImage2D(t3.TEXTURE_2D, 0, a2, 1, 1, 0, t3.RGBA, t3.FLOAT, null), t3.bindFramebuffer(t3.FRAMEBUFFER, n3), t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e3, 0), t3.enable(t3.BLEND), r3 = t3.createShader(t3.VERTEX_SHADER), !!r3 && (t3.shaderSource(r3, "void main(){}"), t3.compileShader(r3), i2 = t3.createShader(t3.FRAGMENT_SHADER), !!i2 && (t3.shaderSource(i2, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), t3.compileShader(i2), o2 = t3.createProgram(), !!o2 && (t3.attachShader(o2, r3), t3.attachShader(o2, i2), t3.linkProgram(o2), t3.useProgram(o2), t3.drawArrays(t3.POINTS, 0, 1), t3.getError() === t3.NO_ERROR)));
          } finally {
            t3.disable(t3.BLEND), o2 && t3.deleteProgram(o2), r3 && t3.deleteShader(r3), i2 && t3.deleteShader(i2), n3 && (t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteFramebuffer(n3)), e3 && (t3.bindTexture(t3.TEXTURE_2D, null), t3.deleteTexture(e3));
          }
        }
        beginTimer() {
          if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
            const t3 = this.gl, e3 = this.disjointTimerQueryWebgl2Extension, n3 = t3.createQuery();
            return t3.beginQuery(e3.TIME_ELAPSED_EXT, n3), n3;
          }
          throw new Error("WebGL1 profiling currently not supported.");
        }
        endTimer() {
          if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
          {
            const t3 = this.gl, e3 = this.disjointTimerQueryWebgl2Extension;
            t3.endQuery(e3.TIME_ELAPSED_EXT);
          }
        }
        isTimerResultAvailable(t3) {
          let e3 = false, n3 = false;
          if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
          {
            const r3 = this.gl, i2 = this.disjointTimerQueryWebgl2Extension;
            e3 = r3.getQueryParameter(t3, r3.QUERY_RESULT_AVAILABLE), n3 = r3.getParameter(i2.GPU_DISJOINT_EXT);
          }
          return e3 && !n3;
        }
        getTimerResult(t3) {
          let e3 = 0;
          if (2 !== this.version) throw new Error("WebGL1 profiling currently not supported");
          {
            const n3 = this.gl;
            e3 = n3.getQueryParameter(t3, n3.QUERY_RESULT), n3.deleteQuery(t3);
          }
          return e3 / 1e6;
        }
        async waitForQueryAndGetTime(t3) {
          return await (0, u2.repeatedTry)(() => this.isTimerResultAvailable(t3)), this.getTimerResult(t3);
        }
        async createAndWaitForFence() {
          const t3 = this.createFence(this.gl);
          return this.pollFence(t3);
        }
        createFence(t3) {
          let e3;
          const n3 = t3, r3 = n3.fenceSync(n3.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return t3.flush(), e3 = null === r3 ? () => true : () => {
            const t4 = n3.clientWaitSync(r3, 0, 0);
            return t4 === n3.ALREADY_SIGNALED || t4 === n3.CONDITION_SATISFIED;
          }, { query: r3, isFencePassed: e3 };
        }
        async pollFence(t3) {
          return new Promise((e3) => {
            this.addItemToPoll(() => t3.isFencePassed(), () => e3());
          });
        }
        pollItems() {
          const t3 = c2(this.itemsToPoll.map((t4) => t4.isDoneFn));
          for (let e3 = 0; e3 <= t3; ++e3) {
            const { resolveFn: t4 } = this.itemsToPoll[e3];
            t4();
          }
          this.itemsToPoll = this.itemsToPoll.slice(t3 + 1);
        }
        async addItemToPoll(t3, e3) {
          this.itemsToPoll.push({ isDoneFn: t3, resolveFn: e3 }), this.itemsToPoll.length > 1 || await (0, u2.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length));
        }
      };
    }, 1036: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.ExecutionPlan = void 0;
      const r2 = n2(6231);
      class i {
        constructor(t3, e3) {
          this.op = t3, this.node = e3;
        }
      }
      e2.ExecutionPlan = class {
        constructor(t3, e3, n3) {
          this.graph = t3, this.profiler = n3, this.initialize(e3);
        }
        initialize(t3) {
          this.profiler.event("session", "ExecutionPlan.initialize", () => {
            const e3 = this.graph.getNodes();
            if (e3.length !== t3.length) throw new Error("The size of nodes and OPs do not match.");
            this._ops = t3.map((t4, n3) => new i(t4, e3[n3])), this.reset(), this._starter = [], this._ops.forEach((t4, e4) => {
              let n3 = true;
              for (const e5 of t4.node.inputs) if (!this._values[e5] && -1 === this.graph.getInputIndices().indexOf(e5)) {
                n3 = false;
                break;
              }
              n3 && this._starter.push(e4);
            });
          });
        }
        reset() {
          this._values = this.graph.getValues().map((t3) => t3.tensor);
        }
        async execute(t3, e3) {
          return this.profiler.event("session", "ExecutionPlan.execute", async () => {
            this.reset();
            const n3 = t3.createInferenceHandler(), i2 = this.graph.getInputIndices();
            if (e3.length !== i2.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e3.length} expected: ${i2.length}`);
            e3.forEach((t4, e4) => {
              const n4 = i2[e4];
              this._values[n4] = t4;
            });
            const o = this._starter.slice(0), a = this.graph.getValues(), s = this.graph.getNodes();
            let u2 = 0;
            for (; u2 < o.length; ) {
              const t4 = o[u2++], e4 = this._ops[t4], i3 = e4.node.inputs.map((t5) => this._values[t5]);
              if (-1 !== i3.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${e4.node}`);
              const c3 = i3;
              r2.Logger.verbose("ExecPlan", `Runing op:${e4.node.name} (${c3.map((t5, n4) => `'${e4.node.inputs[n4]}': ${t5.type}[${t5.dims.join(",")}]`).join(", ")})`);
              const l2 = await this.profiler.event("node", e4.node.name, async () => e4.op.impl(n3, c3, e4.op.context));
              if (l2.length !== e4.node.outputs.length) throw new Error("the size of output does not match model definition.");
              l2.forEach((t5, n4) => {
                const r3 = e4.node.outputs[n4];
                if (this._values[r3]) throw new Error(`output [${r3}] already has value: op:${e4.node.name}`);
                this._values[r3] = t5;
              });
              const p2 = /* @__PURE__ */ new Set();
              l2.forEach((t5, n4) => {
                const r3 = e4.node.outputs[n4];
                for (const t6 of a[r3].to) {
                  const e5 = s[t6];
                  let n5 = true;
                  for (const t7 of e5.inputs) if (!this._values[t7]) {
                    n5 = false;
                    break;
                  }
                  n5 && p2.add(t6);
                }
              }), o.push(...p2);
            }
            const c2 = [];
            for (let t4 = 0; t4 < this.graph.getOutputIndices().length; t4++) {
              const e4 = this.graph.getOutputIndices()[t4], n4 = this._values[e4];
              if (void 0 === n4) throw new Error(`required output [${e4}] does not have value`);
              0 === e4 ? await n4.getData() : n4.data, c2.push(n4);
            }
            return r2.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n3.dispose(), c2;
          });
        }
      };
    }, 7070: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Graph = void 0;
      const r2 = n2(1446), i = n2(7778), o = n2(9395), a = n2(9162), s = n2(2517);
      var u2 = o.onnxruntime.experimental.fbs;
      e2.Graph = { from: (t3, e3) => new p2(t3, e3) };
      class c2 {
        constructor(t3) {
          this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, t3 && (this.type = s.ProtoUtil.tensorValueTypeFromProto(t3.type.tensorType));
        }
        get from() {
          return this._from;
        }
        get to() {
          return this._to;
        }
      }
      class l2 {
        constructor(t3, e3) {
          t3 instanceof r2.onnx.NodeProto ? (this.name = t3.name, this.opType = t3.opType, this.attributes = new i.Attribute(t3.attribute)) : t3 instanceof u2.Node && (this.name = null != e3 ? e3 : t3.name(), this.opType = t3.opType(), this.attributes = new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t3))), this.inputs = [], this.outputs = [], this.executeNode = true;
        }
      }
      class p2 {
        constructor(t3, e3) {
          if (!t3) throw new TypeError("graph is empty");
          this.buildGraph(t3), this.transformGraph(e3), this.checkIsAcyclic();
        }
        getInputIndices() {
          return this._allInputIndices;
        }
        getInputNames() {
          return this._allInputNames;
        }
        getOutputIndices() {
          return this._allOutputIndices;
        }
        getOutputNames() {
          return this._allOutputNames;
        }
        getValues() {
          return this._allData;
        }
        getNodes() {
          return this._nodes;
        }
        buildGraph(t3) {
          if (t3 instanceof r2.onnx.GraphProto) this.buildGraphFromOnnxFormat(t3);
          else {
            if (!(t3 instanceof u2.Graph)) throw new TypeError("Graph type is not supported.");
            this.buildGraphFromOrtFormat(t3);
          }
        }
        buildGraphFromOnnxFormat(t3) {
          const e3 = /* @__PURE__ */ new Map();
          this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
          const n3 = /* @__PURE__ */ new Map();
          if (!t3.input) throw new Error("missing information in graph: input");
          const r3 = [];
          for (const n4 of t3.input) {
            if (e3.has(n4.name)) throw new Error(`duplicated input name: ${n4.name}`);
            const t4 = this._allData.push(new c2(n4)) - 1;
            e3.set(n4.name, t4), r3.push(n4.name);
          }
          if (!t3.initializer) throw new Error("missing information in graph: initializer");
          for (const n4 of t3.initializer) {
            let t4 = e3.get(n4.name);
            if (void 0 === t4) {
              const r4 = new c2();
              r4.type = { shape: { dims: s.ProtoUtil.tensorDimsFromProto(n4.dims) }, tensorType: s.ProtoUtil.tensorDataTypeFromProto(n4.dataType) }, t4 = this._allData.push(r4) - 1, e3.set(n4.name, t4);
            }
            this._allData[t4]._from = -1, this._allData[t4].tensor = a.Tensor.fromProto(n4);
          }
          for (let t4 = 0; t4 < this._allData.length; t4++) this._allData[t4].tensor || (this._allInputIndices.push(t4), this._allInputNames.push(r3[t4]));
          if (!t3.output) throw new Error("missing information in graph: output");
          for (const n4 of t3.output) {
            if (e3.has(n4.name)) throw new Error(`duplicated output name: ${n4.name}`);
            const t4 = this._allData.push(new c2(n4)) - 1;
            e3.set(n4.name, t4), this._allOutputIndices.push(t4), this._allOutputNames.push(n4.name);
          }
          if (!t3.node) throw new Error("missing information in graph: node");
          for (const e4 of t3.node) {
            if (!e4.name) for (let t5 = 0; ; t5++) {
              const r4 = `unnamed_${e4.opType}_${t5}`;
              if (!n3.has(r4)) {
                e4.name = r4;
                break;
              }
            }
            if (n3.has(e4.name)) throw new Error(`duplicated node name: ${e4.name}`);
            const t4 = this._nodes.push(new l2(e4)) - 1;
            n3.set(e4.name, t4);
          }
          for (let n4 = 0; n4 < this._nodes.length; n4++) {
            const r4 = this._nodes[n4], i2 = t3.node[n4];
            if (!i2.output) throw new Error(`missing output for node: ${i2.name}`);
            for (const t4 of i2.output) {
              let o2 = e3.get(t4);
              if (void 0 === o2 && (o2 = this._allData.push(new c2()) - 1, e3.set(t4, o2)), r4.outputs.push(o2), void 0 !== this._allData[o2]._from) throw new Error(`multiple nodes output to one data value: ${o2}`);
              if (this._allData[o2]._from = n4, "Constant" === i2.opType) {
                if (!i2.attribute || 1 !== i2.attribute.length || !i2.attribute[0].t) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                if (!i2.output || 1 !== i2.output.length) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                r4.outputs.pop(), r4.executeNode = false, this._allData[o2]._from = -1, this._allData[o2].tensor = a.Tensor.fromProto(i2.attribute[0].t);
              }
            }
          }
          for (let n4 = 0; n4 < this._nodes.length; n4++) {
            const r4 = this._nodes[n4], i2 = t3.node[n4];
            if (!i2.input) throw new Error(`missing input for node: ${i2.name}`);
            for (const t4 of i2.input) {
              const o2 = e3.get(t4);
              if (void 0 === o2) {
                if ("" === t4 && 3 === i2.input.length && "Resize" === i2.opType) continue;
                throw new Error(`unrecognized input '${t4}' for node: ${i2.name}`);
              }
              r4.inputs.push(o2), this._allData[o2]._to.push(n4);
            }
          }
          return true;
        }
        buildGraphFromOrtFormat(t3) {
          var e3, n3, r3;
          const i2 = /* @__PURE__ */ new Map();
          this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
          const o2 = /* @__PURE__ */ new Map(), p3 = [];
          for (let o3 = 0; o3 < t3.inputsLength(); o3++) {
            const a2 = t3.inputs(o3);
            if (i2.has(a2)) throw new Error(`duplicated input name: ${a2}`);
            for (let o4 = 0; o4 < t3.nodeArgsLength(); o4++) if ((null === (e3 = t3.nodeArgs(o4)) || void 0 === e3 ? void 0 : e3.name()) === a2) {
              const e4 = new c2();
              if ((null === (r3 = null === (n3 = t3.nodeArgs(o4)) || void 0 === n3 ? void 0 : n3.type()) || void 0 === r3 ? void 0 : r3.valueType()) !== u2.TypeInfoValue.tensor_type) throw new Error("Unexpected value type for the nodeArg.");
              const l3 = t3.nodeArgs(o4).type().value(new u2.TensorTypeAndShape()), f2 = s.ProtoUtil.tensorDataTypeFromProto(l3.elemType()), d2 = l3.shape(), h2 = [];
              for (let t4 = 0; t4 < d2.dimLength(); t4++) h2.push(s.LongUtil.longToNumber(d2.dim(t4).value().dimValue()));
              e4.type = { shape: { dims: h2 }, tensorType: f2 };
              const g2 = this._allData.push(e4) - 1;
              i2.set(a2, g2), p3.push(a2);
            }
          }
          for (let e4 = 0; e4 < t3.initializersLength(); e4++) {
            const n4 = t3.initializers(e4);
            let r4 = i2.get(n4.name());
            if (void 0 === r4) {
              const t4 = new c2(), e5 = s.ProtoUtil.tensorDimsFromORTFormat(n4), o3 = s.ProtoUtil.tensorDataTypeFromProto(n4.dataType());
              t4.type = { shape: { dims: e5 }, tensorType: o3 }, r4 = this._allData.push(t4) - 1, i2.set(n4.name(), r4);
            }
            this._allData[r4]._from = -1, this._allData[r4].tensor = a.Tensor.fromOrtTensor(n4);
          }
          for (let t4 = 0; t4 < this._allData.length; t4++) this._allData[t4].tensor || (this._allInputIndices.push(t4), this._allInputNames.push(p3[t4]));
          for (let e4 = 0; e4 < t3.outputsLength(); e4++) {
            const n4 = t3.outputs(e4);
            if (i2.has(n4)) throw new Error(`duplicated output name: ${n4}`);
            const r4 = this._allData.push(new c2()) - 1;
            i2.set(n4, r4), this._allOutputIndices.push(r4), this._allOutputNames.push(n4);
          }
          if (!t3.nodes) throw new Error("missing information in graph: node");
          for (let e4 = 0; e4 < t3.nodesLength(); e4++) {
            const n4 = t3.nodes(e4);
            let r4 = n4.name();
            if (!r4) for (let t4 = 0; r4 = `unnamed_${n4.opType()}_${t4}`, o2.has(r4); t4++) ;
            if (o2.has(r4)) throw new Error(`duplicated node name: ${r4}`);
            const i3 = this._nodes.push(new l2(n4, r4)) - 1;
            o2.set(r4, i3);
          }
          for (let e4 = 0; e4 < this._nodes.length; e4++) {
            const n4 = this._nodes[e4], r4 = t3.nodes(e4);
            if (null == r4) throw new Error(`No node exists at index ${e4}`);
            if (0 === (null == r4 ? void 0 : r4.outputsLength())) throw new Error(`missing output for node: ${r4.name}`);
            for (let t4 = 0; t4 < (null == r4 ? void 0 : r4.outputsLength()); t4++) {
              const o3 = null == r4 ? void 0 : r4.outputs(t4);
              let s2 = i2.get(o3);
              if (void 0 === s2 && (s2 = this._allData.push(new c2()) - 1, i2.set(o3, s2)), n4.outputs.push(s2), void 0 !== this._allData[s2]._from) throw new Error(`multiple nodes output to one data value: ${s2}`);
              if (this._allData[s2]._from = e4, "Constant" === r4.opType()) {
                if (1 !== r4.attributesLength() || !r4.attributes(0).t()) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                if (1 !== r4.outputsLength()) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                n4.outputs.pop(), n4.executeNode = false, this._allData[s2]._from = -1, this._allData[s2].tensor = a.Tensor.fromOrtTensor(r4.attributes(0).t());
              }
            }
          }
          for (let e4 = 0; e4 < this._nodes.length; e4++) {
            const n4 = this._nodes[e4], r4 = t3.nodes(e4);
            if (0 === r4.inputsLength()) throw new Error(`missing input for node: ${r4.name}`);
            for (let t4 = 0; t4 < r4.inputsLength(); t4++) {
              const o3 = r4.inputs(t4), a2 = i2.get(o3);
              if (void 0 === a2) throw new Error(`unrecognized input '${o3}' for node: ${r4.name()}`);
              n4.inputs.push(a2), this._allData[a2]._to.push(e4);
            }
          }
        }
        checkIsAcyclic() {
          const t3 = /* @__PURE__ */ new Set();
          this._allInputIndices.forEach((e4) => {
            this._allData[e4]._to.forEach((e5) => {
              t3.add(e5);
            });
          });
          const e3 = Array.from(t3), n3 = new Array(this._nodes.length).fill("white");
          for (; e3.length > 0; ) {
            const t4 = e3.pop();
            "gray" === n3[t4] ? n3[t4] = "black" : (e3.push(t4), n3[t4] = "gray", this._nodes[t4].outputs.forEach((r3) => {
              const i2 = this._allData[r3];
              if (void 0 !== i2.tensor) throw new Error("node outputs should not be initialized");
              if (i2._from !== t4) throw new Error("from property of the Value object doesn't match index of Node being processed");
              i2._to.forEach((t5) => {
                if ("gray" === n3[t5]) throw new Error("model graph is cyclic");
                "white" === n3[t5] && e3.push(t5);
              });
            }));
          }
        }
        transformGraph(t3) {
          this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), t3 && t3.transformGraph(this), this.finalizeGraph();
        }
        finalizeGraph() {
          let t3 = 0;
          for (let e3 = 0; e3 < this._nodes.length; e3++) this._nodes[e3].executeNode ? t3 > 0 && (this._nodes[e3].inputs.forEach((n3) => {
            const r3 = this._allData[n3]._to.indexOf(e3 + t3);
            -1 !== r3 && (this._allData[n3]._to[r3] = e3);
          }), this._nodes[e3].outputs.forEach((n3) => {
            this._allData[n3]._from && this._allData[n3]._from === e3 + t3 && (this._allData[n3]._from = e3);
          })) : (t3++, this._nodes[e3].outputs.forEach((t4) => {
            this._allData[t4]._from = -2;
          }), this._nodes.splice(e3, 1), e3--);
          t3 = 0;
          for (let e3 = 0; e3 < this._allData.length; e3++) if (-2 !== this._allData[e3].from || -1 !== this._allOutputIndices.indexOf(e3 + t3)) {
            if (t3 > 0) {
              let n3 = -1;
              void 0 !== this._allData[e3].from && -1 !== this._allData[e3].from ? (n3 = this._nodes[this._allData[e3].from].outputs.indexOf(e3 + t3), -1 !== n3 && (this._nodes[this._allData[e3].from].outputs[n3] = e3)) : (n3 = this._allInputIndices.indexOf(e3 + t3), -1 !== n3 && (this._allInputIndices[n3] = e3)), this._allData[e3].to.forEach((r3) => {
                n3 = this._nodes[r3].inputs.indexOf(e3 + t3), -1 !== n3 && (this._nodes[r3].inputs[n3] = e3);
              }), 0 === this._allData[e3].to.length && (n3 = this._allOutputIndices.indexOf(e3 + t3), -1 !== n3 && (this._allOutputIndices[n3] = e3));
            }
          } else t3++, this._allData.splice(e3, 1), e3--;
        }
        deleteNode(t3) {
          const e3 = this._nodes[t3];
          if (e3.outputs.length > 1) {
            for (let t4 = 1; t4 < e3.outputs.length; t4++) if (this._allData[e3.outputs[t4]].to.length > 0) throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
          }
          e3.executeNode = false;
          const n3 = e3.inputs[0], r3 = e3.outputs[0], i2 = this._allData[r3].to, o2 = this._allData[n3].to.indexOf(t3);
          if (-1 === o2) throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
          this._allData[n3].to.splice(o2, 1), this._allData[r3]._to = [];
          const a2 = this._allOutputIndices.indexOf(r3);
          if (-1 !== a2 && (this._allOutputIndices[a2] = n3), i2 && i2.length > 0) for (const t4 of i2) {
            const e4 = this._nodes[t4].inputs.indexOf(r3);
            if (-1 === e4) throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
            this._nodes[t4].inputs[e4] = n3, this._allData[n3].to.push(t4);
          }
        }
        removeAllDropoutNodes() {
          let t3 = 0;
          for (const e3 of this._nodes) {
            if ("Dropout" === e3.opType) {
              if (1 !== e3.inputs.length) throw new Error("Dropout nodes should only contain one input. ");
              if (1 !== e3.outputs.length && 2 !== e3.outputs.length) throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
              if (2 === e3.outputs.length && 0 !== this._allData[e3.outputs[1]]._to.length) throw new Error("Dropout nodes's second output should not be referenced by other nodes");
              this.deleteNode(t3);
            }
            t3++;
          }
        }
        removeAllIdentityNodes() {
          let t3 = 0;
          for (const e3 of this._nodes) "Identity" === e3.opType && this.deleteNode(t3), t3++;
        }
        isActivation(t3) {
          switch (t3.opType) {
            case "Relu":
            case "Sigmoid":
            case "Clip":
              return true;
            default:
              return false;
          }
        }
        fuseConvActivationNodes() {
          for (const t3 of this._nodes) if ("Conv" === t3.opType) {
            const e3 = this._allData[t3.outputs[0]]._to;
            if (1 === e3.length && this.isActivation(this._nodes[e3[0]])) {
              const n3 = this._nodes[e3[0]];
              if ("Clip" === n3.opType) if (1 === n3.inputs.length) try {
                t3.attributes.set("activation_params", "floats", [n3.attributes.getFloat("min"), n3.attributes.getFloat("max")]);
              } catch (e4) {
                t3.attributes.set("activation_params", "floats", [s.MIN_CLIP, s.MAX_CLIP]);
              }
              else {
                if (!(n3.inputs.length >= 3 && void 0 !== this._allData[n3.inputs[1]].tensor && void 0 !== this._allData[n3.inputs[2]].tensor)) continue;
                t3.attributes.set("activation_params", "floats", [this._allData[n3.inputs[1]].tensor.floatData[0], this._allData[n3.inputs[2]].tensor.floatData[0]]);
              }
              t3.attributes.set("activation", "string", n3.opType), this.deleteNode(e3[0]);
            }
          }
        }
      }
    }, 6231: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.now = e2.Profiler = e2.Logger = void 0;
      const n2 = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r2 = { none: new class {
        log(t3, e3, n3) {
        }
      }(), console: new class {
        log(t3, e3, n3) {
          console.log(`${this.color(t3)} ${n3 ? "\x1B[35m" + n3 + "\x1B[0m " : ""}${e3}`);
        }
        color(t3) {
          switch (t3) {
            case "verbose":
              return "\x1B[34;40mv\x1B[0m";
            case "info":
              return "\x1B[32mi\x1B[0m";
            case "warning":
              return "\x1B[30;43mw\x1B[0m";
            case "error":
              return "\x1B[31;40me\x1B[0m";
            case "fatal":
              return "\x1B[101mf\x1B[0m";
            default:
              throw new Error(`unsupported severity: ${t3}`);
          }
        }
      }() }, i = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
      let o = { "": i };
      function a(t3, e3, n3, r3) {
        if (void 0 === e3) return i2 = t3, { verbose: a.verbose.bind(null, i2), info: a.info.bind(null, i2), warning: a.warning.bind(null, i2), error: a.error.bind(null, i2), fatal: a.fatal.bind(null, i2) };
        if (void 0 === n3) s(t3, e3);
        else if ("number" == typeof n3 && void 0 === r3) s(t3, e3);
        else if ("string" == typeof n3 && void 0 === r3) s(t3, n3, 0, e3);
        else {
          if ("string" != typeof n3 || "number" != typeof r3) throw new TypeError("input is valid");
          s(t3, n3, 0, e3);
        }
        var i2;
      }
      function s(t3, e3, i2, a2) {
        const s2 = o[a2 || ""] || o[""];
        n2[t3] < n2[s2.minimalSeverity] || (s2.logDateTime && (e3 = `${(/* @__PURE__ */ new Date()).toISOString()}|${e3}`), s2.logSourceLocation, r2[s2.provider].log(t3, e3, a2));
      }
      !function(t3) {
        function e3(t4) {
          o = {}, n3("", t4 || {});
        }
        function n3(t4, n4) {
          if ("*" === t4) e3(n4);
          else {
            const e4 = o[t4] || i;
            o[t4] = { provider: n4.provider || e4.provider, minimalSeverity: n4.minimalSeverity || e4.minimalSeverity, logDateTime: void 0 === n4.logDateTime ? e4.logDateTime : n4.logDateTime, logSourceLocation: void 0 === n4.logSourceLocation ? e4.logSourceLocation : n4.logSourceLocation };
          }
        }
        t3.verbose = function(e4, n4) {
          t3("verbose", e4, n4);
        }, t3.info = function(e4, n4) {
          t3("info", e4, n4);
        }, t3.warning = function(e4, n4) {
          t3("warning", e4, n4);
        }, t3.error = function(e4, n4) {
          t3("error", e4, n4);
        }, t3.fatal = function(e4, n4) {
          t3("fatal", e4, n4);
        }, t3.reset = e3, t3.set = n3, t3.setWithEnv = function(t4) {
          const e4 = {};
          t4.logLevel && (e4.minimalSeverity = t4.logLevel), n3("", e4);
        };
      }(a || (a = {})), e2.Logger = a;
      class u2 {
        constructor(t3, e3, n3, r3, i2, o2) {
          this.category = t3, this.name = e3, this.startTime = n3, this.endCallback = r3, this.timer = i2, this.ctx = o2;
        }
        end() {
          return this.endCallback(this);
        }
        async checkTimer() {
          if (void 0 === this.ctx || void 0 === this.timer) throw new Error("No webgl timer found");
          return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
        }
      }
      class c2 {
        constructor(t3, e3, n3, r3) {
          this.category = t3, this.name = e3, this.startTime = n3, this.endTime = r3;
        }
      }
      e2.Profiler = class {
        static create(t3) {
          return void 0 === t3 ? new this() : new this(t3.maxNumberEvents, t3.flushBatchSize, t3.flushIntervalInMilliseconds);
        }
        constructor(t3, e3, n3) {
          this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === t3 ? 1e4 : t3, this._flushBatchSize = void 0 === e3 ? 10 : e3, this._flushIntervalInMilliseconds = void 0 === n3 ? 5e3 : n3;
        }
        start() {
          this._started = true, this._timingEvents = [], this._flushTime = (0, e2.now)(), this._flushPointer = 0;
        }
        stop() {
          for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);
        }
        event(t3, e3, n3, r3) {
          const i2 = this._started ? this.begin(t3, e3, r3) : void 0;
          let o2 = false;
          const a2 = n3();
          if (a2 && "function" == typeof a2.then) return o2 = true, new Promise((t4, e4) => {
            a2.then(async (e5) => {
              i2 && await i2.end(), t4(e5);
            }, async (t5) => {
              i2 && await i2.end(), e4(t5);
            });
          });
          if (!o2 && i2) {
            const t4 = i2.end();
            if (t4 && "function" == typeof t4.then) return new Promise((e4, n4) => {
              t4.then(() => {
                e4(a2);
              }, (t5) => {
                n4(t5);
              });
            });
          }
          return a2;
        }
        begin(t3, n3, r3) {
          if (!this._started) throw new Error("profiler is not started yet");
          if (void 0 === r3) {
            const r4 = (0, e2.now)();
            return this.flush(r4), new u2(t3, n3, r4, (t4) => this.endSync(t4));
          }
          {
            const e3 = r3.beginTimer();
            return new u2(t3, n3, 0, async (t4) => this.end(t4), e3, r3);
          }
        }
        async end(t3) {
          const e3 = await t3.checkTimer();
          this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c2(t3.category, t3.name, t3.startTime, e3)), this.flush(e3));
        }
        endSync(t3) {
          const n3 = (0, e2.now)();
          this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c2(t3.category, t3.name, t3.startTime, n3)), this.flush(n3));
        }
        logOneEvent(t3) {
          e2.Logger.verbose(`Profiler.${t3.category}`, `${(t3.endTime - t3.startTime).toFixed(2)}ms on event '${t3.name}' at ${t3.endTime.toFixed(2)}`);
        }
        flush(t3) {
          if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || t3 - this._flushTime >= this._flushIntervalInMilliseconds) {
            for (const t4 = this._flushPointer; this._flushPointer < t4 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);
            this._flushTime = (0, e2.now)();
          }
        }
        get started() {
          return this._started;
        }
      }, e2.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
    }, 2644: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Model = void 0;
      const r2 = n2(5686), i = n2(1446), o = n2(7070), a = n2(9395), s = n2(2517);
      var u2 = a.onnxruntime.experimental.fbs;
      e2.Model = class {
        constructor() {
        }
        load(t3, e3, n3) {
          if (!n3) try {
            return void this.loadFromOnnxFormat(t3, e3);
          } catch (t4) {
            if (void 0 !== n3) throw t4;
          }
          this.loadFromOrtFormat(t3, e3);
        }
        loadFromOnnxFormat(t3, e3) {
          const n3 = i.onnx.ModelProto.decode(t3);
          if (s.LongUtil.longToNumber(n3.irVersion) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
          this._opsets = n3.opsetImport.map((t4) => ({ domain: t4.domain, version: s.LongUtil.longToNumber(t4.version) })), this._graph = o.Graph.from(n3.graph, e3);
        }
        loadFromOrtFormat(t3, e3) {
          const n3 = new r2.flatbuffers.ByteBuffer(t3), i2 = u2.InferenceSession.getRootAsInferenceSession(n3).model();
          if (s.LongUtil.longToNumber(i2.irVersion()) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
          this._opsets = [];
          for (let t4 = 0; t4 < i2.opsetImportLength(); t4++) {
            const e4 = i2.opsetImport(t4);
            this._opsets.push({ domain: null == e4 ? void 0 : e4.domain(), version: s.LongUtil.longToNumber(e4.version()) });
          }
          this._graph = o.Graph.from(i2.graph(), e3);
        }
        get graph() {
          return this._graph;
        }
        get opsets() {
          return this._opsets;
        }
      };
    }, 782: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.FLOAT_TYPES = e2.INT_TYPES = e2.NUMBER_TYPES = void 0, e2.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], e2.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], e2.FLOAT_TYPES = ["float32", "float64"];
    }, 1047: (t2, e2) => {
      function n2(t3, e3) {
        if (e3.endsWith("+")) {
          const n3 = Number.parseInt(e3.substring(0, e3.length - 1), 10);
          return !isNaN(n3) && n3 <= t3;
        }
        if (2 === e3.split("-").length) {
          const n3 = e3.split("-"), r2 = Number.parseInt(n3[0], 10), i = Number.parseInt(n3[1], 10);
          return !isNaN(r2) && !isNaN(i) && r2 <= t3 && t3 <= i;
        }
        return Number.parseInt(e3, 10) === t3;
      }
      Object.defineProperty(e2, "__esModule", { value: true }), e2.resolveOperator = void 0, e2.resolveOperator = function(t3, e3, r2) {
        for (const i of r2) {
          const r3 = i[0], o = i[1], a = i[2], s = i[3], u2 = i[4];
          if (t3.opType === r3) {
            for (const t4 of e3) if ((t4.domain === o || "ai.onnx" === t4.domain && "" === o) && n2(t4.version, a)) return { opImpl: s, opInit: u2 };
          }
        }
        throw new TypeError(`cannot resolve operator '${t3.opType}' with opsets: ${e3.map((t4) => `${t4.domain || "ai.onnx"} v${t4.version}`).join(", ")}`);
      };
    }, 9395: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.onnxruntime = void 0;
      const r2 = n2(5686);
      var i, o;
      i = e2.onnxruntime || (e2.onnxruntime = {}), function(t3) {
        !function(t4) {
          t4[t4.UNDEFINED = 0] = "UNDEFINED", t4[t4.FLOAT = 1] = "FLOAT", t4[t4.INT = 2] = "INT", t4[t4.STRING = 3] = "STRING", t4[t4.TENSOR = 4] = "TENSOR", t4[t4.GRAPH = 5] = "GRAPH", t4[t4.FLOATS = 6] = "FLOATS", t4[t4.INTS = 7] = "INTS", t4[t4.STRINGS = 8] = "STRINGS", t4[t4.TENSORS = 9] = "TENSORS", t4[t4.GRAPHS = 10] = "GRAPHS", t4[t4.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", t4[t4.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
        }(t3.AttributeType || (t3.AttributeType = {}));
      }((o = i.experimental || (i.experimental = {})).fbs || (o.fbs = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            !function(t6) {
              t6[t6.UNKNOWN = 0] = "UNKNOWN", t6[t6.VALUE = 1] = "VALUE", t6[t6.PARAM = 2] = "PARAM";
            }(t5.DimensionValueType || (t5.DimensionValueType = {}));
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            !function(t6) {
              t6[t6.UNDEFINED = 0] = "UNDEFINED", t6[t6.FLOAT = 1] = "FLOAT", t6[t6.UINT8 = 2] = "UINT8", t6[t6.INT8 = 3] = "INT8", t6[t6.UINT16 = 4] = "UINT16", t6[t6.INT16 = 5] = "INT16", t6[t6.INT32 = 6] = "INT32", t6[t6.INT64 = 7] = "INT64", t6[t6.STRING = 8] = "STRING", t6[t6.BOOL = 9] = "BOOL", t6[t6.FLOAT16 = 10] = "FLOAT16", t6[t6.DOUBLE = 11] = "DOUBLE", t6[t6.UINT32 = 12] = "UINT32", t6[t6.UINT64 = 13] = "UINT64", t6[t6.COMPLEX64 = 14] = "COMPLEX64", t6[t6.COMPLEX128 = 15] = "COMPLEX128", t6[t6.BFLOAT16 = 16] = "BFLOAT16";
            }(t5.TensorDataType || (t5.TensorDataType = {}));
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            !function(t6) {
              t6[t6.Primitive = 0] = "Primitive", t6[t6.Fused = 1] = "Fused";
            }(t5.NodeType || (t5.NodeType = {}));
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            !function(t6) {
              t6[t6.NONE = 0] = "NONE", t6[t6.tensor_type = 1] = "tensor_type", t6[t6.sequence_type = 2] = "sequence_type", t6[t6.map_type = 3] = "map_type";
            }(t5.TypeInfoValue || (t5.TypeInfoValue = {}));
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsShape(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsShape(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              dim(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 4);
                return r3 ? (n4 || new t3.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              dimLength() {
                let t4 = this.bb.__offset(this.bb_pos, 4);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startShape(t4) {
                t4.startObject(1);
              }
              static addDim(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static createDimVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startDimVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endShape(t4) {
                return t4.endObject();
              }
              static createShape(t4, e5) {
                return n3.startShape(t4), n3.addDim(t4, e5), n3.endShape(t4);
              }
            }
            e4.Shape = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsDimension(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsDimension(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              value(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 4);
                return n4 ? (e5 || new t3.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              denotation(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              static startDimension(t4) {
                t4.startObject(2);
              }
              static addValue(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDenotation(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static endDimension(t4) {
                return t4.endObject();
              }
              static createDimension(t4, e5, r3) {
                return n3.startDimension(t4), n3.addValue(t4, e5), n3.addDenotation(t4, r3), n3.endDimension(t4);
              }
            }
            e4.Dimension = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsDimensionValue(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsDimensionValue(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              dimType() {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.readInt8(this.bb_pos + e5) : t3.experimental.fbs.DimensionValueType.UNKNOWN;
              }
              dimValue() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.readInt64(this.bb_pos + t4) : this.bb.createLong(0, 0);
              }
              dimParam(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              static startDimensionValue(t4) {
                t4.startObject(3);
              }
              static addDimType(e5, n4) {
                e5.addFieldInt8(0, n4, t3.experimental.fbs.DimensionValueType.UNKNOWN);
              }
              static addDimValue(t4, e5) {
                t4.addFieldInt64(1, e5, t4.createLong(0, 0));
              }
              static addDimParam(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static endDimensionValue(t4) {
                return t4.endObject();
              }
              static createDimensionValue(t4, e5, r3, i2) {
                return n3.startDimensionValue(t4), n3.addDimType(t4, e5), n3.addDimValue(t4, r3), n3.addDimParam(t4, i2), n3.endDimensionValue(t4);
              }
            }
            e4.DimensionValue = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsTensorTypeAndShape(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsTensorTypeAndShape(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              elemType() {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.TensorDataType.UNDEFINED;
              }
              shape(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startTensorTypeAndShape(t4) {
                t4.startObject(2);
              }
              static addElemType(e5, n4) {
                e5.addFieldInt32(0, n4, t3.experimental.fbs.TensorDataType.UNDEFINED);
              }
              static addShape(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static endTensorTypeAndShape(t4) {
                return t4.endObject();
              }
              static createTensorTypeAndShape(t4, e5, r3) {
                return n3.startTensorTypeAndShape(t4), n3.addElemType(t4, e5), n3.addShape(t4, r3), n3.endTensorTypeAndShape(t4);
              }
            }
            e4.TensorTypeAndShape = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsMapType(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsMapType(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              keyType() {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.TensorDataType.UNDEFINED;
              }
              valueType(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startMapType(t4) {
                t4.startObject(2);
              }
              static addKeyType(e5, n4) {
                e5.addFieldInt32(0, n4, t3.experimental.fbs.TensorDataType.UNDEFINED);
              }
              static addValueType(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static endMapType(t4) {
                return t4.endObject();
              }
              static createMapType(t4, e5, r3) {
                return n3.startMapType(t4), n3.addKeyType(t4, e5), n3.addValueType(t4, r3), n3.endMapType(t4);
              }
            }
            e4.MapType = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsSequenceType(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsSequenceType(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              elemType(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 4);
                return n4 ? (e5 || new t3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startSequenceType(t4) {
                t4.startObject(1);
              }
              static addElemType(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static endSequenceType(t4) {
                return t4.endObject();
              }
              static createSequenceType(t4, e5) {
                return n3.startSequenceType(t4), n3.addElemType(t4, e5), n3.endSequenceType(t4);
              }
            }
            e4.SequenceType = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          (t4.fbs || (t4.fbs = {})).EdgeEnd = class {
            constructor() {
              this.bb = null, this.bb_pos = 0;
            }
            __init(t5, e3) {
              return this.bb_pos = t5, this.bb = e3, this;
            }
            nodeIndex() {
              return this.bb.readUint32(this.bb_pos);
            }
            srcArgIndex() {
              return this.bb.readInt32(this.bb_pos + 4);
            }
            dstArgIndex() {
              return this.bb.readInt32(this.bb_pos + 8);
            }
            static createEdgeEnd(t5, e3, n3, r3) {
              return t5.prep(4, 12), t5.writeInt32(r3), t5.writeInt32(n3), t5.writeInt32(e3), t5.offset();
            }
          };
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsNodeEdge(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsNodeEdge(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              nodeIndex() {
                let t4 = this.bb.__offset(this.bb_pos, 4);
                return t4 ? this.bb.readUint32(this.bb_pos + t4) : 0;
              }
              inputEdges(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 6);
                return r3 ? (n4 || new t3.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r3) + 12 * e5, this.bb) : null;
              }
              inputEdgesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              outputEdges(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 8);
                return r3 ? (n4 || new t3.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r3) + 12 * e5, this.bb) : null;
              }
              outputEdgesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 8);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startNodeEdge(t4) {
                t4.startObject(3);
              }
              static addNodeIndex(t4, e5) {
                t4.addFieldInt32(0, e5, 0);
              }
              static addInputEdges(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static startInputEdgesVector(t4, e5) {
                t4.startVector(12, e5, 4);
              }
              static addOutputEdges(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static startOutputEdgesVector(t4, e5) {
                t4.startVector(12, e5, 4);
              }
              static endNodeEdge(t4) {
                return t4.endObject();
              }
              static createNodeEdge(t4, e5, r3, i2) {
                return n3.startNodeEdge(t4), n3.addNodeIndex(t4, e5), n3.addInputEdges(t4, r3), n3.addOutputEdges(t4, i2), n3.endNodeEdge(t4);
              }
            }
            e4.NodeEdge = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsNode(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsNode(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              name(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              domain(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              sinceVersion() {
                let t4 = this.bb.__offset(this.bb_pos, 10);
                return t4 ? this.bb.readInt32(this.bb_pos + t4) : 0;
              }
              index() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? this.bb.readUint32(this.bb_pos + t4) : 0;
              }
              opType(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 14);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              type() {
                let e5 = this.bb.__offset(this.bb_pos, 16);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.NodeType.Primitive;
              }
              executionProviderType(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 18);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              inputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 20);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              inputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 20);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              outputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 22);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              outputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 22);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              attributes(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 24);
                return r3 ? (n4 || new t3.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              attributesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 24);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              inputArgCounts(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 26);
                return e5 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e5) + 4 * t4) : 0;
              }
              inputArgCountsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 26);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              inputArgCountsArray() {
                let t4 = this.bb.__offset(this.bb_pos, 26);
                return t4 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t4), this.bb.__vector_len(this.bb_pos + t4)) : null;
              }
              implicitInputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 28);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              implicitInputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 28);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startNode(t4) {
                t4.startObject(13);
              }
              static addName(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addDomain(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static addSinceVersion(t4, e5) {
                t4.addFieldInt32(3, e5, 0);
              }
              static addIndex(t4, e5) {
                t4.addFieldInt32(4, e5, 0);
              }
              static addOpType(t4, e5) {
                t4.addFieldOffset(5, e5, 0);
              }
              static addType(e5, n4) {
                e5.addFieldInt32(6, n4, t3.experimental.fbs.NodeType.Primitive);
              }
              static addExecutionProviderType(t4, e5) {
                t4.addFieldOffset(7, e5, 0);
              }
              static addInputs(t4, e5) {
                t4.addFieldOffset(8, e5, 0);
              }
              static createInputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startInputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addOutputs(t4, e5) {
                t4.addFieldOffset(9, e5, 0);
              }
              static createOutputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startOutputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addAttributes(t4, e5) {
                t4.addFieldOffset(10, e5, 0);
              }
              static createAttributesVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startAttributesVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addInputArgCounts(t4, e5) {
                t4.addFieldOffset(11, e5, 0);
              }
              static createInputArgCountsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt32(e5[n4]);
                return t4.endVector();
              }
              static startInputArgCountsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addImplicitInputs(t4, e5) {
                t4.addFieldOffset(12, e5, 0);
              }
              static createImplicitInputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startImplicitInputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endNode(t4) {
                return t4.endObject();
              }
              static createNode(t4, e5, r3, i2, o2, a, s, u2, c2, l2, p2, f2, d2, h2) {
                return n3.startNode(t4), n3.addName(t4, e5), n3.addDocString(t4, r3), n3.addDomain(t4, i2), n3.addSinceVersion(t4, o2), n3.addIndex(t4, a), n3.addOpType(t4, s), n3.addType(t4, u2), n3.addExecutionProviderType(t4, c2), n3.addInputs(t4, l2), n3.addOutputs(t4, p2), n3.addAttributes(t4, f2), n3.addInputArgCounts(t4, d2), n3.addImplicitInputs(t4, h2), n3.endNode(t4);
              }
            }
            e4.Node = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsValueInfo(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsValueInfo(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              name(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              type(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 8);
                return n4 ? (e5 || new t3.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startValueInfo(t4) {
                t4.startObject(3);
              }
              static addName(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addType(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static endValueInfo(t4) {
                return t4.endObject();
              }
              static createValueInfo(t4, e5, r3, i2) {
                return n3.startValueInfo(t4), n3.addName(t4, e5), n3.addDocString(t4, r3), n3.addType(t4, i2), n3.endValueInfo(t4);
              }
            }
            e4.ValueInfo = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsTypeInfo(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsTypeInfo(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              denotation(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              valueType() {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.readUint8(this.bb_pos + e5) : t3.experimental.fbs.TypeInfoValue.NONE;
              }
              value(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.__union(t4, this.bb_pos + e5) : null;
              }
              static startTypeInfo(t4) {
                t4.startObject(3);
              }
              static addDenotation(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addValueType(e5, n4) {
                e5.addFieldInt8(1, n4, t3.experimental.fbs.TypeInfoValue.NONE);
              }
              static addValue(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static endTypeInfo(t4) {
                return t4.endObject();
              }
              static createTypeInfo(t4, e5, r3, i2) {
                return n3.startTypeInfo(t4), n3.addDenotation(t4, e5), n3.addValueType(t4, r3), n3.addValue(t4, i2), n3.endTypeInfo(t4);
              }
            }
            e4.TypeInfo = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            class e3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t6, e4) {
                return this.bb_pos = t6, this.bb = e4, this;
              }
              static getRootAsOperatorSetId(t6, n3) {
                return (n3 || new e3()).__init(t6.readInt32(t6.position()) + t6.position(), t6);
              }
              static getSizePrefixedRootAsOperatorSetId(t6, n3) {
                return t6.setPosition(t6.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (n3 || new e3()).__init(t6.readInt32(t6.position()) + t6.position(), t6);
              }
              domain(t6) {
                let e4 = this.bb.__offset(this.bb_pos, 4);
                return e4 ? this.bb.__string(this.bb_pos + e4, t6) : null;
              }
              version() {
                let t6 = this.bb.__offset(this.bb_pos, 6);
                return t6 ? this.bb.readInt64(this.bb_pos + t6) : this.bb.createLong(0, 0);
              }
              static startOperatorSetId(t6) {
                t6.startObject(2);
              }
              static addDomain(t6, e4) {
                t6.addFieldOffset(0, e4, 0);
              }
              static addVersion(t6, e4) {
                t6.addFieldInt64(1, e4, t6.createLong(0, 0));
              }
              static endOperatorSetId(t6) {
                return t6.endObject();
              }
              static createOperatorSetId(t6, n3, r3) {
                return e3.startOperatorSetId(t6), e3.addDomain(t6, n3), e3.addVersion(t6, r3), e3.endOperatorSetId(t6);
              }
            }
            t5.OperatorSetId = e3;
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsTensor(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsTensor(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              name(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              dims(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e5) + 8 * t4) : this.bb.createLong(0, 0);
              }
              dimsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 8);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              dataType() {
                let e5 = this.bb.__offset(this.bb_pos, 10);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.TensorDataType.UNDEFINED;
              }
              rawData(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 12);
                return e5 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e5) + t4) : 0;
              }
              rawDataLength() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              rawDataArray() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t4), this.bb.__vector_len(this.bb_pos + t4)) : null;
              }
              stringData(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 14);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              stringDataLength() {
                let t4 = this.bb.__offset(this.bb_pos, 14);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startTensor(t4) {
                t4.startObject(6);
              }
              static addName(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addDims(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static createDimsVector(t4, e5) {
                t4.startVector(8, e5.length, 8);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt64(e5[n4]);
                return t4.endVector();
              }
              static startDimsVector(t4, e5) {
                t4.startVector(8, e5, 8);
              }
              static addDataType(e5, n4) {
                e5.addFieldInt32(3, n4, t3.experimental.fbs.TensorDataType.UNDEFINED);
              }
              static addRawData(t4, e5) {
                t4.addFieldOffset(4, e5, 0);
              }
              static createRawDataVector(t4, e5) {
                t4.startVector(1, e5.length, 1);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt8(e5[n4]);
                return t4.endVector();
              }
              static startRawDataVector(t4, e5) {
                t4.startVector(1, e5, 1);
              }
              static addStringData(t4, e5) {
                t4.addFieldOffset(5, e5, 0);
              }
              static createStringDataVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startStringDataVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endTensor(t4) {
                return t4.endObject();
              }
              static createTensor(t4, e5, r3, i2, o2, a, s) {
                return n3.startTensor(t4), n3.addName(t4, e5), n3.addDocString(t4, r3), n3.addDims(t4, i2), n3.addDataType(t4, o2), n3.addRawData(t4, a), n3.addStringData(t4, s), n3.endTensor(t4);
              }
            }
            e4.Tensor = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsSparseTensor(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsSparseTensor(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              values(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 4);
                return n4 ? (e5 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              indices(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              dims(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e5) + 8 * t4) : this.bb.createLong(0, 0);
              }
              dimsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 8);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startSparseTensor(t4) {
                t4.startObject(3);
              }
              static addValues(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addIndices(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addDims(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static createDimsVector(t4, e5) {
                t4.startVector(8, e5.length, 8);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt64(e5[n4]);
                return t4.endVector();
              }
              static startDimsVector(t4, e5) {
                t4.startVector(8, e5, 8);
              }
              static endSparseTensor(t4) {
                return t4.endObject();
              }
              static createSparseTensor(t4, e5, r3, i2) {
                return n3.startSparseTensor(t4), n3.addValues(t4, e5), n3.addIndices(t4, r3), n3.addDims(t4, i2), n3.endSparseTensor(t4);
              }
            }
            e4.SparseTensor = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsAttribute(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsAttribute(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              name(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 6);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              type() {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.readInt32(this.bb_pos + e5) : t3.experimental.fbs.AttributeType.UNDEFINED;
              }
              f() {
                let t4 = this.bb.__offset(this.bb_pos, 10);
                return t4 ? this.bb.readFloat32(this.bb_pos + t4) : 0;
              }
              i() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? this.bb.readInt64(this.bb_pos + t4) : this.bb.createLong(0, 0);
              }
              s(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 14);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              t(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 16);
                return n4 ? (e5 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              g(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 18);
                return n4 ? (e5 || new t3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              floats(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 20);
                return e5 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e5) + 4 * t4) : 0;
              }
              floatsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 20);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              floatsArray() {
                let t4 = this.bb.__offset(this.bb_pos, 20);
                return t4 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t4), this.bb.__vector_len(this.bb_pos + t4)) : null;
              }
              ints(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 22);
                return e5 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e5) + 8 * t4) : this.bb.createLong(0, 0);
              }
              intsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 22);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              strings(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 24);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              stringsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 24);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              tensors(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 26);
                return r3 ? (n4 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              tensorsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 26);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              graphs(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 28);
                return r3 ? (n4 || new t3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              graphsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 28);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startAttribute(t4) {
                t4.startObject(13);
              }
              static addName(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addType(e5, n4) {
                e5.addFieldInt32(2, n4, t3.experimental.fbs.AttributeType.UNDEFINED);
              }
              static addF(t4, e5) {
                t4.addFieldFloat32(3, e5, 0);
              }
              static addI(t4, e5) {
                t4.addFieldInt64(4, e5, t4.createLong(0, 0));
              }
              static addS(t4, e5) {
                t4.addFieldOffset(5, e5, 0);
              }
              static addT(t4, e5) {
                t4.addFieldOffset(6, e5, 0);
              }
              static addG(t4, e5) {
                t4.addFieldOffset(7, e5, 0);
              }
              static addFloats(t4, e5) {
                t4.addFieldOffset(8, e5, 0);
              }
              static createFloatsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addFloat32(e5[n4]);
                return t4.endVector();
              }
              static startFloatsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addInts(t4, e5) {
                t4.addFieldOffset(9, e5, 0);
              }
              static createIntsVector(t4, e5) {
                t4.startVector(8, e5.length, 8);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addInt64(e5[n4]);
                return t4.endVector();
              }
              static startIntsVector(t4, e5) {
                t4.startVector(8, e5, 8);
              }
              static addStrings(t4, e5) {
                t4.addFieldOffset(10, e5, 0);
              }
              static createStringsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startStringsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addTensors(t4, e5) {
                t4.addFieldOffset(11, e5, 0);
              }
              static createTensorsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startTensorsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addGraphs(t4, e5) {
                t4.addFieldOffset(12, e5, 0);
              }
              static createGraphsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startGraphsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endAttribute(t4) {
                return t4.endObject();
              }
              static createAttribute(t4, e5, r3, i2, o2, a, s, u2, c2, l2, p2, f2, d2, h2) {
                return n3.startAttribute(t4), n3.addName(t4, e5), n3.addDocString(t4, r3), n3.addType(t4, i2), n3.addF(t4, o2), n3.addI(t4, a), n3.addS(t4, s), n3.addT(t4, u2), n3.addG(t4, c2), n3.addFloats(t4, l2), n3.addInts(t4, p2), n3.addStrings(t4, f2), n3.addTensors(t4, d2), n3.addGraphs(t4, h2), n3.endAttribute(t4);
              }
            }
            e4.Attribute = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsGraph(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsGraph(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              initializers(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 4);
                return r3 ? (n4 || new t3.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              initializersLength() {
                let t4 = this.bb.__offset(this.bb_pos, 4);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              nodeArgs(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 6);
                return r3 ? (n4 || new t3.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              nodeArgsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              nodes(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 8);
                return r3 ? (n4 || new t3.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              nodesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 8);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              maxNodeIndex() {
                let t4 = this.bb.__offset(this.bb_pos, 10);
                return t4 ? this.bb.readUint32(this.bb_pos + t4) : 0;
              }
              nodeEdges(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 12);
                return r3 ? (n4 || new t3.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              nodeEdgesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 12);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              inputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 14);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              inputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 14);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              outputs(t4, e5) {
                let n4 = this.bb.__offset(this.bb_pos, 16);
                return n4 ? this.bb.__string(this.bb.__vector(this.bb_pos + n4) + 4 * t4, e5) : null;
              }
              outputsLength() {
                let t4 = this.bb.__offset(this.bb_pos, 16);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              sparseInitializers(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 18);
                return r3 ? (n4 || new t3.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              sparseInitializersLength() {
                let t4 = this.bb.__offset(this.bb_pos, 18);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startGraph(t4) {
                t4.startObject(8);
              }
              static addInitializers(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static createInitializersVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startInitializersVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addNodeArgs(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static createNodeArgsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startNodeArgsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addNodes(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static createNodesVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startNodesVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addMaxNodeIndex(t4, e5) {
                t4.addFieldInt32(3, e5, 0);
              }
              static addNodeEdges(t4, e5) {
                t4.addFieldOffset(4, e5, 0);
              }
              static createNodeEdgesVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startNodeEdgesVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addInputs(t4, e5) {
                t4.addFieldOffset(5, e5, 0);
              }
              static createInputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startInputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addOutputs(t4, e5) {
                t4.addFieldOffset(6, e5, 0);
              }
              static createOutputsVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startOutputsVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addSparseInitializers(t4, e5) {
                t4.addFieldOffset(7, e5, 0);
              }
              static createSparseInitializersVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startSparseInitializersVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endGraph(t4) {
                return t4.endObject();
              }
              static createGraph(t4, e5, r3, i2, o2, a, s, u2, c2) {
                return n3.startGraph(t4), n3.addInitializers(t4, e5), n3.addNodeArgs(t4, r3), n3.addNodes(t4, i2), n3.addMaxNodeIndex(t4, o2), n3.addNodeEdges(t4, a), n3.addInputs(t4, s), n3.addOutputs(t4, u2), n3.addSparseInitializers(t4, c2), n3.endGraph(t4);
              }
            }
            e4.Graph = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsModel(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsModel(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              irVersion() {
                let t4 = this.bb.__offset(this.bb_pos, 4);
                return t4 ? this.bb.readInt64(this.bb_pos + t4) : this.bb.createLong(0, 0);
              }
              opsetImport(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 6);
                return r3 ? (n4 || new t3.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              opsetImportLength() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              producerName(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 8);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              producerVersion(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 10);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              domain(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 12);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              modelVersion() {
                let t4 = this.bb.__offset(this.bb_pos, 14);
                return t4 ? this.bb.readInt64(this.bb_pos + t4) : this.bb.createLong(0, 0);
              }
              docString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 16);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              graph(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 18);
                return n4 ? (e5 || new t3.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              graphDocString(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 20);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              static startModel(t4) {
                t4.startObject(9);
              }
              static addIrVersion(t4, e5) {
                t4.addFieldInt64(0, e5, t4.createLong(0, 0));
              }
              static addOpsetImport(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static createOpsetImportVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startOpsetImportVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static addProducerName(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static addProducerVersion(t4, e5) {
                t4.addFieldOffset(3, e5, 0);
              }
              static addDomain(t4, e5) {
                t4.addFieldOffset(4, e5, 0);
              }
              static addModelVersion(t4, e5) {
                t4.addFieldInt64(5, e5, t4.createLong(0, 0));
              }
              static addDocString(t4, e5) {
                t4.addFieldOffset(6, e5, 0);
              }
              static addGraph(t4, e5) {
                t4.addFieldOffset(7, e5, 0);
              }
              static addGraphDocString(t4, e5) {
                t4.addFieldOffset(8, e5, 0);
              }
              static endModel(t4) {
                return t4.endObject();
              }
              static createModel(t4, e5, r3, i2, o2, a, s, u2, c2, l2) {
                return n3.startModel(t4), n3.addIrVersion(t4, e5), n3.addOpsetImport(t4, r3), n3.addProducerName(t4, i2), n3.addProducerVersion(t4, o2), n3.addDomain(t4, a), n3.addModelVersion(t4, s), n3.addDocString(t4, u2), n3.addGraph(t4, c2), n3.addGraphDocString(t4, l2), n3.endModel(t4);
              }
            }
            e4.Model = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(t4) {
          !function(t5) {
            class e3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t6, e4) {
                return this.bb_pos = t6, this.bb = e4, this;
              }
              static getRootAsKernelCreateInfos(t6, n3) {
                return (n3 || new e3()).__init(t6.readInt32(t6.position()) + t6.position(), t6);
              }
              static getSizePrefixedRootAsKernelCreateInfos(t6, n3) {
                return t6.setPosition(t6.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (n3 || new e3()).__init(t6.readInt32(t6.position()) + t6.position(), t6);
              }
              nodeIndices(t6) {
                let e4 = this.bb.__offset(this.bb_pos, 4);
                return e4 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e4) + 4 * t6) : 0;
              }
              nodeIndicesLength() {
                let t6 = this.bb.__offset(this.bb_pos, 4);
                return t6 ? this.bb.__vector_len(this.bb_pos + t6) : 0;
              }
              nodeIndicesArray() {
                let t6 = this.bb.__offset(this.bb_pos, 4);
                return t6 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t6), this.bb.__vector_len(this.bb_pos + t6)) : null;
              }
              kernelDefHashes(t6) {
                let e4 = this.bb.__offset(this.bb_pos, 6);
                return e4 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e4) + 8 * t6) : this.bb.createLong(0, 0);
              }
              kernelDefHashesLength() {
                let t6 = this.bb.__offset(this.bb_pos, 6);
                return t6 ? this.bb.__vector_len(this.bb_pos + t6) : 0;
              }
              static startKernelCreateInfos(t6) {
                t6.startObject(2);
              }
              static addNodeIndices(t6, e4) {
                t6.addFieldOffset(0, e4, 0);
              }
              static createNodeIndicesVector(t6, e4) {
                t6.startVector(4, e4.length, 4);
                for (let n3 = e4.length - 1; n3 >= 0; n3--) t6.addInt32(e4[n3]);
                return t6.endVector();
              }
              static startNodeIndicesVector(t6, e4) {
                t6.startVector(4, e4, 4);
              }
              static addKernelDefHashes(t6, e4) {
                t6.addFieldOffset(1, e4, 0);
              }
              static createKernelDefHashesVector(t6, e4) {
                t6.startVector(8, e4.length, 8);
                for (let n3 = e4.length - 1; n3 >= 0; n3--) t6.addInt64(e4[n3]);
                return t6.endVector();
              }
              static startKernelDefHashesVector(t6, e4) {
                t6.startVector(8, e4, 8);
              }
              static endKernelCreateInfos(t6) {
                return t6.endObject();
              }
              static createKernelCreateInfos(t6, n3, r3) {
                return e3.startKernelCreateInfos(t6), e3.addNodeIndices(t6, n3), e3.addKernelDefHashes(t6, r3), e3.endKernelCreateInfos(t6);
              }
            }
            t5.KernelCreateInfos = e3;
          }(t4.fbs || (t4.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsSubGraphSessionState(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsSubGraphSessionState(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              graphId(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              sessionState(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startSubGraphSessionState(t4) {
                t4.startObject(2);
              }
              static addGraphId(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addSessionState(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static endSubGraphSessionState(t4) {
                let e5 = t4.endObject();
                return t4.requiredField(e5, 4), e5;
              }
              static createSubGraphSessionState(t4, e5, r3) {
                return n3.startSubGraphSessionState(t4), n3.addGraphId(t4, e5), n3.addSessionState(t4, r3), n3.endSubGraphSessionState(t4);
              }
            }
            e4.SubGraphSessionState = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsSessionState(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsSessionState(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              kernels(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 4);
                return n4 ? (e5 || new t3.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              subGraphSessionStates(e5, n4) {
                let r3 = this.bb.__offset(this.bb_pos, 6);
                return r3 ? (n4 || new t3.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r3) + 4 * e5), this.bb) : null;
              }
              subGraphSessionStatesLength() {
                let t4 = this.bb.__offset(this.bb_pos, 6);
                return t4 ? this.bb.__vector_len(this.bb_pos + t4) : 0;
              }
              static startSessionState(t4) {
                t4.startObject(2);
              }
              static addKernels(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addSubGraphSessionStates(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static createSubGraphSessionStatesVector(t4, e5) {
                t4.startVector(4, e5.length, 4);
                for (let n4 = e5.length - 1; n4 >= 0; n4--) t4.addOffset(e5[n4]);
                return t4.endVector();
              }
              static startSubGraphSessionStatesVector(t4, e5) {
                t4.startVector(4, e5, 4);
              }
              static endSessionState(t4) {
                return t4.endObject();
              }
              static createSessionState(t4, e5, r3) {
                return n3.startSessionState(t4), n3.addKernels(t4, e5), n3.addSubGraphSessionStates(t4, r3), n3.endSessionState(t4);
              }
            }
            e4.SessionState = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {})), function(t3) {
        !function(e3) {
          !function(e4) {
            class n3 {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(t4, e5) {
                return this.bb_pos = t4, this.bb = e5, this;
              }
              static getRootAsInferenceSession(t4, e5) {
                return (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static getSizePrefixedRootAsInferenceSession(t4, e5) {
                return t4.setPosition(t4.position() + r2.flatbuffers.SIZE_PREFIX_LENGTH), (e5 || new n3()).__init(t4.readInt32(t4.position()) + t4.position(), t4);
              }
              static bufferHasIdentifier(t4) {
                return t4.__has_identifier("ORTM");
              }
              ortVersion(t4) {
                let e5 = this.bb.__offset(this.bb_pos, 4);
                return e5 ? this.bb.__string(this.bb_pos + e5, t4) : null;
              }
              model(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 6);
                return n4 ? (e5 || new t3.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              sessionState(e5) {
                let n4 = this.bb.__offset(this.bb_pos, 8);
                return n4 ? (e5 || new t3.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n4), this.bb) : null;
              }
              static startInferenceSession(t4) {
                t4.startObject(3);
              }
              static addOrtVersion(t4, e5) {
                t4.addFieldOffset(0, e5, 0);
              }
              static addModel(t4, e5) {
                t4.addFieldOffset(1, e5, 0);
              }
              static addSessionState(t4, e5) {
                t4.addFieldOffset(2, e5, 0);
              }
              static endInferenceSession(t4) {
                return t4.endObject();
              }
              static finishInferenceSessionBuffer(t4, e5) {
                t4.finish(e5, "ORTM");
              }
              static finishSizePrefixedInferenceSessionBuffer(t4, e5) {
                t4.finish(e5, "ORTM", true);
              }
              static createInferenceSession(t4, e5, r3, i2) {
                return n3.startInferenceSession(t4), n3.addOrtVersion(t4, e5), n3.addModel(t4, r3), n3.addSessionState(t4, i2), n3.endInferenceSession(t4);
              }
            }
            e4.InferenceSession = n3;
          }(e3.fbs || (e3.fbs = {}));
        }(t3.experimental || (t3.experimental = {}));
      }(e2.onnxruntime || (e2.onnxruntime = {}));
    }, 7448: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.OnnxjsSessionHandler = void 0;
      const r2 = n2(1670), i = n2(9162);
      e2.OnnxjsSessionHandler = class {
        constructor(t3) {
          this.session = t3, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
        }
        async dispose() {
        }
        async run(t3, e3, n3) {
          const o = /* @__PURE__ */ new Map();
          for (const e4 in t3) if (Object.hasOwnProperty.call(t3, e4)) {
            const n4 = t3[e4];
            o.set(e4, new i.Tensor(n4.dims, n4.type, void 0, void 0, n4.data));
          }
          const a = await this.session.run(o), s = {};
          return a.forEach((t4, e4) => {
            s[e4] = new r2.Tensor(t4.type, t4.data, t4.dims);
          }), s;
        }
        startProfiling() {
          this.session.startProfiling();
        }
        endProfiling() {
          this.session.endProfiling();
        }
      };
    }, 6919: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Session = void 0;
      const r2 = n2(7067), i = n2(1296), o = n2(7091), a = n2(1036), s = n2(6231), u2 = n2(2644);
      e2.Session = class {
        constructor(t3 = {}) {
          this._initialized = false, this.backendHint = t3.backendHint, this.profiler = s.Profiler.create(t3.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
        }
        get inputNames() {
          return this._model.graph.getInputNames();
        }
        get outputNames() {
          return this._model.graph.getOutputNames();
        }
        startProfiling() {
          this.profiler.start();
        }
        endProfiling() {
          this.profiler.stop();
        }
        async loadModel(t3, e3, n3) {
          await this.profiler.event("session", "Session.loadModel", async () => {
            const a2 = await (0, o.resolveBackend)(this.backendHint);
            if (this.sessionHandler = a2.createSessionHandler(this.context), this._model = new u2.Model(), "string" == typeof t3) {
              const e4 = t3.endsWith(".ort");
              if ("undefined" == typeof fetch) {
                const n4 = await (0, i.promisify)(r2.readFile)(t3);
                this.initialize(n4, e4);
              } else {
                const n4 = await fetch(t3), r3 = await n4.arrayBuffer();
                this.initialize(new Uint8Array(r3), e4);
              }
            } else if (ArrayBuffer.isView(t3)) this.initialize(t3);
            else {
              const r3 = new Uint8Array(t3, e3 || 0, n3 || t3.byteLength);
              this.initialize(r3);
            }
          });
        }
        initialize(t3, e3) {
          if (this._initialized) throw new Error("already initialized");
          this.profiler.event("session", "Session.initialize", () => {
            const n3 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
            this._model.load(t3, n3, e3), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);
          }), this._initialized = true;
        }
        async run(t3) {
          if (!this._initialized) throw new Error("session not initialized yet");
          return this.profiler.event("session", "Session.run", async () => {
            const e3 = this.normalizeAndValidateInputs(t3), n3 = await this._executionPlan.execute(this.sessionHandler, e3);
            return this.createOutput(n3);
          });
        }
        normalizeAndValidateInputs(t3) {
          const e3 = this._model.graph.getInputNames();
          if (Array.isArray(t3)) {
            if (t3.length !== e3.length) throw new Error(`incorrect input array length: expected ${e3.length} but got ${t3.length}`);
          } else {
            if (t3.size !== e3.length) throw new Error(`incorrect input map size: expected ${e3.length} but got ${t3.size}`);
            const n3 = new Array(t3.size);
            let r3 = 0;
            for (let i2 = 0; i2 < e3.length; ++i2) {
              const o2 = t3.get(e3[i2]);
              if (!o2) throw new Error(`missing input tensor for: '${name}'`);
              n3[r3++] = o2;
            }
            t3 = n3;
          }
          if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, t3, false);
          else {
            const e4 = this._model.graph.getInputIndices(), n3 = this._model.graph.getValues(), r3 = new Array(e4.length);
            for (let i2 = 0; i2 < e4.length; ++i2) {
              const o2 = n3[e4[i2]];
              r3[i2] = o2.type.shape.dims, this.context.graphInputTypes.push(o2.type.tensorType), this.context.graphInputDims.push(t3[i2].dims);
            }
            this.validateInputTensorDims(r3, t3, true);
          }
          return this.validateInputTensorTypes(this.context.graphInputTypes, t3), t3;
        }
        validateInputTensorTypes(t3, e3) {
          for (let n3 = 0; n3 < e3.length; n3++) {
            const r3 = t3[n3], i2 = e3[n3].type;
            if (r3 !== i2) throw new Error(`input tensor[${n3}] check failed: expected type '${r3}' but got ${i2}`);
          }
        }
        validateInputTensorDims(t3, e3, n3) {
          for (let r3 = 0; r3 < e3.length; r3++) {
            const i2 = t3[r3], o2 = e3[r3].dims;
            if (!this.compareTensorDims(i2, o2, n3)) throw new Error(`input tensor[${r3}] check failed: expected shape '[${i2.join(",")}]' but got [${o2.join(",")}]`);
          }
        }
        compareTensorDims(t3, e3, n3) {
          if (t3.length !== e3.length) return false;
          for (let r3 = 0; r3 < t3.length; ++r3) if (t3[r3] !== e3[r3] && (!n3 || 0 !== t3[r3])) return false;
          return true;
        }
        createOutput(t3) {
          const e3 = this._model.graph.getOutputNames();
          if (t3.length !== e3.length) throw new Error("expected number of outputs do not match number of generated outputs");
          const n3 = /* @__PURE__ */ new Map();
          for (let r3 = 0; r3 < e3.length; ++r3) n3.set(e3[r3], t3[r3]);
          return n3;
        }
        initializeOps(t3) {
          const e3 = t3.getNodes();
          this._ops = new Array(e3.length);
          for (let n3 = 0; n3 < e3.length; n3++) this._ops[n3] = this.sessionHandler.resolve(e3[n3], this._model.opsets, t3);
        }
      };
    }, 9162: function(t2, e2, n2) {
      var r2 = this && this.__importDefault || function(t3) {
        return t3 && t3.__esModule ? t3 : { default: t3 };
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.Tensor = void 0;
      const i = n2(3442), o = r2(n2(3720)), a = n2(1446), s = n2(9395), u2 = n2(2517);
      var c2 = s.onnxruntime.experimental.fbs;
      class l2 {
        get data() {
          if (void 0 === this.cache) {
            const t3 = this.dataProvider(this.dataId);
            if (t3.length !== this.size) throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
            this.cache = t3;
          }
          return this.cache;
        }
        get stringData() {
          if ("string" !== this.type) throw new TypeError("data type is not string");
          return this.data;
        }
        get integerData() {
          switch (this.type) {
            case "uint8":
            case "int8":
            case "uint16":
            case "int16":
            case "int32":
            case "uint32":
            case "bool":
              return this.data;
            default:
              throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
          }
        }
        get floatData() {
          switch (this.type) {
            case "float32":
            case "float64":
              return this.data;
            default:
              throw new TypeError("data type is not float (float32, float64)");
          }
        }
        get numberData() {
          if ("string" !== this.type) return this.data;
          throw new TypeError("type cannot be non-number (string)");
        }
        get(t3) {
          return this.data[u2.ShapeUtil.indicesToOffset(t3, this.strides)];
        }
        set(t3, e3) {
          this.data[u2.ShapeUtil.indicesToOffset(t3, this.strides)] = e3;
        }
        async getData() {
          return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
        }
        get strides() {
          return this._strides || (this._strides = u2.ShapeUtil.computeStrides(this.dims)), this._strides;
        }
        constructor(t3, e3, n3, r3, o2, a2 = i.Guid.create()) {
          this.dims = t3, this.type = e3, this.dataProvider = n3, this.asyncDataProvider = r3, this.cache = o2, this.dataId = a2, this.size = u2.ShapeUtil.validateDimsAndCalcSize(t3);
          const s2 = this.size, c3 = void 0 === n3 && void 0 === r3 && void 0 === o2;
          if (void 0 !== o2 && o2.length !== s2) throw new RangeError("Input dims doesn't match data length.");
          if ("string" === e3) {
            if (!(void 0 === o2 || Array.isArray(o2) && o2.every((t4) => "string" == typeof t4))) throw new TypeError("cache should be a string array");
            c3 && (this.cache = new Array(s2));
          } else {
            if (void 0 !== o2) {
              const t4 = f2(e3);
              if (!(o2 instanceof t4)) throw new TypeError(`cache should be type ${t4.name}`);
            }
            if (c3) {
              const t4 = new ArrayBuffer(s2 * function(t5) {
                switch (t5) {
                  case "bool":
                  case "int8":
                  case "uint8":
                    return 1;
                  case "int16":
                  case "uint16":
                    return 2;
                  case "int32":
                  case "uint32":
                  case "float32":
                    return 4;
                  case "float64":
                    return 8;
                  default:
                    throw new Error(`cannot calculate sizeof() on type ${t5}`);
                }
              }(e3));
              this.cache = function(t5, e4) {
                return new (f2(e4))(t5);
              }(t4, e3);
            }
          }
        }
        static fromProto(t3) {
          if (!t3) throw new Error("cannot construct Value from an empty tensor");
          const e3 = u2.ProtoUtil.tensorDataTypeFromProto(t3.dataType), n3 = u2.ProtoUtil.tensorDimsFromProto(t3.dims), r3 = new l2(n3, e3);
          if ("string" === e3) t3.stringData.forEach((t4, e4) => {
            r3.data[e4] = (0, u2.decodeUtf8String)(t4);
          });
          else if (t3.rawData && "number" == typeof t3.rawData.byteLength && t3.rawData.byteLength > 0) {
            const e4 = r3.data, n4 = new DataView(t3.rawData.buffer, t3.rawData.byteOffset, t3.rawData.byteLength), i2 = p2(t3.dataType), o2 = t3.rawData.byteLength / i2;
            if (t3.rawData.byteLength % i2 != 0) throw new Error("invalid buffer length");
            if (e4.length !== o2) throw new Error("buffer length mismatch");
            for (let r4 = 0; r4 < o2; r4++) {
              const o3 = h2(n4, t3.dataType, r4 * i2);
              e4[r4] = o3;
            }
          } else {
            let e4;
            switch (t3.dataType) {
              case a.onnx.TensorProto.DataType.FLOAT:
                e4 = t3.floatData;
                break;
              case a.onnx.TensorProto.DataType.INT32:
              case a.onnx.TensorProto.DataType.INT16:
              case a.onnx.TensorProto.DataType.UINT16:
              case a.onnx.TensorProto.DataType.INT8:
              case a.onnx.TensorProto.DataType.UINT8:
              case a.onnx.TensorProto.DataType.BOOL:
                e4 = t3.int32Data;
                break;
              case a.onnx.TensorProto.DataType.INT64:
                e4 = t3.int64Data;
                break;
              case a.onnx.TensorProto.DataType.DOUBLE:
                e4 = t3.doubleData;
                break;
              case a.onnx.TensorProto.DataType.UINT32:
              case a.onnx.TensorProto.DataType.UINT64:
                e4 = t3.uint64Data;
                break;
              default:
                throw new Error("unspecific error");
            }
            if (null == e4) throw new Error("failed to populate data from a tensorproto value");
            const n4 = r3.data;
            if (n4.length !== e4.length) throw new Error("array length mismatch");
            for (let r4 = 0; r4 < e4.length; r4++) {
              const i2 = e4[r4];
              o.default.isLong(i2) ? n4[r4] = d2(i2, t3.dataType) : n4[r4] = i2;
            }
          }
          return r3;
        }
        static fromData(t3, e3, n3) {
          return new l2(e3, n3, void 0, void 0, t3);
        }
        static fromOrtTensor(t3) {
          if (!t3) throw new Error("cannot construct Value from an empty tensor");
          const e3 = u2.ProtoUtil.tensorDimsFromORTFormat(t3), n3 = u2.ProtoUtil.tensorDataTypeFromProto(t3.dataType()), r3 = new l2(e3, n3);
          if ("string" === n3) for (let e4 = 0; e4 < t3.stringDataLength(); e4++) r3.data[e4] = t3.stringData(e4);
          else if (t3.rawDataArray() && "number" == typeof t3.rawDataLength() && t3.rawDataLength() > 0) {
            const e4 = r3.data, n4 = new DataView(t3.rawDataArray().buffer, t3.rawDataArray().byteOffset, t3.rawDataLength()), i2 = p2(t3.dataType()), o2 = t3.rawDataLength() / i2;
            if (t3.rawDataLength() % i2 != 0) throw new Error("invalid buffer length");
            if (e4.length !== o2) throw new Error("buffer length mismatch");
            for (let r4 = 0; r4 < o2; r4++) {
              const o3 = h2(n4, t3.dataType(), r4 * i2);
              e4[r4] = o3;
            }
          }
          return r3;
        }
      }
      function p2(t3) {
        switch (t3) {
          case a.onnx.TensorProto.DataType.UINT8:
          case a.onnx.TensorProto.DataType.INT8:
          case a.onnx.TensorProto.DataType.BOOL:
            return 1;
          case a.onnx.TensorProto.DataType.UINT16:
          case a.onnx.TensorProto.DataType.INT16:
            return 2;
          case a.onnx.TensorProto.DataType.FLOAT:
          case a.onnx.TensorProto.DataType.INT32:
          case a.onnx.TensorProto.DataType.UINT32:
            return 4;
          case a.onnx.TensorProto.DataType.INT64:
          case a.onnx.TensorProto.DataType.DOUBLE:
          case a.onnx.TensorProto.DataType.UINT64:
            return 8;
          default:
            throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t3]}`);
        }
      }
      function f2(t3) {
        switch (t3) {
          case "bool":
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "int16":
            return Int16Array;
          case "uint16":
            return Uint16Array;
          case "int32":
            return Int32Array;
          case "uint32":
            return Uint32Array;
          case "float32":
            return Float32Array;
          case "float64":
            return Float64Array;
          default:
            throw new Error("unspecified error");
        }
      }
      function d2(t3, e3) {
        if (e3 === a.onnx.TensorProto.DataType.INT64 || e3 === c2.TensorDataType.INT64) {
          if (t3.greaterThanOrEqual(2147483648) || t3.lessThan(-2147483648)) throw new TypeError("int64 is not supported");
        } else {
          if (e3 !== a.onnx.TensorProto.DataType.UINT32 && e3 !== c2.TensorDataType.UINT32 && e3 !== a.onnx.TensorProto.DataType.UINT64 && e3 !== c2.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e3]}`);
          if (t3.greaterThanOrEqual(4294967296) || t3.lessThan(0)) throw new TypeError("uint64 is not supported");
        }
        return t3.toNumber();
      }
      function h2(t3, e3, n3) {
        switch (e3) {
          case a.onnx.TensorProto.DataType.BOOL:
          case a.onnx.TensorProto.DataType.UINT8:
            return t3.getUint8(n3);
          case a.onnx.TensorProto.DataType.INT8:
            return t3.getInt8(n3);
          case a.onnx.TensorProto.DataType.UINT16:
            return t3.getUint16(n3, true);
          case a.onnx.TensorProto.DataType.INT16:
            return t3.getInt16(n3, true);
          case a.onnx.TensorProto.DataType.FLOAT:
            return t3.getFloat32(n3, true);
          case a.onnx.TensorProto.DataType.INT32:
            return t3.getInt32(n3, true);
          case a.onnx.TensorProto.DataType.UINT32:
            return t3.getUint32(n3, true);
          case a.onnx.TensorProto.DataType.INT64:
            return d2(o.default.fromBits(t3.getUint32(n3, true), t3.getUint32(n3 + 4, true), false), e3);
          case a.onnx.TensorProto.DataType.DOUBLE:
            return t3.getFloat64(n3, true);
          case a.onnx.TensorProto.DataType.UINT64:
            return d2(o.default.fromBits(t3.getUint32(n3, true), t3.getUint32(n3 + 4, true), true), e3);
          default:
            throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e3]}`);
        }
      }
      e2.Tensor = l2;
    }, 2517: function(t2, e2, n2) {
      var r2 = this && this.__importDefault || function(t3) {
        return t3 && t3.__esModule ? t3 : { default: t3 };
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.decodeUtf8String = e2.MAX_CLIP = e2.MIN_CLIP = e2.PoolConvUtil = e2.ReduceUtil = e2.SplitUtil = e2.MathUtil = e2.ShapeUtil = e2.LongUtil = e2.ProtoUtil = e2.GemmUtil = e2.arrayCopyHelper = e2.BroadcastUtil = e2.MatMulUtil = e2.ArrayUtil = e2.assert = e2.checkInputsShape = void 0;
      const i = n2(5686), o = r2(n2(3720)), a = n2(1446), s = n2(9162);
      e2.checkInputsShape = function(t3, ...e3) {
        if (!t3 || t3.length !== e3.length) return false;
        for (let n3 = 0; n3 < t3.length; n3++) if (!t3[n3].dims || t3[n3].dims.length !== e3[n3]) return false;
        return true;
      }, e2.assert = function(t3, e3) {
        if (!t3) throw new Error("string" == typeof e3 ? e3 : e3());
      }, e2.ArrayUtil = class {
        static arraysEqual(t3, e3) {
          if (t3.length !== e3.length) return false;
          for (let n3 = 0; n3 < t3.length; n3++) if (t3[n3] !== e3[n3]) return false;
          return true;
        }
      };
      class u2 {
        static preprocessInputShapes(t3, e3) {
          return [1 === t3.length ? [1, t3[0]] : t3, 1 === e3.length ? [e3[0], 1] : e3];
        }
        static postprocessOutputShape(t3, e3, n3) {
          1 === e3 && t3.splice(t3.length - 2, 1), 1 === n3 && t3.pop();
        }
        static calcMatMulShape(t3, e3) {
          return t3[1] !== e3[0] ? void 0 : [t3[0], e3[1]];
        }
      }
      e2.MatMulUtil = u2;
      class c2 {
        static calcShape(t3, e3, n3 = false) {
          const r3 = t3.length, i2 = e3.length;
          if (0 === r3) return e3;
          if (0 === i2) return t3;
          const o2 = Math.max(t3.length, e3.length), a2 = new Array(o2);
          if (n3) {
            if (r3 < 2 || i2 < 2) return;
            const n4 = u2.calcMatMulShape([t3[r3 - 2], t3[r3 - 1]], [e3[i2 - 2], e3[i2 - 1]]);
            if (void 0 === n4) return;
            [a2[o2 - 2], a2[o2 - 1]] = n4;
          }
          for (let s2 = n3 ? 3 : 1; s2 <= o2; s2++) {
            const n4 = r3 - s2 < 0 ? 1 : t3[r3 - s2], u3 = i2 - s2 < 0 ? 1 : e3[i2 - s2];
            if (n4 !== u3 && n4 > 1 && u3 > 1) return;
            a2[o2 - s2] = Math.max(n4, u3);
          }
          return a2;
        }
        static index(t3, e3) {
          const n3 = new Array(e3.length);
          return c2.fillIndex(t3, e3, n3), n3;
        }
        static fillIndex(t3, e3, n3) {
          const r3 = t3.length - e3.length;
          for (let i2 = 0; i2 < e3.length; i2++) n3[i2] = t3[r3 + i2] % e3[i2];
        }
        static calc(t3, e3, n3, r3, i2) {
          const o2 = c2.calcShape(t3.dims, e3.dims);
          if (o2) {
            if (r3 && !f2.areEqual(o2, t3.dims)) return;
            const a2 = f2.size(o2), u3 = r3 ? t3 : new s.Tensor(o2, i2 || t3.type);
            if (0 === o2.length) u3.set([], n3(t3.get([]), e3.get([])));
            else {
              const r4 = new Array(o2.length), i3 = new Array(t3.dims.length), s2 = new Array(e3.dims.length);
              let l3, p3 = 0, f3 = 0, d3 = false, h3 = false;
              0 === t3.dims.length && (p3 = t3.get([]), d3 = true), 0 === e3.dims.length && (f3 = e3.get([]), h3 = true);
              for (let g3 = 0; g3 < a2; g3++) {
                l3 = g3;
                for (let t4 = o2.length - 1; t4 >= 0; t4--) r4[t4] = l3 % o2[t4], l3 = Math.floor(l3 / o2[t4]);
                d3 || (c2.fillIndex(r4, t3.dims, i3), p3 = t3.get(i3)), h3 || (c2.fillIndex(r4, e3.dims, s2), f3 = e3.get(s2)), u3.set(r4, n3(p3, f3));
              }
            }
            return u3;
          }
        }
        static isValidBroadcast(t3, e3) {
          const n3 = t3.length, r3 = e3.length;
          if (n3 > r3) return false;
          for (let i2 = 1; i2 <= n3; i2++) if (1 !== t3[n3 - i2] && t3[n3 - i2] !== e3[r3 - i2]) return false;
          return true;
        }
        static getBroadcastDims(t3, e3) {
          const n3 = t3.length, r3 = [];
          for (let i2 = 0; i2 < n3; i2++) {
            const o2 = n3 - 1 - i2, a2 = t3[o2] || 1;
            (e3[e3.length - 1 - i2] || 1) > 1 && 1 === a2 && r3.unshift(o2);
          }
          return r3;
        }
      }
      e2.BroadcastUtil = c2, e2.arrayCopyHelper = function(t3, e3, n3, r3, i2) {
        if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
        if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
        if (r3 + i2 > e3.length) throw new Error("source indices to be copied are outside bounds");
        if (n3 + i2 > t3.length) throw new Error("target array is too small to hold result");
        for (let o2 = 0; o2 < i2; o2++) t3[n3 + o2] = e3[r3 + o2];
      }, e2.GemmUtil = class {
        static getShapeOfGemmResult(t3, e3, n3, r3, i2) {
          if (2 !== t3.length || 2 !== n3.length) throw new Error("shape need to be of size 2");
          let o2, a2, s2;
          e3 ? (o2 = t3[1], a2 = t3[0]) : (o2 = t3[0], a2 = t3[1]);
          let u3 = -1;
          if (r3 ? (s2 = n3[0], u3 = 1) : (s2 = n3[1], u3 = 0), n3[u3] !== a2) throw new Error("dimension mismatch");
          if (o2 <= 0 || s2 <= 0 || a2 <= 0) throw new Error("invalid shape specified");
          if (i2 && !c2.isValidBroadcast(i2, [o2, s2])) throw new Error("gemm: invalid bias shape for broadcast");
          return [o2, s2, a2];
        }
      };
      class l2 {
        static tensorDataTypeFromProto(t3) {
          switch (t3) {
            case a.onnx.TensorProto.DataType.INT8:
              return "int8";
            case a.onnx.TensorProto.DataType.UINT8:
              return "uint8";
            case a.onnx.TensorProto.DataType.BOOL:
              return "bool";
            case a.onnx.TensorProto.DataType.INT16:
              return "int16";
            case a.onnx.TensorProto.DataType.UINT16:
              return "uint16";
            case a.onnx.TensorProto.DataType.INT32:
              return "int32";
            case a.onnx.TensorProto.DataType.UINT32:
              return "uint32";
            case a.onnx.TensorProto.DataType.FLOAT:
              return "float32";
            case a.onnx.TensorProto.DataType.DOUBLE:
              return "float64";
            case a.onnx.TensorProto.DataType.STRING:
              return "string";
            case a.onnx.TensorProto.DataType.INT64:
              return "int32";
            case a.onnx.TensorProto.DataType.UINT64:
              return "uint32";
            default:
              throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t3]}`);
          }
        }
        static tensorDataTypeStringToEnum(t3) {
          switch (t3) {
            case "int8":
              return a.onnx.TensorProto.DataType.INT8;
            case "uint8":
              return a.onnx.TensorProto.DataType.UINT8;
            case "bool":
              return a.onnx.TensorProto.DataType.BOOL;
            case "int16":
              return a.onnx.TensorProto.DataType.INT16;
            case "uint16":
              return a.onnx.TensorProto.DataType.UINT16;
            case "int32":
              return a.onnx.TensorProto.DataType.INT32;
            case "uint32":
              return a.onnx.TensorProto.DataType.UINT32;
            case "float32":
              return a.onnx.TensorProto.DataType.FLOAT;
            case "float64":
              return a.onnx.TensorProto.DataType.DOUBLE;
            case "string":
              return a.onnx.TensorProto.DataType.STRING;
            case "int64":
              return a.onnx.TensorProto.DataType.INT64;
            case "uint64":
              return a.onnx.TensorProto.DataType.UINT64;
            default:
              throw new Error(`unsupported data type: ${t3}`);
          }
        }
        static tensorDimsFromProto(t3) {
          return t3.map((t4) => o.default.isLong(t4) ? t4.toNumber() : t4);
        }
        static tensorValueTypeFromProto(t3) {
          return { tensorType: l2.tensorDataTypeFromProto(t3.elemType), shape: { dims: l2.tensorDimsFromProto(t3.shape.dim.map((t4) => t4.dimValue)) } };
        }
        static tensorDimsFromORTFormat(t3) {
          const e3 = [];
          for (let n3 = 0; n3 < t3.dimsLength(); n3++) e3.push(p2.longToNumber(t3.dims(n3)));
          return e3;
        }
        static tensorAttributesFromORTFormat(t3) {
          const e3 = [];
          for (let n3 = 0; n3 < t3.attributesLength(); n3++) e3.push(t3.attributes(n3));
          return e3;
        }
      }
      e2.ProtoUtil = l2;
      class p2 {
        static longToNumber(t3, e3) {
          return o.default.isLong(t3) ? t3.toNumber() : t3 instanceof i.flatbuffers.Long ? o.default.fromValue({ low: t3.low, high: t3.high, unsigned: null != e3 && e3 }).toNumber() : t3;
        }
        static isLong(t3) {
          return o.default.isLong(t3) || t3 instanceof i.flatbuffers.Long;
        }
      }
      e2.LongUtil = p2;
      class f2 {
        static size(t3) {
          return f2.getSizeFromDimensionRange(t3, 0, t3.length);
        }
        static sizeFromDimension(t3, e3) {
          if (e3 < 0 || e3 > t3.length) throw new Error(`invalid dimension of ${e3} for sizeFromDimension as Tensor has ${t3.length} dimensions.`);
          return f2.getSizeFromDimensionRange(t3, e3, t3.length);
        }
        static sizeToDimension(t3, e3) {
          if (e3 < 0 || e3 > t3.length) throw new Error(`invalid dimension of ${e3} for sizeToDimension as Tensor has ${t3.length} dimensions.`);
          return f2.getSizeFromDimensionRange(t3, 0, e3);
        }
        static getSizeFromDimensionRange(t3, e3, n3) {
          let r3 = 1;
          for (let i2 = e3; i2 < n3; i2++) {
            if (t3[i2] <= 0) throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
            r3 *= t3[i2];
          }
          return r3;
        }
        static computeStrides(t3) {
          const e3 = t3.length;
          if (0 === e3) return [];
          if (1 === e3) return [1];
          const n3 = new Array(e3);
          n3[e3 - 1] = 1, n3[e3 - 2] = t3[e3 - 1];
          for (let r3 = e3 - 3; r3 >= 0; --r3) n3[r3] = n3[r3 + 1] * t3[r3 + 1];
          return n3;
        }
        static transpose(t3) {
          return t3.slice().reverse();
        }
        static indicesToOffset(t3, e3, n3) {
          void 0 === n3 && (n3 = t3.length);
          let r3 = 0;
          for (let i2 = 0; i2 < n3; ++i2) r3 += e3[i2] * t3[i2];
          return r3;
        }
        static offsetToIndices(t3, e3) {
          const n3 = e3.length;
          if (0 === n3) return [];
          if (1 === n3) return [t3 * e3[0]];
          const r3 = new Array(e3.length);
          for (let n4 = 0; n4 < r3.length - 1; ++n4) r3[n4] = Math.floor(t3 / e3[n4]), t3 -= r3[n4] * e3[n4];
          return r3[r3.length - 1] = t3, r3;
        }
        static normalizeAxis(t3, e3) {
          if (t3 < -e3 && t3 >= e3) throw new Error("unsupported axis for this operation.");
          return t3 < 0 ? t3 + e3 : t3;
        }
        static normalizeAxes(t3, e3) {
          return t3.map((t4) => this.normalizeAxis(t4, e3));
        }
        static incrementIndex(t3, e3, n3) {
          if (0 === e3.length || 0 === t3.length) throw new Error("Index incrementing unsupported for scalar Tensor");
          if (void 0 === n3) n3 = e3.length;
          else if (n3 <= 0 || n3 > e3.length) throw new Error("Incorrect axis to increment on");
          for (let r3 = n3 - 1; r3 >= 0 && (t3[r3]++, !(t3[r3] < e3[r3])); --r3) t3[r3] = 0;
        }
        static calculateReshapedDims(t3, e3) {
          if (0 === e3.length) {
            if (0 === t3.length || 1 === f2.size(t3)) return [];
            throw new Error("cannot reshape to a scalar Tensor");
          }
          const n3 = e3.length, r3 = new Array(n3);
          let i2 = -1, o2 = 1;
          for (let a3 = 0; a3 < n3; a3++) {
            if (e3[a3] < -1) throw new Error("a dimension in shape hints cannot be less than -1");
            if (-1 === e3[a3]) {
              if (-1 !== i2) throw new Error("at most one dimension in shape hints can be -1");
              i2 = a3;
            } else {
              if (0 === e3[a3]) {
                if (a3 >= t3.length) throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                r3[a3] = t3[a3];
              } else r3[a3] = e3[a3];
              o2 *= r3[a3];
            }
          }
          const a2 = f2.size(t3);
          if (-1 !== i2) {
            if (a2 % o2 != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t3}] Output shape: [${e3}]`);
            r3[i2] = a2 / o2;
          } else if (o2 !== a2) throw new Error("reshapedDims and originalDims don't have matching sizes");
          return r3;
        }
        static sortBasedOnPerm(t3, e3) {
          return e3 ? e3.map((e4) => t3[e4]) : t3.slice().reverse();
        }
        static padShape(t3, e3) {
          const n3 = t3.length;
          return t3.map((t4, r3) => t4 + e3[r3] + e3[r3 + n3]);
        }
        static areEqual(t3, e3) {
          return t3.length === e3.length && t3.every((t4, n3) => t4 === e3[n3]);
        }
        static validateDimsAndCalcSize(t3) {
          if (t3.length > 6) throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
          let e3 = 1;
          for (const n3 of t3) {
            if (!Number.isInteger(n3)) throw new TypeError(`Invalid shape: ${n3} is not an integer`);
            if (n3 < 0 || n3 > 2147483647) throw new TypeError(`Invalid shape: length ${n3} is not allowed`);
            e3 *= n3;
          }
          return e3;
        }
        static flattenShape(t3, e3) {
          e3 < 0 && (e3 += t3.length);
          const n3 = t3.reduce((t4, e4) => t4 * e4, 1), r3 = t3.slice(e3).reduce((t4, e4) => t4 * e4, 1);
          return [n3 / r3, r3];
        }
        static squeezeShape(t3, e3) {
          const n3 = new Array();
          e3 = f2.normalizeAxes(e3, t3.length);
          for (let r3 = 0; r3 < t3.length; r3++) {
            const i2 = e3.indexOf(r3) >= 0;
            if (i2 && 1 !== t3[r3]) throw new Error("squeeze an axis of size different than 1");
            (0 === e3.length && t3[r3] > 1 || e3.length > 0 && !i2) && n3.push(t3[r3]);
          }
          return n3;
        }
        static unsqueezeShape(t3, e3) {
          const n3 = new Array(t3.length + e3.length);
          n3.fill(0);
          for (let t4 = 0; t4 < e3.length; t4++) {
            const r4 = f2.normalizeAxis(e3[t4], n3.length);
            if (r4 >= n3.length) throw new Error("'axes' has an out of range axis");
            if (0 !== n3[r4]) throw new Error("'axes' has a duplicate axis");
            n3[r4] = 1;
          }
          let r3 = 0;
          for (let e4 = 0; e4 < n3.length; e4++) 0 === n3[e4] && (n3[e4] = t3[r3++]);
          if (r3 !== t3.length) throw new Error("the unsqueezed dimension could not be established");
          return n3;
        }
      }
      e2.ShapeUtil = f2, e2.MathUtil = class {
        static sqr(t3, e3, n3, r3, i2) {
          if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
          if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
          if (r3 + i2 > e3.length) throw new Error("source indices to be copied are outside bounds");
          if (n3 + i2 > t3.length) throw new Error("target array is too small to hold result");
          for (let o2 = 0; o2 < i2; o2++) t3[n3 + o2] += Math.pow(e3[r3 + o2], 2);
        }
        static axpy(t3, e3, n3, r3, i2, o2) {
          if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
          if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
          if (r3 + i2 > e3.length) throw new Error("source indices to be copied are outside bounds");
          if (n3 + i2 > t3.length) throw new Error("target array is too small to hold result");
          for (let a2 = 0; a2 < i2; a2++) t3[n3 + a2] += o2 * e3[r3 + a2];
        }
        static powx(t3, e3, n3, r3, i2, o2) {
          if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
          if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
          if (r3 + i2 > e3.length) throw new Error("source indices to be copied are outside bounds");
          if (n3 + i2 > t3.length) throw new Error("target array is too small to hold result");
          for (let a2 = 0; a2 < i2; a2++) t3[n3 + a2] = Math.pow(e3[r3 + a2], o2);
        }
        static mul(t3, e3, n3, r3, i2) {
          if (r3 < 0 || r3 >= e3.length) throw new Error("sourceIndex out of bounds");
          if (n3 < 0 || n3 >= t3.length) throw new Error("targetIndex out of bounds");
          if (r3 + i2 > e3.length) throw new Error("source indices to be copied are outside bounds");
          if (n3 + i2 > t3.length) throw new Error("target array is too small to hold result");
          for (let o2 = 0; o2 < i2; o2++) t3[n3 + o2] = e3[r3 + o2] * t3[n3 + o2];
        }
      };
      class d2 {
        static splitShape(t3, e3, n3, r3) {
          if (0 === n3.length) {
            if (!r3) throw new Error("need to know number of outputs when the 'split' attribute is not specified");
            d2.determineSplit(t3[e3], r3, n3);
          }
          const i2 = [], o2 = [0];
          for (let r4 = 0; r4 < n3.length; ++r4) {
            0 !== r4 && o2.push(o2[r4 - 1] + n3[r4 - 1]);
            const a2 = t3.slice();
            a2[e3] = n3[r4], i2.push(a2);
          }
          return [i2, o2];
        }
        static determineSplit(t3, e3, n3) {
          if (t3 % e3 != 0) throw new Error("cannot split tensor to equal sized parts");
          for (let r3 = 0; r3 < e3; ++r3) n3.push(t3 / e3);
        }
      }
      e2.SplitUtil = d2;
      class h2 {
        static calcReduce(t3, e3, n3, r3, i2) {
          const o2 = t3.dims.slice(0);
          0 === e3.length && o2.forEach((t4, n4) => e3.push(n4));
          const a2 = h2.calcReduceShape(o2, e3, true), u3 = f2.size(a2), l3 = new s.Tensor(a2, t3.type), p3 = f2.computeStrides(a2), d3 = f2.computeStrides(o2), g3 = new Array(o2.length);
          for (let n4 = 0; n4 < u3; n4++) {
            const a3 = f2.offsetToIndices(n4, p3);
            c2.fillIndex(a3, o2, g3), l3.set(a3, h2.calcReduceByAxis(t3.numberData, e3, o2, 0, f2.indicesToOffset(g3, d3), r3, i2));
          }
          return n3 ? l3 : new s.Tensor(h2.calcReduceShape(o2, e3, n3), l3.type, void 0, void 0, l3.data, l3.dataId);
        }
        static calcReduceByAxis(t3, e3, n3, r3, i2, o2, a2) {
          let s2 = 0;
          if (r3 >= e3.length) return o2(t3[i2]);
          const u3 = e3[r3], c3 = u3 >= n3.length ? 1 : f2.size(n3.slice(u3 + 1));
          for (let l3 = 0; l3 < n3[u3]; l3++) s2 = 0 === l3 ? h2.calcReduceByAxis(t3, e3, n3, r3 + 1, i2, o2, a2) : a2(s2, h2.calcReduceByAxis(t3, e3, n3, r3 + 1, i2, o2, a2)), i2 += c3;
          return s2;
        }
        static calcReduceShape(t3, e3, n3) {
          const r3 = t3.slice();
          for (let t4 = 0; t4 < e3.length; t4++) r3[e3[t4]] = n3 ? 1 : 0;
          return r3.filter((t4) => 0 !== t4);
        }
      }
      e2.ReduceUtil = h2;
      class g2 {
        static adjustPoolAttributes(t3, e3, n3, r3, i2, o2) {
          if (!t3 && n3.length !== e3.length - 2) throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
          if (t3) for (let t4 = 0; t4 < e3.length - 2; t4++) t4 >= n3.length ? n3.push(e3[t4 + 2]) : n3[t4] = e3[t4 + 2];
          for (let t4 = 0; t4 < n3.length; t4++) if (t4 < r3.length) {
            if (r3[t4] < 0) throw new Error("strides should be greater than or equal to 1");
          } else r3.push(1);
          for (let t4 = 0; t4 < n3.length; t4++) if (t4 < i2.length) {
            if (i2[t4] < 0) throw new Error("dilations should be greater than or equal to 1");
          } else i2.push(1);
          for (let t4 = 0; t4 < 2 * n3.length; t4++) if (t4 < o2.length) {
            if (o2[t4] < 0) throw new Error("pad should be greater than or equal to 1");
          } else o2.push(0);
          for (let t4 = 0; t4 < n3.length; t4++) {
            if (n3[t4] <= 0) throw new Error("kernel shapes need to be greater than 0");
            if (o2[t4] >= n3[t4] || o2[t4 + n3.length] >= n3[t4]) throw new Error("pads should be smaller than kernel");
          }
        }
        static adjustPadsBasedOnAutoPad(t3, e3, n3, r3, i2, o2) {
          if (o2) {
            if (i2.length !== 2 * (t3.length - 2)) throw new Error("length of pads should be twice the length of data dimensions");
            if (e3.length !== t3.length - 2) throw new Error("length of strides should be the length of data dimensions");
            if (r3.length !== t3.length - 2) throw new Error("length of kernel shapes should be the length of data dimensions");
            for (let a2 = 0; a2 < t3.length - 2; a2++) g2.adjustPadAndReturnShape(t3[a2 + 2], e3[a2], n3[a2], r3[a2], i2, a2, a2 + t3.length - 2, o2);
          }
        }
        static computePoolOutputShape(t3, e3, n3, r3, i2, o2, a2) {
          if (e3.length <= 0) throw new Error("input shape must be of size greater than 0");
          const s2 = [e3[0], e3[1]];
          return g2.computeShapeHelper(t3, e3, s2, n3, r3, i2, o2, a2), s2;
        }
        static computeConvOutputShape(t3, e3, n3, r3, i2, o2, a2) {
          if (t3.length <= 0 || e3.length <= 0) throw new Error("invalid input tensor dims or invalid filter tensor dims");
          const s2 = [t3[0], e3[0]];
          return g2.computeShapeHelper(false, t3, s2, n3, r3, i2, o2, a2), s2;
        }
        static computeShapeHelper(t3, e3, n3, r3, i2, o2, a2, s2) {
          if (t3) for (let t4 = 0; t4 < e3.length - 2; t4++) n3.push(1);
          else for (let t4 = 0; t4 < e3.length - 2; t4++) n3.push(g2.adjustPadAndReturnShape(e3[t4 + 2], r3[t4], i2[t4], o2[t4], a2, t4, t4 + e3.length - 2, s2));
        }
        static adjustPadAndReturnShape(t3, e3, n3, r3, i2, o2, a2, s2) {
          const u3 = n3 * (r3 - 1) + 1;
          if (!s2 || "NOTSET" === s2) return Math.floor((t3 + i2[o2] + i2[a2] - u3) / e3 + 1);
          switch (s2) {
            case "VALID":
              return i2[o2] = 0, i2[a2] = 0, Math.floor((t3 - u3) / e3 + 1);
            case "SAME_LOWER":
            case "SAME_UPPER":
              if (1 !== n3) throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
              {
                const n4 = ((t3 + e3 - 1) / e3 - 1) * e3 + r3 - t3;
                return i2[o2] = "SAME_LOWER" === s2 ? Math.floor((n4 + 1) / 2) : Math.floor(n4 / 2), i2[a2] = n4 - i2[o2], Math.floor((t3 + n4 - r3) / e3 + 1);
              }
            default:
              throw new Error("Unsupported AutoPad type");
          }
        }
      }
      e2.PoolConvUtil = g2, e2.MIN_CLIP = -34028234663852886e22, e2.MAX_CLIP = 34028234663852886e22, e2.decodeUtf8String = function(t3) {
        return new TextDecoder().decode(t3);
      };
    }, 7967: (t2, e2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.iterateExtraOptions = void 0, e2.iterateExtraOptions = (t3, n2, r2, i) => {
        if ("object" == typeof t3 && null !== t3) {
          if (r2.has(t3)) throw new Error("Circular reference in options");
          r2.add(t3);
        }
        Object.entries(t3).forEach(([t4, o]) => {
          const a = n2 ? n2 + t4 : t4;
          if ("object" == typeof o) (0, e2.iterateExtraOptions)(o, a + ".", r2, i);
          else if ("string" == typeof o || "number" == typeof o) i(a, o.toString());
          else {
            if ("boolean" != typeof o) throw new Error("Can't handle extra config type: " + typeof o);
            i(a, o ? "1" : "0");
          }
        });
      };
    }, 2157: function(t2, e2, n2) {
      var r2, i = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i2 = Object.getOwnPropertyDescriptor(e3, n3);
        i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i2);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), o = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
        Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
      } : function(t3, e3) {
        t3.default = e3;
      }), a = this && this.__importStar || function(t3) {
        if (t3 && t3.__esModule) return t3;
        var e3 = {};
        if (null != t3) for (var n3 in t3) "default" !== n3 && Object.prototype.hasOwnProperty.call(t3, n3) && i(e3, t3, n3);
        return o(e3, t3), e3;
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.endProfiling = e2.run = e2.releaseSession = e2.createSession = e2.createSessionFinalize = e2.createSessionAllocate = e2.initOrt = e2.initWasm = void 0;
      const s = n2(1670), u2 = a(n2(349)), c2 = n2(6361), l2 = () => !!s.env.wasm.proxy && "undefined" != typeof document;
      let p2, f2, d2, h2 = false, g2 = false, b2 = false;
      const m2 = [], y2 = [], _ = [], v2 = [], w2 = [], x2 = [], T2 = () => {
        if (h2 || !g2 || b2 || !p2) throw new Error("worker not ready");
      }, S2 = (t3) => {
        switch (t3.data.type) {
          case "init-wasm":
            h2 = false, t3.data.err ? (b2 = true, f2[1](t3.data.err)) : (g2 = true, f2[0]());
            break;
          case "init-ort":
            t3.data.err ? d2[1](t3.data.err) : d2[0]();
            break;
          case "create_allocate":
            t3.data.err ? m2.shift()[1](t3.data.err) : m2.shift()[0](t3.data.out);
            break;
          case "create_finalize":
            t3.data.err ? y2.shift()[1](t3.data.err) : y2.shift()[0](t3.data.out);
            break;
          case "create":
            t3.data.err ? _.shift()[1](t3.data.err) : _.shift()[0](t3.data.out);
            break;
          case "release":
            t3.data.err ? v2.shift()[1](t3.data.err) : v2.shift()[0]();
            break;
          case "run":
            t3.data.err ? w2.shift()[1](t3.data.err) : w2.shift()[0](t3.data.out);
            break;
          case "end-profiling":
            t3.data.err ? x2.shift()[1](t3.data.err) : x2.shift()[0]();
        }
      }, O2 = "undefined" != typeof document ? null === (r2 = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r2 ? void 0 : r2.src : void 0;
      e2.initWasm = async () => {
        if (l2()) {
          if (g2) return;
          if (h2) throw new Error("multiple calls to 'initWasm()' detected.");
          if (b2) throw new Error("previous call to 'initWasm()' failed.");
          return h2 = true, void 0 === s.env.wasm.wasmPaths && O2 && 0 !== O2.indexOf("blob:") && (s.env.wasm.wasmPaths = O2.substr(0, +O2.lastIndexOf("/") + 1)), new Promise((t3, e3) => {
            null == p2 || p2.terminate(), p2 = n2(9710).Z(), p2.onmessage = S2, f2 = [t3, e3];
            const r3 = { type: "init-wasm", in: s.env.wasm };
            p2.postMessage(r3);
          });
        }
        return (0, c2.initializeWebAssembly)(s.env.wasm);
      }, e2.initOrt = async (t3, e3) => {
        if (l2()) return T2(), new Promise((n3, r3) => {
          d2 = [n3, r3];
          const i2 = { type: "init-ort", in: { numThreads: t3, loggingLevel: e3 } };
          p2.postMessage(i2);
        });
        u2.initOrt(t3, e3);
      }, e2.createSessionAllocate = async (t3) => l2() ? (T2(), new Promise((e3, n3) => {
        m2.push([e3, n3]);
        const r3 = { type: "create_allocate", in: { model: t3 } };
        p2.postMessage(r3, [t3.buffer]);
      })) : u2.createSessionAllocate(t3), e2.createSessionFinalize = async (t3, e3) => l2() ? (T2(), new Promise((n3, r3) => {
        y2.push([n3, r3]);
        const i2 = { type: "create_finalize", in: { modeldata: t3, options: e3 } };
        p2.postMessage(i2);
      })) : u2.createSessionFinalize(t3, e3), e2.createSession = async (t3, e3) => l2() ? (T2(), new Promise((n3, r3) => {
        _.push([n3, r3]);
        const i2 = { type: "create", in: { model: t3, options: e3 } };
        p2.postMessage(i2, [t3.buffer]);
      })) : u2.createSession(t3, e3), e2.releaseSession = async (t3) => {
        if (l2()) return T2(), new Promise((e3, n3) => {
          v2.push([e3, n3]);
          const r3 = { type: "release", in: t3 };
          p2.postMessage(r3);
        });
        u2.releaseSession(t3);
      }, e2.run = async (t3, e3, n3, r3, i2) => l2() ? (T2(), new Promise((o2, a2) => {
        w2.push([o2, a2]);
        const s2 = { type: "run", in: { sessionId: t3, inputIndices: e3, inputs: n3, outputIndices: r3, options: i2 } };
        p2.postMessage(s2, u2.extractTransferableBuffers(n3));
      })) : u2.run(t3, e3, n3, r3, i2), e2.endProfiling = async (t3) => {
        if (l2()) return T2(), new Promise((e3, n3) => {
          x2.push([e3, n3]);
          const r3 = { type: "end-profiling", in: t3 };
          p2.postMessage(r3);
        });
        u2.endProfiling(t3);
      };
    }, 586: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.setRunOptions = void 0;
      const r2 = n2(7967), i = n2(4983), o = n2(6361);
      e2.setRunOptions = (t3) => {
        const e3 = (0, o.getInstance)();
        let n3 = 0;
        const a = [], s = t3 || {};
        try {
          if (void 0 === (null == t3 ? void 0 : t3.logSeverityLevel)) s.logSeverityLevel = 2;
          else if ("number" != typeof t3.logSeverityLevel || !Number.isInteger(t3.logSeverityLevel) || t3.logSeverityLevel < 0 || t3.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t3.logSeverityLevel}`);
          if (void 0 === (null == t3 ? void 0 : t3.logVerbosityLevel)) s.logVerbosityLevel = 0;
          else if ("number" != typeof t3.logVerbosityLevel || !Number.isInteger(t3.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t3.logVerbosityLevel}`);
          void 0 === (null == t3 ? void 0 : t3.terminate) && (s.terminate = false);
          let o2 = 0;
          if (void 0 !== (null == t3 ? void 0 : t3.tag) && (o2 = (0, i.allocWasmString)(t3.tag, a)), n3 = e3._OrtCreateRunOptions(s.logSeverityLevel, s.logVerbosityLevel, !!s.terminate, o2), 0 === n3) throw new Error("Can't create run options");
          return void 0 !== (null == t3 ? void 0 : t3.extra) && (0, r2.iterateExtraOptions)(t3.extra, "", /* @__PURE__ */ new WeakSet(), (t4, r3) => {
            const o3 = (0, i.allocWasmString)(t4, a), s2 = (0, i.allocWasmString)(r3, a);
            if (0 !== e3._OrtAddRunConfigEntry(n3, o3, s2)) throw new Error(`Can't set a run config entry: ${t4} - ${r3}`);
          }), [n3, a];
        } catch (t4) {
          throw 0 !== n3 && e3._OrtReleaseRunOptions(n3), a.forEach(e3._free), t4;
        }
      };
    }, 2306: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.OnnxruntimeWebAssemblySessionHandler = void 0;
      const r2 = n2(2806), i = n2(1670), o = n2(2850), a = n2(2157);
      let s;
      e2.OnnxruntimeWebAssemblySessionHandler = class {
        async createSessionAllocate(t3) {
          const e3 = await fetch(t3), n3 = await e3.arrayBuffer();
          return (0, a.createSessionAllocate)(new Uint8Array(n3));
        }
        async loadModel(t3, e3) {
          if (s || (await (0, a.initOrt)(i.env.wasm.numThreads, ((t4) => {
            switch (t4) {
              case "verbose":
                return 0;
              case "info":
                return 1;
              case "warning":
                return 2;
              case "error":
                return 3;
              case "fatal":
                return 4;
              default:
                throw new Error(`unsupported logging level: ${t4}`);
            }
          })(i.env.logLevel)), s = true), "string" == typeof t3) if ("undefined" == typeof fetch) {
            const n3 = await (0, o.promisify)(r2.readFile)(t3);
            [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n3, e3);
          } else {
            const n3 = await this.createSessionAllocate(t3);
            [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n3, e3);
          }
          else [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(t3, e3);
        }
        async dispose() {
          return (0, a.releaseSession)(this.sessionId);
        }
        async run(t3, e3, n3) {
          const r3 = [], o2 = [];
          Object.entries(t3).forEach((t4) => {
            const e4 = t4[0], n4 = t4[1], i2 = this.inputNames.indexOf(e4);
            if (-1 === i2) throw new Error(`invalid input '${e4}'`);
            r3.push(n4), o2.push(i2);
          });
          const s2 = [];
          Object.entries(e3).forEach((t4) => {
            const e4 = t4[0], n4 = this.outputNames.indexOf(e4);
            if (-1 === n4) throw new Error(`invalid output '${e4}'`);
            s2.push(n4);
          });
          const u2 = await (0, a.run)(this.sessionId, o2, r3.map((t4) => [t4.type, t4.dims, t4.data]), s2, n3), c2 = {};
          for (let t4 = 0; t4 < u2.length; t4++) c2[this.outputNames[s2[t4]]] = new i.Tensor(u2[t4][0], u2[t4][2], u2[t4][1]);
          return c2;
        }
        startProfiling() {
        }
        endProfiling() {
          (0, a.endProfiling)(this.sessionId);
        }
      };
    }, 4919: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.setSessionOptions = void 0;
      const r2 = n2(7967), i = n2(4983), o = n2(6361);
      e2.setSessionOptions = (t3) => {
        const e3 = (0, o.getInstance)();
        let n3 = 0;
        const a = [], s = t3 || {};
        ((t4) => {
          t4.extra || (t4.extra = {}), t4.extra.session || (t4.extra.session = {});
          const e4 = t4.extra.session;
          e4.use_ort_model_bytes_directly || (e4.use_ort_model_bytes_directly = "1");
        })(s);
        try {
          void 0 === (null == t3 ? void 0 : t3.graphOptimizationLevel) && (s.graphOptimizationLevel = "all");
          const u2 = ((t4) => {
            switch (t4) {
              case "disabled":
                return 0;
              case "basic":
                return 1;
              case "extended":
                return 2;
              case "all":
                return 99;
              default:
                throw new Error(`unsupported graph optimization level: ${t4}`);
            }
          })(s.graphOptimizationLevel);
          void 0 === (null == t3 ? void 0 : t3.enableCpuMemArena) && (s.enableCpuMemArena = true), void 0 === (null == t3 ? void 0 : t3.enableMemPattern) && (s.enableMemPattern = true), void 0 === (null == t3 ? void 0 : t3.executionMode) && (s.executionMode = "sequential");
          const c2 = ((t4) => {
            switch (t4) {
              case "sequential":
                return 0;
              case "parallel":
                return 1;
              default:
                throw new Error(`unsupported execution mode: ${t4}`);
            }
          })(s.executionMode);
          let l2 = 0;
          if (void 0 !== (null == t3 ? void 0 : t3.logId) && (l2 = (0, i.allocWasmString)(t3.logId, a)), void 0 === (null == t3 ? void 0 : t3.logSeverityLevel)) s.logSeverityLevel = 2;
          else if ("number" != typeof t3.logSeverityLevel || !Number.isInteger(t3.logSeverityLevel) || t3.logSeverityLevel < 0 || t3.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t3.logSeverityLevel}`);
          if (void 0 === (null == t3 ? void 0 : t3.logVerbosityLevel)) s.logVerbosityLevel = 0;
          else if ("number" != typeof t3.logVerbosityLevel || !Number.isInteger(t3.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t3.logVerbosityLevel}`);
          if (void 0 === (null == t3 ? void 0 : t3.enableProfiling) && (s.enableProfiling = false), n3 = e3._OrtCreateSessionOptions(u2, !!s.enableCpuMemArena, !!s.enableMemPattern, c2, !!s.enableProfiling, 0, l2, s.logSeverityLevel, s.logVerbosityLevel), 0 === n3) throw new Error("Can't create session options");
          return (null == t3 ? void 0 : t3.executionProviders) && ((t4, e4, n4) => {
            for (const r3 of e4) {
              let e5 = "string" == typeof r3 ? r3 : r3.name;
              switch (e5) {
                case "xnnpack":
                  e5 = "XNNPACK";
                  break;
                case "wasm":
                case "cpu":
                  continue;
                default:
                  throw new Error(`not supported EP: ${e5}`);
              }
              const a2 = (0, i.allocWasmString)(e5, n4);
              if (0 !== (0, o.getInstance)()._OrtAppendExecutionProvider(t4, a2)) throw new Error(`Can't append execution provider: ${e5}`);
            }
          })(n3, t3.executionProviders, a), void 0 !== (null == t3 ? void 0 : t3.extra) && (0, r2.iterateExtraOptions)(t3.extra, "", /* @__PURE__ */ new WeakSet(), (t4, r3) => {
            const o2 = (0, i.allocWasmString)(t4, a), s2 = (0, i.allocWasmString)(r3, a);
            if (0 !== e3._OrtAddSessionConfigEntry(n3, o2, s2)) throw new Error(`Can't set a session config entry: ${t4} - ${r3}`);
          }), [n3, a];
        } catch (t4) {
          throw 0 !== n3 && e3._OrtReleaseSessionOptions(n3), a.forEach(e3._free), t4;
        }
      };
    }, 4983: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.allocWasmString = void 0;
      const r2 = n2(6361);
      e2.allocWasmString = (t3, e3) => {
        const n3 = (0, r2.getInstance)(), i = n3.lengthBytesUTF8(t3) + 1, o = n3._malloc(i);
        return n3.stringToUTF8(t3, o, i), e3.push(o), o;
      };
    }, 349: (t2, e2, n2) => {
      Object.defineProperty(e2, "__esModule", { value: true }), e2.extractTransferableBuffers = e2.endProfiling = e2.run = e2.releaseSession = e2.createSession = e2.createSessionFinalize = e2.createSessionAllocate = e2.initOrt = void 0;
      const r2 = n2(586), i = n2(4919), o = n2(4983), a = n2(6361);
      e2.initOrt = (t3, e3) => {
        const n3 = (0, a.getInstance)()._OrtInit(t3, e3);
        if (0 !== n3) throw new Error(`Can't initialize onnxruntime. error code = ${n3}`);
      };
      const s = /* @__PURE__ */ new Map();
      e2.createSessionAllocate = (t3) => {
        const e3 = (0, a.getInstance)(), n3 = e3._malloc(t3.byteLength);
        return e3.HEAPU8.set(t3, n3), [n3, t3.byteLength];
      }, e2.createSessionFinalize = (t3, e3) => {
        const n3 = (0, a.getInstance)();
        let r3 = 0, o2 = 0, u3 = [];
        try {
          if ([o2, u3] = (0, i.setSessionOptions)(e3), r3 = n3._OrtCreateSession(t3[0], t3[1], o2), 0 === r3) throw new Error("Can't create a session");
        } finally {
          n3._free(t3[0]), n3._OrtReleaseSessionOptions(o2), u3.forEach(n3._free);
        }
        const c3 = n3._OrtGetInputCount(r3), l3 = n3._OrtGetOutputCount(r3), p2 = [], f2 = [], d2 = [], h2 = [];
        for (let t4 = 0; t4 < c3; t4++) {
          const e4 = n3._OrtGetInputName(r3, t4);
          if (0 === e4) throw new Error("Can't get an input name");
          f2.push(e4), p2.push(n3.UTF8ToString(e4));
        }
        for (let t4 = 0; t4 < l3; t4++) {
          const e4 = n3._OrtGetOutputName(r3, t4);
          if (0 === e4) throw new Error("Can't get an output name");
          h2.push(e4), d2.push(n3.UTF8ToString(e4));
        }
        return s.set(r3, [r3, f2, h2]), [r3, p2, d2];
      }, e2.createSession = (t3, n3) => {
        const r3 = (0, e2.createSessionAllocate)(t3);
        return (0, e2.createSessionFinalize)(r3, n3);
      }, e2.releaseSession = (t3) => {
        const e3 = (0, a.getInstance)(), n3 = s.get(t3);
        if (!n3) throw new Error("invalid session id");
        const r3 = n3[0], i2 = n3[1], o2 = n3[2];
        i2.forEach(e3._OrtFree), o2.forEach(e3._OrtFree), e3._OrtReleaseSession(r3), s.delete(t3);
      };
      const u2 = (t3) => {
        switch (t3) {
          case "int8":
            return 3;
          case "uint8":
            return 2;
          case "bool":
            return 9;
          case "int16":
            return 5;
          case "uint16":
            return 4;
          case "int32":
            return 6;
          case "uint32":
            return 12;
          case "float32":
            return 1;
          case "float64":
            return 11;
          case "string":
            return 8;
          case "int64":
            return 7;
          case "uint64":
            return 13;
          default:
            throw new Error(`unsupported data type: ${t3}`);
        }
      }, c2 = (t3) => {
        switch (t3) {
          case 3:
            return "int8";
          case 2:
            return "uint8";
          case 9:
            return "bool";
          case 5:
            return "int16";
          case 4:
            return "uint16";
          case 6:
            return "int32";
          case 12:
            return "uint32";
          case 1:
            return "float32";
          case 11:
            return "float64";
          case 8:
            return "string";
          case 7:
            return "int64";
          case 13:
            return "uint64";
          default:
            throw new Error(`unsupported data type: ${t3}`);
        }
      }, l2 = (t3) => {
        switch (t3) {
          case "float32":
            return Float32Array;
          case "uint8":
          case "bool":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "uint16":
            return Uint16Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "float64":
            return Float64Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "uint64":
            return BigUint64Array;
          default:
            throw new Error(`unsupported type: ${t3}`);
        }
      };
      e2.run = (t3, e3, n3, i2, p2) => {
        const f2 = (0, a.getInstance)(), d2 = s.get(t3);
        if (!d2) throw new Error("invalid session id");
        const h2 = d2[0], g2 = d2[1], b2 = d2[2], m2 = e3.length, y2 = i2.length;
        let _ = 0, v2 = [];
        const w2 = [], x2 = [];
        try {
          [_, v2] = (0, r2.setRunOptions)(p2);
          for (let t5 = 0; t5 < m2; t5++) {
            const e4 = n3[t5][0], r3 = n3[t5][1], i3 = n3[t5][2];
            let a3, s3;
            if (Array.isArray(i3)) {
              s3 = 4 * i3.length, a3 = f2._malloc(s3), x2.push(a3);
              let t6 = a3 / 4;
              for (let e5 = 0; e5 < i3.length; e5++) {
                if ("string" != typeof i3[e5]) throw new TypeError(`tensor data at index ${e5} is not a string`);
                f2.HEAPU32[t6++] = (0, o.allocWasmString)(i3[e5], x2);
              }
            } else s3 = i3.byteLength, a3 = f2._malloc(s3), x2.push(a3), f2.HEAPU8.set(new Uint8Array(i3.buffer, i3.byteOffset, s3), a3);
            const c3 = f2.stackSave(), l3 = f2.stackAlloc(4 * r3.length);
            try {
              let t6 = l3 / 4;
              r3.forEach((e5) => f2.HEAP32[t6++] = e5);
              const n4 = f2._OrtCreateTensor(u2(e4), a3, s3, l3, r3.length);
              if (0 === n4) throw new Error("Can't create a tensor");
              w2.push(n4);
            } finally {
              f2.stackRestore(c3);
            }
          }
          const t4 = f2.stackSave(), a2 = f2.stackAlloc(4 * m2), s2 = f2.stackAlloc(4 * m2), d3 = f2.stackAlloc(4 * y2), T2 = f2.stackAlloc(4 * y2);
          try {
            let n4 = a2 / 4, r3 = s2 / 4, o2 = d3 / 4, u3 = T2 / 4;
            for (let t5 = 0; t5 < m2; t5++) f2.HEAPU32[n4++] = w2[t5], f2.HEAPU32[r3++] = g2[e3[t5]];
            for (let t5 = 0; t5 < y2; t5++) f2.HEAPU32[o2++] = 0, f2.HEAPU32[u3++] = b2[i2[t5]];
            let p3 = f2._OrtRun(h2, s2, a2, m2, T2, y2, d3, _);
            const v3 = [];
            if (0 === p3) for (let t5 = 0; t5 < y2; t5++) {
              const e4 = f2.HEAPU32[d3 / 4 + t5], n5 = f2.stackSave(), r4 = f2.stackAlloc(16);
              let i3, o3 = 0;
              try {
                if (p3 = f2._OrtGetTensorData(e4, r4, r4 + 4, r4 + 8, r4 + 12), 0 !== p3) throw new Error(`Can't access output tensor data. error code = ${p3}`);
                let t6 = r4 / 4;
                const a3 = f2.HEAPU32[t6++];
                o3 = f2.HEAPU32[t6++];
                const s3 = f2.HEAPU32[t6++], u4 = f2.HEAPU32[t6++], d4 = [];
                for (let t7 = 0; t7 < u4; t7++) d4.push(f2.HEAPU32[s3 / 4 + t7]);
                f2._OrtFree(s3);
                const h3 = 0 === d4.length ? 1 : d4.reduce((t7, e5) => t7 * e5);
                if (i3 = c2(a3), "string" === i3) {
                  const t7 = [];
                  let e5 = o3 / 4;
                  for (let n6 = 0; n6 < h3; n6++) {
                    const r5 = f2.HEAPU32[e5++], i4 = n6 === h3 - 1 ? void 0 : f2.HEAPU32[e5] - r5;
                    t7.push(f2.UTF8ToString(r5, i4));
                  }
                  v3.push([i3, d4, t7]);
                } else {
                  const t7 = new (l2(i3))(h3);
                  new Uint8Array(t7.buffer, t7.byteOffset, t7.byteLength).set(f2.HEAPU8.subarray(o3, o3 + t7.byteLength)), v3.push([i3, d4, t7]);
                }
              } finally {
                f2.stackRestore(n5), "string" === i3 && o3 && f2._free(o3), f2._OrtReleaseTensor(e4);
              }
            }
            if (0 === p3) return v3;
            throw new Error(`failed to call OrtRun(). error code = ${p3}.`);
          } finally {
            f2.stackRestore(t4);
          }
        } finally {
          w2.forEach(f2._OrtReleaseTensor), x2.forEach(f2._free), f2._OrtReleaseRunOptions(_), v2.forEach(f2._free);
        }
      }, e2.endProfiling = (t3) => {
        const e3 = (0, a.getInstance)(), n3 = s.get(t3);
        if (!n3) throw new Error("invalid session id");
        const r3 = n3[0], i2 = e3._OrtEndProfiling(r3);
        if (0 === i2) throw new Error("Can't get an profile file name");
        e3._OrtFree(i2);
      }, e2.extractTransferableBuffers = (t3) => {
        const e3 = [];
        for (const n3 of t3) {
          const t4 = n3[2];
          !Array.isArray(t4) && t4.buffer && e3.push(t4.buffer);
        }
        return e3;
      };
    }, 6361: function(t2, e2, n2) {
      var r2 = this && this.__createBinding || (Object.create ? function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3);
        var i2 = Object.getOwnPropertyDescriptor(e3, n3);
        i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
          return e3[n3];
        } }), Object.defineProperty(t3, r3, i2);
      } : function(t3, e3, n3, r3) {
        void 0 === r3 && (r3 = n3), t3[r3] = e3[n3];
      }), i = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
        Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
      } : function(t3, e3) {
        t3.default = e3;
      }), o = this && this.__importStar || function(t3) {
        if (t3 && t3.__esModule) return t3;
        var e3 = {};
        if (null != t3) for (var n3 in t3) "default" !== n3 && Object.prototype.hasOwnProperty.call(t3, n3) && r2(e3, t3, n3);
        return i(e3, t3), e3;
      }, a = this && this.__importDefault || function(t3) {
        return t3 && t3.__esModule ? t3 : { default: t3 };
      };
      Object.defineProperty(e2, "__esModule", { value: true }), e2.dispose = e2.getInstance = e2.initializeWebAssembly = void 0;
      const s = o(n2(6449)), u2 = a(n2(932)), c2 = n2(3474);
      let l2, p2 = false, f2 = false, d2 = false;
      const h2 = (t3, e3) => e3 ? t3 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : t3 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm";
      e2.initializeWebAssembly = async (t3) => {
        if (p2) return Promise.resolve();
        if (f2) throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        if (d2) throw new Error("previous call to 'initializeWebAssembly()' failed.");
        f2 = true;
        const e3 = t3.initTimeout, r3 = t3.numThreads, i2 = t3.simd, o2 = r3 > 1 && (() => {
          try {
            return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
          } catch (t4) {
            return false;
          }
        })(), a2 = i2 && (() => {
          try {
            return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
          } catch (t4) {
            return false;
          }
        })(), g2 = "string" == typeof t3.wasmPaths ? t3.wasmPaths : void 0, b2 = h2(false, o2), m2 = h2(a2, o2), y2 = "object" == typeof t3.wasmPaths ? t3.wasmPaths[m2] : void 0;
        let _ = false;
        const v2 = [];
        if (e3 > 0 && v2.push(new Promise((t4) => {
          setTimeout(() => {
            _ = true, t4();
          }, e3);
        })), v2.push(new Promise((t4, e4) => {
          const r4 = o2 ? c2 : u2.default, i3 = { locateFile: (t5, e5) => o2 && t5.endsWith(".worker.js") && "undefined" != typeof Blob ? URL.createObjectURL(new Blob([n2(4154)], { type: "text/javascript" })) : t5 === b2 ? null != y2 ? y2 : (null != g2 ? g2 : e5) + m2 : e5 + t5 };
          if (o2) if ("undefined" == typeof Blob) i3.mainScriptUrlOrBlob = s.join("/", "ort-wasm-threaded.js");
          else {
            const t5 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r4.toString()}})();`;
            i3.mainScriptUrlOrBlob = new Blob([t5], { type: "text/javascript" });
          }
          r4(i3).then((e5) => {
            f2 = false, p2 = true, l2 = e5, t4();
          }, (t5) => {
            f2 = false, d2 = true, e4(t5);
          });
        })), await Promise.race(v2), _) throw new Error(`WebAssembly backend initializing failed due to timeout: ${e3}ms`);
      }, e2.getInstance = () => {
        if (p2 && l2) return l2;
        throw new Error("WebAssembly is not initialized yet.");
      }, e2.dispose = () => {
        var t3;
        !p2 || f2 || d2 || (f2 = true, null === (t3 = l2.PThread) || void 0 === t3 || t3.terminateAllThreads(), l2 = void 0, f2 = false, p2 = false, d2 = true);
      };
    }, 9710: (t2, e2, n2) => {
      n2.d(e2, { Z: () => o });
      var r2 = n2(477), i = n2.n(r2);
      function o() {
        return i()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n', "Worker", void 0, void 0);
      }
    }, 477: (t2) => {
      t2.exports = function(t3, e2, n2, r2) {
        var i = self || window;
        try {
          try {
            var o;
            try {
              o = new i.Blob([t3]);
            } catch (e3) {
              (o = new (i.BlobBuilder || i.WebKitBlobBuilder || i.MozBlobBuilder || i.MSBlobBuilder)()).append(t3), o = o.getBlob();
            }
            var a = i.URL || i.webkitURL, s = a.createObjectURL(o), u2 = new i[e2](s, n2);
            return a.revokeObjectURL(s), u2;
          } catch (r3) {
            return new i[e2]("data:application/javascript,".concat(encodeURIComponent(t3)), n2);
          }
        } catch (t4) {
          if (!r2) throw Error("Inline worker is not supported");
          return new i[e2](r2, n2);
        }
      };
    }, 4154: (t2) => {
      t2.exports = '"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n';
    }, 1670: (t2) => {
      t2.exports = __WEBPACK_EXTERNAL_MODULE__1670__;
    }, 7067: () => {
    }, 1296: () => {
    }, 1384: () => {
    }, 3993: () => {
    }, 908: () => {
    }, 6953: () => {
    }, 9925: () => {
    }, 2806: () => {
    }, 6449: () => {
    }, 2850: () => {
    }, 5381: () => {
    }, 5686: (t2, e2, n2) => {
      n2.r(e2), n2.d(e2, { flatbuffers: () => r2 });
      var r2 = {};
      r2.Offset, r2.Table, r2.SIZEOF_SHORT = 2, r2.SIZEOF_INT = 4, r2.FILE_IDENTIFIER_LENGTH = 4, r2.SIZE_PREFIX_LENGTH = 4, r2.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r2.int32 = new Int32Array(2), r2.float32 = new Float32Array(r2.int32.buffer), r2.float64 = new Float64Array(r2.int32.buffer), r2.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r2.Long = function(t3, e3) {
        this.low = 0 | t3, this.high = 0 | e3;
      }, r2.Long.create = function(t3, e3) {
        return 0 == t3 && 0 == e3 ? r2.Long.ZERO : new r2.Long(t3, e3);
      }, r2.Long.prototype.toFloat64 = function() {
        return (this.low >>> 0) + 4294967296 * this.high;
      }, r2.Long.prototype.equals = function(t3) {
        return this.low == t3.low && this.high == t3.high;
      }, r2.Long.ZERO = new r2.Long(0, 0), r2.Builder = function(t3) {
        if (t3) e3 = t3;
        else var e3 = 1024;
        this.bb = r2.ByteBuffer.allocate(e3), this.space = e3, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
      }, r2.Builder.prototype.clear = function() {
        this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
      }, r2.Builder.prototype.forceDefaults = function(t3) {
        this.force_defaults = t3;
      }, r2.Builder.prototype.dataBuffer = function() {
        return this.bb;
      }, r2.Builder.prototype.asUint8Array = function() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
      }, r2.Builder.prototype.prep = function(t3, e3) {
        t3 > this.minalign && (this.minalign = t3);
        for (var n3 = 1 + ~(this.bb.capacity() - this.space + e3) & t3 - 1; this.space < n3 + t3 + e3; ) {
          var i = this.bb.capacity();
          this.bb = r2.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;
        }
        this.pad(n3);
      }, r2.Builder.prototype.pad = function(t3) {
        for (var e3 = 0; e3 < t3; e3++) this.bb.writeInt8(--this.space, 0);
      }, r2.Builder.prototype.writeInt8 = function(t3) {
        this.bb.writeInt8(this.space -= 1, t3);
      }, r2.Builder.prototype.writeInt16 = function(t3) {
        this.bb.writeInt16(this.space -= 2, t3);
      }, r2.Builder.prototype.writeInt32 = function(t3) {
        this.bb.writeInt32(this.space -= 4, t3);
      }, r2.Builder.prototype.writeInt64 = function(t3) {
        this.bb.writeInt64(this.space -= 8, t3);
      }, r2.Builder.prototype.writeFloat32 = function(t3) {
        this.bb.writeFloat32(this.space -= 4, t3);
      }, r2.Builder.prototype.writeFloat64 = function(t3) {
        this.bb.writeFloat64(this.space -= 8, t3);
      }, r2.Builder.prototype.addInt8 = function(t3) {
        this.prep(1, 0), this.writeInt8(t3);
      }, r2.Builder.prototype.addInt16 = function(t3) {
        this.prep(2, 0), this.writeInt16(t3);
      }, r2.Builder.prototype.addInt32 = function(t3) {
        this.prep(4, 0), this.writeInt32(t3);
      }, r2.Builder.prototype.addInt64 = function(t3) {
        this.prep(8, 0), this.writeInt64(t3);
      }, r2.Builder.prototype.addFloat32 = function(t3) {
        this.prep(4, 0), this.writeFloat32(t3);
      }, r2.Builder.prototype.addFloat64 = function(t3) {
        this.prep(8, 0), this.writeFloat64(t3);
      }, r2.Builder.prototype.addFieldInt8 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addInt8(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldInt16 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addInt16(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldInt32 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addInt32(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldInt64 = function(t3, e3, n3) {
        !this.force_defaults && e3.equals(n3) || (this.addInt64(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldFloat32 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addFloat32(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldFloat64 = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addFloat64(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldOffset = function(t3, e3, n3) {
        (this.force_defaults || e3 != n3) && (this.addOffset(e3), this.slot(t3));
      }, r2.Builder.prototype.addFieldStruct = function(t3, e3, n3) {
        e3 != n3 && (this.nested(e3), this.slot(t3));
      }, r2.Builder.prototype.nested = function(t3) {
        if (t3 != this.offset()) throw new Error("FlatBuffers: struct must be serialized inline.");
      }, r2.Builder.prototype.notNested = function() {
        if (this.isNested) throw new Error("FlatBuffers: object serialization must not be nested.");
      }, r2.Builder.prototype.slot = function(t3) {
        this.vtable[t3] = this.offset();
      }, r2.Builder.prototype.offset = function() {
        return this.bb.capacity() - this.space;
      }, r2.Builder.growByteBuffer = function(t3) {
        var e3 = t3.capacity();
        if (3221225472 & e3) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
        var n3 = e3 << 1, i = r2.ByteBuffer.allocate(n3);
        return i.setPosition(n3 - e3), i.bytes().set(t3.bytes(), n3 - e3), i;
      }, r2.Builder.prototype.addOffset = function(t3) {
        this.prep(r2.SIZEOF_INT, 0), this.writeInt32(this.offset() - t3 + r2.SIZEOF_INT);
      }, r2.Builder.prototype.startObject = function(t3) {
        this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t3;
        for (var e3 = 0; e3 < t3; e3++) this.vtable[e3] = 0;
        this.isNested = true, this.object_start = this.offset();
      }, r2.Builder.prototype.endObject = function() {
        if (null == this.vtable || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject");
        this.addInt32(0);
        for (var t3 = this.offset(), e3 = this.vtable_in_use - 1; e3 >= 0 && 0 == this.vtable[e3]; e3--) ;
        for (var n3 = e3 + 1; e3 >= 0; e3--) this.addInt16(0 != this.vtable[e3] ? t3 - this.vtable[e3] : 0);
        this.addInt16(t3 - this.object_start);
        var i = (n3 + 2) * r2.SIZEOF_SHORT;
        this.addInt16(i);
        var o = 0, a = this.space;
        t: for (e3 = 0; e3 < this.vtables.length; e3++) {
          var s = this.bb.capacity() - this.vtables[e3];
          if (i == this.bb.readInt16(s)) {
            for (var u2 = r2.SIZEOF_SHORT; u2 < i; u2 += r2.SIZEOF_SHORT) if (this.bb.readInt16(a + u2) != this.bb.readInt16(s + u2)) continue t;
            o = this.vtables[e3];
            break;
          }
        }
        return o ? (this.space = this.bb.capacity() - t3, this.bb.writeInt32(this.space, o - t3)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t3, this.offset() - t3)), this.isNested = false, t3;
      }, r2.Builder.prototype.finish = function(t3, e3, n3) {
        var i = n3 ? r2.SIZE_PREFIX_LENGTH : 0;
        if (e3) {
          var o = e3;
          if (this.prep(this.minalign, r2.SIZEOF_INT + r2.FILE_IDENTIFIER_LENGTH + i), o.length != r2.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r2.FILE_IDENTIFIER_LENGTH);
          for (var a = r2.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--) this.writeInt8(o.charCodeAt(a));
        }
        this.prep(this.minalign, r2.SIZEOF_INT + i), this.addOffset(t3), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
      }, r2.Builder.prototype.finishSizePrefixed = function(t3, e3) {
        this.finish(t3, e3, true);
      }, r2.Builder.prototype.requiredField = function(t3, e3) {
        var n3 = this.bb.capacity() - t3, r3 = n3 - this.bb.readInt32(n3);
        if (0 == this.bb.readInt16(r3 + e3)) throw new Error("FlatBuffers: field " + e3 + " must be set");
      }, r2.Builder.prototype.startVector = function(t3, e3, n3) {
        this.notNested(), this.vector_num_elems = e3, this.prep(r2.SIZEOF_INT, t3 * e3), this.prep(n3, t3 * e3);
      }, r2.Builder.prototype.endVector = function() {
        return this.writeInt32(this.vector_num_elems), this.offset();
      }, r2.Builder.prototype.createString = function(t3) {
        if (t3 instanceof Uint8Array) var e3 = t3;
        else {
          e3 = [];
          for (var n3 = 0; n3 < t3.length; ) {
            var r3, i = t3.charCodeAt(n3++);
            (r3 = i < 55296 || i >= 56320 ? i : (i << 10) + t3.charCodeAt(n3++) + -56613888) < 128 ? e3.push(r3) : (r3 < 2048 ? e3.push(r3 >> 6 & 31 | 192) : (r3 < 65536 ? e3.push(r3 >> 12 & 15 | 224) : e3.push(r3 >> 18 & 7 | 240, r3 >> 12 & 63 | 128), e3.push(r3 >> 6 & 63 | 128)), e3.push(63 & r3 | 128));
          }
        }
        this.addInt8(0), this.startVector(1, e3.length, 1), this.bb.setPosition(this.space -= e3.length), n3 = 0;
        for (var o = this.space, a = this.bb.bytes(); n3 < e3.length; n3++) a[o++] = e3[n3];
        return this.endVector();
      }, r2.Builder.prototype.createLong = function(t3, e3) {
        return r2.Long.create(t3, e3);
      }, r2.ByteBuffer = function(t3) {
        this.bytes_ = t3, this.position_ = 0;
      }, r2.ByteBuffer.allocate = function(t3) {
        return new r2.ByteBuffer(new Uint8Array(t3));
      }, r2.ByteBuffer.prototype.clear = function() {
        this.position_ = 0;
      }, r2.ByteBuffer.prototype.bytes = function() {
        return this.bytes_;
      }, r2.ByteBuffer.prototype.position = function() {
        return this.position_;
      }, r2.ByteBuffer.prototype.setPosition = function(t3) {
        this.position_ = t3;
      }, r2.ByteBuffer.prototype.capacity = function() {
        return this.bytes_.length;
      }, r2.ByteBuffer.prototype.readInt8 = function(t3) {
        return this.readUint8(t3) << 24 >> 24;
      }, r2.ByteBuffer.prototype.readUint8 = function(t3) {
        return this.bytes_[t3];
      }, r2.ByteBuffer.prototype.readInt16 = function(t3) {
        return this.readUint16(t3) << 16 >> 16;
      }, r2.ByteBuffer.prototype.readUint16 = function(t3) {
        return this.bytes_[t3] | this.bytes_[t3 + 1] << 8;
      }, r2.ByteBuffer.prototype.readInt32 = function(t3) {
        return this.bytes_[t3] | this.bytes_[t3 + 1] << 8 | this.bytes_[t3 + 2] << 16 | this.bytes_[t3 + 3] << 24;
      }, r2.ByteBuffer.prototype.readUint32 = function(t3) {
        return this.readInt32(t3) >>> 0;
      }, r2.ByteBuffer.prototype.readInt64 = function(t3) {
        return new r2.Long(this.readInt32(t3), this.readInt32(t3 + 4));
      }, r2.ByteBuffer.prototype.readUint64 = function(t3) {
        return new r2.Long(this.readUint32(t3), this.readUint32(t3 + 4));
      }, r2.ByteBuffer.prototype.readFloat32 = function(t3) {
        return r2.int32[0] = this.readInt32(t3), r2.float32[0];
      }, r2.ByteBuffer.prototype.readFloat64 = function(t3) {
        return r2.int32[r2.isLittleEndian ? 0 : 1] = this.readInt32(t3), r2.int32[r2.isLittleEndian ? 1 : 0] = this.readInt32(t3 + 4), r2.float64[0];
      }, r2.ByteBuffer.prototype.writeInt8 = function(t3, e3) {
        this.bytes_[t3] = e3;
      }, r2.ByteBuffer.prototype.writeUint8 = function(t3, e3) {
        this.bytes_[t3] = e3;
      }, r2.ByteBuffer.prototype.writeInt16 = function(t3, e3) {
        this.bytes_[t3] = e3, this.bytes_[t3 + 1] = e3 >> 8;
      }, r2.ByteBuffer.prototype.writeUint16 = function(t3, e3) {
        this.bytes_[t3] = e3, this.bytes_[t3 + 1] = e3 >> 8;
      }, r2.ByteBuffer.prototype.writeInt32 = function(t3, e3) {
        this.bytes_[t3] = e3, this.bytes_[t3 + 1] = e3 >> 8, this.bytes_[t3 + 2] = e3 >> 16, this.bytes_[t3 + 3] = e3 >> 24;
      }, r2.ByteBuffer.prototype.writeUint32 = function(t3, e3) {
        this.bytes_[t3] = e3, this.bytes_[t3 + 1] = e3 >> 8, this.bytes_[t3 + 2] = e3 >> 16, this.bytes_[t3 + 3] = e3 >> 24;
      }, r2.ByteBuffer.prototype.writeInt64 = function(t3, e3) {
        this.writeInt32(t3, e3.low), this.writeInt32(t3 + 4, e3.high);
      }, r2.ByteBuffer.prototype.writeUint64 = function(t3, e3) {
        this.writeUint32(t3, e3.low), this.writeUint32(t3 + 4, e3.high);
      }, r2.ByteBuffer.prototype.writeFloat32 = function(t3, e3) {
        r2.float32[0] = e3, this.writeInt32(t3, r2.int32[0]);
      }, r2.ByteBuffer.prototype.writeFloat64 = function(t3, e3) {
        r2.float64[0] = e3, this.writeInt32(t3, r2.int32[r2.isLittleEndian ? 0 : 1]), this.writeInt32(t3 + 4, r2.int32[r2.isLittleEndian ? 1 : 0]);
      }, r2.ByteBuffer.prototype.getBufferIdentifier = function() {
        if (this.bytes_.length < this.position_ + r2.SIZEOF_INT + r2.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
        for (var t3 = "", e3 = 0; e3 < r2.FILE_IDENTIFIER_LENGTH; e3++) t3 += String.fromCharCode(this.readInt8(this.position_ + r2.SIZEOF_INT + e3));
        return t3;
      }, r2.ByteBuffer.prototype.__offset = function(t3, e3) {
        var n3 = t3 - this.readInt32(t3);
        return e3 < this.readInt16(n3) ? this.readInt16(n3 + e3) : 0;
      }, r2.ByteBuffer.prototype.__union = function(t3, e3) {
        return t3.bb_pos = e3 + this.readInt32(e3), t3.bb = this, t3;
      }, r2.ByteBuffer.prototype.__string = function(t3, e3) {
        t3 += this.readInt32(t3);
        var n3 = this.readInt32(t3), i = "", o = 0;
        if (t3 += r2.SIZEOF_INT, e3 === r2.Encoding.UTF8_BYTES) return this.bytes_.subarray(t3, t3 + n3);
        for (; o < n3; ) {
          var a, s = this.readUint8(t3 + o++);
          if (s < 192) a = s;
          else {
            var u2 = this.readUint8(t3 + o++);
            if (s < 224) a = (31 & s) << 6 | 63 & u2;
            else {
              var c2 = this.readUint8(t3 + o++);
              a = s < 240 ? (15 & s) << 12 | (63 & u2) << 6 | 63 & c2 : (7 & s) << 18 | (63 & u2) << 12 | (63 & c2) << 6 | 63 & this.readUint8(t3 + o++);
            }
          }
          a < 65536 ? i += String.fromCharCode(a) : (a -= 65536, i += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));
        }
        return i;
      }, r2.ByteBuffer.prototype.__indirect = function(t3) {
        return t3 + this.readInt32(t3);
      }, r2.ByteBuffer.prototype.__vector = function(t3) {
        return t3 + this.readInt32(t3) + r2.SIZEOF_INT;
      }, r2.ByteBuffer.prototype.__vector_len = function(t3) {
        return this.readInt32(t3 + this.readInt32(t3));
      }, r2.ByteBuffer.prototype.__has_identifier = function(t3) {
        if (t3.length != r2.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r2.FILE_IDENTIFIER_LENGTH);
        for (var e3 = 0; e3 < r2.FILE_IDENTIFIER_LENGTH; e3++) if (t3.charCodeAt(e3) != this.readInt8(this.position_ + r2.SIZEOF_INT + e3)) return false;
        return true;
      }, r2.ByteBuffer.prototype.createLong = function(t3, e3) {
        return r2.Long.create(t3, e3);
      };
    } }, __webpack_module_cache__ = {};
    function __webpack_require__(t2) {
      var e2 = __webpack_module_cache__[t2];
      if (void 0 !== e2) return e2.exports;
      var n2 = __webpack_module_cache__[t2] = { exports: {} };
      return __webpack_modules__[t2].call(n2.exports, n2, n2.exports, __webpack_require__), n2.exports;
    }
    __webpack_require__.n = (t2) => {
      var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
      return __webpack_require__.d(e2, { a: e2 }), e2;
    }, __webpack_require__.d = (t2, e2) => {
      for (var n2 in e2) __webpack_require__.o(e2, n2) && !__webpack_require__.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
    }, __webpack_require__.g = function() {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t2) {
        if ("object" == typeof window) return window;
      }
    }(), __webpack_require__.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), __webpack_require__.r = (t2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    };
    var __webpack_exports__ = __webpack_require__(6018);
    return __webpack_exports__;
  })());
})(ortWeb_min);
var ortWeb_minExports = ortWeb_min.exports;
var models = {};
var common$2 = {};
Object.defineProperty(common$2, "__esModule", { value: true });
var legacy = {};
var _a$1;
Object.defineProperty(legacy, "__esModule", { value: true });
legacy.SileroLegacy = void 0;
const logging_1$2 = logging;
class SileroLegacy {
  constructor(ortInstance, _session, _h, _c, _sr) {
    this.ortInstance = ortInstance;
    this._session = _session;
    this._h = _h;
    this._c = _c;
    this._sr = _sr;
    this.reset_state = () => {
      const zeroes = Array(2 * 64).fill(0);
      this._h = new this.ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
      this._c = new this.ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
    };
    this.process = async (audioFrame) => {
      const t2 = new this.ortInstance.Tensor("float32", audioFrame, [
        1,
        audioFrame.length
      ]);
      const inputs = {
        input: t2,
        h: this._h,
        c: this._c,
        sr: this._sr
      };
      const out = await this._session.run(inputs);
      this._h = out["hn"];
      this._c = out["cn"];
      const [isSpeech] = out["output"]?.data;
      const notSpeech = 1 - isSpeech;
      return { notSpeech, isSpeech };
    };
  }
}
legacy.SileroLegacy = SileroLegacy;
_a$1 = SileroLegacy;
SileroLegacy.new = async (ortInstance, modelFetcher) => {
  logging_1$2.log.debug("initializing vad");
  const modelArrayBuffer = await modelFetcher();
  const _session = await ortInstance.InferenceSession.create(modelArrayBuffer);
  const _sr = new ortInstance.Tensor("int64", [16000n]);
  const zeroes = Array(2 * 64).fill(0);
  const _h = new ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
  const _c = new ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
  logging_1$2.log.debug("vad is initialized");
  const model = new _a$1(ortInstance, _session, _h, _c, _sr);
  return model;
};
var v5 = {};
var _a;
Object.defineProperty(v5, "__esModule", { value: true });
v5.SileroV5 = void 0;
const logging_1$1 = logging;
function getNewState(ortInstance) {
  const zeroes = Array(2 * 128).fill(0);
  return new ortInstance.Tensor("float32", zeroes, [2, 1, 128]);
}
class SileroV5 {
  constructor(_session, _state, _sr, ortInstance) {
    this._session = _session;
    this._state = _state;
    this._sr = _sr;
    this.ortInstance = ortInstance;
    this.reset_state = () => {
      this._state = getNewState(this.ortInstance);
    };
    this.process = async (audioFrame) => {
      const t2 = new this.ortInstance.Tensor("float32", audioFrame, [
        1,
        audioFrame.length
      ]);
      const inputs = {
        input: t2,
        state: this._state,
        sr: this._sr
      };
      const out = await this._session.run(inputs);
      this._state = out["stateN"];
      const [isSpeech] = out["output"]?.data;
      const notSpeech = 1 - isSpeech;
      return { notSpeech, isSpeech };
    };
  }
}
v5.SileroV5 = SileroV5;
_a = SileroV5;
SileroV5.new = async (ortInstance, modelFetcher) => {
  logging_1$1.log.debug("Loading VAD...");
  const modelArrayBuffer = await modelFetcher();
  const _session = await ortInstance.InferenceSession.create(modelArrayBuffer);
  const _sr = new ortInstance.Tensor("int64", [16000n]);
  const _state = getNewState(ortInstance);
  logging_1$1.log.debug("...finished loading VAD");
  return new _a(_session, _state, _sr, ortInstance);
};
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SileroV5 = exports2.SileroLegacy = void 0;
  __exportStar(common$2, exports2);
  var legacy_1 = legacy;
  Object.defineProperty(exports2, "SileroLegacy", { enumerable: true, get: function() {
    return legacy_1.SileroLegacy;
  } });
  var v5_1 = v5;
  Object.defineProperty(exports2, "SileroV5", { enumerable: true, get: function() {
    return v5_1.SileroV5;
  } });
})(models);
var resampler = {};
Object.defineProperty(resampler, "__esModule", { value: true });
resampler.Resampler = void 0;
const logging_1 = logging;
class Resampler {
  constructor(options2) {
    this.options = options2;
    this.process = (audioFrame) => {
      const outputFrames = [];
      for (const sample of audioFrame) {
        this.inputBuffer.push(sample);
        while (this.hasEnoughDataForFrame()) {
          const outputFrame = this.generateOutputFrame();
          outputFrames.push(outputFrame);
        }
      }
      return outputFrames;
    };
    if (options2.nativeSampleRate < 16e3) {
      logging_1.log.error("nativeSampleRate is too low. Should have 16000 = targetSampleRate <= nativeSampleRate");
    }
    this.inputBuffer = [];
  }
  async *stream(audioInput) {
    for (const sample of audioInput) {
      this.inputBuffer.push(sample);
      while (this.hasEnoughDataForFrame()) {
        const outputFrame = this.generateOutputFrame();
        yield outputFrame;
      }
    }
  }
  hasEnoughDataForFrame() {
    return this.inputBuffer.length * this.options.targetSampleRate / this.options.nativeSampleRate >= this.options.targetFrameSize;
  }
  generateOutputFrame() {
    const outputFrame = new Float32Array(this.options.targetFrameSize);
    let outputIndex = 0;
    let inputIndex = 0;
    while (outputIndex < this.options.targetFrameSize) {
      let sum = 0;
      let num = 0;
      while (inputIndex < Math.min(this.inputBuffer.length, (outputIndex + 1) * this.options.nativeSampleRate / this.options.targetSampleRate)) {
        const value = this.inputBuffer[inputIndex];
        if (value !== void 0) {
          sum += value;
          num++;
        }
        inputIndex++;
      }
      outputFrame[outputIndex] = sum / num;
      outputIndex++;
    }
    this.inputBuffer = this.inputBuffer.slice(inputIndex);
    return outputFrame;
  }
}
resampler.Resampler = Resampler;
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  } : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2)) __createBinding(result, mod2, k2);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.NonRealTimeVAD = exports2.defaultNonRealTimeVADOptions = void 0;
  const ortInstance = __importStar(ortWeb_minExports);
  const asset_path_1 = assetPath;
  const default_model_fetcher_1 = defaultModelFetcher$1;
  const frame_processor_1 = frameProcessor;
  const messages_12 = messages;
  const models_1 = models;
  const resampler_1 = resampler;
  exports2.defaultNonRealTimeVADOptions = {
    ...frame_processor_1.defaultLegacyFrameProcessorOptions,
    ortConfig: void 0,
    modelURL: asset_path_1.baseAssetPath + "silero_vad_legacy.onnx",
    modelFetcher: default_model_fetcher_1.defaultModelFetcher
  };
  class NonRealTimeVAD {
    static async new(options2 = {}) {
      const fullOptions = {
        ...exports2.defaultNonRealTimeVADOptions,
        ...options2
      };
      (0, frame_processor_1.validateOptions)(fullOptions);
      if (fullOptions.ortConfig !== void 0) {
        fullOptions.ortConfig(ortInstance);
      }
      const modelFetcher = () => fullOptions.modelFetcher(fullOptions.modelURL);
      const model = await models_1.SileroLegacy.new(ortInstance, modelFetcher);
      const frameProcessor2 = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
        frameSamples: fullOptions.frameSamples,
        positiveSpeechThreshold: fullOptions.positiveSpeechThreshold,
        negativeSpeechThreshold: fullOptions.negativeSpeechThreshold,
        redemptionFrames: fullOptions.redemptionFrames,
        preSpeechPadFrames: fullOptions.preSpeechPadFrames,
        minSpeechFrames: fullOptions.minSpeechFrames,
        submitUserSpeechOnPause: fullOptions.submitUserSpeechOnPause
      });
      frameProcessor2.resume();
      const vad = new this(modelFetcher, ortInstance, fullOptions, frameProcessor2);
      return vad;
    }
    constructor(modelFetcher, ort, options2, frameProcessor2) {
      this.modelFetcher = modelFetcher;
      this.ort = ort;
      this.options = options2;
      this.frameProcessor = frameProcessor2;
    }
    async *run(inputAudio, sampleRate) {
      const resamplerOptions = {
        nativeSampleRate: sampleRate,
        targetSampleRate: 16e3,
        targetFrameSize: this.options.frameSamples
      };
      const resampler2 = new resampler_1.Resampler(resamplerOptions);
      let start = 0;
      let end = 0;
      let frameIndex = 0;
      let messageContainer = [];
      for await (const frame of resampler2.stream(inputAudio)) {
        await this.frameProcessor.process(frame, (event) => {
          messageContainer.push(event);
        });
        for (const event of messageContainer) {
          switch (event.msg) {
            case messages_12.Message.SpeechStart:
              start = frameIndex * this.options.frameSamples / 16;
              break;
            case messages_12.Message.SpeechEnd:
              end = (frameIndex + 1) * this.options.frameSamples / 16;
              yield { audio: event.audio, start, end };
              break;
          }
        }
        frameIndex++;
      }
      const { msg, audio } = this.frameProcessor.endSegment((event) => {
        messageContainer.push(event);
      });
      for (const event of messageContainer) {
        switch (event.msg) {
          case messages_12.Message.SpeechEnd:
            yield {
              audio: event.audio,
              start,
              end: frameIndex * this.options.frameSamples / 16
            };
        }
      }
    }
  }
  exports2.NonRealTimeVAD = NonRealTimeVAD;
})(nonRealTimeVad);
var utils = {};
Object.defineProperty(utils, "__esModule", { value: true });
utils.audioFileToArray = utils.encodeWAV = utils.arrayBufferToBase64 = utils.minFramesForTargetMS = void 0;
function minFramesForTargetMS(targetDuration, frameSamples, sr = 16e3) {
  return Math.ceil(targetDuration * sr / 1e3 / frameSamples);
}
utils.minFramesForTargetMS = minFramesForTargetMS;
function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  const binary = new Array(len);
  for (var i = 0; i < len; i++) {
    const byte = bytes[i];
    if (byte === void 0) {
      break;
    }
    binary[i] = String.fromCharCode(byte);
  }
  return btoa(binary.join(""));
}
utils.arrayBufferToBase64 = arrayBufferToBase64;
function encodeWAV(samples, format = 3, sampleRate = 16e3, numChannels = 1, bitDepth = 32) {
  var bytesPerSample = bitDepth / 8;
  var blockAlign = numChannels * bytesPerSample;
  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
  var view = new DataView(buffer);
  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + samples.length * bytesPerSample, true);
  writeString(view, 8, "WAVE");
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, "data");
  view.setUint32(40, samples.length * bytesPerSample, true);
  if (format === 1) {
    floatTo16BitPCM(view, 44, samples);
  } else {
    writeFloat32(view, 44, samples);
  }
  return buffer;
}
utils.encodeWAV = encodeWAV;
function writeFloat32(output, offset2, input) {
  for (var i = 0; i < input.length; i++, offset2 += 4) {
    output.setFloat32(offset2, input[i], true);
  }
}
function floatTo16BitPCM(output, offset2, input) {
  for (var i = 0; i < input.length; i++, offset2 += 2) {
    var s = Math.max(-1, Math.min(1, input[i]));
    output.setInt16(offset2, s < 0 ? s * 32768 : s * 32767, true);
  }
}
function writeString(view, offset2, string) {
  for (var i = 0; i < string.length; i++) {
    view.setUint8(offset2 + i, string.charCodeAt(i));
  }
}
async function audioFileToArray(audioFileData) {
  const ctx = new OfflineAudioContext(1, 1, 44100);
  const reader = new FileReader();
  let audioBuffer = null;
  await new Promise((res) => {
    reader.addEventListener("loadend", (ev) => {
      const audioData = reader.result;
      ctx.decodeAudioData(audioData, (buffer) => {
        audioBuffer = buffer;
        ctx.startRendering().then((renderedBuffer) => {
          console.log("Rendering completed successfully");
          res();
        }).catch((err) => {
          console.error(`Rendering failed: ${err}`);
        });
      }, (e2) => {
        console.log(`Error with decoding audio data: ${e2}`);
      });
    });
    reader.readAsArrayBuffer(audioFileData);
  });
  if (audioBuffer === null) {
    throw Error("some shit");
  }
  let _audioBuffer = audioBuffer;
  let out = new Float32Array(_audioBuffer.length);
  for (let i = 0; i < _audioBuffer.length; i++) {
    for (let j = 0; j < _audioBuffer.numberOfChannels; j++) {
      out[i] += _audioBuffer.getChannelData(j)[i];
    }
  }
  return { audio: out, sampleRate: _audioBuffer.sampleRate };
}
utils.audioFileToArray = audioFileToArray;
var realTimeVad = {};
(function(exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  } : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2)) __createBinding(result, mod2, k2);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AudioNodeVAD = exports2.MicVAD = exports2.getDefaultRealTimeVADOptions = exports2.ort = exports2.DEFAULT_MODEL = void 0;
  const ortInstance = __importStar(ortWeb_minExports);
  const default_model_fetcher_1 = defaultModelFetcher$1;
  const frame_processor_1 = frameProcessor;
  const logging_12 = logging;
  const messages_12 = messages;
  const models_1 = models;
  const resampler_1 = resampler;
  exports2.DEFAULT_MODEL = "legacy";
  exports2.ort = ortInstance;
  const workletFile = "vad.worklet.bundle.min.js";
  const sileroV5File = "silero_vad_v5.onnx";
  const sileroLegacyFile = "silero_vad_legacy.onnx";
  const getDefaultRealTimeVADOptions = (model) => {
    const frameProcessorOptions = model === "v5" ? frame_processor_1.defaultV5FrameProcessorOptions : frame_processor_1.defaultLegacyFrameProcessorOptions;
    return {
      ...frameProcessorOptions,
      onFrameProcessed: (probabilities, frame) => {
      },
      onVADMisfire: () => {
        logging_12.log.debug("VAD misfire");
      },
      onSpeechStart: () => {
        logging_12.log.debug("Detected speech start");
      },
      onSpeechEnd: () => {
        logging_12.log.debug("Detected speech end");
      },
      onSpeechRealStart: () => {
        logging_12.log.debug("Detected real speech start");
      },
      baseAssetPath: "https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@latest/dist/",
      onnxWASMBasePath: "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/",
      stream: void 0,
      ortConfig: void 0,
      model,
      workletOptions: {}
    };
  };
  exports2.getDefaultRealTimeVADOptions = getDefaultRealTimeVADOptions;
  class MicVAD {
    static async new(options2 = {}) {
      const fullOptions = {
        ...(0, exports2.getDefaultRealTimeVADOptions)(options2.model ?? exports2.DEFAULT_MODEL),
        ...options2
      };
      (0, frame_processor_1.validateOptions)(fullOptions);
      let stream;
      if (fullOptions.stream === void 0)
        stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            ...fullOptions.additionalAudioConstraints,
            channelCount: 1,
            echoCancellation: true,
            autoGainControl: true,
            noiseSuppression: true
          }
        });
      else
        stream = fullOptions.stream;
      const audioContext = new AudioContext();
      const sourceNode = new MediaStreamAudioSourceNode(audioContext, {
        mediaStream: stream
      });
      const audioNodeVAD = await AudioNodeVAD.new(audioContext, fullOptions);
      audioNodeVAD.receive(sourceNode);
      return new MicVAD(fullOptions, audioContext, stream, audioNodeVAD, sourceNode);
    }
    constructor(options2, audioContext, stream, audioNodeVAD, sourceNode, listening = false) {
      this.options = options2;
      this.audioContext = audioContext;
      this.stream = stream;
      this.audioNodeVAD = audioNodeVAD;
      this.sourceNode = sourceNode;
      this.listening = listening;
      this.pause = () => {
        this.audioNodeVAD.pause();
        this.listening = false;
      };
      this.start = () => {
        this.audioNodeVAD.start();
        this.listening = true;
      };
      this.destroy = () => {
        if (this.listening) {
          this.pause();
        }
        if (this.options.stream === void 0) {
          this.stream.getTracks().forEach((track) => track.stop());
        }
        this.sourceNode.disconnect();
        this.audioNodeVAD.destroy();
        this.audioContext.close();
      };
      this.setOptions = (options3) => {
        this.audioNodeVAD.setFrameProcessorOptions(options3);
      };
    }
  }
  exports2.MicVAD = MicVAD;
  class AudioNodeVAD {
    static async new(ctx, options2 = {}) {
      const fullOptions = {
        ...(0, exports2.getDefaultRealTimeVADOptions)(options2.model ?? exports2.DEFAULT_MODEL),
        ...options2
      };
      (0, frame_processor_1.validateOptions)(fullOptions);
      exports2.ort.env.wasm.wasmPaths = fullOptions.onnxWASMBasePath;
      if (fullOptions.ortConfig !== void 0) {
        fullOptions.ortConfig(exports2.ort);
      }
      const modelFile = fullOptions.model === "v5" ? sileroV5File : sileroLegacyFile;
      const modelURL = fullOptions.baseAssetPath + modelFile;
      const modelFactory = fullOptions.model === "v5" ? models_1.SileroV5.new : models_1.SileroLegacy.new;
      let model;
      try {
        model = await modelFactory(exports2.ort, () => (0, default_model_fetcher_1.defaultModelFetcher)(modelURL));
      } catch (e2) {
        console.error(`Encountered an error while loading model file ${modelURL}`);
        throw e2;
      }
      const frameProcessor2 = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
        frameSamples: fullOptions.frameSamples,
        positiveSpeechThreshold: fullOptions.positiveSpeechThreshold,
        negativeSpeechThreshold: fullOptions.negativeSpeechThreshold,
        redemptionFrames: fullOptions.redemptionFrames,
        preSpeechPadFrames: fullOptions.preSpeechPadFrames,
        minSpeechFrames: fullOptions.minSpeechFrames,
        submitUserSpeechOnPause: fullOptions.submitUserSpeechOnPause
      });
      const audioNodeVAD = new AudioNodeVAD(ctx, fullOptions, frameProcessor2);
      await audioNodeVAD.setupAudioNode();
      return audioNodeVAD;
    }
    constructor(ctx, options2, frameProcessor2) {
      this.ctx = ctx;
      this.options = options2;
      this.bufferIndex = 0;
      this.pause = () => {
        this.frameProcessor.pause(this.handleFrameProcessorEvent);
      };
      this.start = () => {
        this.frameProcessor.resume();
      };
      this.receive = (node2) => {
        node2.connect(this.audioNode);
      };
      this.processFrame = async (frame) => {
        await this.frameProcessor.process(frame, this.handleFrameProcessorEvent);
      };
      this.handleFrameProcessorEvent = (ev) => {
        switch (ev.msg) {
          case messages_12.Message.FrameProcessed:
            this.options.onFrameProcessed(ev.probs, ev.frame);
            break;
          case messages_12.Message.SpeechStart:
            this.options.onSpeechStart();
            break;
          case messages_12.Message.SpeechRealStart:
            this.options.onSpeechRealStart();
            break;
          case messages_12.Message.VADMisfire:
            this.options.onVADMisfire();
            break;
          case messages_12.Message.SpeechEnd:
            this.options.onSpeechEnd(ev.audio);
            break;
        }
      };
      this.destroy = () => {
        if (this.audioNode instanceof AudioWorkletNode) {
          this.audioNode.port.postMessage({
            message: messages_12.Message.SpeechStop
          });
        }
        this.audioNode.disconnect();
        this.gainNode?.disconnect();
      };
      this.setFrameProcessorOptions = (options3) => {
        this.frameProcessor.options = {
          ...this.frameProcessor.options,
          ...options3
        };
      };
      this.frameProcessor = frameProcessor2;
    }
    async setupAudioNode() {
      const hasAudioWorklet = "audioWorklet" in this.ctx && typeof AudioWorkletNode === "function";
      if (hasAudioWorklet) {
        try {
          const workletURL = this.options.baseAssetPath + workletFile;
          await this.ctx.audioWorklet.addModule(workletURL);
          const workletOptions = this.options.workletOptions ?? {};
          workletOptions.processorOptions = {
            ...workletOptions.processorOptions ?? {},
            frameSamples: this.options.frameSamples
          };
          this.audioNode = new AudioWorkletNode(this.ctx, "vad-helper-worklet", workletOptions);
          this.audioNode.port.onmessage = async (ev) => {
            switch (ev.data?.message) {
              case messages_12.Message.AudioFrame:
                let buffer = ev.data.data;
                if (!(buffer instanceof ArrayBuffer)) {
                  buffer = new ArrayBuffer(ev.data.data.byteLength);
                  new Uint8Array(buffer).set(new Uint8Array(ev.data.data));
                }
                const frame = new Float32Array(buffer);
                await this.processFrame(frame);
                break;
            }
          };
          return;
        } catch (e2) {
          console.log("AudioWorklet setup failed, falling back to ScriptProcessor", e2);
        }
      }
      this.resampler = new resampler_1.Resampler({
        nativeSampleRate: this.ctx.sampleRate,
        targetSampleRate: 16e3,
        targetFrameSize: this.options.frameSamples ?? 480
      });
      const bufferSize = 4096;
      this.audioNode = this.ctx.createScriptProcessor(bufferSize, 1, 1);
      this.gainNode = this.ctx.createGain();
      this.gainNode.gain.value = 0;
      let processingAudio = false;
      this.audioNode.onaudioprocess = async (e2) => {
        if (processingAudio)
          return;
        processingAudio = true;
        try {
          const input = e2.inputBuffer.getChannelData(0);
          const output = e2.outputBuffer.getChannelData(0);
          output.fill(0);
          if (this.resampler) {
            const frames = this.resampler.process(input);
            for (const frame of frames) {
              await this.processFrame(frame);
            }
          }
        } catch (error2) {
          console.error("Error processing audio:", error2);
        } finally {
          processingAudio = false;
        }
      };
      this.audioNode.connect(this.gainNode);
      this.gainNode.connect(this.ctx.destination);
    }
  }
  exports2.AudioNodeVAD = AudioNodeVAD;
})(realTimeVad);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getDefaultRealTimeVADOptions = exports2.MicVAD = exports2.DEFAULT_MODEL = exports2.AudioNodeVAD = exports2.utils = exports2.NonRealTimeVAD = exports2.Message = exports2.FrameProcessor = exports2.defaultModelFetcher = exports2.baseAssetPath = void 0;
  var asset_path_1 = assetPath;
  Object.defineProperty(exports2, "baseAssetPath", { enumerable: true, get: function() {
    return asset_path_1.baseAssetPath;
  } });
  var default_model_fetcher_1 = defaultModelFetcher$1;
  Object.defineProperty(exports2, "defaultModelFetcher", { enumerable: true, get: function() {
    return default_model_fetcher_1.defaultModelFetcher;
  } });
  var frame_processor_1 = frameProcessor;
  Object.defineProperty(exports2, "FrameProcessor", { enumerable: true, get: function() {
    return frame_processor_1.FrameProcessor;
  } });
  var messages_12 = messages;
  Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
    return messages_12.Message;
  } });
  var non_real_time_vad_1 = nonRealTimeVad;
  Object.defineProperty(exports2, "NonRealTimeVAD", { enumerable: true, get: function() {
    return non_real_time_vad_1.NonRealTimeVAD;
  } });
  const utils_1 = utils;
  exports2.utils = {
    audioFileToArray: utils_1.audioFileToArray,
    minFramesForTargetMS: utils_1.minFramesForTargetMS,
    arrayBufferToBase64: utils_1.arrayBufferToBase64,
    encodeWAV: utils_1.encodeWAV
  };
  var real_time_vad_1 = realTimeVad;
  Object.defineProperty(exports2, "AudioNodeVAD", { enumerable: true, get: function() {
    return real_time_vad_1.AudioNodeVAD;
  } });
  Object.defineProperty(exports2, "DEFAULT_MODEL", { enumerable: true, get: function() {
    return real_time_vad_1.DEFAULT_MODEL;
  } });
  Object.defineProperty(exports2, "MicVAD", { enumerable: true, get: function() {
    return real_time_vad_1.MicVAD;
  } });
  Object.defineProperty(exports2, "getDefaultRealTimeVADOptions", { enumerable: true, get: function() {
    return real_time_vad_1.getDefaultRealTimeVADOptions;
  } });
})(dist);
class TaskQueue {
  queue = [];
  running = false;
  taskInterval;
  pendingComplete = false;
  activeTasks = /* @__PURE__ */ new Set();
  constructor(taskIntervalMs = 3e3) {
    this.taskInterval = taskIntervalMs;
  }
  addTask(task) {
    this.queue.push(task);
    this.runNextTask();
  }
  clearQueue() {
    this.queue = [];
    this.activeTasks.clear();
    this.running = false;
  }
  async runNextTask() {
    if (this.running || this.queue.length === 0) {
      if (this.queue.length === 0 && this.activeTasks.size === 0 && this.pendingComplete) {
        this.pendingComplete = false;
        await new Promise((resolve2) => setTimeout(resolve2, this.taskInterval));
      }
      return;
    }
    this.running = true;
    const task = this.queue.shift();
    if (task) {
      const taskPromise = task();
      this.activeTasks.add(taskPromise);
      try {
        await taskPromise;
        await new Promise((resolve2) => setTimeout(resolve2, this.taskInterval));
      } catch (error2) {
        console.error("Task Queue Error", error2);
      } finally {
        this.activeTasks.delete(taskPromise);
        this.running = false;
        this.runNextTask();
      }
    }
  }
  hasTask() {
    return this.queue.length > 0 || this.activeTasks.size > 0 || this.running;
  }
  waitForCompletion() {
    this.pendingComplete = true;
    return new Promise((resolve2) => {
      const check = () => {
        if (!this.hasTask()) {
          resolve2();
        } else {
          setTimeout(check, 100);
        }
      };
      check();
    });
  }
}
const audioTaskQueue = new TaskQueue(20);
const ScreenCaptureContext = reactExports.createContext(void 0);
function ScreenCaptureProvider({ children }) {
  const { t: t2 } = useTranslation();
  const [stream, setStream] = reactExports.useState(null);
  const [isStreaming, setIsStreaming] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState("");
  const startCapture = async () => {
    try {
      let mediaStream;
      if (window.electron) {
        const sourceId = await window.electron.ipcRenderer.invoke("get-screen-capture");
        const displayMediaOptions = {
          video: {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            mandatory: {
              chromeMediaSource: "desktop",
              chromeMediaSourceId: sourceId,
              minWidth: 1280,
              maxWidth: 1280,
              minHeight: 720,
              maxHeight: 720
            }
          },
          audio: false
        };
        mediaStream = await navigator.mediaDevices.getUserMedia(displayMediaOptions);
      } else {
        const displayMediaOptions = {
          video: true,
          audio: false
        };
        mediaStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
      }
      setStream(mediaStream);
      setIsStreaming(true);
      setError("");
    } catch (err) {
      setError(t2("error.failedStartScreenCapture"));
      toaster.create({
        title: `${t2("error.failedStartScreenCapture")}: ${err}`,
        type: "error",
        duration: 2e3
      });
      console.error(err);
    }
  };
  const stopCapture = () => {
    if (stream) {
      stream.getTracks().forEach((track) => track.stop());
      setStream(null);
      setIsStreaming(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScreenCaptureContext.Provider,
    {
      value: {
        stream,
        isStreaming,
        error: error2,
        startCapture,
        stopCapture
      },
      children
    }
  );
}
const useScreenCaptureContext = () => {
  const context = reactExports.useContext(ScreenCaptureContext);
  if (context === void 0) {
    throw new Error("useScreenCaptureContext must be used within a ScreenCaptureProvider");
  }
  return context;
};
function useMediaCapture() {
  const { t: t2 } = useTranslation();
  const { stream: cameraStream } = useCamera();
  const { stream: screenStream } = useScreenCaptureContext();
  const getCompressionQuality = reactExports.useCallback(() => {
    const storedQuality = localStorage.getItem(IMAGE_COMPRESSION_QUALITY_KEY);
    if (storedQuality) {
      const quality = parseFloat(storedQuality);
      if (!Number.isNaN(quality) && quality >= 0.1 && quality <= 1) {
        return quality;
      }
    }
    return DEFAULT_IMAGE_COMPRESSION_QUALITY;
  }, []);
  const getImageMaxWidth = reactExports.useCallback(() => {
    const storedMaxWidth = localStorage.getItem(IMAGE_MAX_WIDTH_KEY);
    if (storedMaxWidth) {
      const maxWidth = parseInt(storedMaxWidth, 10);
      if (!Number.isNaN(maxWidth) && maxWidth >= 0) {
        return maxWidth;
      }
    }
    return DEFAULT_IMAGE_MAX_WIDTH;
  }, []);
  const captureFrame = reactExports.useCallback(async (stream, source) => {
    if (!stream) {
      console.warn(`No ${source} stream available`);
      return null;
    }
    const videoTrack = stream.getVideoTracks()[0];
    if (!videoTrack) {
      console.warn(`No video track in ${source} stream`);
      return null;
    }
    const imageCapture = new ImageCapture(videoTrack);
    try {
      const bitmap = await imageCapture.grabFrame();
      const canvas2 = document.createElement("canvas");
      let { width, height } = bitmap;
      const maxWidth = getImageMaxWidth();
      if (maxWidth > 0 && width > maxWidth) {
        height = maxWidth / width * height;
        width = maxWidth;
      }
      canvas2.width = width;
      canvas2.height = height;
      const ctx = canvas2.getContext("2d");
      if (!ctx) {
        console.error("Failed to get canvas context");
        return null;
      }
      ctx.drawImage(bitmap, 0, 0, width, height);
      const quality = getCompressionQuality();
      return canvas2.toDataURL("image/jpeg", quality);
    } catch (error2) {
      console.error(`Error capturing ${source} frame:`, error2);
      toaster.create({
        title: `${t2("error.failedCapture", { source })}: ${error2}`,
        type: "error",
        duration: 2e3
      });
      return null;
    }
  }, [t2, getCompressionQuality, getImageMaxWidth]);
  const captureAllMedia = reactExports.useCallback(async () => {
    const images = [];
    if (cameraStream) {
      const cameraFrame = await captureFrame(cameraStream, "camera");
      if (cameraFrame) {
        images.push({
          source: "camera",
          data: cameraFrame,
          mime_type: "image/jpeg"
        });
      }
    }
    if (screenStream) {
      const screenFrame = await captureFrame(screenStream, "screen");
      if (screenFrame) {
        images.push({
          source: "screen",
          data: screenFrame,
          mime_type: "image/jpeg"
        });
      }
    }
    console.log("images: ", images);
    return images;
  }, [cameraStream, screenStream, captureFrame]);
  return {
    captureAllMedia
  };
}
const ManualSendContext = reactExports.createContext(null);
const MANUAL_SEND_ENABLED = true;
function ManualSendProvider({ children }) {
  const [segments, setSegments] = reactExports.useState([]);
  const [pendingImages, setPendingImages] = reactExports.useState(void 0);
  const [sendLocked, setSendLocked] = reactExports.useState(false);
  const [pendingNoticeToken, setPendingNoticeToken] = reactExports.useState(0);
  const awaitersRef = reactExports.useRef([]);
  const hasPendingUtterance = segments.length > 0;
  const aggregatedText = segments.filter((segment) => segment.status === "ready" && segment.text).sort((a, b2) => a.createdAt - b2.createdAt).map((segment) => segment.text.trim()).filter((text) => text.length > 0).join("\n");
  const registerPendingUtterance = reactExports.useCallback((segmentId, images) => {
    if (sendLocked) {
      console.debug("[manual-send] register skipped because manual send disabled or locked", { segmentId });
      return;
    }
    const imageCount = images?.length ?? 0;
    setSegments((prev2) => {
      const next2 = [
        ...prev2,
        {
          id: segmentId,
          text: "",
          status: "pending",
          createdAt: Date.now()
        }
      ];
      console.debug("[manual-send] registered new segment", {
        segmentId,
        pendingCount: next2.length,
        imageCount
      });
      return next2;
    });
    setPendingImages(images);
    setPendingNoticeToken(Date.now());
  }, [sendLocked]);
  const completePendingUtterance = reactExports.useCallback((segmentId, text) => {
    if (!segmentId) return;
    setSegments((prev2) => prev2.map((segment) => segment.id === segmentId ? {
      ...segment,
      status: "ready",
      text
    } : segment));
    console.debug("[manual-send] transcription completed for segment", {
      segmentId,
      preview: text?.slice(0, 40) ?? ""
    });
  }, []);
  const clearPendingUtterance = reactExports.useCallback(() => {
    if (segments.length > 0) {
      console.debug("[manual-send] clearing pending segments", { count: segments.length });
    }
    setSegments([]);
    setPendingImages(void 0);
    if (awaitersRef.current.length) {
      awaitersRef.current.forEach((resolve2) => resolve2());
      awaitersRef.current = [];
    }
  }, [segments.length]);
  const awaitSegmentsReady = reactExports.useCallback(() => {
    if (!segments.length || segments.every((segment) => segment.status === "ready")) {
      return Promise.resolve();
    }
    console.debug("[manual-send] waiting for segments to finish transcription", {
      pendingCount: segments.length
    });
    return new Promise((resolve2) => {
      awaitersRef.current.push(resolve2);
    });
  }, [segments]);
  const lockUntilNextMic = reactExports.useCallback(() => {
    setSendLocked(true);
    clearPendingUtterance();
  }, [clearPendingUtterance]);
  const resetForNextMic = reactExports.useCallback(() => {
    setSendLocked(false);
    clearPendingUtterance();
  }, [clearPendingUtterance]);
  const canSendNow = hasPendingUtterance && !sendLocked;
  reactExports.useEffect(() => {
    if (hasPendingUtterance && segments.every((segment) => segment.status === "ready") && awaitersRef.current.length > 0) {
      console.debug("[manual-send] all pending segments completed", { count: segments.length });
      awaitersRef.current.forEach((resolve2) => resolve2());
      awaitersRef.current = [];
    }
  }, [segments, hasPendingUtterance]);
  const value = reactExports.useMemo(() => ({
    manualSendEnabled: MANUAL_SEND_ENABLED,
    hasPendingUtterance,
    canSendNow,
    pendingImages,
    aggregatedText,
    pendingNoticeToken,
    registerPendingUtterance,
    completePendingUtterance,
    awaitSegmentsReady,
    clearPendingUtterance,
    lockUntilNextMic,
    resetForNextMic
  }), [
    hasPendingUtterance,
    pendingImages,
    registerPendingUtterance,
    completePendingUtterance,
    awaitSegmentsReady,
    clearPendingUtterance,
    lockUntilNextMic,
    resetForNextMic,
    sendLocked,
    aggregatedText,
    pendingNoticeToken,
    canSendNow
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ManualSendContext.Provider, { value, children });
}
function useManualSend() {
  const context = reactExports.useContext(ManualSendContext);
  if (!context) {
    throw new Error("useManualSend must be used within a ManualSendProvider");
  }
  return context;
}
const generateSegmentId = () => {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
};
function useSendAudio() {
  const { sendMessage } = useWebSocket();
  const { captureAllMedia } = useMediaCapture();
  const { manualSendEnabled, registerPendingUtterance } = useManualSend();
  const sendAudioPartition = reactExports.useCallback(
    async (audio) => {
      const chunkSize = 4096;
      const images = await captureAllMedia();
      if (manualSendEnabled) {
        const segmentId = generateSegmentId();
        console.debug("[manual-send] start streaming segment", {
          segmentId,
          samples: audio.length
        });
        registerPendingUtterance(
          segmentId,
          images && images.length > 0 ? images : void 0
        );
        let chunkCount = 0;
        for (let index = 0; index < audio.length; index += chunkSize) {
          const endIndex = Math.min(index + chunkSize, audio.length);
          const chunk = audio.slice(index, endIndex);
          chunkCount += 1;
          sendMessage({
            type: "manual-segment-chunk",
            segment_id: segmentId,
            audio: Array.from(chunk)
          });
        }
        sendMessage({ type: "manual-segment-end", segment_id: segmentId });
        console.debug("[manual-send] finished streaming segment", {
          segmentId,
          chunkCount,
          images: images?.length ?? 0
        });
        return;
      }
      for (let index = 0; index < audio.length; index += chunkSize) {
        const endIndex = Math.min(index + chunkSize, audio.length);
        const chunk = audio.slice(index, endIndex);
        sendMessage({
          type: "mic-audio-data",
          audio: Array.from(chunk)
        });
      }
      sendMessage({ type: "mic-audio-end", images });
    },
    [sendMessage, captureAllMedia, manualSendEnabled, registerPendingUtterance]
  );
  return {
    sendAudioPartition
  };
}
var AiStateEnum = /* @__PURE__ */ ((AiStateEnum2) => {
  AiStateEnum2["IDLE"] = "idle";
  AiStateEnum2["THINKING_SPEAKING"] = "thinking-speaking";
  AiStateEnum2["INTERRUPTED"] = "interrupted";
  AiStateEnum2["LOADING"] = "loading";
  AiStateEnum2["LISTENING"] = "listening";
  AiStateEnum2["WAITING"] = "waiting";
  return AiStateEnum2;
})(AiStateEnum || {});
const initialState = "loading";
const AiStateContext = reactExports.createContext(null);
function AiStateProvider({ children }) {
  const [aiState2, setAiStateInternal] = reactExports.useState(initialState);
  const [backendSynthComplete, setBackendSynthComplete] = reactExports.useState(false);
  const timerRef = reactExports.useRef(null);
  const setAiState = reactExports.useCallback((newState) => {
    const nextState = typeof newState === "function" ? newState(aiState2) : newState;
    if (nextState === "waiting") {
      if (aiState2 !== "thinking-speaking") {
        setAiStateInternal(nextState);
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
        timerRef.current = setTimeout(() => {
          setAiStateInternal(
            "idle"
            /* IDLE */
          );
          timerRef.current = null;
        }, 2e3);
      }
    } else {
      setAiStateInternal(nextState);
      if (timerRef.current) {
        clearTimeout(timerRef.current);
        timerRef.current = null;
      }
    }
  }, [aiState2]);
  const stateChecks = reactExports.useMemo(
    () => ({
      isIdle: aiState2 === "idle",
      isThinkingSpeaking: aiState2 === "thinking-speaking",
      isInterrupted: aiState2 === "interrupted",
      isLoading: aiState2 === "loading",
      isListening: aiState2 === "listening",
      isWaiting: aiState2 === "waiting"
      /* WAITING */
    }),
    [aiState2]
  );
  const resetState = reactExports.useCallback(() => {
    setAiState(
      "idle"
      /* IDLE */
    );
  }, [setAiState]);
  reactExports.useEffect(() => () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      aiState: aiState2,
      setAiState,
      backendSynthComplete,
      setBackendSynthComplete,
      ...stateChecks,
      resetState
    }),
    [aiState2, setAiState, backendSynthComplete, stateChecks, resetState]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AiStateContext.Provider, { value: contextValue, children });
}
function useAiState() {
  const context = reactExports.useContext(AiStateContext);
  if (!context) {
    throw new Error("useAiState must be used within a AiStateProvider");
  }
  return context;
}
const DEFAULT_VAD_SETTINGS = {
  positiveSpeechThreshold: 50,
  negativeSpeechThreshold: 35,
  redemptionFrames: 35
};
const DEFAULT_VAD_STATE = {
  micOn: false,
  autoStopMic: false,
  autoStartMicOn: false,
  autoStartMicOnConvEnd: false
};
const VADContext = reactExports.createContext(null);
function VADProvider({ children }) {
  const { t: t2 } = useTranslation();
  const vadRef = reactExports.useRef(null);
  const previousTriggeredProbabilityRef = reactExports.useRef(0);
  const previousAiStateRef = reactExports.useRef("idle");
  const [micOn, setMicOn] = useLocalStorage("micOn", DEFAULT_VAD_STATE.micOn);
  const autoStopMicRef = reactExports.useRef(true);
  const [autoStopMic, setAutoStopMicState] = useLocalStorage(
    "autoStopMic",
    DEFAULT_VAD_STATE.autoStopMic
  );
  const [settings2, setSettings] = useLocalStorage(
    "vadSettings",
    DEFAULT_VAD_SETTINGS
  );
  const [autoStartMicOn, setAutoStartMicOnState] = useLocalStorage(
    "autoStartMicOn",
    DEFAULT_VAD_STATE.autoStartMicOn
  );
  const autoStartMicRef = reactExports.useRef(false);
  const [autoStartMicOnConvEnd, setAutoStartMicOnConvEndState] = useLocalStorage(
    "autoStartMicOnConvEnd",
    DEFAULT_VAD_STATE.autoStartMicOnConvEnd
  );
  const autoStartMicOnConvEndRef = reactExports.useRef(false);
  const [, forceUpdate] = reactExports.useReducer((x2) => x2 + 1, 0);
  const { interrupt } = useInterrupt();
  const { sendAudioPartition } = useSendAudio();
  const { setSubtitleText } = reactExports.useContext(SubtitleContext);
  const { aiState: aiState2, setAiState } = reactExports.useContext(AiStateContext);
  const { resetForNextMic } = useManualSend();
  const interruptRef = reactExports.useRef(interrupt);
  const sendAudioPartitionRef = reactExports.useRef(sendAudioPartition);
  const aiStateRef = reactExports.useRef(aiState2);
  const setSubtitleTextRef = reactExports.useRef(setSubtitleText);
  const setAiStateRef = reactExports.useRef(setAiState);
  const isProcessingRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    aiStateRef.current = aiState2;
  }, [aiState2]);
  reactExports.useEffect(() => {
    interruptRef.current = interrupt;
  }, [interrupt]);
  reactExports.useEffect(() => {
    sendAudioPartitionRef.current = sendAudioPartition;
  }, [sendAudioPartition]);
  reactExports.useEffect(() => {
    setSubtitleTextRef.current = setSubtitleText;
  }, [setSubtitleText]);
  reactExports.useEffect(() => {
    setAiStateRef.current = setAiState;
  }, [setAiState]);
  reactExports.useEffect(() => {
    autoStopMicRef.current = autoStopMic;
  }, []);
  reactExports.useEffect(() => {
    autoStartMicRef.current = autoStartMicOn;
  }, []);
  reactExports.useEffect(() => {
    autoStartMicOnConvEndRef.current = autoStartMicOnConvEnd;
  }, []);
  const setPreviousTriggeredProbability = reactExports.useCallback((value) => {
    previousTriggeredProbabilityRef.current = value;
    forceUpdate();
  }, []);
  const handleSpeechStart = reactExports.useCallback(() => {
    console.log("Speech started - saving current state");
    previousAiStateRef.current = aiStateRef.current;
    isProcessingRef.current = true;
  }, []);
  const handleSpeechRealStart = reactExports.useCallback(() => {
    console.log("Real speech confirmed - checking if need to interrupt");
    if (previousAiStateRef.current === "thinking-speaking") {
      console.log("Interrupting AI speech due to user speaking");
      interruptRef.current();
    }
    setAiStateRef.current("listening");
  }, []);
  const handleFrameProcessed = reactExports.useCallback((probs) => {
    if (probs.isSpeech > previousTriggeredProbabilityRef.current) {
      setPreviousTriggeredProbability(probs.isSpeech);
    }
  }, []);
  const handleSpeechEnd = reactExports.useCallback((audio) => {
    if (!isProcessingRef.current) return;
    console.log("Speech ended");
    audioTaskQueue.clearQueue();
    if (autoStopMicRef.current) {
      stopMic();
    } else {
      console.log("Auto stop mic is OFF, keeping mic active");
    }
    setPreviousTriggeredProbability(0);
    sendAudioPartitionRef.current(audio);
    isProcessingRef.current = false;
    setAiStateRef.current("thinking-speaking");
  }, []);
  const handleVADMisfire = reactExports.useCallback(() => {
    if (!isProcessingRef.current) return;
    console.log("VAD misfire detected");
    setPreviousTriggeredProbability(0);
    isProcessingRef.current = false;
    setAiStateRef.current(previousAiStateRef.current);
    setSubtitleTextRef.current(t2("error.vadMisfire"));
  }, [t2]);
  const updateSettings = reactExports.useCallback((newSettings) => {
    setSettings(newSettings);
    if (vadRef.current) {
      stopMic();
      setTimeout(() => {
        startMic();
      }, 100);
    }
  }, []);
  const initVAD = async () => {
    const newVAD = await dist.MicVAD.new({
      model: "v5",
      preSpeechPadFrames: 20,
      positiveSpeechThreshold: settings2.positiveSpeechThreshold / 100,
      negativeSpeechThreshold: settings2.negativeSpeechThreshold / 100,
      redemptionFrames: settings2.redemptionFrames,
      baseAssetPath: withBasePath("/libs/") || "/libs/",
      onnxWASMBasePath: withBasePath("/libs/") || "/libs/",
      onSpeechStart: handleSpeechStart,
      onSpeechRealStart: handleSpeechRealStart,
      onFrameProcessed: handleFrameProcessed,
      onSpeechEnd: handleSpeechEnd,
      onVADMisfire: handleVADMisfire
    });
    vadRef.current = newVAD;
    newVAD.start();
  };
  const startMic = reactExports.useCallback(async () => {
    resetForNextMic();
    try {
      if (!vadRef.current) {
        console.log("Initializing VAD");
        await initVAD();
      } else {
        console.log("Starting VAD");
        vadRef.current.start();
      }
      setMicOn(true);
    } catch (error2) {
      console.error("Failed to start VAD:", error2);
      toaster.create({
        title: `${t2("error.failedStartVAD")}: ${error2}`,
        type: "error",
        duration: 2e3
      });
    }
  }, [t2, resetForNextMic]);
  const stopMic = reactExports.useCallback(() => {
    console.log("Stopping VAD");
    if (vadRef.current) {
      vadRef.current.pause();
      vadRef.current.destroy();
      vadRef.current = null;
      console.log("VAD stopped and destroyed successfully");
      setPreviousTriggeredProbability(0);
    } else {
      console.log("VAD instance not found");
    }
    setMicOn(false);
    isProcessingRef.current = false;
  }, []);
  const setAutoStopMic = reactExports.useCallback((value) => {
    autoStopMicRef.current = value;
    setAutoStopMicState(value);
    forceUpdate();
  }, []);
  const setAutoStartMicOn = reactExports.useCallback((value) => {
    autoStartMicRef.current = value;
    setAutoStartMicOnState(value);
    forceUpdate();
  }, []);
  const setAutoStartMicOnConvEnd = reactExports.useCallback((value) => {
    autoStartMicOnConvEndRef.current = value;
    setAutoStartMicOnConvEndState(value);
    forceUpdate();
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      autoStopMic: autoStopMicRef.current,
      micOn,
      setMicOn,
      setAutoStopMic,
      startMic,
      stopMic,
      previousTriggeredProbability: previousTriggeredProbabilityRef.current,
      setPreviousTriggeredProbability,
      settings: settings2,
      updateSettings,
      autoStartMicOn: autoStartMicRef.current,
      setAutoStartMicOn,
      autoStartMicOnConvEnd: autoStartMicOnConvEndRef.current,
      setAutoStartMicOnConvEnd
    }),
    [
      micOn,
      startMic,
      stopMic,
      settings2,
      updateSettings
    ]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VADContext.Provider, { value: contextValue, children });
}
function useVAD() {
  const context = reactExports.useContext(VADContext);
  if (!context) {
    throw new Error("useVAD must be used within a VADProvider");
  }
  return context;
}
function useMicToggle() {
  const { startMic, stopMic, micOn } = useVAD();
  const { aiState: aiState2, setAiState } = useAiState();
  const handleMicToggle = async () => {
    if (micOn) {
      stopMic();
      if (aiState2 === "listening") {
        setAiState("idle");
      }
    } else {
      await startMic();
    }
  };
  return {
    handleMicToggle,
    micOn
  };
}
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener3) => listener3(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState2;
  const subscribe2 = (listener3) => {
    listeners.add(listener3);
    return () => listeners.delete(listener3);
  };
  const api = { setState, getState, getInitialState, subscribe: subscribe2 };
  const initialState2 = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
const identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice2 = React.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  React.useDebugValue(slice2);
  return slice2;
}
const createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createState ? createImpl(createState) : createImpl;
const useForceIgnoreMouseStore = create((set2) => ({
  forceIgnoreMouse: false,
  setForceIgnoreMouse: (forceIgnore) => set2({ forceIgnoreMouse: forceIgnore })
}));
function useForceIgnoreMouse() {
  const { forceIgnoreMouse, setForceIgnoreMouse } = useForceIgnoreMouseStore();
  return {
    forceIgnoreMouse,
    setForceIgnoreMouse
  };
}
const ModeContext = reactExports.createContext(void 0);
const ModeProvider = ({ children }) => {
  const [mode, setModeState] = reactExports.useState("window");
  const isElectron2 = window.api !== void 0;
  const setMode = (newMode) => {
    if (newMode === "pet" && !isElectron2) {
      toaster.create({
        title: "Pet mode unavailable",
        description: "Pet mode is only available in the desktop application",
        type: "info",
        duration: 2e3
      });
      return;
    }
    if (isElectron2 && window.api) {
      window.api.setMode(newMode);
    } else {
      setModeState(newMode);
    }
  };
  reactExports.useEffect(() => {
    if (isElectron2 && window.electron) {
      const handlePreModeChange = (_event, newMode) => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            window.electron?.ipcRenderer.send("renderer-ready-for-mode-change", newMode);
          });
        });
      };
      const handleModeChanged = (_event, newMode) => {
        setModeState(newMode);
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            window.electron?.ipcRenderer.send("mode-change-rendered");
          });
        });
      };
      window.electron.ipcRenderer.on("pre-mode-changed", handlePreModeChange);
      window.electron.ipcRenderer.on("mode-changed", handleModeChanged);
      return () => {
        if (window.electron) {
          window.electron.ipcRenderer.removeListener("pre-mode-changed", handlePreModeChange);
          window.electron.ipcRenderer.removeListener("mode-changed", handleModeChanged);
        }
      };
    }
    return void 0;
  }, [isElectron2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ModeContext.Provider, { value: { mode, setMode, isElectron: isElectron2 }, children });
};
const useMode = () => {
  const context = reactExports.useContext(ModeContext);
  if (context === void 0) {
    throw new Error("useMode must be used within a ModeProvider");
  }
  return context;
};
function useIpcHandlers() {
  const { handleMicToggle } = useMicToggle();
  const { interrupt } = useInterrupt();
  const { modelInfo, setModelInfo } = useLive2DConfig();
  const { switchCharacter } = useSwitchCharacter();
  const { setForceIgnoreMouse } = useForceIgnoreMouse();
  const { mode } = useMode();
  const isPet = mode === "pet";
  const micToggleHandler = reactExports.useCallback(() => {
    handleMicToggle();
  }, [handleMicToggle]);
  const interruptHandler = reactExports.useCallback(() => {
    interrupt();
  }, [interrupt]);
  const scrollToResizeHandler = reactExports.useCallback(() => {
    if (modelInfo) {
      setModelInfo({
        ...modelInfo,
        scrollToResize: !modelInfo.scrollToResize
      });
    }
  }, [modelInfo, setModelInfo]);
  const switchCharacterHandler = reactExports.useCallback(
    (_event, filename) => {
      switchCharacter(filename);
    },
    [switchCharacter]
  );
  const forceIgnoreMouseChangedHandler = reactExports.useCallback(
    (_event, isForced) => {
      console.log("Force ignore mouse changed:", isForced);
      setForceIgnoreMouse(isForced);
    },
    [setForceIgnoreMouse]
  );
  const toggleForceIgnoreMouseHandler = reactExports.useCallback(() => {
    window.api.toggleForceIgnoreMouse();
  }, []);
  reactExports.useEffect(() => {
    if (!window.electron?.ipcRenderer) return;
    if (!isPet) return;
    window.electron.ipcRenderer.removeAllListeners("mic-toggle");
    window.electron.ipcRenderer.removeAllListeners("interrupt");
    window.electron.ipcRenderer.removeAllListeners("toggle-scroll-to-resize");
    window.electron.ipcRenderer.removeAllListeners("switch-character");
    window.electron.ipcRenderer.removeAllListeners("toggle-force-ignore-mouse");
    window.electron.ipcRenderer.removeAllListeners("force-ignore-mouse-changed");
    window.electron.ipcRenderer.on("mic-toggle", micToggleHandler);
    window.electron.ipcRenderer.on("interrupt", interruptHandler);
    window.electron.ipcRenderer.on(
      "toggle-scroll-to-resize",
      scrollToResizeHandler
    );
    window.electron.ipcRenderer.on("switch-character", switchCharacterHandler);
    window.electron.ipcRenderer.on(
      "toggle-force-ignore-mouse",
      toggleForceIgnoreMouseHandler
    );
    window.electron.ipcRenderer.on(
      "force-ignore-mouse-changed",
      forceIgnoreMouseChangedHandler
    );
    return () => {
      window.electron?.ipcRenderer.removeAllListeners("mic-toggle");
      window.electron?.ipcRenderer.removeAllListeners("interrupt");
      window.electron?.ipcRenderer.removeAllListeners(
        "toggle-scroll-to-resize"
      );
      window.electron?.ipcRenderer.removeAllListeners("switch-character");
      window.electron?.ipcRenderer.removeAllListeners("toggle-force-ignore-mouse");
      window.electron?.ipcRenderer.removeAllListeners("force-ignore-mouse-changed");
    };
  }, [
    micToggleHandler,
    interruptHandler,
    scrollToResizeHandler,
    switchCharacterHandler,
    toggleForceIgnoreMouseHandler,
    forceIgnoreMouseChangedHandler,
    isPet
  ]);
}
const DEFAULT_HISTORY = {
  messages: [],
  historyList: [],
  currentHistoryUid: null,
  fullResponse: ""
};
const ChatHistoryContext = reactExports.createContext(null);
function ChatHistoryProvider({ children }) {
  const [messages2, setMessages] = reactExports.useState(DEFAULT_HISTORY.messages);
  const [historyList, setHistoryList] = reactExports.useState(
    DEFAULT_HISTORY.historyList
  );
  const [currentHistoryUid, setCurrentHistoryUid] = reactExports.useState(
    DEFAULT_HISTORY.currentHistoryUid
  );
  const [fullResponse, setFullResponse] = reactExports.useState(DEFAULT_HISTORY.fullResponse);
  const [forceNewMessage, setForceNewMessage] = reactExports.useState(false);
  const appendHumanMessage = reactExports.useCallback((content) => {
    const newMessage = {
      id: Date.now().toString(),
      content,
      role: "human",
      type: "text",
      // Explicitly set type for human messages
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    setMessages((prevMessages) => [...prevMessages, newMessage]);
  }, []);
  const appendAIMessage = reactExports.useCallback((content, name2, avatar) => {
    setMessages((prevMessages) => {
      const lastMessage = prevMessages[prevMessages.length - 1];
      if (forceNewMessage || !lastMessage || lastMessage.role !== "ai" || lastMessage.type !== "text") {
        setForceNewMessage(false);
        return [...prevMessages, {
          id: Date.now().toString(),
          content,
          role: "ai",
          type: "text",
          // Explicitly set type for AI text messages
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          name: name2,
          avatar
        }];
      }
      return [
        ...prevMessages.slice(0, -1),
        {
          ...lastMessage,
          content: lastMessage.content + content,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      ];
    });
  }, [forceNewMessage, setForceNewMessage]);
  const appendOrUpdateToolCallMessage = reactExports.useCallback((toolMessageData) => {
    if (!toolMessageData.tool_id || !toolMessageData.tool_name || !toolMessageData.status || !toolMessageData.timestamp) {
      console.error("Incomplete tool message data received:", toolMessageData);
      return;
    }
    setMessages((prevMessages) => {
      const existingMessageIndex = prevMessages.findIndex(
        (msg) => msg.type === "tool_call_status" && msg.tool_id === toolMessageData.tool_id
      );
      if (existingMessageIndex !== -1) {
        const updatedMessages = [...prevMessages];
        const existingMsg = updatedMessages[existingMessageIndex];
        updatedMessages[existingMessageIndex] = {
          ...existingMsg,
          status: toolMessageData.status,
          // Update status
          name: toolMessageData.name || existingMsg.name,
          content: toolMessageData.content || existingMsg.content,
          // Update content (result/error or keep input)
          timestamp: toolMessageData.timestamp
          // Update timestamp
        };
        return updatedMessages;
      } else {
        const newToolMessage = {
          id: toolMessageData.tool_id,
          // Use tool_id as the main ID for uniqueness
          role: "ai",
          type: "tool_call_status",
          name: toolMessageData.name || "",
          tool_id: toolMessageData.tool_id,
          tool_name: toolMessageData.tool_name,
          status: toolMessageData.status,
          content: toolMessageData.content || "",
          // Initial content (input)
          timestamp: toolMessageData.timestamp
          // name/avatar could potentially be added if needed
        };
        return [...prevMessages, newToolMessage];
      }
    });
  }, []);
  const updateHistoryList = reactExports.useCallback(
    (uid, latestMessage) => {
      if (!uid) {
        console.error("updateHistoryList: uid is null");
      }
      if (!currentHistoryUid) {
        console.error("updateHistoryList: currentHistoryUid is null");
      }
      setHistoryList((prevList) => prevList.map((history2) => {
        if (history2.uid === uid) {
          return {
            ...history2,
            latest_message: latestMessage ? {
              content: latestMessage.content,
              role: latestMessage.role,
              timestamp: latestMessage.timestamp
            } : null,
            timestamp: latestMessage?.timestamp || history2.timestamp
          };
        }
        return history2;
      }));
    },
    [currentHistoryUid]
  );
  const appendResponse = reactExports.useCallback((text) => {
    setFullResponse((prev2) => prev2 + (text || ""));
  }, []);
  const clearResponse = reactExports.useCallback(() => {
    setFullResponse(DEFAULT_HISTORY.fullResponse);
  }, []);
  const contextValue = reactExports.useMemo(
    () => ({
      messages: messages2,
      historyList,
      currentHistoryUid,
      appendHumanMessage,
      appendAIMessage,
      appendOrUpdateToolCallMessage,
      // Add to context value
      setMessages,
      setHistoryList,
      setCurrentHistoryUid,
      updateHistoryList,
      fullResponse,
      setFullResponse,
      appendResponse,
      clearResponse,
      setForceNewMessage
    }),
    [
      messages2,
      historyList,
      currentHistoryUid,
      appendHumanMessage,
      appendAIMessage,
      appendOrUpdateToolCallMessage,
      // Add dependency
      updateHistoryList,
      fullResponse,
      appendResponse,
      clearResponse,
      setForceNewMessage
    ]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ChatHistoryContext.Provider, { value: contextValue, children });
}
function useChatHistory() {
  const context = reactExports.useContext(ChatHistoryContext);
  if (!context) {
    throw new Error("useChatHistory must be used within a ChatHistoryProvider");
  }
  return context;
}
class AudioManager {
  currentAudio = null;
  currentModel = null;
  /**
   * Set the current playing audio
   */
  setCurrentAudio(audio, model) {
    this.currentAudio = audio;
    this.currentModel = model;
  }
  /**
   * Stop current audio playback and lip sync
   */
  stopCurrentAudioAndLipSync() {
    if (this.currentAudio) {
      console.log("[AudioManager] Stopping current audio and lip sync");
      const audio = this.currentAudio;
      audio.pause();
      audio.src = "";
      audio.load();
      const model = this.currentModel;
      if (model && model._wavFileHandler) {
        try {
          model._wavFileHandler.releasePcmData();
          console.log("[AudioManager] Called _wavFileHandler.releasePcmData()");
          model._wavFileHandler._lastRms = 0;
          model._wavFileHandler._sampleOffset = 0;
          model._wavFileHandler._userTimeSeconds = 0;
          console.log("[AudioManager] Also reset _lastRms, _sampleOffset, _userTimeSeconds as fallback");
        } catch (e2) {
          console.error("[AudioManager] Error stopping/resetting wavFileHandler:", e2);
        }
      } else if (model) {
        console.warn("[AudioManager] Current model does not have _wavFileHandler to stop/reset.");
      } else {
        console.log("[AudioManager] No associated model found to stop lip sync.");
      }
      this.currentAudio = null;
      this.currentModel = null;
    } else {
      console.log("[AudioManager] No current audio playing to stop.");
    }
  }
  /**
   * Clear the current audio reference (called when audio ends naturally)
   */
  clearCurrentAudio(audio) {
    if (this.currentAudio === audio) {
      this.currentAudio = null;
      this.currentModel = null;
    }
  }
  /**
   * Check if there's currently playing audio
   */
  hasCurrentAudio() {
    return this.currentAudio !== null;
  }
}
const audioManager = new AudioManager();
const useLive2DExpression = () => {
  const setExpression = reactExports.useCallback((expressionValue, lappAdapter, logMessage) => {
    try {
      if (typeof expressionValue === "string") {
        lappAdapter.setExpression(expressionValue);
      } else if (typeof expressionValue === "number") {
        const expressionName = lappAdapter.getExpressionName(expressionValue);
        if (expressionName) {
          lappAdapter.setExpression(expressionName);
        }
      }
      if (logMessage) {
        console.log(logMessage);
      }
    } catch (error2) {
      console.error("Failed to set expression:", error2);
    }
  }, []);
  const resetExpression = reactExports.useCallback((lappAdapter, modelInfo) => {
    if (!lappAdapter) return;
    try {
      const model = lappAdapter.getModel();
      if (!model || !model._modelSetting) {
        console.log("Model or model settings not loaded yet, skipping expression reset");
        return;
      }
      if (modelInfo?.defaultEmotion !== void 0) {
        setExpression(
          modelInfo.defaultEmotion,
          lappAdapter,
          `Reset expression to default: ${modelInfo.defaultEmotion}`
        );
      } else {
        const expressionCount = lappAdapter.getExpressionCount();
        if (expressionCount > 0) {
          const defaultExpressionName = lappAdapter.getExpressionName(0);
          if (defaultExpressionName) {
            setExpression(
              defaultExpressionName,
              lappAdapter
            );
          }
        }
      }
    } catch (error2) {
      console.log("Failed to reset expression:", error2);
    }
  }, [setExpression]);
  return {
    setExpression,
    resetExpression
  };
};
class csmVector {
  /**
   * 
   * @param iniitalCapacity _capacity * sizeof(T)
   * @param zeroClear true0
   */
  constructor(initialCapacity = 0) {
    if (initialCapacity < 1) {
      this._ptr = [];
      this._capacity = 0;
      this._size = 0;
    } else {
      this._ptr = new Array(initialCapacity);
      this._capacity = initialCapacity;
      this._size = 0;
    }
  }
  /**
   * 
   */
  at(index) {
    return this._ptr[index];
  }
  /**
   * 
   * @param index 
   * @param value 
   */
  set(index, value) {
    this._ptr[index] = value;
  }
  /**
   * 
   */
  get(offset2 = 0) {
    const ret = new Array();
    for (let i = offset2; i < this._size; i++) {
      ret.push(this._ptr[i]);
    }
    return ret;
  }
  /**
   * pushBack
   * @param value PushBack
   */
  pushBack(value) {
    if (this._size >= this._capacity) {
      this.prepareCapacity(
        this._capacity == 0 ? csmVector.DefaultSize : this._capacity * 2
      );
    }
    this._ptr[this._size++] = value;
  }
  /**
   * 
   */
  clear() {
    this._ptr.length = 0;
    this._size = 0;
  }
  /**
   * 
   * @return 
   */
  getSize() {
    return this._size;
  }
  /**
   * 
   * @param newSize 
   * @param value 
   */
  assign(newSize, value) {
    const curSize = this._size;
    if (curSize < newSize) {
      this.prepareCapacity(newSize);
    }
    for (let i = 0; i < newSize; i++) {
      this._ptr[i] = value;
    }
    this._size = newSize;
  }
  /**
   * 
   */
  resize(newSize, value = null) {
    this.updateSize(newSize, value, true);
  }
  /**
   * 
   */
  updateSize(newSize, value = null, callPlacementNew = true) {
    const curSize = this._size;
    if (curSize < newSize) {
      this.prepareCapacity(newSize);
      if (callPlacementNew) {
        for (let i = this._size; i < newSize; i++) {
          if (typeof value == "function") {
            this._ptr[i] = JSON.parse(JSON.stringify(new value()));
          } else {
            this._ptr[i] = value;
          }
        }
      } else {
        for (let i = this._size; i < newSize; i++) {
          this._ptr[i] = value;
        }
      }
    } else {
      const sub = this._size - newSize;
      this._ptr.splice(this._size - sub, sub);
    }
    this._size = newSize;
  }
  /**
   * 
   * @param position 
   * @param begin 
   * @param end 
   */
  insert(position2, begin, end) {
    let dstSi = position2._index;
    const srcSi = begin._index;
    const srcEi = end._index;
    const addCount = srcEi - srcSi;
    this.prepareCapacity(this._size + addCount);
    const addSize = this._size - dstSi;
    if (addSize > 0) {
      for (let i = 0; i < addSize; i++) {
        this._ptr.splice(dstSi + i, 0, null);
      }
    }
    for (let i = srcSi; i < srcEi; i++, dstSi++) {
      this._ptr[dstSi] = begin._vector._ptr[i];
    }
    this._size = this._size + addCount;
  }
  /**
   * 
   * @param index 
   * @return true 
   * @return false 
   */
  remove(index) {
    if (index < 0 || this._size <= index) {
      return false;
    }
    this._ptr.splice(index, 1);
    --this._size;
    return true;
  }
  /**
   * 
   * @param ite 
   */
  erase(ite) {
    const index = ite._index;
    if (index < 0 || this._size <= index) {
      return ite;
    }
    this._ptr.splice(index, 1);
    --this._size;
    const ite2 = new iterator$1(this, index);
    return ite2;
  }
  /**
   * 
   * @param newSize .
   */
  prepareCapacity(newSize) {
    if (newSize > this._capacity) {
      if (this._capacity == 0) {
        this._ptr = new Array(newSize);
        this._capacity = newSize;
      } else {
        this._ptr.length = newSize;
        this._capacity = newSize;
      }
    }
  }
  /**
   * 
   */
  begin() {
    const ite = this._size == 0 ? this.end() : new iterator$1(this, 0);
    return ite;
  }
  /**
   * 
   */
  end() {
    const ite = new iterator$1(this, this._size);
    return ite;
  }
  getOffset(offset2) {
    const newVector = new csmVector();
    newVector._ptr = this.get(offset2);
    newVector._size = this.get(offset2).length;
    newVector._capacity = this.get(offset2).length;
    return newVector;
  }
  static {
    this.DefaultSize = 10;
  }
  // 
}
let iterator$1 = class iterator2 {
  /**
   * 
   */
  constructor(v2, index) {
    this._vector = v2 != void 0 ? v2 : null;
    this._index = index != void 0 ? index : 0;
  }
  /**
   * 
   */
  set(ite) {
    this._index = ite._index;
    this._vector = ite._vector;
    return this;
  }
  /**
   * ++
   */
  preIncrement() {
    ++this._index;
    return this;
  }
  /**
   * --
   */
  preDecrement() {
    --this._index;
    return this;
  }
  /**
   * ++
   */
  increment() {
    const iteold = new iterator2(this._vector, this._index++);
    return iteold;
  }
  /**
   * --
   */
  decrement() {
    const iteold = new iterator2(this._vector, this._index--);
    return iteold;
  }
  /**
   * ptr
   */
  ptr() {
    return this._vector._ptr[this._index];
  }
  /**
   * =
   */
  substitution(ite) {
    this._index = ite._index;
    this._vector = ite._vector;
    return this;
  }
  /**
   * !=
   */
  notEqual(ite) {
    return this._index != ite._index || this._vector != ite._vector;
  }
  // 
};
var Live2DCubismFramework$E;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.csmVector = csmVector;
  Live2DCubismFramework2.iterator = iterator$1;
})(Live2DCubismFramework$E || (Live2DCubismFramework$E = {}));
class csmString {
  /**
   * 
   *
   * @param c 
   * @return 
   */
  append(c2, length2) {
    this.s += length2 !== void 0 ? c2.substr(0, length2) : c2;
    return this;
  }
  /**
   * 
   * @param length    
   * @param v         
   * @return 
   */
  expansion(length2, v2) {
    for (let i = 0; i < length2; i++) {
      this.append(v2);
    }
    return this;
  }
  /**
   * 
   */
  getBytes() {
    return encodeURIComponent(this.s).replace(/%../g, "x").length;
  }
  /**
   * 
   */
  getLength() {
    return this.s.length;
  }
  /**
   *  <
   * @param s 
   * @return true:    
   * @return false:   
   */
  isLess(s) {
    return this.s < s.s;
  }
  /**
   *  >
   * @param s 
   * @return true:    
   * @return false:   
   */
  isGreat(s) {
    return this.s > s.s;
  }
  /**
   *  ==
   * @param s 
   * @return true:    
   * @return false:   
   */
  isEqual(s) {
    return this.s == s;
  }
  /**
   * 
   * @return true: 
   * @return false: 
   */
  isEmpty() {
    return this.s.length == 0;
  }
  /**
   * 
   */
  constructor(s) {
    this.s = s;
  }
}
var Live2DCubismFramework$D;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.csmString = csmString;
})(Live2DCubismFramework$D || (Live2DCubismFramework$D = {}));
class CubismId {
  /**
   * CubismId
   *
   * @param id ID
   * @returns CubismId
   * @note IDCubismId
   *       CubismIdManager().getId(id)
   */
  static createIdInternal(id2) {
    return new CubismId(id2);
  }
  /**
   * ID
   */
  getString() {
    return this._id;
  }
  /**
   * id
   * @param c id
   * @return true,false
   */
  isEqual(c2) {
    if (typeof c2 === "string") {
      return this._id.isEqual(c2);
    } else if (c2 instanceof csmString) {
      return this._id.isEqual(c2.s);
    } else if (c2 instanceof CubismId) {
      return this._id.isEqual(c2._id.s);
    }
    return false;
  }
  /**
   * id
   * @param c id
   * @return true,false
   */
  isNotEqual(c2) {
    if (typeof c2 == "string") {
      return !this._id.isEqual(c2);
    } else if (c2 instanceof csmString) {
      return !this._id.isEqual(c2.s);
    } else if (c2 instanceof CubismId) {
      return !this._id.isEqual(c2._id.s);
    }
    return false;
  }
  /**
   * 
   *
   * @note 
   */
  constructor(id2) {
    if (typeof id2 === "string") {
      this._id = new csmString(id2);
      return;
    }
    this._id = id2;
  }
  // ID
}
var Live2DCubismFramework$C;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismId = CubismId;
})(Live2DCubismFramework$C || (Live2DCubismFramework$C = {}));
class CubismIdManager {
  /**
   * 
   */
  constructor() {
    this._ids = new csmVector();
  }
  /**
   * 
   */
  release() {
    for (let i = 0; i < this._ids.getSize(); ++i) {
      this._ids.set(i, void 0);
    }
    this._ids = null;
  }
  /**
   * ID
   *
   * @param ids ID
   * @param count ID
   */
  registerIds(ids) {
    for (let i = 0; i < ids.length; i++) {
      this.registerId(ids[i]);
    }
  }
  /**
   * ID
   *
   * @param id ID
   */
  registerId(id2) {
    let result = null;
    if ("string" == typeof id2) {
      if ((result = this.findId(id2)) != null) {
        return result;
      }
      result = CubismId.createIdInternal(id2);
      this._ids.pushBack(result);
    } else {
      return this.registerId(id2.s);
    }
    return result;
  }
  /**
   * IDID
   *
   * @param id ID
   */
  getId(id2) {
    return this.registerId(id2);
  }
  /**
   * IDID
   *
   * @return true 
   * @return false 
   */
  isExist(id2) {
    if ("string" == typeof id2) {
      return this.findId(id2) != null;
    }
    return this.isExist(id2.s);
  }
  /**
   * IDID
   *
   * @param id ID
   * @return IDNULL
   */
  findId(id2) {
    for (let i = 0; i < this._ids.getSize(); ++i) {
      if (this._ids.at(i).getString().isEqual(id2)) {
        return this._ids.at(i);
      }
    }
    return null;
  }
  // ID
}
var Live2DCubismFramework$B;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismIdManager = CubismIdManager;
})(Live2DCubismFramework$B || (Live2DCubismFramework$B = {}));
class CubismMatrix44 {
  /**
   * 
   */
  constructor() {
    this._tr = new Float32Array(16);
    this.loadIdentity();
  }
  /**
   * 
   *
   * @param a a
   * @param b b
   * @return 
   */
  static multiply(a, b2, dst) {
    const c2 = new Float32Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    const n2 = 4;
    for (let i = 0; i < n2; ++i) {
      for (let j = 0; j < n2; ++j) {
        for (let k2 = 0; k2 < n2; ++k2) {
          c2[j + i * 4] += a[k2 + i * 4] * b2[j + k2 * 4];
        }
      }
    }
    for (let i = 0; i < 16; ++i) {
      dst[i] = c2[i];
    }
  }
  /**
   * 
   */
  loadIdentity() {
    const c2 = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    this.setMatrix(c2);
  }
  /**
   * 
   *
   * @param tr 164x4
   */
  setMatrix(tr) {
    for (let i = 0; i < 16; ++i) {
      this._tr[i] = tr[i];
    }
  }
  /**
   * 
   *
   * @return 164x4
   */
  getArray() {
    return this._tr;
  }
  /**
   * X
   * @return X
   */
  getScaleX() {
    return this._tr[0];
  }
  /**
   * Y
   *
   * @return Y
   */
  getScaleY() {
    return this._tr[5];
  }
  /**
   * X
   * @return X
   */
  getTranslateX() {
    return this._tr[12];
  }
  /**
   * Y
   * @return Y
   */
  getTranslateY() {
    return this._tr[13];
  }
  /**
   * X
   *
   * @param src X
   * @return X
   */
  transformX(src) {
    return this._tr[0] * src + this._tr[12];
  }
  /**
   * Y
   *
   * @param src Y
   * @return Y
   */
  transformY(src) {
    return this._tr[5] * src + this._tr[13];
  }
  /**
   * X
   */
  invertTransformX(src) {
    return (src - this._tr[12]) / this._tr[0];
  }
  /**
   * Y
   */
  invertTransformY(src) {
    return (src - this._tr[13]) / this._tr[5];
  }
  /**
   * 
   *
   * 
   *
   * @param x X
   * @param y Y
   */
  translateRelative(x2, y2) {
    const tr1 = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      x2,
      y2,
      0,
      1
    ]);
    CubismMatrix44.multiply(tr1, this._tr, this._tr);
  }
  /**
   * 
   *
   * 
   *
   * @param x X
   * @param y y
   */
  translate(x2, y2) {
    this._tr[12] = x2;
    this._tr[13] = y2;
  }
  /**
   * X
   *
   * @param x X
   */
  translateX(x2) {
    this._tr[12] = x2;
  }
  /**
   * Y
   *
   * @param y Y
   */
  translateY(y2) {
    this._tr[13] = y2;
  }
  /**
   * 
   *
   * @param x X
   * @param y Y
   */
  scaleRelative(x2, y2) {
    const tr1 = new Float32Array([
      x2,
      0,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    CubismMatrix44.multiply(tr1, this._tr, this._tr);
  }
  /**
   * 
   *
   * @param x X
   * @param y Y
   */
  scale(x2, y2) {
    this._tr[0] = x2;
    this._tr[5] = y2;
  }
  /**
   * 
   * () * ()
   *
   * @note 
   * @param m 
   */
  multiplyByMatrix(m2) {
    CubismMatrix44.multiply(m2.getArray(), this._tr, this._tr);
  }
  /**
   * 
   */
  clone() {
    const cloneMatrix = new CubismMatrix44();
    for (let i = 0; i < this._tr.length; i++) {
      cloneMatrix._tr[i] = this._tr[i];
    }
    return cloneMatrix;
  }
  // 4x4
}
var Live2DCubismFramework$A;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMatrix44 = CubismMatrix44;
})(Live2DCubismFramework$A || (Live2DCubismFramework$A = {}));
class csmRect {
  /**
   * 
   * @param x X
   * @param y Y
   * @param w 
   * @param h 
   */
  constructor(x2, y2, w2, h2) {
    this.x = x2;
    this.y = y2;
    this.width = w2;
    this.height = h2;
  }
  /**
   * X
   */
  getCenterX() {
    return this.x + 0.5 * this.width;
  }
  /**
   * Y
   */
  getCenterY() {
    return this.y + 0.5 * this.height;
  }
  /**
   * X
   */
  getRight() {
    return this.x + this.width;
  }
  /**
   * Y
   */
  getBottom() {
    return this.y + this.height;
  }
  /**
   * 
   * @param r 
   */
  setRect(r2) {
    this.x = r2.x;
    this.y = r2.y;
    this.width = r2.width;
    this.height = r2.height;
  }
  /**
   * 
   * @param w 
   * @param h 
   */
  expand(w2, h2) {
    this.x -= w2;
    this.y -= h2;
    this.width += w2 * 2;
    this.height += h2 * 2;
  }
  // 
}
var Live2DCubismFramework$z;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.csmRect = csmRect;
})(Live2DCubismFramework$z || (Live2DCubismFramework$z = {}));
class CubismRenderer {
  /**
   * 
   *
   * @return 
   */
  static create() {
    return null;
  }
  /**
   * 
   */
  static delete(renderer) {
  }
  /**
   * 
   * 
   * @param model 
   */
  initialize(model) {
    this._model = model;
  }
  /**
   * 
   */
  drawModel() {
    if (this.getModel() == null) return;
    this.saveProfile();
    this.doDrawModel();
    this.restoreProfile();
  }
  /**
   * Model-View-Projection 
   * 
   * @param matrix44 Model-View-Projection 
   */
  setMvpMatrix(matrix44) {
    this._mvpMatrix4x4.setMatrix(matrix44.getArray());
  }
  /**
   * Model-View-Projection 
   * @return Model-View-Projection 
   */
  getMvpMatrix() {
    return this._mvpMatrix4x4;
  }
  /**
   * 
   * 0.0~1.01.0
   * @param red 
   * @param green 
   * @param blue 
   * @param alpha 
   */
  setModelColor(red, green, blue, alpha) {
    if (red < 0) {
      red = 0;
    } else if (red > 1) {
      red = 1;
    }
    if (green < 0) {
      green = 0;
    } else if (green > 1) {
      green = 1;
    }
    if (blue < 0) {
      blue = 0;
    } else if (blue > 1) {
      blue = 1;
    }
    if (alpha < 0) {
      alpha = 0;
    } else if (alpha > 1) {
      alpha = 1;
    }
    this._modelColor.r = red;
    this._modelColor.g = green;
    this._modelColor.b = blue;
    this._modelColor.a = alpha;
  }
  /**
   * 
   * 0.0~1.0(1.0)
   *
   * @return RGBA
   */
  getModelColor() {
    return JSON.parse(JSON.stringify(this._modelColor));
  }
  /**
   * 
   *
   * @param opacity 
   *
   * @return RGBA
   */
  getModelColorWithOpacity(opacity) {
    const modelColorRGBA = this.getModelColor();
    modelColorRGBA.a *= opacity;
    if (this.isPremultipliedAlpha()) {
      modelColorRGBA.r *= modelColorRGBA.a;
      modelColorRGBA.g *= modelColorRGBA.a;
      modelColorRGBA.b *= modelColorRGBA.a;
    }
    return modelColorRGBA;
  }
  /**
   * 
   * truefalse
   */
  setIsPremultipliedAlpha(enable) {
    this._isPremultipliedAlpha = enable;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isPremultipliedAlpha() {
    return this._isPremultipliedAlpha;
  }
  /**
   * 
   * truefalse
   */
  setIsCulling(culling) {
    this._isCulling = culling;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isCulling() {
    return this._isCulling;
  }
  /**
   * 
   * 
   * @param n 
   */
  setAnisotropy(n2) {
    this._anisotropy = n2;
  }
  /**
   * 
   * @return 
   */
  getAnisotropy() {
    return this._anisotropy;
  }
  /**
   * 
   * @return 
   */
  getModel() {
    return this._model;
  }
  /**
   * 
   * false1
   * 36
   * true
   * 
   * @param high 
   */
  useHighPrecisionMask(high) {
    this._useHighPrecisionMask = high;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isUsingHighPrecisionMask() {
    return this._useHighPrecisionMask;
  }
  /**
   * 
   */
  constructor() {
    this._isCulling = false;
    this._isPremultipliedAlpha = false;
    this._anisotropy = 0;
    this._model = null;
    this._modelColor = new CubismTextureColor();
    this._useHighPrecisionMask = false;
    this._mvpMatrix4x4 = new CubismMatrix44();
    this._mvpMatrix4x4.loadIdentity();
  }
  // false true
}
var CubismBlendMode = /* @__PURE__ */ ((CubismBlendMode2) => {
  CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Normal"] = 0] = "CubismBlendMode_Normal";
  CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Additive"] = 1] = "CubismBlendMode_Additive";
  CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Multiplicative"] = 2] = "CubismBlendMode_Multiplicative";
  return CubismBlendMode2;
})(CubismBlendMode || {});
class CubismTextureColor {
  /**
   * 
   */
  constructor(r2 = 1, g2 = 1, b2 = 1, a = 1) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    this.a = a;
  }
  // 
}
class CubismClippingContext {
  /**
   * 
   */
  constructor(clippingDrawableIndices, clipCount) {
    this._clippingIdList = clippingDrawableIndices;
    this._clippingIdCount = clipCount;
    this._allClippedDrawRect = new csmRect();
    this._layoutBounds = new csmRect();
    this._clippedDrawableIndexList = [];
    this._matrixForMask = new CubismMatrix44();
    this._matrixForDraw = new CubismMatrix44();
    this._bufferIndex = 0;
  }
  /**
   * 
   */
  release() {
    if (this._layoutBounds != null) {
      this._layoutBounds = null;
    }
    if (this._allClippedDrawRect != null) {
      this._allClippedDrawRect = null;
    }
    if (this._clippedDrawableIndexList != null) {
      this._clippedDrawableIndexList = null;
    }
  }
  /**
   * 
   *
   * @param drawableIndex 
   */
  addClippedDrawable(drawableIndex) {
    this._clippedDrawableIndexList.push(drawableIndex);
  }
  // 
}
var Live2DCubismFramework$y;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismBlendMode = CubismBlendMode;
  Live2DCubismFramework2.CubismRenderer = CubismRenderer;
  Live2DCubismFramework2.CubismTextureColor = CubismTextureColor;
})(Live2DCubismFramework$y || (Live2DCubismFramework$y = {}));
const CubismLogPrint = (level, fmt, args) => {
  CubismDebug.print(level, "[CSM]" + fmt, args);
};
const CubismLogPrintIn = (level, fmt, args) => {
  CubismLogPrint(level, fmt + "\n", args);
};
const CSM_ASSERT = (expr) => {
  console.assert(expr);
};
let CubismLogDebug;
let CubismLogInfo;
let CubismLogWarning;
let CubismLogError;
{
  CubismLogDebug = (fmt, ...args) => {
    CubismLogPrintIn(LogLevel.LogLevel_Debug, "[D]" + fmt, args);
  };
  CubismLogInfo = (fmt, ...args) => {
    CubismLogPrintIn(LogLevel.LogLevel_Info, "[I]" + fmt, args);
  };
  CubismLogWarning = (fmt, ...args) => {
    CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
  };
  CubismLogError = (fmt, ...args) => {
    CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
  };
}
class CubismDebug {
  /**
   * 
   * CubismFramework.initialize()
   *
   * @param logLevel 
   * @param format 
   * @param args 
   */
  static print(logLevel, format, args) {
    if (logLevel < CubismFramework.getLoggingLevel()) {
      return;
    }
    const logPrint = CubismFramework.coreLogFunction;
    if (!logPrint) return;
    const buffer = format.replace(/\{(\d+)\}/g, (m2, k2) => {
      return args[k2];
    });
    logPrint(buffer);
  }
  /**
   * 
   * CubismFramework.initialize()
   *
   * @param logLevel 
   * @param data 
   * @param length 
   */
  static dumpBytes(logLevel, data, length2) {
    for (let i = 0; i < length2; i++) {
      if (i % 16 == 0 && i > 0) this.print(logLevel, "\n");
      else if (i % 8 == 0 && i > 0) this.print(logLevel, "  ");
      this.print(logLevel, "{0} ", [data[i] & 255]);
    }
    this.print(logLevel, "\n");
  }
  /**
   * private 
   */
  constructor() {
  }
}
var Live2DCubismFramework$x;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismDebug = CubismDebug;
})(Live2DCubismFramework$x || (Live2DCubismFramework$x = {}));
class csmPair {
  /**
   * 
   * @param key Key
   * @param value Value
   */
  constructor(key, value) {
    this.first = key == void 0 ? null : key;
    this.second = value == void 0 ? null : value;
  }
  // value
}
class csmMap {
  /**
   * 
   * @param size 
   */
  constructor(size2) {
    if (size2 != void 0) {
      if (size2 < 1) {
        this._keyValues = [];
        this._dummyValue = null;
        this._size = 0;
      } else {
        this._keyValues = new Array(size2);
        this._size = size2;
      }
    } else {
      this._keyValues = [];
      this._dummyValue = null;
      this._size = 0;
    }
  }
  /**
   * 
   */
  release() {
    this.clear();
  }
  /**
   * 
   * @param key 
   */
  appendKey(key) {
    this.prepareCapacity(this._size + 1, false);
    this._keyValues[this._size] = new csmPair(key);
    this._size += 1;
  }
  /**
   * [key](get)
   * @param key Value
   */
  getValue(key) {
    let found = -1;
    for (let i = 0; i < this._size; i++) {
      if (this._keyValues[i].first == key) {
        found = i;
        break;
      }
    }
    if (found >= 0) {
      return this._keyValues[found].second;
    } else {
      this.appendKey(key);
      return this._keyValues[this._size - 1].second;
    }
  }
  /**
   * [key](set)
   * @param key Value
   * @param value Value
   */
  setValue(key, value) {
    let found = -1;
    for (let i = 0; i < this._size; i++) {
      if (this._keyValues[i].first == key) {
        found = i;
        break;
      }
    }
    if (found >= 0) {
      this._keyValues[found].second = value;
    } else {
      this.appendKey(key);
      this._keyValues[this._size - 1].second = value;
    }
  }
  /**
   * Key
   * @param key key
   * @return true key
   * @return false key
   */
  isExist(key) {
    for (let i = 0; i < this._size; i++) {
      if (this._keyValues[i].first == key) {
        return true;
      }
    }
    return false;
  }
  /**
   * keyValue
   */
  clear() {
    this._keyValues = void 0;
    this._keyValues = null;
    this._keyValues = [];
    this._size = 0;
  }
  /**
   * 
   *
   * @return 
   */
  getSize() {
    return this._size;
  }
  /**
   * 
   * @param newSize 
   * @param fitToSize truefalse2
   */
  prepareCapacity(newSize, fitToSize) {
    if (newSize > this._keyValues.length) {
      if (this._keyValues.length == 0) {
        if (!fitToSize && newSize < csmMap.DefaultSize)
          newSize = csmMap.DefaultSize;
        this._keyValues.length = newSize;
      } else {
        if (!fitToSize && newSize < this._keyValues.length * 2)
          newSize = this._keyValues.length * 2;
        this._keyValues.length = newSize;
      }
    }
  }
  /**
   * 
   */
  begin() {
    const ite = new iterator(this, 0);
    return ite;
  }
  /**
   * 
   */
  end() {
    const ite = new iterator(
      this,
      this._size
    );
    return ite;
  }
  /**
   * 
   *
   * @param ite 
   */
  erase(ite) {
    const index = ite._index;
    if (index < 0 || this._size <= index) {
      return ite;
    }
    this._keyValues.splice(index, 1);
    --this._size;
    const ite2 = new iterator(
      this,
      index
    );
    return ite2;
  }
  /**
   * 32
   */
  dumpAsInt() {
    for (let i = 0; i < this._size; i++) {
      CubismLogDebug("{0} ,", this._keyValues[i]);
      CubismLogDebug("\n");
    }
  }
  static {
    this.DefaultSize = 10;
  }
  // 
}
class iterator {
  /**
   * 
   */
  constructor(v2, idx) {
    this._map = v2 != void 0 ? v2 : new csmMap();
    this._index = idx != void 0 ? idx : 0;
  }
  /**
   * =
   */
  set(ite) {
    this._index = ite._index;
    this._map = ite._map;
    return this;
  }
  /**
   * ++
   */
  preIncrement() {
    ++this._index;
    return this;
  }
  /**
   * --
   */
  preDecrement() {
    --this._index;
    return this;
  }
  /**
   * ++
   */
  increment() {
    const iteold = new iterator(this._map, this._index++);
    return iteold;
  }
  /**
   * --
   */
  decrement() {
    const iteold = new iterator(this._map, this._index);
    this._map = iteold._map;
    this._index = iteold._index;
    return this;
  }
  /**
   * *
   */
  ptr() {
    return this._map._keyValues[this._index];
  }
  /**
   * !=
   */
  notEqual(ite) {
    return this._index != ite._index || this._map != ite._map;
  }
  // 
}
var Live2DCubismFramework$w;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.csmMap = csmMap;
  Live2DCubismFramework2.csmPair = csmPair;
  Live2DCubismFramework2.iterator = iterator;
})(Live2DCubismFramework$w || (Live2DCubismFramework$w = {}));
class CubismJsonExtension {
  static parseJsonObject(obj, map) {
    Object.keys(obj).forEach((key) => {
      if (typeof obj[key] == "boolean") {
        const convValue = Boolean(obj[key]);
        map.put(key, new JsonBoolean(convValue));
      } else if (typeof obj[key] == "string") {
        const convValue = String(obj[key]);
        map.put(key, new JsonString(convValue));
      } else if (typeof obj[key] == "number") {
        const convValue = Number(obj[key]);
        map.put(key, new JsonFloat(convValue));
      } else if (obj[key] instanceof Array) {
        map.put(key, CubismJsonExtension.parseJsonArray(obj[key]));
      } else if (obj[key] instanceof Object) {
        map.put(
          key,
          CubismJsonExtension.parseJsonObject(obj[key], new JsonMap())
        );
      } else if (obj[key] == null) {
        map.put(key, new JsonNullvalue());
      } else {
        map.put(key, obj[key]);
      }
    });
    return map;
  }
  static parseJsonArray(obj) {
    const arr2 = new JsonArray();
    Object.keys(obj).forEach((key) => {
      const convKey = Number(key);
      if (typeof convKey == "number") {
        if (typeof obj[key] == "boolean") {
          const convValue = Boolean(obj[key]);
          arr2.add(new JsonBoolean(convValue));
        } else if (typeof obj[key] == "string") {
          const convValue = String(obj[key]);
          arr2.add(new JsonString(convValue));
        } else if (typeof obj[key] == "number") {
          const convValue = Number(obj[key]);
          arr2.add(new JsonFloat(convValue));
        } else if (obj[key] instanceof Array) {
          arr2.add(this.parseJsonArray(obj[key]));
        } else if (obj[key] instanceof Object) {
          arr2.add(this.parseJsonObject(obj[key], new JsonMap()));
        } else if (obj[key] == null) {
          arr2.add(new JsonNullvalue());
        } else {
          arr2.add(obj[key]);
        }
      } else if (obj[key] instanceof Array) {
        arr2.add(this.parseJsonArray(obj[key]));
      } else if (obj[key] instanceof Object) {
        arr2.add(this.parseJsonObject(obj[key], new JsonMap()));
      } else if (obj[key] == null) {
        arr2.add(new JsonNullvalue());
      } else {
        const convValue = Array(obj[key]);
        for (let i = 0; i < convValue.length; i++) {
          arr2.add(convValue[i]);
        }
      }
    });
    return arr2;
  }
}
const CSM_JSON_ERROR_TYPE_MISMATCH = "Error: type mismatch";
const CSM_JSON_ERROR_INDEX_OF_BOUNDS = "Error: index out of bounds";
let Value$2 = class Value2 {
  /**
   * 
   */
  constructor() {
  }
  /**
   * (string)
   */
  getRawString(defaultValue, indent) {
    return this.getString(defaultValue, indent);
  }
  /**
   * (number)
   */
  toInt(defaultValue = 0) {
    return defaultValue;
  }
  /**
   * (number)
   */
  toFloat(defaultValue = 0) {
    return defaultValue;
  }
  /**
   * (boolean)
   */
  toBoolean(defaultValue = false) {
    return defaultValue;
  }
  /**
   * 
   */
  getSize() {
    return 0;
  }
  /**
   * (Value[])
   */
  getArray(defaultValue = null) {
    return defaultValue;
  }
  /**
   * (array)
   */
  getVector(defaultValue = new csmVector()) {
    return defaultValue;
  }
  /**
   * (csmMap<csmString, Value>)
   */
  getMap(defaultValue) {
    return defaultValue;
  }
  /**
   * [index]
   */
  getValueByIndex(index) {
    return Value2.errorValue.setErrorNotForClientCall(
      CSM_JSON_ERROR_TYPE_MISMATCH
    );
  }
  /**
   * [string | csmString]
   */
  getValueByString(s) {
    return Value2.nullValue.setErrorNotForClientCall(
      CSM_JSON_ERROR_TYPE_MISMATCH
    );
  }
  /**
   * 
   *
   * @return 
   */
  getKeys() {
    return Value2.dummyKeys;
  }
  /**
   * Valuetrue
   */
  isError() {
    return false;
  }
  /**
   * Valuenulltrue
   */
  isNull() {
    return false;
  }
  /**
   * Valuetrue
   */
  isBool() {
    return false;
  }
  /**
   * Valuetrue
   */
  isFloat() {
    return false;
  }
  /**
   * Valuetrue
   */
  isString() {
    return false;
  }
  /**
   * Valuetrue
   */
  isArray() {
    return false;
  }
  /**
   * Valuetrue
   */
  isMap() {
    return false;
  }
  equals(value) {
    return false;
  }
  /**
   * Valuetrue
   */
  isStatic() {
    return false;
  }
  /**
   * Value
   */
  setErrorNotForClientCall(errorStr) {
    return JsonError.errorValue;
  }
  /**
   * 
   */
  static staticInitializeNotForClientCall() {
    JsonBoolean.trueValue = new JsonBoolean(true);
    JsonBoolean.falseValue = new JsonBoolean(false);
    Value2.errorValue = new JsonError("ERROR", true);
    Value2.nullValue = new JsonNullvalue();
    Value2.dummyKeys = new csmVector();
  }
  /**
   * 
   */
  static staticReleaseNotForClientCall() {
    JsonBoolean.trueValue = null;
    JsonBoolean.falseValue = null;
    Value2.errorValue = null;
    Value2.nullValue = null;
    Value2.dummyKeys = null;
  }
  // any
};
class CubismJson {
  /**
   * 
   */
  constructor(buffer, length2) {
    this._parseCallback = CubismJsonExtension.parseJsonObject;
    this._error = null;
    this._lineCount = 0;
    this._root = null;
    if (buffer != void 0) {
      this.parseBytes(buffer, length2, this._parseCallback);
    }
  }
  /**
   * 
   *
   * @param buffer 
   * @param size 
   * @return CubismJsonNULL
   */
  static create(buffer, size2) {
    const json = new CubismJson();
    const succeeded = json.parseBytes(
      buffer,
      size2,
      json._parseCallback
    );
    if (!succeeded) {
      CubismJson.delete(json);
      return null;
    } else {
      return json;
    }
  }
  /**
   * JSON
   *
   * @param instance CubismJson
   */
  static delete(instance2) {
  }
  /**
   * JSON
   */
  getRoot() {
    return this._root;
  }
  /**
   *  UnicodeString
   *
   * @param buffer 
   * @return 
   */
  static arrayBufferToString(buffer) {
    const uint8Array = new Uint8Array(buffer);
    let str = "";
    for (let i = 0, len = uint8Array.length; i < len; ++i) {
      str += "%" + this.pad(uint8Array[i].toString(16));
    }
    str = decodeURIComponent(str);
    return str;
  }
  /**
   * 
   */
  static pad(n2) {
    return n2.length < 2 ? "0" + n2 : n2;
  }
  /**
   * JSON
   * @param buffer    
   * @param size      
   * return true : 
   * return false: 
   */
  parseBytes(buffer, size2, parseCallback) {
    const endPos = new Array(1);
    const decodeBuffer = CubismJson.arrayBufferToString(buffer);
    if (parseCallback == void 0) {
      this._root = this.parseValue(decodeBuffer, size2, 0, endPos);
    } else {
      this._root = parseCallback(JSON.parse(decodeBuffer), new JsonMap());
    }
    if (this._error) {
      let strbuf = "\0";
      strbuf = "Json parse error : @line " + (this._lineCount + 1) + "\n";
      this._root = new JsonString(strbuf);
      CubismLogInfo("{0}", this._root.getRawString());
      return false;
    } else if (this._root == null) {
      this._root = new JsonError(new csmString(this._error), false);
      return false;
    }
    return true;
  }
  /**
   * 
   */
  getParseError() {
    return this._error;
  }
  /**
   * true
   */
  checkEndOfFile() {
    return this._root.getArray()[1].equals("EOF");
  }
  /**
   * JSONValue(float,String,Value*,Array,null,true,false)
   * ParseString(), ParseObject(), ParseArray()
   *
   * @param   buffer      JSON
   * @param   length      
   * @param   begin       
   * @param   outEndPos   
   * @return      Value
   */
  parseValue(buffer, length2, begin, outEndPos) {
    if (this._error) return null;
    let o = null;
    let i = begin;
    let f2;
    for (; i < length2; i++) {
      const c2 = buffer[i];
      switch (c2) {
        case "-":
        case ".":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          const afterString = new Array(1);
          f2 = strtod(buffer.slice(i), afterString);
          outEndPos[0] = buffer.indexOf(afterString[0]);
          return new JsonFloat(f2);
        }
        case '"':
          return new JsonString(
            this.parseString(buffer, length2, i + 1, outEndPos)
          );
        case "[":
          o = this.parseArray(buffer, length2, i + 1, outEndPos);
          return o;
        case "{":
          o = this.parseObject(buffer, length2, i + 1, outEndPos);
          return o;
        case "n":
          if (i + 3 < length2) {
            o = new JsonNullvalue();
            outEndPos[0] = i + 4;
          } else {
            this._error = "parse null";
          }
          return o;
        case "t":
          if (i + 3 < length2) {
            o = JsonBoolean.trueValue;
            outEndPos[0] = i + 4;
          } else {
            this._error = "parse true";
          }
          return o;
        case "f":
          if (i + 4 < length2) {
            o = JsonBoolean.falseValue;
            outEndPos[0] = i + 5;
          } else {
            this._error = "illegal ',' position";
          }
          return o;
        case ",":
          this._error = "illegal ',' position";
          return null;
        case "]":
          outEndPos[0] = i;
          return null;
        case "\n":
          this._lineCount++;
      }
    }
    this._error = "illegal end of value";
    return null;
  }
  /**
   * "
   *
   * @param   string  ->  
   * @param   length  ->  
   * @param   begin   ->  
   * @param  outEndPos   ->  
   * @return      F
   */
  parseString(string, length2, begin, outEndPos) {
    if (this._error) {
      return null;
    }
    if (!string) {
      this._error = "string is null";
      return null;
    }
    let i = begin;
    let c2, c22;
    const ret = new csmString("");
    let bufStart = begin;
    for (; i < length2; i++) {
      c2 = string[i];
      switch (c2) {
        case '"': {
          outEndPos[0] = i + 1;
          ret.append(string.slice(bufStart), i - bufStart);
          return ret.s;
        }
        case "//": {
          i++;
          if (i - 1 > bufStart) {
            ret.append(string.slice(bufStart), i - bufStart);
          }
          bufStart = i + 1;
          if (i < length2) {
            c22 = string[i];
            switch (c22) {
              case "\\":
                ret.expansion(1, "\\");
                break;
              case '"':
                ret.expansion(1, '"');
                break;
              case "/":
                ret.expansion(1, "/");
                break;
              case "b":
                ret.expansion(1, "\b");
                break;
              case "f":
                ret.expansion(1, "\f");
                break;
              case "n":
                ret.expansion(1, "\n");
                break;
              case "r":
                ret.expansion(1, "\r");
                break;
              case "t":
                ret.expansion(1, "	");
                break;
              case "u":
                this._error = "parse string/unicord escape not supported";
                break;
            }
          } else {
            this._error = "parse string/escape error";
          }
        }
      }
    }
    this._error = "parse string/illegal end";
    return null;
  }
  /**
   * JSONValue
   *
   * @param buffer    JSON
   * @param length    
   * @param begin     
   * @param outEndPos 
   * @return Value
   */
  parseObject(buffer, length2, begin, outEndPos) {
    if (this._error) {
      return null;
    }
    if (!buffer) {
      this._error = "buffer is null";
      return null;
    }
    const ret = new JsonMap();
    let key = "";
    let i = begin;
    let c2 = "";
    const localRetEndPos2 = Array(1);
    let ok2 = false;
    for (; i < length2; i++) {
      FOR_LOOP: for (; i < length2; i++) {
        c2 = buffer[i];
        switch (c2) {
          case '"':
            key = this.parseString(buffer, length2, i + 1, localRetEndPos2);
            if (this._error) {
              return null;
            }
            i = localRetEndPos2[0];
            ok2 = true;
            break FOR_LOOP;
          case "}":
            outEndPos[0] = i + 1;
            return ret;
          case ":":
            this._error = "illegal ':' position";
            break;
          case "\n":
            this._lineCount++;
        }
      }
      if (!ok2) {
        this._error = "key not found";
        return null;
      }
      ok2 = false;
      FOR_LOOP2: for (; i < length2; i++) {
        c2 = buffer[i];
        switch (c2) {
          case ":":
            ok2 = true;
            i++;
            break FOR_LOOP2;
          case "}":
            this._error = "illegal '}' position";
            break;
          case "\n":
            this._lineCount++;
        }
      }
      if (!ok2) {
        this._error = "':' not found";
        return null;
      }
      const value = this.parseValue(buffer, length2, i, localRetEndPos2);
      if (this._error) {
        return null;
      }
      i = localRetEndPos2[0];
      ret.put(key, value);
      FOR_LOOP3: for (; i < length2; i++) {
        c2 = buffer[i];
        switch (c2) {
          case ",":
            break FOR_LOOP3;
          case "}":
            outEndPos[0] = i + 1;
            return ret;
          case "\n":
            this._lineCount++;
        }
      }
    }
    this._error = "illegal end of perseObject";
    return null;
  }
  /**
   * "
   * @param buffer    JSON
   * @param length    
   * @param begin     
   * @param outEndPos 
   * @return Value
   */
  parseArray(buffer, length2, begin, outEndPos) {
    if (this._error) {
      return null;
    }
    if (!buffer) {
      this._error = "buffer is null";
      return null;
    }
    let ret = new JsonArray();
    let i = begin;
    let c2;
    const localRetEndpos2 = new Array(1);
    for (; i < length2; i++) {
      const value = this.parseValue(buffer, length2, i, localRetEndpos2);
      if (this._error) {
        return null;
      }
      i = localRetEndpos2[0];
      if (value) {
        ret.add(value);
      }
      FOR_LOOP: for (; i < length2; i++) {
        c2 = buffer[i];
        switch (c2) {
          case ",":
            break FOR_LOOP;
          case "]":
            outEndPos[0] = i + 1;
            return ret;
          case "\n":
            ++this._lineCount;
        }
      }
    }
    ret = void 0;
    this._error = "illegal end of parseObject";
    return null;
  }
  // 
}
class JsonFloat extends Value$2 {
  /**
   * 
   */
  constructor(v2) {
    super();
    this._value = v2;
  }
  /**
   * Valuetrue
   */
  isFloat() {
    return true;
  }
  /**
   * (csmString)
   */
  getString(defaultValue, indent) {
    const strbuf = "\0";
    this._value = parseFloat(strbuf);
    this._stringBuffer = strbuf;
    return this._stringBuffer;
  }
  /**
   * (number)
   */
  toInt(defaultValue = 0) {
    return parseInt(this._value.toString());
  }
  /**
   * (number)
   */
  toFloat(defaultValue = 0) {
    return this._value;
  }
  equals(value) {
    if ("number" === typeof value) {
      if (Math.round(value)) {
        return false;
      } else {
        return value == this._value;
      }
    }
    return false;
  }
  // JSON
}
class JsonBoolean extends Value$2 {
  /**
   * Valuetrue
   */
  isBool() {
    return true;
  }
  /**
   * (boolean)
   */
  toBoolean(defaultValue = false) {
    return this._boolValue;
  }
  /**
   * (csmString)
   */
  getString(defaultValue, indent) {
    this._stringBuffer = this._boolValue ? "true" : "false";
    return this._stringBuffer;
  }
  equals(value) {
    if ("boolean" === typeof value) {
      return value == this._boolValue;
    }
    return false;
  }
  /**
   * Valuetrue, 
   */
  isStatic() {
    return true;
  }
  /**
   * 
   */
  constructor(v2) {
    super();
    this._boolValue = v2;
  }
  // JSON
}
class JsonString extends Value$2 {
  constructor(s) {
    super();
    if ("string" === typeof s) {
      this._stringBuffer = s;
    }
    if (s instanceof csmString) {
      this._stringBuffer = s.s;
    }
  }
  /**
   * Valuetrue
   */
  isString() {
    return true;
  }
  /**
   * (csmString)
   */
  getString(defaultValue, indent) {
    return this._stringBuffer;
  }
  equals(value) {
    if ("string" === typeof value) {
      return this._stringBuffer == value;
    }
    if (value instanceof csmString) {
      return this._stringBuffer == value.s;
    }
    return false;
  }
}
class JsonError extends JsonString {
  /**
   * Valuetrue
   */
  isStatic() {
    return this._isStatic;
  }
  /**
   * 
   */
  setErrorNotForClientCall(s) {
    this._stringBuffer = s;
    return this;
  }
  /**
   * 
   */
  constructor(s, isStatic) {
    if ("string" === typeof s) {
      super(s);
    } else {
      super(s);
    }
    this._isStatic = isStatic;
  }
  /**
   * Valuetrue
   */
  isError() {
    return true;
  }
  // Value
}
class JsonNullvalue extends Value$2 {
  /**
   * ValueNULLtrue
   */
  isNull() {
    return true;
  }
  /**
   * (csmString)
   */
  getString(defaultValue, indent) {
    return this._stringBuffer;
  }
  /**
   * Valuetrue, 
   */
  isStatic() {
    return true;
  }
  /**
   * Value
   */
  setErrorNotForClientCall(s) {
    this._stringBuffer = s;
    return JsonError.nullValue;
  }
  /**
   * 
   */
  constructor() {
    super();
    this._stringBuffer = "NullValue";
  }
}
class JsonArray extends Value$2 {
  /**
   * 
   */
  constructor() {
    super();
    this._array = new csmVector();
  }
  /**
   * 
   */
  release() {
    for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.preIncrement()) {
      let v2 = ite.ptr();
      if (v2 && !v2.isStatic()) {
        v2 = void 0;
        v2 = null;
      }
    }
  }
  /**
   * Valuetrue
   */
  isArray() {
    return true;
  }
  /**
   * [index]
   */
  getValueByIndex(index) {
    if (index < 0 || this._array.getSize() <= index) {
      return Value$2.errorValue.setErrorNotForClientCall(
        CSM_JSON_ERROR_INDEX_OF_BOUNDS
      );
    }
    const v2 = this._array.at(index);
    if (v2 == null) {
      return Value$2.nullValue;
    }
    return v2;
  }
  /**
   * [string | csmString]
   */
  getValueByString(s) {
    return Value$2.errorValue.setErrorNotForClientCall(
      CSM_JSON_ERROR_TYPE_MISMATCH
    );
  }
  /**
   * (csmString)
   */
  getString(defaultValue, indent) {
    const stringBuffer = indent + "[\n";
    for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.increment()) {
      const v2 = ite.ptr();
      this._stringBuffer += indent + "" + v2.getString(indent + " ") + "\n";
    }
    this._stringBuffer = stringBuffer + indent + "]\n";
    return this._stringBuffer;
  }
  /**
   * 
   * @param v 
   */
  add(v2) {
    this._array.pushBack(v2);
  }
  /**
   * (csmVector<Value>)
   */
  getVector(defaultValue = null) {
    return this._array;
  }
  /**
   * 
   */
  getSize() {
    return this._array.getSize();
  }
  // JSON
}
class JsonMap extends Value$2 {
  /**
   * 
   */
  constructor() {
    super();
    this._map = new csmMap();
  }
  /**
   * 
   */
  release() {
    const ite = this._map.begin();
    while (ite.notEqual(this._map.end())) {
      let v2 = ite.ptr().second;
      if (v2 && !v2.isStatic()) {
        v2 = void 0;
        v2 = null;
      }
      ite.preIncrement();
    }
  }
  /**
   * ValueMaptrue
   */
  isMap() {
    return true;
  }
  /**
   * [string | csmString]
   */
  getValueByString(s) {
    if (s instanceof csmString) {
      const ret = this._map.getValue(s.s);
      if (ret == null) {
        return Value$2.nullValue;
      }
      return ret;
    }
    for (let iter = this._map.begin(); iter.notEqual(this._map.end()); iter.preIncrement()) {
      if (iter.ptr().first == s) {
        if (iter.ptr().second == null) {
          return Value$2.nullValue;
        }
        return iter.ptr().second;
      }
    }
    return Value$2.nullValue;
  }
  /**
   * [index]
   */
  getValueByIndex(index) {
    return Value$2.errorValue.setErrorNotForClientCall(
      CSM_JSON_ERROR_TYPE_MISMATCH
    );
  }
  /**
   * (csmString)
   */
  getString(defaultValue, indent) {
    this._stringBuffer = indent + "{\n";
    const ite = this._map.begin();
    while (ite.notEqual(this._map.end())) {
      const key = ite.ptr().first;
      const v2 = ite.ptr().second;
      this._stringBuffer += indent + " " + key + " : " + v2.getString(indent + "   ") + " \n";
      ite.preIncrement();
    }
    this._stringBuffer += indent + "}\n";
    return this._stringBuffer;
  }
  /**
   * Map
   */
  getMap(defaultValue) {
    return this._map;
  }
  /**
   * Map
   */
  put(key, v2) {
    this._map.setValue(key, v2);
  }
  /**
   * Map
   */
  getKeys() {
    if (!this._keys) {
      this._keys = new csmVector();
      const ite = this._map.begin();
      while (ite.notEqual(this._map.end())) {
        const key = ite.ptr().first;
        this._keys.pushBack(key);
        ite.preIncrement();
      }
    }
    return this._keys;
  }
  /**
   * Map
   */
  getSize() {
    return this._keys.getSize();
  }
  // JSON
}
var Live2DCubismFramework$v;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismJson = CubismJson;
  Live2DCubismFramework2.JsonArray = JsonArray;
  Live2DCubismFramework2.JsonBoolean = JsonBoolean;
  Live2DCubismFramework2.JsonError = JsonError;
  Live2DCubismFramework2.JsonFloat = JsonFloat;
  Live2DCubismFramework2.JsonMap = JsonMap;
  Live2DCubismFramework2.JsonNullvalue = JsonNullvalue;
  Live2DCubismFramework2.JsonString = JsonString;
  Live2DCubismFramework2.Value = Value$2;
})(Live2DCubismFramework$v || (Live2DCubismFramework$v = {}));
function strtod(s, endPtr) {
  let index = 0;
  for (let i = 1; ; i++) {
    const testC = s.slice(i - 1, i);
    if (testC == "e" || testC == "-" || testC == "E") {
      continue;
    }
    const test = s.substring(0, i);
    const number = Number(test);
    if (isNaN(number)) {
      break;
    }
    index = i;
  }
  let d2 = parseFloat(s);
  if (isNaN(d2)) {
    d2 = NaN;
  }
  endPtr[0] = s.slice(index);
  return d2;
}
let s_isStarted = false;
let s_isInitialized = false;
let s_option = null;
let s_cubismIdManager = null;
const Constant = Object.freeze({
  vertexOffset: 0,
  // 
  vertexStep: 2
  // 
});
function csmDelete(address) {
  if (!address) {
    return;
  }
  address = void 0;
}
class CubismFramework {
  /**
   * Cubism FrameworkAPI
   *  API
   *  
   *
   * @param    option      Option
   *
   * @return   true
   */
  static startUp(option = null) {
    if (s_isStarted) {
      CubismLogInfo("CubismFramework.startUp() is already done.");
      return s_isStarted;
    }
    s_option = option;
    if (s_option != null) {
      Live2DCubismCore.Logging.csmSetLogFunction(s_option.logFunction);
    }
    s_isStarted = true;
    if (s_isStarted) {
      const version = Live2DCubismCore.Version.csmGetVersion();
      const major = (version & 4278190080) >> 24;
      const minor = (version & 16711680) >> 16;
      const patch = version & 65535;
      const versionNumber = version;
      CubismLogInfo(
        `Live2D Cubism Core version: {0}.{1}.{2} ({3})`,
        ("00" + major).slice(-2),
        ("00" + minor).slice(-2),
        ("0000" + patch).slice(-4),
        versionNumber
      );
    }
    CubismLogInfo("CubismFramework.startUp() is complete.");
    return s_isStarted;
  }
  /**
   * StartUp()CubismFramework
   * Dispose()CubismFramework
   */
  static cleanUp() {
    s_isStarted = false;
    s_isInitialized = false;
    s_option = null;
    s_cubismIdManager = null;
  }
  /**
   * Cubism Framework<br>
   *     Initialize()Dispose()
   *
   * @param memorySize  [byte(s)]
   *    
   *    1024*1024*16 byte(16MB)
   *    1024*1024*16 byte
   */
  static initialize(memorySize = 0) {
    CSM_ASSERT(s_isStarted);
    if (!s_isStarted) {
      CubismLogWarning("CubismFramework is not started.");
      return;
    }
    if (s_isInitialized) {
      CubismLogWarning(
        "CubismFramework.initialize() skipped, already initialized."
      );
      return;
    }
    Value$2.staticInitializeNotForClientCall();
    s_cubismIdManager = new CubismIdManager();
    Live2DCubismCore.Memory.initializeAmountOfMemory(memorySize);
    s_isInitialized = true;
    CubismLogInfo("CubismFramework.initialize() is complete.");
  }
  /**
   * Cubism Framework
   *      
   *      
   */
  static dispose() {
    CSM_ASSERT(s_isStarted);
    if (!s_isStarted) {
      CubismLogWarning("CubismFramework is not started.");
      return;
    }
    if (!s_isInitialized) {
      CubismLogWarning("CubismFramework.dispose() skipped, not initialized.");
      return;
    }
    Value$2.staticReleaseNotForClientCall();
    s_cubismIdManager.release();
    s_cubismIdManager = null;
    CubismRenderer.staticRelease();
    s_isInitialized = false;
    CubismLogInfo("CubismFramework.dispose() is complete.");
  }
  /**
   * Cubism FrameworkAPI
   * @return APItrue
   */
  static isStarted() {
    return s_isStarted;
  }
  /**
   * Cubism Framework
   * @return true
   */
  static isInitialized() {
    return s_isInitialized;
  }
  /**
   * Core API
   *
   * @praram message 
   */
  static coreLogFunction(message) {
    if (!Live2DCubismCore.Logging.csmGetLogFunction()) {
      return;
    }
    Live2DCubismCore.Logging.csmGetLogFunction()(message);
  }
  /**
   * 
   *
   * @return  
   */
  static getLoggingLevel() {
    if (s_option != null) {
      return s_option.loggingLevel;
    }
    return 5;
  }
  /**
   * ID
   * @return CubismManager
   */
  static getIdManager() {
    return s_cubismIdManager;
  }
  /**
   * 
   * 
   */
  constructor() {
  }
}
class Option {
  // 
}
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["LogLevel_Verbose"] = 0] = "LogLevel_Verbose";
  LogLevel2[LogLevel2["LogLevel_Debug"] = 1] = "LogLevel_Debug";
  LogLevel2[LogLevel2["LogLevel_Info"] = 2] = "LogLevel_Info";
  LogLevel2[LogLevel2["LogLevel_Warning"] = 3] = "LogLevel_Warning";
  LogLevel2[LogLevel2["LogLevel_Error"] = 4] = "LogLevel_Error";
  LogLevel2[LogLevel2["LogLevel_Off"] = 5] = "LogLevel_Off";
  return LogLevel2;
})(LogLevel || {});
var Live2DCubismFramework$u;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.Constant = Constant;
  Live2DCubismFramework2.csmDelete = csmDelete;
  Live2DCubismFramework2.CubismFramework = CubismFramework;
})(Live2DCubismFramework$u || (Live2DCubismFramework$u = {}));
const CanvasSize = "auto";
const ViewScale = 1;
let CurrentKScale = ViewScale;
const ViewMaxScale = 2;
const ViewMinScale = 0.8;
const ViewLogicalLeft = -1;
const ViewLogicalRight = 1;
const ViewLogicalBottom = -1;
const ViewLogicalTop = 1;
const ViewLogicalMaxLeft = -2;
const ViewLogicalMaxRight = 2;
const ViewLogicalMaxBottom = -2;
const ViewLogicalMaxTop = 2;
let ResourcesPath = "";
let ModelDir = [];
let ModelFileNames = [];
function updateModelConfig(resourcePath, modelDirectory, modelFileName, kScale) {
  console.log("Updating model config:", { resourcePath, modelDirectory, modelFileName, kScale });
  ResourcesPath = resourcePath;
  ModelDir = [modelDirectory];
  ModelFileNames = [modelFileName];
  if (kScale !== void 0) {
    CurrentKScale = kScale;
  }
  ModelDirSize = ModelDir.length;
}
let ModelDirSize = ModelDir.length;
const BackImageName = "back_class_normal.png";
const GearImageName = "icon_gear.png";
const PowerImageName = "CloseNormal.png";
const MotionGroupIdle = "Idle";
const MotionGroupTapBody = "TapBody";
const HitAreaNameHead = "Head";
const HitAreaNameBody = "Body";
const PriorityNone = 0;
const PriorityIdle = 1;
const PriorityNormal = 2;
const PriorityForce = 3;
const MOCConsistencyValidationEnable = true;
const DebugLogEnable = false;
const DebugTouchLogEnable = false;
const CubismLoggingLevel = LogLevel.LogLevel_Verbose;
const RenderTargetWidth = 1900;
const RenderTargetHeight = 1e3;
const ENABLE_LIMITED_FRAME_RATE = true;
const LIMITED_FRAME_RATE = 60;
const LAppDefine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BackImageName,
  CanvasSize,
  CubismLoggingLevel,
  get CurrentKScale() {
    return CurrentKScale;
  },
  DebugLogEnable,
  DebugTouchLogEnable,
  ENABLE_LIMITED_FRAME_RATE,
  GearImageName,
  HitAreaNameBody,
  HitAreaNameHead,
  LIMITED_FRAME_RATE,
  MOCConsistencyValidationEnable,
  get ModelDir() {
    return ModelDir;
  },
  get ModelDirSize() {
    return ModelDirSize;
  },
  get ModelFileNames() {
    return ModelFileNames;
  },
  MotionGroupIdle,
  MotionGroupTapBody,
  PowerImageName,
  PriorityForce,
  PriorityIdle,
  PriorityNone,
  PriorityNormal,
  RenderTargetHeight,
  RenderTargetWidth,
  get ResourcesPath() {
    return ResourcesPath;
  },
  ViewLogicalBottom,
  ViewLogicalLeft,
  ViewLogicalMaxBottom,
  ViewLogicalMaxLeft,
  ViewLogicalMaxRight,
  ViewLogicalMaxTop,
  ViewLogicalRight,
  ViewLogicalTop,
  ViewMaxScale,
  ViewMinScale,
  ViewScale,
  updateModelConfig
}, Symbol.toStringTag, { value: "Module" }));
const useAudioTask = () => {
  const { t: t2 } = useTranslation();
  const { aiState: aiState2, backendSynthComplete, setBackendSynthComplete } = useAiState();
  const { setSubtitleText } = useSubtitle();
  const { appendResponse, appendAIMessage } = useChatHistory();
  const { sendMessage } = useWebSocket();
  const { setExpression } = useLive2DExpression();
  const stateRef = reactExports.useRef({
    aiState: aiState2,
    setSubtitleText,
    appendResponse,
    appendAIMessage
  });
  stateRef.current = {
    aiState: aiState2,
    setSubtitleText,
    appendResponse,
    appendAIMessage
  };
  const stopCurrentAudioAndLipSync = reactExports.useCallback(() => {
    audioManager.stopCurrentAudioAndLipSync();
  }, []);
  const handleAudioPlayback = (options2) => new Promise((resolve2) => {
    const {
      aiState: currentAiState,
      setSubtitleText: updateSubtitle,
      appendResponse: appendText,
      appendAIMessage: appendAI
    } = stateRef.current;
    if (currentAiState === "interrupted") {
      console.warn("Audio playback blocked by interruption state.");
      resolve2();
      return;
    }
    const { audioBase64, displayText, expressions, forwarded } = options2;
    if (displayText) {
      appendText(displayText.text);
      appendAI(displayText.text, displayText.name, displayText.avatar);
      if (audioBase64) {
        updateSubtitle(displayText.text);
      }
      if (!forwarded) {
        sendMessage({
          type: "audio-play-start",
          display_text: displayText,
          forwarded: true
        });
      }
    }
    try {
      if (audioBase64) {
        const audioDataUrl = `data:audio/wav;base64,${audioBase64}`;
        const live2dManager = window.getLive2DManager?.();
        if (!live2dManager) {
          console.error("Live2D manager not found");
          resolve2();
          return;
        }
        const model = live2dManager.getModel(0);
        if (!model) {
          console.error("Live2D model not found at index 0");
          resolve2();
          return;
        }
        console.log("Found model for audio playback");
        if (!model._wavFileHandler) {
          console.warn("Model does not have _wavFileHandler for lip sync");
        } else {
          console.log("Model has _wavFileHandler available");
        }
        const lappAdapter = window.getLAppAdapter?.();
        if (lappAdapter && expressions?.[0] !== void 0) {
          setExpression(
            expressions[0],
            lappAdapter,
            `Set expression to: ${expressions[0]}`
          );
        }
        if (LAppDefine && PriorityNormal) {
          console.log("Starting random 'Talk' motion");
          model.startRandomMotion(
            "Talk",
            PriorityNormal
          );
        } else {
          console.warn("LAppDefine.PriorityNormal not found - cannot start talk motion");
        }
        const audio = new Audio(audioDataUrl);
        audioManager.setCurrentAudio(audio, model);
        let isFinished = false;
        const cleanup = () => {
          audioManager.clearCurrentAudio(audio);
          if (!isFinished) {
            isFinished = true;
            resolve2();
          }
        };
        const lipSyncScale = 2;
        audio.addEventListener("canplaythrough", () => {
          if (stateRef.current.aiState === "interrupted" || !audioManager.hasCurrentAudio()) {
            console.warn("Audio playback cancelled due to interruption or audio was stopped");
            cleanup();
            return;
          }
          console.log("Starting audio playback with lip sync");
          audio.play().catch((err) => {
            console.error("Audio play error:", err);
            cleanup();
          });
          if (model._wavFileHandler) {
            if (!model._wavFileHandler._initialized) {
              console.log("Applying enhanced lip sync");
              model._wavFileHandler._initialized = true;
              const originalUpdate = model._wavFileHandler.update.bind(model._wavFileHandler);
              model._wavFileHandler.update = function(deltaTimeSeconds) {
                const result = originalUpdate(deltaTimeSeconds);
                this._lastRms = Math.min(2, this._lastRms * lipSyncScale);
                return result;
              };
            }
            if (audioManager.hasCurrentAudio()) {
              model._wavFileHandler.start(audioDataUrl);
            } else {
              console.warn("WavFileHandler start skipped - audio was stopped");
            }
          }
        });
        audio.addEventListener("ended", () => {
          console.log("Audio playback completed");
          cleanup();
        });
        audio.addEventListener("error", (error2) => {
          console.error("Audio playback error:", error2);
          cleanup();
        });
        audio.load();
      } else {
        resolve2();
      }
    } catch (error2) {
      console.error("Audio playback setup error:", error2);
      toaster.create({
        title: `${t2("error.audioPlayback")}: ${error2}`,
        type: "error",
        duration: 2e3
      });
      resolve2();
    }
  });
  reactExports.useEffect(() => {
    let isMounted = true;
    const handleComplete = async () => {
      await audioTaskQueue.waitForCompletion();
      if (isMounted && backendSynthComplete) {
        stopCurrentAudioAndLipSync();
        sendMessage({ type: "frontend-playback-complete" });
        setBackendSynthComplete(false);
      }
    };
    handleComplete();
    return () => {
      isMounted = false;
    };
  }, [backendSynthComplete, sendMessage, setBackendSynthComplete, stopCurrentAudioAndLipSync]);
  const addAudioTask = async (options2) => {
    const { aiState: currentState } = stateRef.current;
    if (currentState === "interrupted") {
      console.log("Skipping audio task due to interrupted state");
      return;
    }
    console.log(`Adding audio task ${options2.displayText?.text} to queue`);
    audioTaskQueue.addTask(() => handleAudioPlayback(options2));
  };
  return {
    addAudioTask,
    appendResponse,
    stopCurrentAudioAndLipSync
  };
};
const useInterrupt = () => {
  const { aiState: aiState2, setAiState } = useAiState();
  const { sendMessage } = useWebSocket();
  const { fullResponse, clearResponse } = useChatHistory();
  const { subtitleText, setSubtitleText } = useSubtitle();
  const { stopCurrentAudioAndLipSync } = useAudioTask();
  const interrupt = (sendSignal = true) => {
    if (aiState2 !== "thinking-speaking") return;
    console.log("Interrupting conversation chain");
    stopCurrentAudioAndLipSync();
    audioTaskQueue.clearQueue();
    setAiState("interrupted");
    if (sendSignal) {
      sendMessage({
        type: "interrupt-signal",
        text: fullResponse
      });
    }
    clearResponse();
    if (subtitleText === "Thinking...") {
      setSubtitleText("");
    }
    console.log("Interrupted!");
  };
  return { interrupt };
};
let canvas = null;
let gl = null;
let s_instance$4 = null;
class LAppGlManager {
  /**
   * 
   * 
   *
   * @return 
   */
  static getInstance() {
    if (s_instance$4 == null) {
      s_instance$4 = new LAppGlManager();
    }
    return s_instance$4;
  }
  /**
   * 
   */
  static releaseInstance() {
    if (s_instance$4 != null) {
      s_instance$4.release();
    }
    s_instance$4 = null;
  }
  constructor() {
    canvas = document.getElementById("canvas");
    if (!canvas) {
      console.warn("Canvas element not found during LAppGlManager initialization");
      return;
    }
    gl = canvas.getContext("webgl2");
    if (!gl) {
      alert("Cannot initialize WebGL. This browser does not support.");
      gl = null;
      document.body.innerHTML = "This browser does not support the <code>&lt;canvas&gt;</code> element.";
    }
  }
  /**
   * 
   */
  release() {
  }
}
const CubismDefaultParameterId = Object.freeze({
  // ID
  HitAreaPrefix: "HitArea",
  HitAreaHead: "Head",
  HitAreaBody: "Body",
  PartsIdCore: "Parts01Core",
  PartsArmPrefix: "Parts01Arm_",
  PartsArmLPrefix: "Parts01ArmL_",
  PartsArmRPrefix: "Parts01ArmR_",
  // ID
  ParamAngleX: "ParamAngleX",
  ParamAngleY: "ParamAngleY",
  ParamAngleZ: "ParamAngleZ",
  ParamEyeLOpen: "ParamEyeLOpen",
  ParamEyeLSmile: "ParamEyeLSmile",
  ParamEyeROpen: "ParamEyeROpen",
  ParamEyeRSmile: "ParamEyeRSmile",
  ParamEyeBallX: "ParamEyeBallX",
  ParamEyeBallY: "ParamEyeBallY",
  ParamEyeBallForm: "ParamEyeBallForm",
  ParamBrowLY: "ParamBrowLY",
  ParamBrowRY: "ParamBrowRY",
  ParamBrowLX: "ParamBrowLX",
  ParamBrowRX: "ParamBrowRX",
  ParamBrowLAngle: "ParamBrowLAngle",
  ParamBrowRAngle: "ParamBrowRAngle",
  ParamBrowLForm: "ParamBrowLForm",
  ParamBrowRForm: "ParamBrowRForm",
  ParamMouthForm: "ParamMouthForm",
  ParamMouthOpenY: "ParamMouthOpenY",
  ParamCheek: "ParamCheek",
  ParamBodyAngleX: "ParamBodyAngleX",
  ParamBodyAngleY: "ParamBodyAngleY",
  ParamBodyAngleZ: "ParamBodyAngleZ",
  ParamBreath: "ParamBreath",
  ParamArmLA: "ParamArmLA",
  ParamArmRA: "ParamArmRA",
  ParamArmLB: "ParamArmLB",
  ParamArmRB: "ParamArmRB",
  ParamHandL: "ParamHandL",
  ParamHandR: "ParamHandR",
  ParamHairFront: "ParamHairFront",
  ParamHairSide: "ParamHairSide",
  ParamHairBack: "ParamHairBack",
  ParamHairFluffy: "ParamHairFluffy",
  ParamShoulderY: "ParamShoulderY",
  ParamBustX: "ParamBustX",
  ParamBustY: "ParamBustY",
  ParamBaseX: "ParamBaseX",
  ParamBaseY: "ParamBaseY",
  ParamNONE: "NONE:"
});
var Live2DCubismFramework$t;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.HitAreaBody = CubismDefaultParameterId.HitAreaBody;
  Live2DCubismFramework2.HitAreaHead = CubismDefaultParameterId.HitAreaHead;
  Live2DCubismFramework2.HitAreaPrefix = CubismDefaultParameterId.HitAreaPrefix;
  Live2DCubismFramework2.ParamAngleX = CubismDefaultParameterId.ParamAngleX;
  Live2DCubismFramework2.ParamAngleY = CubismDefaultParameterId.ParamAngleY;
  Live2DCubismFramework2.ParamAngleZ = CubismDefaultParameterId.ParamAngleZ;
  Live2DCubismFramework2.ParamArmLA = CubismDefaultParameterId.ParamArmLA;
  Live2DCubismFramework2.ParamArmLB = CubismDefaultParameterId.ParamArmLB;
  Live2DCubismFramework2.ParamArmRA = CubismDefaultParameterId.ParamArmRA;
  Live2DCubismFramework2.ParamArmRB = CubismDefaultParameterId.ParamArmRB;
  Live2DCubismFramework2.ParamBaseX = CubismDefaultParameterId.ParamBaseX;
  Live2DCubismFramework2.ParamBaseY = CubismDefaultParameterId.ParamBaseY;
  Live2DCubismFramework2.ParamBodyAngleX = CubismDefaultParameterId.ParamBodyAngleX;
  Live2DCubismFramework2.ParamBodyAngleY = CubismDefaultParameterId.ParamBodyAngleY;
  Live2DCubismFramework2.ParamBodyAngleZ = CubismDefaultParameterId.ParamBodyAngleZ;
  Live2DCubismFramework2.ParamBreath = CubismDefaultParameterId.ParamBreath;
  Live2DCubismFramework2.ParamBrowLAngle = CubismDefaultParameterId.ParamBrowLAngle;
  Live2DCubismFramework2.ParamBrowLForm = CubismDefaultParameterId.ParamBrowLForm;
  Live2DCubismFramework2.ParamBrowLX = CubismDefaultParameterId.ParamBrowLX;
  Live2DCubismFramework2.ParamBrowLY = CubismDefaultParameterId.ParamBrowLY;
  Live2DCubismFramework2.ParamBrowRAngle = CubismDefaultParameterId.ParamBrowRAngle;
  Live2DCubismFramework2.ParamBrowRForm = CubismDefaultParameterId.ParamBrowRForm;
  Live2DCubismFramework2.ParamBrowRX = CubismDefaultParameterId.ParamBrowRX;
  Live2DCubismFramework2.ParamBrowRY = CubismDefaultParameterId.ParamBrowRY;
  Live2DCubismFramework2.ParamBustX = CubismDefaultParameterId.ParamBustX;
  Live2DCubismFramework2.ParamBustY = CubismDefaultParameterId.ParamBustY;
  Live2DCubismFramework2.ParamCheek = CubismDefaultParameterId.ParamCheek;
  Live2DCubismFramework2.ParamEyeBallForm = CubismDefaultParameterId.ParamEyeBallForm;
  Live2DCubismFramework2.ParamEyeBallX = CubismDefaultParameterId.ParamEyeBallX;
  Live2DCubismFramework2.ParamEyeBallY = CubismDefaultParameterId.ParamEyeBallY;
  Live2DCubismFramework2.ParamEyeLOpen = CubismDefaultParameterId.ParamEyeLOpen;
  Live2DCubismFramework2.ParamEyeLSmile = CubismDefaultParameterId.ParamEyeLSmile;
  Live2DCubismFramework2.ParamEyeROpen = CubismDefaultParameterId.ParamEyeROpen;
  Live2DCubismFramework2.ParamEyeRSmile = CubismDefaultParameterId.ParamEyeRSmile;
  Live2DCubismFramework2.ParamHairBack = CubismDefaultParameterId.ParamHairBack;
  Live2DCubismFramework2.ParamHairFluffy = CubismDefaultParameterId.ParamHairFluffy;
  Live2DCubismFramework2.ParamHairFront = CubismDefaultParameterId.ParamHairFront;
  Live2DCubismFramework2.ParamHairSide = CubismDefaultParameterId.ParamHairSide;
  Live2DCubismFramework2.ParamHandL = CubismDefaultParameterId.ParamHandL;
  Live2DCubismFramework2.ParamHandR = CubismDefaultParameterId.ParamHandR;
  Live2DCubismFramework2.ParamMouthForm = CubismDefaultParameterId.ParamMouthForm;
  Live2DCubismFramework2.ParamMouthOpenY = CubismDefaultParameterId.ParamMouthOpenY;
  Live2DCubismFramework2.ParamNONE = CubismDefaultParameterId.ParamNONE;
  Live2DCubismFramework2.ParamShoulderY = CubismDefaultParameterId.ParamShoulderY;
  Live2DCubismFramework2.PartsArmLPrefix = CubismDefaultParameterId.PartsArmLPrefix;
  Live2DCubismFramework2.PartsArmPrefix = CubismDefaultParameterId.PartsArmPrefix;
  Live2DCubismFramework2.PartsArmRPrefix = CubismDefaultParameterId.PartsArmRPrefix;
  Live2DCubismFramework2.PartsIdCore = CubismDefaultParameterId.PartsIdCore;
})(Live2DCubismFramework$t || (Live2DCubismFramework$t = {}));
class ICubismModelSetting {
}
var Live2DCubismFramework$s;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.ICubismModelSetting = ICubismModelSetting;
})(Live2DCubismFramework$s || (Live2DCubismFramework$s = {}));
const FileReferences = "FileReferences";
const Groups$1 = "Groups";
const Layout = "Layout";
const HitAreas = "HitAreas";
const Moc = "Moc";
const Textures = "Textures";
const Physics = "Physics";
const Pose = "Pose";
const Expressions = "Expressions";
const Motions = "Motions";
const UserData$2 = "UserData";
const Name = "Name";
const FilePath = "File";
const Id$4 = "Id";
const Ids = "Ids";
const SoundPath = "Sound";
const FadeInTime$1 = "FadeInTime";
const FadeOutTime$1 = "FadeOutTime";
const LipSync = "LipSync";
const EyeBlink = "EyeBlink";
class CubismModelSettingJson extends ICubismModelSetting {
  /**
   * 
   *
   * @param buffer    Model3Json
   * @param size      Model3Json
   */
  constructor(buffer, size2) {
    super();
    this._json = CubismJson.create(buffer, size2);
    if (this.getJson()) {
      this._jsonValue = new csmVector();
      this._jsonValue.pushBack(
        this.getJson().getRoot().getValueByString(Groups$1)
      );
      this._jsonValue.pushBack(
        this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Moc)
      );
      this._jsonValue.pushBack(
        this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Motions)
      );
      this._jsonValue.pushBack(
        this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Expressions)
      );
      this._jsonValue.pushBack(
        this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Textures)
      );
      this._jsonValue.pushBack(
        this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Physics)
      );
      this._jsonValue.pushBack(
        this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Pose)
      );
      this._jsonValue.pushBack(
        this.getJson().getRoot().getValueByString(HitAreas)
      );
    }
  }
  /**
   * 
   */
  release() {
    CubismJson.delete(this._json);
    this._jsonValue = null;
  }
  /**
   * CubismJson
   *
   * @return CubismJson
   */
  getJson() {
    return this._json;
  }
  /**
   * Moc
   * @return Moc
   */
  getModelFileName() {
    if (!this.isExistModelFile()) {
      return "";
    }
    return this._jsonValue.at(
      1
      /* FrequestNode_Moc */
    ).getRawString();
  }
  /**
   * 
   * 
   */
  getTextureCount() {
    if (!this.isExistTextureFiles()) {
      return 0;
    }
    return this._jsonValue.at(
      4
      /* FrequestNode_Textures */
    ).getSize();
  }
  /**
   * 
   * @return 
   */
  getTextureDirectory() {
    const texturePath = this._jsonValue.at(
      4
      /* FrequestNode_Textures */
    ).getValueByIndex(0).getRawString();
    const pathArray = texturePath.split("/");
    const arrayLength = pathArray.length - 1;
    let textureDirectoryStr = "";
    for (let i = 0; i < arrayLength; i++) {
      textureDirectoryStr += pathArray[i];
      if (i < arrayLength - 1) {
        textureDirectoryStr += "/";
      }
    }
    return textureDirectoryStr;
  }
  /**
   * 
   * @param index 
   * @return 
   */
  getTextureFileName(index) {
    return this._jsonValue.at(
      4
      /* FrequestNode_Textures */
    ).getValueByIndex(index).getRawString();
  }
  /**
   * 
   * @return 
   */
  getHitAreasCount() {
    if (!this.isExistHitAreas()) {
      return 0;
    }
    return this._jsonValue.at(
      7
      /* FrequestNode_HitAreas */
    ).getSize();
  }
  /**
   * ID
   *
   * @param index index
   * @return ID
   */
  getHitAreaId(index) {
    return CubismFramework.getIdManager().getId(
      this._jsonValue.at(
        7
        /* FrequestNode_HitAreas */
      ).getValueByIndex(index).getValueByString(Id$4).getRawString()
    );
  }
  /**
   * 
   * @param index 
   * @return 
   */
  getHitAreaName(index) {
    return this._jsonValue.at(
      7
      /* FrequestNode_HitAreas */
    ).getValueByIndex(index).getValueByString(Name).getRawString();
  }
  /**
   * 
   * @return 
   */
  getPhysicsFileName() {
    if (!this.isExistPhysicsFile()) {
      return "";
    }
    return this._jsonValue.at(
      5
      /* FrequestNode_Physics */
    ).getRawString();
  }
  /**
   * 
   * @return 
   */
  getPoseFileName() {
    if (!this.isExistPoseFile()) {
      return "";
    }
    return this._jsonValue.at(
      6
      /* FrequestNode_Pose */
    ).getRawString();
  }
  /**
   * 
   * @return 
   */
  getExpressionCount() {
    if (!this.isExistExpressionFile()) {
      return 0;
    }
    return this._jsonValue.at(
      3
      /* FrequestNode_Expressions */
    ).getSize();
  }
  /**
   * 
   * @param index 
   * @return 
   */
  getExpressionName(index) {
    return this._jsonValue.at(
      3
      /* FrequestNode_Expressions */
    ).getValueByIndex(index).getValueByString(Name).getRawString();
  }
  /**
   * 
   * @param index 
   * @return 
   */
  getExpressionFileName(index) {
    return this._jsonValue.at(
      3
      /* FrequestNode_Expressions */
    ).getValueByIndex(index).getValueByString(FilePath).getRawString();
  }
  /**
   * 
   * @return 
   */
  getMotionGroupCount() {
    if (!this.isExistMotionGroups()) {
      return 0;
    }
    return this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getKeys().getSize();
  }
  /**
   * 
   * @param index 
   * @return 
   */
  getMotionGroupName(index) {
    if (!this.isExistMotionGroups()) {
      return null;
    }
    return this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getKeys().at(index);
  }
  /**
   * 
   * @param groupName 
   * @return 
   */
  getMotionCount(groupName) {
    if (!this.isExistMotionGroupName(groupName)) {
      return 0;
    }
    return this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName).getSize();
  }
  /**
   * 
   * @param groupName 
   * @param index     
   * @return 
   */
  getMotionFileName(groupName, index) {
    if (!this.isExistMotionGroupName(groupName)) {
      return "";
    }
    return this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName).getValueByIndex(index).getValueByString(FilePath).getRawString();
  }
  /**
   * 
   * @param groupName 
   * @param index 
   * @return 
   */
  getMotionSoundFileName(groupName, index) {
    if (!this.isExistMotionSoundFile(groupName, index)) {
      return "";
    }
    return this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName).getValueByIndex(index).getValueByString(SoundPath).getRawString();
  }
  /**
   * 
   * @param groupName 
   * @param index 
   * @return []
   */
  getMotionFadeInTimeValue(groupName, index) {
    if (!this.isExistMotionFadeIn(groupName, index)) {
      return -1;
    }
    return this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeInTime$1).toFloat();
  }
  /**
   * 
   * @param groupName 
   * @param index 
   * @return []
   */
  getMotionFadeOutTimeValue(groupName, index) {
    if (!this.isExistMotionFadeOut(groupName, index)) {
      return -1;
    }
    return this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeOutTime$1).toFloat();
  }
  /**
   * 
   * @return 
   */
  getUserDataFile() {
    if (!this.isExistUserDataFile()) {
      return "";
    }
    return this.getJson().getRoot().getValueByString(FileReferences).getValueByString(UserData$2).getRawString();
  }
  /**
   * 
   * @param outLayoutMap csmMap
   * @return true 
   * @return false 
   */
  getLayoutMap(outLayoutMap) {
    const map = this.getJson().getRoot().getValueByString(Layout).getMap();
    if (map == null) {
      return false;
    }
    let ret = false;
    for (const ite = map.begin(); ite.notEqual(map.end()); ite.preIncrement()) {
      outLayoutMap.setValue(ite.ptr().first, ite.ptr().second.toFloat());
      ret = true;
    }
    return ret;
  }
  /**
   * 
   * @return 
   */
  getEyeBlinkParameterCount() {
    if (!this.isExistEyeBlinkParameters()) {
      return 0;
    }
    let num = 0;
    for (let i = 0; i < this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).getSize(); i++) {
      const refI = this._jsonValue.at(
        0
        /* FrequestNode_Groups */
      ).getValueByIndex(i);
      if (refI.isNull() || refI.isError()) {
        continue;
      }
      if (refI.getValueByString(Name).getRawString() == EyeBlink) {
        num = refI.getValueByString(Ids).getVector().getSize();
        break;
      }
    }
    return num;
  }
  /**
   * ID
   * @param index 
   * @return ID
   */
  getEyeBlinkParameterId(index) {
    if (!this.isExistEyeBlinkParameters()) {
      return null;
    }
    for (let i = 0; i < this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).getSize(); i++) {
      const refI = this._jsonValue.at(
        0
        /* FrequestNode_Groups */
      ).getValueByIndex(i);
      if (refI.isNull() || refI.isError()) {
        continue;
      }
      if (refI.getValueByString(Name).getRawString() == EyeBlink) {
        return CubismFramework.getIdManager().getId(
          refI.getValueByString(Ids).getValueByIndex(index).getRawString()
        );
      }
    }
    return null;
  }
  /**
   * 
   * @return 
   */
  getLipSyncParameterCount() {
    if (!this.isExistLipSyncParameters()) {
      return 0;
    }
    let num = 0;
    for (let i = 0; i < this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).getSize(); i++) {
      const refI = this._jsonValue.at(
        0
        /* FrequestNode_Groups */
      ).getValueByIndex(i);
      if (refI.isNull() || refI.isError()) {
        continue;
      }
      if (refI.getValueByString(Name).getRawString() == LipSync) {
        num = refI.getValueByString(Ids).getVector().getSize();
        break;
      }
    }
    return num;
  }
  /**
   * 
   * @param index 
   * @return ID
   */
  getLipSyncParameterId(index) {
    if (!this.isExistLipSyncParameters()) {
      return null;
    }
    for (let i = 0; i < this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).getSize(); i++) {
      const refI = this._jsonValue.at(
        0
        /* FrequestNode_Groups */
      ).getValueByIndex(i);
      if (refI.isNull() || refI.isError()) {
        continue;
      }
      if (refI.getValueByString(Name).getRawString() == LipSync) {
        return CubismFramework.getIdManager().getId(
          refI.getValueByString(Ids).getValueByIndex(index).getRawString()
        );
      }
    }
    return null;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistModelFile() {
    const node2 = this._jsonValue.at(
      1
      /* FrequestNode_Moc */
    );
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistTextureFiles() {
    const node2 = this._jsonValue.at(
      4
      /* FrequestNode_Textures */
    );
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistHitAreas() {
    const node2 = this._jsonValue.at(
      7
      /* FrequestNode_HitAreas */
    );
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistPhysicsFile() {
    const node2 = this._jsonValue.at(
      5
      /* FrequestNode_Physics */
    );
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistPoseFile() {
    const node2 = this._jsonValue.at(
      6
      /* FrequestNode_Pose */
    );
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistExpressionFile() {
    const node2 = this._jsonValue.at(
      3
      /* FrequestNode_Expressions */
    );
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistMotionGroups() {
    const node2 = this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    );
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @param groupName  
   * @return true 
   * @return false 
   */
  isExistMotionGroupName(groupName) {
    const node2 = this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName);
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @param groupName  
   * @param index 
   * @return true 
   * @return false 
   */
  isExistMotionSoundFile(groupName, index) {
    const node2 = this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName).getValueByIndex(index).getValueByString(SoundPath);
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @param groupName  
   * @param index 
   * @return true 
   * @return false 
   */
  isExistMotionFadeIn(groupName, index) {
    const node2 = this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeInTime$1);
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @param groupName  
   * @param index 
   * @return true 
   * @return false 
   */
  isExistMotionFadeOut(groupName, index) {
    const node2 = this._jsonValue.at(
      2
      /* FrequestNode_Motions */
    ).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeOutTime$1);
    return !node2.isNull() && !node2.isError();
  }
  /**
   * UserData
   * @return true 
   * @return false 
   */
  isExistUserDataFile() {
    const node2 = this.getJson().getRoot().getValueByString(FileReferences).getValueByString(UserData$2);
    return !node2.isNull() && !node2.isError();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistEyeBlinkParameters() {
    if (this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).isNull() || this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).isError()) {
      return false;
    }
    for (let i = 0; i < this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).getSize(); ++i) {
      if (this._jsonValue.at(
        0
        /* FrequestNode_Groups */
      ).getValueByIndex(i).getValueByString(Name).getRawString() == EyeBlink) {
        return true;
      }
    }
    return false;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistLipSyncParameters() {
    if (this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).isNull() || this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).isError()) {
      return false;
    }
    for (let i = 0; i < this._jsonValue.at(
      0
      /* FrequestNode_Groups */
    ).getSize(); ++i) {
      if (this._jsonValue.at(
        0
        /* FrequestNode_Groups */
      ).getValueByIndex(i).getValueByString(Name).getRawString() == LipSync) {
        return true;
      }
    }
    return false;
  }
}
var Live2DCubismFramework$r;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismModelSettingJson = CubismModelSettingJson;
})(Live2DCubismFramework$r || (Live2DCubismFramework$r = {}));
class CubismBreath {
  /**
   * 
   */
  static create() {
    return new CubismBreath();
  }
  /**
   * 
   * @param instance CubismBreath
   */
  static delete(instance2) {
  }
  /**
   * 
   * @param breathParameters 
   */
  setParameters(breathParameters) {
    this._breathParameters = breathParameters;
  }
  /**
   * 
   * @return 
   */
  getParameters() {
    return this._breathParameters;
  }
  /**
   * 
   * @param model 
   * @param deltaTimeSeconds []
   */
  updateParameters(model, deltaTimeSeconds) {
    this._currentTime += deltaTimeSeconds;
    const t2 = this._currentTime * 2 * 3.14159;
    for (let i = 0; i < this._breathParameters.getSize(); ++i) {
      const data = this._breathParameters.at(i);
      model.addParameterValueById(
        data.parameterId,
        data.offset + data.peak * Math.sin(t2 / data.cycle),
        data.weight
      );
    }
  }
  /**
   * 
   */
  constructor() {
    this._currentTime = 0;
  }
  // []
}
class BreathParameterData {
  /**
   * 
   * @param parameterId   ID
   * @param offset        
   * @param peak          
   * @param cycle         
   * @param weight        
   */
  constructor(parameterId, offset2, peak, cycle, weight) {
    this.parameterId = parameterId == void 0 ? null : parameterId;
    this.offset = offset2 == void 0 ? 0 : offset2;
    this.peak = peak == void 0 ? 0 : peak;
    this.cycle = cycle == void 0 ? 0 : cycle;
    this.weight = weight == void 0 ? 0 : weight;
  }
  // 
}
var Live2DCubismFramework$q;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.BreathParameterData = BreathParameterData;
  Live2DCubismFramework2.CubismBreath = CubismBreath;
})(Live2DCubismFramework$q || (Live2DCubismFramework$q = {}));
class CubismEyeBlink {
  /**
   * 
   * @param modelSetting 
   * @return 
   * @note NULLID
   */
  static create(modelSetting = null) {
    return new CubismEyeBlink(modelSetting);
  }
  /**
   * 
   * @param eyeBlink CubismEyeBlink
   */
  static delete(eyeBlink) {
  }
  /**
   * 
   * @param blinkingInterval []
   */
  setBlinkingInterval(blinkingInterval) {
    this._blinkingIntervalSeconds = blinkingInterval;
  }
  /**
   * 
   * @param closing   []
   * @param closed    []
   * @param opening   []
   */
  setBlinkingSetting(closing, closed, opening) {
    this._closingSeconds = closing;
    this._closedSeconds = closed;
    this._openingSeconds = opening;
  }
  /**
   * ID
   * @param parameterIds ID
   */
  setParameterIds(parameterIds) {
    this._parameterIds = parameterIds;
  }
  /**
   * ID
   * @return ID
   */
  getParameterIds() {
    return this._parameterIds;
  }
  /**
   * 
   * @param model 
   * @param deltaTimeSeconds []
   */
  updateParameters(model, deltaTimeSeconds) {
    this._userTimeSeconds += deltaTimeSeconds;
    let parameterValue;
    let t2 = 0;
    const blinkingState = this._blinkingState;
    switch (blinkingState) {
      case 2:
        t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closingSeconds;
        if (t2 >= 1) {
          t2 = 1;
          this._blinkingState = 3;
          this._stateStartTimeSeconds = this._userTimeSeconds;
        }
        parameterValue = 1 - t2;
        break;
      case 3:
        t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closedSeconds;
        if (t2 >= 1) {
          this._blinkingState = 4;
          this._stateStartTimeSeconds = this._userTimeSeconds;
        }
        parameterValue = 0;
        break;
      case 4:
        t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._openingSeconds;
        if (t2 >= 1) {
          t2 = 1;
          this._blinkingState = 1;
          this._nextBlinkingTime = this.determinNextBlinkingTiming();
        }
        parameterValue = t2;
        break;
      case 1:
        if (this._nextBlinkingTime < this._userTimeSeconds) {
          this._blinkingState = 2;
          this._stateStartTimeSeconds = this._userTimeSeconds;
        }
        parameterValue = 1;
        break;
      case 0:
      default:
        this._blinkingState = 1;
        this._nextBlinkingTime = this.determinNextBlinkingTiming();
        parameterValue = 1;
        break;
    }
    if (!CubismEyeBlink.CloseIfZero) {
      parameterValue = -parameterValue;
    }
    for (let i = 0; i < this._parameterIds.getSize(); ++i) {
      model.setParameterValueById(this._parameterIds.at(i), parameterValue);
    }
  }
  /**
   * 
   * @param modelSetting 
   */
  constructor(modelSetting) {
    this._blinkingState = 0;
    this._nextBlinkingTime = 0;
    this._stateStartTimeSeconds = 0;
    this._blinkingIntervalSeconds = 4;
    this._closingSeconds = 0.1;
    this._closedSeconds = 0.05;
    this._openingSeconds = 0.15;
    this._userTimeSeconds = 0;
    this._parameterIds = new csmVector();
    if (modelSetting == null) {
      return;
    }
    for (let i = 0; i < modelSetting.getEyeBlinkParameterCount(); ++i) {
      this._parameterIds.pushBack(modelSetting.getEyeBlinkParameterId(i));
    }
  }
  /**
   * 
   *
   * @return []
   */
  determinNextBlinkingTiming() {
    const r2 = Math.random();
    return this._userTimeSeconds + r2 * (2 * this._blinkingIntervalSeconds - 1);
  }
  static {
    this.CloseIfZero = true;
  }
}
var EyeState = /* @__PURE__ */ ((EyeState2) => {
  EyeState2[EyeState2["EyeState_First"] = 0] = "EyeState_First";
  EyeState2[EyeState2["EyeState_Interval"] = 1] = "EyeState_Interval";
  EyeState2[EyeState2["EyeState_Closing"] = 2] = "EyeState_Closing";
  EyeState2[EyeState2["EyeState_Closed"] = 3] = "EyeState_Closed";
  EyeState2[EyeState2["EyeState_Opening"] = 4] = "EyeState_Opening";
  return EyeState2;
})(EyeState || {});
var Live2DCubismFramework$p;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismEyeBlink = CubismEyeBlink;
  Live2DCubismFramework2.EyeState = EyeState;
})(Live2DCubismFramework$p || (Live2DCubismFramework$p = {}));
const Epsilon$1 = 1e-3;
const DefaultFadeInSeconds = 0.5;
const FadeIn = "FadeInTime";
const Link = "Link";
const Groups = "Groups";
const Id$3 = "Id";
class CubismPose {
  /**
   * 
   * @param pose3json pose3.json
   * @param size pose3.json[byte]
   * @return 
   */
  static create(pose3json, size2) {
    const json = CubismJson.create(pose3json, size2);
    if (!json) {
      return null;
    }
    const ret = new CubismPose();
    const root = json.getRoot();
    if (!root.getValueByString(FadeIn).isNull()) {
      ret._fadeTimeSeconds = root.getValueByString(FadeIn).toFloat(DefaultFadeInSeconds);
      if (ret._fadeTimeSeconds <= 0) {
        ret._fadeTimeSeconds = DefaultFadeInSeconds;
      }
    }
    const poseListInfo = root.getValueByString(Groups);
    const poseCount = poseListInfo.getSize();
    for (let poseIndex = 0; poseIndex < poseCount; ++poseIndex) {
      const idListInfo = poseListInfo.getValueByIndex(poseIndex);
      const idCount = idListInfo.getSize();
      let groupCount = 0;
      for (let groupIndex = 0; groupIndex < idCount; ++groupIndex) {
        const partInfo = idListInfo.getValueByIndex(groupIndex);
        const partData = new PartData();
        const parameterId = CubismFramework.getIdManager().getId(
          partInfo.getValueByString(Id$3).getRawString()
        );
        partData.partId = parameterId;
        if (!partInfo.getValueByString(Link).isNull()) {
          const linkListInfo = partInfo.getValueByString(Link);
          const linkCount = linkListInfo.getSize();
          for (let linkIndex = 0; linkIndex < linkCount; ++linkIndex) {
            const linkPart = new PartData();
            const linkId = CubismFramework.getIdManager().getId(
              linkListInfo.getValueByIndex(linkIndex).getString()
            );
            linkPart.partId = linkId;
            partData.link.pushBack(linkPart);
          }
        }
        ret._partGroups.pushBack(partData.clone());
        ++groupCount;
      }
      ret._partGroupCounts.pushBack(groupCount);
    }
    CubismJson.delete(json);
    return ret;
  }
  /**
   * 
   * @param pose CubismPose
   */
  static delete(pose) {
  }
  /**
   * 
   * @param model 
   * @param deltaTimeSeconds []
   */
  updateParameters(model, deltaTimeSeconds) {
    if (model != this._lastModel) {
      this.reset(model);
    }
    this._lastModel = model;
    if (deltaTimeSeconds < 0) {
      deltaTimeSeconds = 0;
    }
    let beginIndex = 0;
    for (let i = 0; i < this._partGroupCounts.getSize(); i++) {
      const partGroupCount = this._partGroupCounts.at(i);
      this.doFade(model, deltaTimeSeconds, beginIndex, partGroupCount);
      beginIndex += partGroupCount;
    }
    this.copyPartOpacities(model);
  }
  /**
   * 
   * @param model 
   * @note 0
   */
  reset(model) {
    let beginIndex = 0;
    for (let i = 0; i < this._partGroupCounts.getSize(); ++i) {
      const groupCount = this._partGroupCounts.at(i);
      for (let j = beginIndex; j < beginIndex + groupCount; ++j) {
        this._partGroups.at(j).initialize(model);
        const partsIndex = this._partGroups.at(j).partIndex;
        const paramIndex = this._partGroups.at(j).parameterIndex;
        if (partsIndex < 0) {
          continue;
        }
        model.setPartOpacityByIndex(partsIndex, j == beginIndex ? 1 : 0);
        model.setParameterValueByIndex(paramIndex, j == beginIndex ? 1 : 0);
        for (let k2 = 0; k2 < this._partGroups.at(j).link.getSize(); ++k2) {
          this._partGroups.at(j).link.at(k2).initialize(model);
        }
      }
      beginIndex += groupCount;
    }
  }
  /**
   * 
   *
   * @param model 
   */
  copyPartOpacities(model) {
    for (let groupIndex = 0; groupIndex < this._partGroups.getSize(); ++groupIndex) {
      const partData = this._partGroups.at(groupIndex);
      if (partData.link.getSize() == 0) {
        continue;
      }
      const partIndex = this._partGroups.at(groupIndex).partIndex;
      const opacity = model.getPartOpacityByIndex(partIndex);
      for (let linkIndex = 0; linkIndex < partData.link.getSize(); ++linkIndex) {
        const linkPart = partData.link.at(linkIndex);
        const linkPartIndex = linkPart.partIndex;
        if (linkPartIndex < 0) {
          continue;
        }
        model.setPartOpacityByIndex(linkPartIndex, opacity);
      }
    }
  }
  /**
   * 
   * @param model 
   * @param deltaTimeSeconds []
   * @param beginIndex 
   * @param partGroupCount 
   */
  doFade(model, deltaTimeSeconds, beginIndex, partGroupCount) {
    let visiblePartIndex = -1;
    let newOpacity = 1;
    const phi = 0.5;
    const backOpacityThreshold = 0.15;
    for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {
      const partIndex = this._partGroups.at(i).partIndex;
      const paramIndex = this._partGroups.at(i).parameterIndex;
      if (model.getParameterValueByIndex(paramIndex) > Epsilon$1) {
        if (visiblePartIndex >= 0) {
          break;
        }
        visiblePartIndex = i;
        newOpacity = model.getPartOpacityByIndex(partIndex);
        newOpacity += deltaTimeSeconds / this._fadeTimeSeconds;
        if (newOpacity > 1) {
          newOpacity = 1;
        }
      }
    }
    if (visiblePartIndex < 0) {
      visiblePartIndex = 0;
      newOpacity = 1;
    }
    for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {
      const partsIndex = this._partGroups.at(i).partIndex;
      if (visiblePartIndex == i) {
        model.setPartOpacityByIndex(partsIndex, newOpacity);
      } else {
        let opacity = model.getPartOpacityByIndex(partsIndex);
        let a1;
        if (newOpacity < phi) {
          a1 = newOpacity * (phi - 1) / phi + 1;
        } else {
          a1 = (1 - newOpacity) * phi / (1 - phi);
        }
        const backOpacity = (1 - a1) * (1 - newOpacity);
        if (backOpacity > backOpacityThreshold) {
          a1 = 1 - backOpacityThreshold / (1 - newOpacity);
        }
        if (opacity > a1) {
          opacity = a1;
        }
        model.setPartOpacityByIndex(partsIndex, opacity);
      }
    }
  }
  /**
   * 
   */
  constructor() {
    this._fadeTimeSeconds = DefaultFadeInSeconds;
    this._lastModel = null;
    this._partGroups = new csmVector();
    this._partGroupCounts = new csmVector();
  }
  // 
}
class PartData {
  /**
   * 
   */
  constructor(v2) {
    this.parameterIndex = 0;
    this.partIndex = 0;
    this.link = new csmVector();
    if (v2 != void 0) {
      this.partId = v2.partId;
      for (const ite = v2.link.begin(); ite.notEqual(v2.link.end()); ite.preIncrement()) {
        this.link.pushBack(ite.ptr().clone());
      }
    }
  }
  /**
   * =
   */
  assignment(v2) {
    this.partId = v2.partId;
    for (const ite = v2.link.begin(); ite.notEqual(v2.link.end()); ite.preIncrement()) {
      this.link.pushBack(ite.ptr().clone());
    }
    return this;
  }
  /**
   * 
   * @param model 
   */
  initialize(model) {
    this.parameterIndex = model.getParameterIndex(this.partId);
    this.partIndex = model.getPartIndex(this.partId);
    model.setParameterValueByIndex(this.parameterIndex, 1);
  }
  /**
   * 
   */
  clone() {
    const clonePartData = new PartData();
    clonePartData.partId = this.partId;
    clonePartData.parameterIndex = this.parameterIndex;
    clonePartData.partIndex = this.partIndex;
    clonePartData.link = new csmVector();
    for (let ite = this.link.begin(); ite.notEqual(this.link.end()); ite.increment()) {
      clonePartData.link.pushBack(ite.ptr().clone());
    }
    return clonePartData;
  }
  // 
}
var Live2DCubismFramework$o;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismPose = CubismPose;
  Live2DCubismFramework2.PartData = PartData;
})(Live2DCubismFramework$o || (Live2DCubismFramework$o = {}));
class CubismModelMatrix extends CubismMatrix44 {
  /**
   * 
   *
   * @param w 
   * @param h 
   */
  constructor(w2, h2) {
    super();
    this._width = w2 !== void 0 ? w2 : 0;
    this._height = h2 !== void 0 ? h2 : 0;
    this.setHeight(2);
  }
  /**
   * 
   *
   * @param w 
   */
  setWidth(w2) {
    const scaleX = w2 / this._width;
    const scaleY = scaleX;
    this.scale(scaleX, scaleY);
  }
  /**
   * 
   * @param h 
   */
  setHeight(h2) {
    const scaleX = h2 / this._height;
    const scaleY = scaleX;
    this.scale(scaleX, scaleY);
  }
  /**
   * 
   *
   * @param x X
   * @param y Y
   */
  setPosition(x2, y2) {
    this.translate(x2, y2);
  }
  /**
   * 
   *
   * @param x X
   * @param y Y
   *
   * @note widthheight
   */
  setCenterPosition(x2, y2) {
    this.centerX(x2);
    this.centerY(y2);
  }
  /**
   * 
   *
   * @param y Y
   */
  top(y2) {
    this.setY(y2);
  }
  /**
   * 
   *
   * @param y Y
   */
  bottom(y2) {
    const h2 = this._height * this.getScaleY();
    this.translateY(y2 - h2);
  }
  /**
   * 
   *
   * @param x X
   */
  left(x2) {
    this.setX(x2);
  }
  /**
   * 
   *
   * @param x X
   */
  right(x2) {
    const w2 = this._width * this.getScaleX();
    this.translateX(x2 - w2);
  }
  /**
   * X
   *
   * @param x X
   */
  centerX(x2) {
    const w2 = this._width * this.getScaleX();
    this.translateX(x2 - w2 / 2);
  }
  /**
   * X
   *
   * @param x X
   */
  setX(x2) {
    this.translateX(x2);
  }
  /**
   * Y
   *
   * @param y Y
   */
  centerY(y2) {
    const h2 = this._height * this.getScaleY();
    this.translateY(y2 - h2 / 2);
  }
  /**
   * Y
   *
   * @param y Y
   */
  setY(y2) {
    this.translateY(y2);
  }
  /**
   * 
   *
   * @param layout 
   */
  setupFromLayout(layout) {
    const keyWidth = "width";
    const keyHeight = "height";
    const keyX = "x";
    const keyY = "y";
    const keyCenterX = "center_x";
    const keyCenterY = "center_y";
    const keyTop = "top";
    const keyBottom = "bottom";
    const keyLeft = "left";
    const keyRight = "right";
    for (const ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {
      const key = ite.ptr().first;
      const value = ite.ptr().second;
      if (key == keyWidth) {
        this.setWidth(value);
      } else if (key == keyHeight) {
        this.setHeight(value);
      }
    }
    for (const ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {
      const key = ite.ptr().first;
      const value = ite.ptr().second;
      if (key == keyX) {
        this.setX(value);
      } else if (key == keyY) {
        this.setY(value);
      } else if (key == keyCenterX) {
        this.centerX(value);
      } else if (key == keyCenterY) {
        this.centerY(value);
      } else if (key == keyTop) {
        this.top(value);
      } else if (key == keyBottom) {
        this.bottom(value);
      } else if (key == keyLeft) {
        this.left(value);
      } else if (key == keyRight) {
        this.right(value);
      }
    }
  }
  // 
}
var Live2DCubismFramework$n;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismModelMatrix = CubismModelMatrix;
})(Live2DCubismFramework$n || (Live2DCubismFramework$n = {}));
class CubismVector2 {
  /**
   * 
   */
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
    this.x = x2 == void 0 ? 0 : x2;
    this.y = y2 == void 0 ? 0 : y2;
  }
  /**
   * 
   *
   * @param vector2 
   * @return  
   */
  add(vector2) {
    const ret = new CubismVector2(0, 0);
    ret.x = this.x + vector2.x;
    ret.y = this.y + vector2.y;
    return ret;
  }
  /**
   * 
   *
   * @param vector2 
   * @return  
   */
  substract(vector2) {
    const ret = new CubismVector2(0, 0);
    ret.x = this.x - vector2.x;
    ret.y = this.y - vector2.y;
    return ret;
  }
  /**
   * 
   *
   * @param vector2 
   * @return  
   */
  multiply(vector2) {
    const ret = new CubismVector2(0, 0);
    ret.x = this.x * vector2.x;
    ret.y = this.y * vector2.y;
    return ret;
  }
  /**
   * ()
   *
   * @param scalar 
   * @return  
   */
  multiplyByScaler(scalar) {
    return this.multiply(new CubismVector2(scalar, scalar));
  }
  /**
   * 
   *
   * @param vector2 
   * @return  
   */
  division(vector2) {
    const ret = new CubismVector2(0, 0);
    ret.x = this.x / vector2.x;
    ret.y = this.y / vector2.y;
    return ret;
  }
  /**
   * ()
   *
   * @param scalar 
   * @return  
   */
  divisionByScalar(scalar) {
    return this.division(new CubismVector2(scalar, scalar));
  }
  /**
   * 
   *
   * @return 
   */
  getLength() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * 
   *
   * @param a 
   * @return 
   */
  getDistanceWith(a) {
    return Math.sqrt(
      (this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y)
    );
  }
  /**
   * 
   *
   * @param a 
   * @return 
   */
  dot(a) {
    return this.x * a.x + this.y * a.y;
  }
  /**
   * 
   */
  normalize() {
    const length2 = Math.pow(this.x * this.x + this.y * this.y, 0.5);
    this.x = this.x / length2;
    this.y = this.y / length2;
  }
  /**
   * 
   *
   * 
   *
   * @param rhs 
   * @return true 
   * @return false 
   */
  isEqual(rhs) {
    return this.x == rhs.x && this.y == rhs.y;
  }
  /**
   * 
   *
   * 
   *
   * @param rhs 
   * @return true 
   * @return false 
   */
  isNotEqual(rhs) {
    return !this.isEqual(rhs);
  }
}
var Live2DCubismFramework$m;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismVector2 = CubismVector2;
})(Live2DCubismFramework$m || (Live2DCubismFramework$m = {}));
class CubismMath {
  static {
    this.Epsilon = 1e-5;
  }
  /**
   * 
   *
   * @param value 
   * @param min   
   * @param max   
   * @return 
   */
  static range(value, min2, max2) {
    if (value < min2) {
      value = min2;
    } else if (value > max2) {
      value = max2;
    }
    return value;
  }
  /**
   * 
   *
   * @param x 
   * @return sin(x)
   */
  static sin(x2) {
    return Math.sin(x2);
  }
  /**
   * 
   *
   * @param x ()
   * @return cos(x)
   */
  static cos(x2) {
    return Math.cos(x2);
  }
  /**
   * 
   *
   * @param x 
   * @return 
   */
  static abs(x2) {
    return Math.abs(x2);
  }
  /**
   * ()
   * @param x -> 
   * @return 
   */
  static sqrt(x2) {
    return Math.sqrt(x2);
  }
  /**
   * 
   * @param x -> 
   * @return 
   */
  static cbrt(x2) {
    if (x2 === 0) {
      return x2;
    }
    let cx2 = x2;
    const isNegativeNumber = cx2 < 0;
    if (isNegativeNumber) {
      cx2 = -cx2;
    }
    let ret;
    if (cx2 === Infinity) {
      ret = Infinity;
    } else {
      ret = Math.exp(Math.log(cx2) / 3);
      ret = (cx2 / (ret * ret) + 2 * ret) / 3;
    }
    return isNegativeNumber ? -ret : ret;
  }
  /**
   * 
   * 
   *
   * @param value 
   * @return 
   */
  static getEasingSine(value) {
    if (value < 0) {
      return 0;
    } else if (value > 1) {
      return 1;
    }
    return 0.5 - 0.5 * this.cos(value * Math.PI);
  }
  /**
   * 
   *
   * @param left 
   * @param right 
   * @return 
   */
  static max(left, right) {
    return left > right ? left : right;
  }
  /**
   * 
   *
   * @param left  
   * @param right 
   * @return 
   */
  static min(left, right) {
    return left > right ? right : left;
  }
  /**
   * 
   *
   * @param degrees   
   * @return 
   */
  static degreesToRadian(degrees) {
    return degrees / 180 * Math.PI;
  }
  /**
   * 
   *
   * @param radian    
   * @return 
   */
  static radianToDegrees(radian) {
    return radian * 180 / Math.PI;
  }
  /**
   * 
   *
   * @param from  
   * @param to    
   * @return 
   */
  static directionToRadian(from2, to) {
    const q1 = Math.atan2(to.y, to.x);
    const q2 = Math.atan2(from2.y, from2.x);
    let ret = q1 - q2;
    while (ret < -Math.PI) {
      ret += Math.PI * 2;
    }
    while (ret > Math.PI) {
      ret -= Math.PI * 2;
    }
    return ret;
  }
  /**
   * 
   *
   * @param from  
   * @param to    
   * @return 
   */
  static directionToDegrees(from2, to) {
    const radian = this.directionToRadian(from2, to);
    let degree = this.radianToDegrees(radian);
    if (to.x - from2.x > 0) {
      degree = -degree;
    }
    return degree;
  }
  /**
   * 
   *
   * @param totalAngle    
   * @return 
   */
  static radianToDirection(totalAngle) {
    const ret = new CubismVector2();
    ret.x = this.sin(totalAngle);
    ret.y = this.cos(totalAngle);
    return ret;
  }
  /**
   * 0
   * a * x^2 + b * x + c = 0
   *
   * @param   a -> 
   * @param   b -> 
   * @param   c -> 
   * @return  
   */
  static quadraticEquation(a, b2, c2) {
    if (this.abs(a) < CubismMath.Epsilon) {
      if (this.abs(b2) < CubismMath.Epsilon) {
        return -c2;
      }
      return -c2 / b2;
    }
    return -(b2 + this.sqrt(b2 * b2 - 4 * a * c2)) / (2 * a);
  }
  /**
   * t
   * 0.01.0
   *
   * a * x^3 + b * x^2 + c * x + d = 0
   *
   * @param   a -> 
   * @param   b -> 
   * @param   c -> 
   * @param   d -> 
   * @return  0.01.0
   */
  static cardanoAlgorithmForBezier(a, b2, c2, d2) {
    if (this.sqrt(a) < CubismMath.Epsilon) {
      return this.range(this.quadraticEquation(b2, c2, d2), 0, 1);
    }
    const ba = b2 / a;
    const ca2 = c2 / a;
    const da2 = d2 / a;
    const p2 = (3 * ca2 - ba * ba) / 3;
    const p3 = p2 / 3;
    const q2 = (2 * ba * ba * ba - 9 * ba * ca2 + 27 * da2) / 27;
    const q22 = q2 / 2;
    const discriminant = q22 * q22 + p3 * p3 * p3;
    const center = 0.5;
    const threshold = center + 0.01;
    if (discriminant < 0) {
      const mp3 = -p2 / 3;
      const mp33 = mp3 * mp3 * mp3;
      const r2 = this.sqrt(mp33);
      const t2 = -q2 / (2 * r2);
      const cosphi = this.range(t2, -1, 1);
      const phi = Math.acos(cosphi);
      const crtr = this.cbrt(r2);
      const t1 = 2 * crtr;
      const root12 = t1 * this.cos(phi / 3) - ba / 3;
      if (this.abs(root12 - center) < threshold) {
        return this.range(root12, 0, 1);
      }
      const root2 = t1 * this.cos((phi + 2 * Math.PI) / 3) - ba / 3;
      if (this.abs(root2 - center) < threshold) {
        return this.range(root2, 0, 1);
      }
      const root3 = t1 * this.cos((phi + 4 * Math.PI) / 3) - ba / 3;
      return this.range(root3, 0, 1);
    }
    if (discriminant == 0) {
      let u12;
      if (q22 < 0) {
        u12 = this.cbrt(-q22);
      } else {
        u12 = -this.cbrt(q22);
      }
      const root12 = 2 * u12 - ba / 3;
      if (this.abs(root12 - center) < threshold) {
        return this.range(root12, 0, 1);
      }
      const root2 = -u12 - ba / 3;
      return this.range(root2, 0, 1);
    }
    const sd2 = this.sqrt(discriminant);
    const u1 = this.cbrt(sd2 - q22);
    const v1 = this.cbrt(sd2 + q22);
    const root1 = u1 - v1 - ba / 3;
    return this.range(root1, 0, 1);
  }
  /**
   * 
   *
   * @param dividend 
   * @param divisor 
   * @returns 
   */
  static mod(dividend, divisor) {
    if (!isFinite(dividend) || divisor === 0 || isNaN(dividend) || isNaN(divisor)) {
      console.warn(
        `divided: ${dividend}, divisor: ${divisor} mod() returns 'NaN'.`
      );
      return NaN;
    }
    const absDividend = Math.abs(dividend);
    const absDivisor = Math.abs(divisor);
    let result = absDividend - Math.floor(absDividend / absDivisor) * absDivisor;
    result *= Math.sign(dividend);
    return result;
  }
  /**
   * 
   */
  constructor() {
  }
}
var Live2DCubismFramework$l;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMath = CubismMath;
})(Live2DCubismFramework$l || (Live2DCubismFramework$l = {}));
const FrameRate = 30;
const Epsilon = 0.01;
class CubismTargetPoint {
  /**
   * 
   */
  constructor() {
    this._faceTargetX = 0;
    this._faceTargetY = 0;
    this._faceX = 0;
    this._faceY = 0;
    this._faceVX = 0;
    this._faceVY = 0;
    this._lastTimeSeconds = 0;
    this._userTimeSeconds = 0;
  }
  /**
   * 
   */
  update(deltaTimeSeconds) {
    this._userTimeSeconds += deltaTimeSeconds;
    const faceParamMaxV = 40 / 10;
    const maxV = faceParamMaxV * 1 / FrameRate;
    if (this._lastTimeSeconds == 0) {
      this._lastTimeSeconds = this._userTimeSeconds;
      return;
    }
    const deltaTimeWeight = (this._userTimeSeconds - this._lastTimeSeconds) * FrameRate;
    this._lastTimeSeconds = this._userTimeSeconds;
    const timeToMaxSpeed = 0.15;
    const frameToMaxSpeed = timeToMaxSpeed * FrameRate;
    const maxA = deltaTimeWeight * maxV / frameToMaxSpeed;
    const dx = this._faceTargetX - this._faceX;
    const dy = this._faceTargetY - this._faceY;
    if (CubismMath.abs(dx) <= Epsilon && CubismMath.abs(dy) <= Epsilon) {
      return;
    }
    const d2 = CubismMath.sqrt(dx * dx + dy * dy);
    const vx = maxV * dx / d2;
    const vy = maxV * dy / d2;
    let ax = vx - this._faceVX;
    let ay = vy - this._faceVY;
    const a = CubismMath.sqrt(ax * ax + ay * ay);
    if (a < -maxA || a > maxA) {
      ax *= maxA / a;
      ay *= maxA / a;
    }
    this._faceVX += ax;
    this._faceVY += ay;
    {
      const maxV2 = 0.5 * (CubismMath.sqrt(maxA * maxA + 16 * maxA * d2 - 8 * maxA * d2) - maxA);
      const curV = CubismMath.sqrt(
        this._faceVX * this._faceVX + this._faceVY * this._faceVY
      );
      if (curV > maxV2) {
        this._faceVX *= maxV2 / curV;
        this._faceVY *= maxV2 / curV;
      }
    }
    this._faceX += this._faceVX;
    this._faceY += this._faceVY;
  }
  /**
   * X
   *
   * @return X-1.0 ~ 1.0
   */
  getX() {
    return this._faceX;
  }
  /**
   * Y
   *
   * @return Y-1.0 ~ 1.0
   */
  getY() {
    return this._faceY;
  }
  /**
   * 
   *
   * @param x X-1.0 ~ 1.0
   * @param y Y-1.0 ~ 1.0
   */
  set(x2, y2) {
    this._faceTargetX = x2;
    this._faceTargetY = y2;
  }
  // []
}
var Live2DCubismFramework$k;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismTargetPoint = CubismTargetPoint;
})(Live2DCubismFramework$k || (Live2DCubismFramework$k = {}));
class ACubismMotion {
  /**
   * 
   */
  constructor() {
    this.setFinishedMotionHandler = (onFinishedMotionHandler) => this._onFinishedMotion = onFinishedMotionHandler;
    this.getFinishedMotionHandler = () => this._onFinishedMotion;
    this._fadeInSeconds = -1;
    this._fadeOutSeconds = -1;
    this._weight = 1;
    this._offsetSeconds = 0;
    this._firedEventValues = new csmVector();
  }
  /**
   * 
   */
  static delete(motion) {
    motion.release();
    motion = null;
  }
  /**
   * 
   */
  release() {
    this._weight = 0;
  }
  /**
   * 
   * @param model 
   * @param motionQueueEntry CubismMotionQueueManager
   * @param userTimeSeconds []
   */
  updateParameters(model, motionQueueEntry, userTimeSeconds) {
    if (!motionQueueEntry.isAvailable() || motionQueueEntry.isFinished()) {
      return;
    }
    this.setupMotionQueueEntry(motionQueueEntry, userTimeSeconds);
    const fadeWeight = this.updateFadeWeight(motionQueueEntry, userTimeSeconds);
    this.doUpdateParameters(
      model,
      userTimeSeconds,
      fadeWeight,
      motionQueueEntry
    );
    if (motionQueueEntry.getEndTime() > 0 && motionQueueEntry.getEndTime() < userTimeSeconds) {
      motionQueueEntry.setIsFinished(true);
    }
  }
  /**
   * @brief 
   *
   * 
   *
   * @param[in]   motionQueueEntry    CubismMotionQueueManager
   * @param[in]   userTimeSeconds     []
   */
  setupMotionQueueEntry(motionQueueEntry, userTimeSeconds) {
    if (motionQueueEntry == null || motionQueueEntry.isStarted()) {
      return;
    }
    if (!motionQueueEntry.isAvailable()) {
      return;
    }
    motionQueueEntry.setIsStarted(true);
    motionQueueEntry.setStartTime(userTimeSeconds - this._offsetSeconds);
    motionQueueEntry.setFadeInStartTime(userTimeSeconds);
    const duration = this.getDuration();
    if (motionQueueEntry.getEndTime() < 0) {
      motionQueueEntry.setEndTime(
        duration <= 0 ? -1 : motionQueueEntry.getStartTime() + duration
      );
    }
  }
  /**
   * @brief 
   *
   * 
   *
   * @param[in]   motionQueueEntry    CubismMotionQueueManager
   * @param[in]   userTimeSeconds     []
   */
  updateFadeWeight(motionQueueEntry, userTimeSeconds) {
    if (motionQueueEntry == null) {
      CubismDebug.print(LogLevel.LogLevel_Error, "motionQueueEntry is null.");
    }
    let fadeWeight = this._weight;
    const fadeIn = this._fadeInSeconds == 0 ? 1 : CubismMath.getEasingSine(
      (userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds
    );
    const fadeOut = this._fadeOutSeconds == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine(
      (motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds
    );
    fadeWeight = fadeWeight * fadeIn * fadeOut;
    motionQueueEntry.setState(userTimeSeconds, fadeWeight);
    CSM_ASSERT(0 <= fadeWeight && fadeWeight <= 1);
    return fadeWeight;
  }
  /**
   * 
   * @param fadeInSeconds []
   */
  setFadeInTime(fadeInSeconds) {
    this._fadeInSeconds = fadeInSeconds;
  }
  /**
   * 
   * @param fadeOutSeconds []
   */
  setFadeOutTime(fadeOutSeconds) {
    this._fadeOutSeconds = fadeOutSeconds;
  }
  /**
   * 
   * @return []
   */
  getFadeOutTime() {
    return this._fadeOutSeconds;
  }
  /**
   * 
   * @return []
   */
  getFadeInTime() {
    return this._fadeInSeconds;
  }
  /**
   * 
   * @param weight 0.0 - 1.0
   */
  setWeight(weight) {
    this._weight = weight;
  }
  /**
   * 
   * @return 0.0 - 1.0
   */
  getWeight() {
    return this._weight;
  }
  /**
   * 
   * @return []
   *
   * @note -1
   *       
   *       
   *       -1
   */
  getDuration() {
    return -1;
  }
  /**
   * 1
   * @return []
   *
   * @note getDuration()
   *       ()-1
   */
  getLoopDuration() {
    return -1;
  }
  /**
   * 
   * @param offsetSeconds []
   */
  setOffsetTime(offsetSeconds) {
    this._offsetSeconds = offsetSeconds;
  }
  /**
   * 
   *
   * 
   * 
   *
   * @param beforeCheckTimeSeconds []
   * @param motionTimeSeconds []
   */
  getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
    return this._firedEventValues;
  }
  /**
   * 
   *
   * @returns true  -> 
   *          false -> 
   */
  isExistModelOpacity() {
    return false;
  }
  /**
   * 
   *
   * @returns success:
   */
  getModelOpacityIndex() {
    return -1;
  }
  /**
   * Id
   *
   * @param index 
   * @returns success:Id
   */
  getModelOpacityId(index) {
    return null;
  }
  /**
   * 
   *
   * @returns success:Opacity
   *
   * @note  UpdateParameters() 
   */
  getModelOpacityValue() {
    return 1;
  }
}
var Live2DCubismFramework$j;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.ACubismMotion = ACubismMotion;
})(Live2DCubismFramework$j || (Live2DCubismFramework$j = {}));
const ExpressionKeyFadeIn = "FadeInTime";
const ExpressionKeyFadeOut = "FadeOutTime";
const ExpressionKeyParameters = "Parameters";
const ExpressionKeyId = "Id";
const ExpressionKeyValue = "Value";
const ExpressionKeyBlend = "Blend";
const BlendValueAdd = "Add";
const BlendValueMultiply = "Multiply";
const BlendValueOverwrite = "Overwrite";
const DefaultFadeTime = 1;
class CubismExpressionMotion extends ACubismMotion {
  static {
    this.DefaultAdditiveValue = 0;
  }
  static {
    this.DefaultMultiplyValue = 1;
  }
  // 
  /**
   * 
   * @param buffer exp
   * @param size 
   * @return 
   */
  static create(buffer, size2) {
    const expression = new CubismExpressionMotion();
    expression.parse(buffer, size2);
    return expression;
  }
  /**
   * 
   * @param model 
   * @param userTimeSeconds []
   * @param weight 
   * @param motionQueueEntry CubismMotionQueueManager
   */
  doUpdateParameters(model, userTimeSeconds, weight, motionQueueEntry) {
    for (let i = 0; i < this._parameters.getSize(); ++i) {
      const parameter = this._parameters.at(i);
      switch (parameter.blendType) {
        case 0: {
          model.addParameterValueById(
            parameter.parameterId,
            parameter.value,
            weight
          );
          break;
        }
        case 1: {
          model.multiplyParameterValueById(
            parameter.parameterId,
            parameter.value,
            weight
          );
          break;
        }
        case 2: {
          model.setParameterValueById(
            parameter.parameterId,
            parameter.value,
            weight
          );
          break;
        }
      }
    }
  }
  /**
   * @brief 
   *
   * 
   *
   * @param[in]   model                        
   * @param[in]   userTimeSeconds              []
   * @param[in]   motionQueueEntry             CubismMotionQueueManager
   * @param[in]   expressionParameterValues    
   * @param[in]   expressionIndex              
   * @param[in]   fadeWeight                   
   */
  calculateExpressionParameters(model, userTimeSeconds, motionQueueEntry, expressionParameterValues, expressionIndex, fadeWeight) {
    if (motionQueueEntry == null || expressionParameterValues == null) {
      return;
    }
    if (!motionQueueEntry.isAvailable()) {
      return;
    }
    this._fadeWeight = this.updateFadeWeight(motionQueueEntry, userTimeSeconds);
    for (let i = 0; i < expressionParameterValues.getSize(); ++i) {
      const expressionParameterValue = expressionParameterValues.at(i);
      if (expressionParameterValue.parameterId == null) {
        continue;
      }
      const currentParameterValue = expressionParameterValue.overwriteValue = model.getParameterValueById(expressionParameterValue.parameterId);
      const expressionParameters = this.getExpressionParameters();
      let parameterIndex = -1;
      for (let j = 0; j < expressionParameters.getSize(); ++j) {
        if (expressionParameterValue.parameterId != expressionParameters.at(j).parameterId) {
          continue;
        }
        parameterIndex = j;
        break;
      }
      if (parameterIndex < 0) {
        if (expressionIndex == 0) {
          expressionParameterValue.additiveValue = CubismExpressionMotion.DefaultAdditiveValue;
          expressionParameterValue.multiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
          expressionParameterValue.overwriteValue = currentParameterValue;
        } else {
          expressionParameterValue.additiveValue = this.calculateValue(
            expressionParameterValue.additiveValue,
            CubismExpressionMotion.DefaultAdditiveValue,
            fadeWeight
          );
          expressionParameterValue.multiplyValue = this.calculateValue(
            expressionParameterValue.multiplyValue,
            CubismExpressionMotion.DefaultMultiplyValue,
            fadeWeight
          );
          expressionParameterValue.overwriteValue = this.calculateValue(
            expressionParameterValue.overwriteValue,
            currentParameterValue,
            fadeWeight
          );
        }
        continue;
      }
      const value = expressionParameters.at(parameterIndex).value;
      let newAdditiveValue, newMultiplyValue, newOverwriteValue;
      switch (expressionParameters.at(parameterIndex).blendType) {
        case 0:
          newAdditiveValue = value;
          newMultiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
          newOverwriteValue = currentParameterValue;
          break;
        case 1:
          newAdditiveValue = CubismExpressionMotion.DefaultAdditiveValue;
          newMultiplyValue = value;
          newOverwriteValue = currentParameterValue;
          break;
        case 2:
          newAdditiveValue = CubismExpressionMotion.DefaultAdditiveValue;
          newMultiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
          newOverwriteValue = value;
          break;
        default:
          return;
      }
      if (expressionIndex == 0) {
        expressionParameterValue.additiveValue = newAdditiveValue;
        expressionParameterValue.multiplyValue = newMultiplyValue;
        expressionParameterValue.overwriteValue = newOverwriteValue;
      } else {
        expressionParameterValue.additiveValue = expressionParameterValue.additiveValue * (1 - fadeWeight) + newAdditiveValue * fadeWeight;
        expressionParameterValue.multiplyValue = expressionParameterValue.multiplyValue * (1 - fadeWeight) + newMultiplyValue * fadeWeight;
        expressionParameterValue.overwriteValue = expressionParameterValue.overwriteValue * (1 - fadeWeight) + newOverwriteValue * fadeWeight;
      }
    }
  }
  /**
   * @brief 
   *
   * 
   *
   * @return 
   */
  getExpressionParameters() {
    return this._parameters;
  }
  /**
   * @brief 
   *
   * 
   *
   * @returns 
   *
   * @deprecated CubismExpressionMotion.fadeWeight
   * CubismExpressionMotionManager.getFadeWeight(index: number): number 
   * @see CubismExpressionMotionManager#getFadeWeight(index: number)
   */
  getFadeWeight() {
    return this._fadeWeight;
  }
  parse(buffer, size2) {
    const json = CubismJson.create(buffer, size2);
    if (!json) {
      return;
    }
    const root = json.getRoot();
    this.setFadeInTime(
      root.getValueByString(ExpressionKeyFadeIn).toFloat(DefaultFadeTime)
    );
    this.setFadeOutTime(
      root.getValueByString(ExpressionKeyFadeOut).toFloat(DefaultFadeTime)
    );
    const parameterCount = root.getValueByString(ExpressionKeyParameters).getSize();
    this._parameters.prepareCapacity(parameterCount);
    for (let i = 0; i < parameterCount; ++i) {
      const param = root.getValueByString(ExpressionKeyParameters).getValueByIndex(i);
      const parameterId = CubismFramework.getIdManager().getId(
        param.getValueByString(ExpressionKeyId).getRawString()
      );
      const value = param.getValueByString(ExpressionKeyValue).toFloat();
      let blendType;
      if (param.getValueByString(ExpressionKeyBlend).isNull() || param.getValueByString(ExpressionKeyBlend).getString() == BlendValueAdd) {
        blendType = 0;
      } else if (param.getValueByString(ExpressionKeyBlend).getString() == BlendValueMultiply) {
        blendType = 1;
      } else if (param.getValueByString(ExpressionKeyBlend).getString() == BlendValueOverwrite) {
        blendType = 2;
      } else {
        blendType = 0;
      }
      const item = new ExpressionParameter();
      item.parameterId = parameterId;
      item.blendType = blendType;
      item.value = value;
      this._parameters.pushBack(item);
    }
    CubismJson.delete(json);
  }
  /**
   * @brief 
   *
   * 
   *
   * @param source 
   * @param destination 
   * @param weight 
   * @returns 
   */
  calculateValue(source, destination, fadeWeight) {
    return source * (1 - fadeWeight) + destination * fadeWeight;
  }
  /**
   * 
   */
  constructor() {
    super();
    this._parameters = new csmVector();
    this._fadeWeight = 0;
  }
}
var ExpressionBlendType = /* @__PURE__ */ ((ExpressionBlendType2) => {
  ExpressionBlendType2[ExpressionBlendType2["Additive"] = 0] = "Additive";
  ExpressionBlendType2[ExpressionBlendType2["Multiply"] = 1] = "Multiply";
  ExpressionBlendType2[ExpressionBlendType2["Overwrite"] = 2] = "Overwrite";
  return ExpressionBlendType2;
})(ExpressionBlendType || {});
class ExpressionParameter {
  // 
}
var Live2DCubismFramework$i;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismExpressionMotion = CubismExpressionMotion;
  Live2DCubismFramework2.ExpressionBlendType = ExpressionBlendType;
  Live2DCubismFramework2.ExpressionParameter = ExpressionParameter;
})(Live2DCubismFramework$i || (Live2DCubismFramework$i = {}));
class CubismMotionQueueEntry {
  /**
   * 
   */
  constructor() {
    this._autoDelete = false;
    this._motion = null;
    this._available = true;
    this._finished = false;
    this._started = false;
    this._startTimeSeconds = -1;
    this._fadeInStartTimeSeconds = 0;
    this._endTimeSeconds = -1;
    this._stateTimeSeconds = 0;
    this._stateWeight = 0;
    this._lastEventCheckSeconds = 0;
    this._motionQueueEntryHandle = this;
    this._fadeOutSeconds = 0;
    this._isTriggeredFadeOut = false;
  }
  /**
   * 
   */
  release() {
    if (this._autoDelete && this._motion) {
      ACubismMotion.delete(this._motion);
    }
  }
  /**
   * 
   * @param fadeOutSeconds []
   */
  setFadeOut(fadeOutSeconds) {
    this._fadeOutSeconds = fadeOutSeconds;
    this._isTriggeredFadeOut = true;
  }
  /**
   * 
   * @param fadeOutSeconds []
   * @param userTimeSeconds []
   */
  startFadeOut(fadeOutSeconds, userTimeSeconds) {
    const newEndTimeSeconds = userTimeSeconds + fadeOutSeconds;
    this._isTriggeredFadeOut = true;
    if (this._endTimeSeconds < 0 || newEndTimeSeconds < this._endTimeSeconds) {
      this._endTimeSeconds = newEndTimeSeconds;
    }
  }
  /**
   * 
   *
   * @return true 
   * @return false 
   */
  isFinished() {
    return this._finished;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isStarted() {
    return this._started;
  }
  /**
   * 
   * @return []
   */
  getStartTime() {
    return this._startTimeSeconds;
  }
  /**
   * 
   * @return []
   */
  getFadeInStartTime() {
    return this._fadeInStartTimeSeconds;
  }
  /**
   * 
   * @return 
   */
  getEndTime() {
    return this._endTimeSeconds;
  }
  /**
   * 
   * @param startTime 
   */
  setStartTime(startTime) {
    this._startTimeSeconds = startTime;
  }
  /**
   * 
   * @param startTime []
   */
  setFadeInStartTime(startTime) {
    this._fadeInStartTimeSeconds = startTime;
  }
  /**
   * 
   * @param endTime []
   */
  setEndTime(endTime) {
    this._endTimeSeconds = endTime;
  }
  /**
   * 
   * @param f true
   */
  setIsFinished(f2) {
    this._finished = f2;
  }
  /**
   * 
   * @param f true
   */
  setIsStarted(f2) {
    this._started = f2;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isAvailable() {
    return this._available;
  }
  /**
   * 
   * @param v true
   */
  setIsAvailable(v2) {
    this._available = v2;
  }
  /**
   * 
   * @param timeSeconds []
   * @param weight 
   */
  setState(timeSeconds, weight) {
    this._stateTimeSeconds = timeSeconds;
    this._stateWeight = weight;
  }
  /**
   * 
   * @return []
   */
  getStateTime() {
    return this._stateTimeSeconds;
  }
  /**
   * 
   * @return 
   */
  getStateWeight() {
    return this._stateWeight;
  }
  /**
   * 
   *
   * @return []
   */
  getLastCheckEventSeconds() {
    return this._lastEventCheckSeconds;
  }
  /**
   * 
   * @param checkSeconds []
   */
  setLastCheckEventSeconds(checkSeconds) {
    this._lastEventCheckSeconds = checkSeconds;
  }
  /**
   * 
   * @return 
   */
  isTriggeredFadeOut() {
    return this._isTriggeredFadeOut;
  }
  /**
   * 
   * @return []
   */
  getFadeOutSeconds() {
    return this._fadeOutSeconds;
  }
  /**
   * 
   *
   * @return 
   */
  getCubismMotion() {
    return this._motion;
  }
  // 
}
var Live2DCubismFramework$h;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMotionQueueEntry = CubismMotionQueueEntry;
})(Live2DCubismFramework$h || (Live2DCubismFramework$h = {}));
class CubismMotionQueueManager {
  /**
   * 
   */
  constructor() {
    this._userTimeSeconds = 0;
    this._eventCallBack = null;
    this._eventCustomData = null;
    this._motions = new csmVector();
  }
  /**
   * 
   */
  release() {
    for (let i = 0; i < this._motions.getSize(); ++i) {
      if (this._motions.at(i)) {
        this._motions.at(i).release();
        this._motions.set(i, null);
      }
    }
    this._motions = null;
  }
  /**
   * 
   *
   * 
   *
   * @param   motion          
   * @param   autoDelete       true
   * @param   userTimeSeconds Deprecated: [] 
   * @return                      IsFinished()-1
   */
  startMotion(motion, autoDelete, userTimeSeconds) {
    if (motion == null) {
      return InvalidMotionQueueEntryHandleValue;
    }
    let motionQueueEntry = null;
    for (let i = 0; i < this._motions.getSize(); ++i) {
      motionQueueEntry = this._motions.at(i);
      if (motionQueueEntry == null) {
        continue;
      }
      motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime());
    }
    motionQueueEntry = new CubismMotionQueueEntry();
    motionQueueEntry._autoDelete = autoDelete;
    motionQueueEntry._motion = motion;
    this._motions.pushBack(motionQueueEntry);
    return motionQueueEntry._motionQueueEntryHandle;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isFinished() {
    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
      let motionQueueEntry = ite.ptr();
      if (motionQueueEntry == null) {
        ite = this._motions.erase(ite);
        continue;
      }
      const motion = motionQueueEntry._motion;
      if (motion == null) {
        motionQueueEntry.release();
        motionQueueEntry = null;
        ite = this._motions.erase(ite);
        continue;
      }
      if (!motionQueueEntry.isFinished()) {
        return false;
      } else {
        ite.preIncrement();
      }
    }
    return true;
  }
  /**
   * 
   * @param motionQueueEntryNumber 
   * @return true 
   * @return false 
   */
  isFinishedByHandle(motionQueueEntryNumber) {
    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.increment()) {
      const motionQueueEntry = ite.ptr();
      if (motionQueueEntry == null) {
        continue;
      }
      if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber && !motionQueueEntry.isFinished()) {
        return false;
      }
    }
    return true;
  }
  /**
   * 
   */
  stopAllMotions() {
    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
      let motionQueueEntry = ite.ptr();
      if (motionQueueEntry == null) {
        ite = this._motions.erase(ite);
        continue;
      }
      motionQueueEntry.release();
      motionQueueEntry = null;
      ite = this._motions.erase(ite);
    }
  }
  /**
   * @brief CubismMotionQueueEntry
   *
   * CubismMotionQueueEntry
   *
   * @return  CubismMotionQueueEntry
   * @retval  NULL   
   */
  getCubismMotionQueueEntries() {
    return this._motions;
  }
  /**
     * CubismMotionQueueEntry
  
     * @param   motionQueueEntryNumber  
     * @return  CubismMotionQueueEntry
     * @return  null   
     */
  getCubismMotionQueueEntry(motionQueueEntryNumber) {
    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.preIncrement()) {
      const motionQueueEntry = ite.ptr();
      if (motionQueueEntry == null) {
        continue;
      }
      if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber) {
        return motionQueueEntry;
      }
    }
    return null;
  }
  /**
   * Callback
   *
   * @param callback 
   * @param customData 
   */
  setEventCallback(callback, customData = null) {
    this._eventCallBack = callback;
    this._eventCustomData = customData;
  }
  /**
   * 
   *
   * @param   model   
   * @param   userTimeSeconds   []
   * @return  true    
   * @return  false   ()
   */
  doUpdateMotion(model, userTimeSeconds) {
    let updated = false;
    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
      let motionQueueEntry = ite.ptr();
      if (motionQueueEntry == null) {
        ite = this._motions.erase(ite);
        continue;
      }
      const motion = motionQueueEntry._motion;
      if (motion == null) {
        motionQueueEntry.release();
        motionQueueEntry = null;
        ite = this._motions.erase(ite);
        continue;
      }
      motion.updateParameters(model, motionQueueEntry, userTimeSeconds);
      updated = true;
      const firedList = motion.getFiredEvent(
        motionQueueEntry.getLastCheckEventSeconds() - motionQueueEntry.getStartTime(),
        userTimeSeconds - motionQueueEntry.getStartTime()
      );
      for (let i = 0; i < firedList.getSize(); ++i) {
        this._eventCallBack(this, firedList.at(i), this._eventCustomData);
      }
      motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);
      if (motionQueueEntry.isFinished()) {
        motionQueueEntry.release();
        motionQueueEntry = null;
        ite = this._motions.erase(ite);
      } else {
        if (motionQueueEntry.isTriggeredFadeOut()) {
          motionQueueEntry.startFadeOut(
            motionQueueEntry.getFadeOutSeconds(),
            userTimeSeconds
          );
        }
        ite.preIncrement();
      }
    }
    return updated;
  }
  // 
}
const InvalidMotionQueueEntryHandleValue = -1;
var Live2DCubismFramework$g;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMotionQueueManager = CubismMotionQueueManager;
  Live2DCubismFramework2.InvalidMotionQueueEntryHandleValue = InvalidMotionQueueEntryHandleValue;
})(Live2DCubismFramework$g || (Live2DCubismFramework$g = {}));
class ExpressionParameterValue {
  // 
}
class CubismExpressionMotionManager extends CubismMotionQueueManager {
  /**
   * 
   */
  constructor() {
    super();
    this._currentPriority = 0;
    this._reservePriority = 0;
    this._expressionParameterValues = new csmVector();
    this._fadeWeights = new csmVector();
  }
  /**
   * 
   */
  release() {
    if (this._expressionParameterValues) {
      csmDelete(this._expressionParameterValues);
      this._expressionParameterValues = null;
    }
    if (this._fadeWeights) {
      csmDelete(this._fadeWeights);
      this._fadeWeights = null;
    }
  }
  /**
   * @brief 
   *
   * 
   *
   * @returns 
   */
  getCurrentPriority() {
    return this._currentPriority;
  }
  /**
   * @brief 
   *
   * 
   *
   * @return  
   */
  getReservePriority() {
    return this._reservePriority;
  }
  /**
   * @brief 
   *
   * @param[in]    index    
   * @returns               
   */
  getFadeWeight(index) {
    return this._fadeWeights.at(index);
  }
  /**
   * @brief 
   *
   * 
   *
   * @param[in]   priority     
   */
  setReservePriority(priority) {
    this._reservePriority = priority;
  }
  /**
   * @brief 
   *
   * 
   *
   * @param[in]   motion          
   * @param[in]   autoDelete      true
   * @param[in]   priority        
   * @return                      IsFinished()-1
   */
  startMotionPriority(motion, autoDelete, priority) {
    if (priority == this.getReservePriority()) {
      this.setReservePriority(0);
    }
    this._currentPriority = priority;
    this._fadeWeights.pushBack(0);
    return this.startMotion(motion, autoDelete);
  }
  /**
   * @brief 
   *
   * 
   *
   * @param[in]   model   
   * @param[in]   deltaTimeSeconds    []
   * @retval  true    
   * @retval  false   
   */
  updateMotion(model, deltaTimeSeconds) {
    this._userTimeSeconds += deltaTimeSeconds;
    let updated = false;
    const motions = this.getCubismMotionQueueEntries();
    let expressionWeight = 0;
    let expressionIndex = 0;
    for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
      const motionQueueEntry = ite.ptr();
      if (motionQueueEntry == null) {
        ite = motions.erase(ite);
        continue;
      }
      const expressionMotion = motionQueueEntry.getCubismMotion();
      if (expressionMotion == null) {
        csmDelete(motionQueueEntry);
        ite = motions.erase(ite);
        continue;
      }
      const expressionParameters = expressionMotion.getExpressionParameters();
      if (motionQueueEntry.isAvailable()) {
        for (let i = 0; i < expressionParameters.getSize(); ++i) {
          if (expressionParameters.at(i).parameterId == null) {
            continue;
          }
          let index = -1;
          for (let j = 0; j < this._expressionParameterValues.getSize(); ++j) {
            if (this._expressionParameterValues.at(j).parameterId != expressionParameters.at(i).parameterId) {
              continue;
            }
            index = j;
            break;
          }
          if (index >= 0) {
            continue;
          }
          const item = new ExpressionParameterValue();
          item.parameterId = expressionParameters.at(i).parameterId;
          item.additiveValue = CubismExpressionMotion.DefaultAdditiveValue;
          item.multiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
          item.overwriteValue = model.getParameterValueById(item.parameterId);
          this._expressionParameterValues.pushBack(item);
        }
      }
      expressionMotion.setupMotionQueueEntry(
        motionQueueEntry,
        this._userTimeSeconds
      );
      this._fadeWeights.set(
        expressionIndex,
        expressionMotion.updateFadeWeight(
          motionQueueEntry,
          this._userTimeSeconds
        )
      );
      expressionMotion.calculateExpressionParameters(
        model,
        this._userTimeSeconds,
        motionQueueEntry,
        this._expressionParameterValues,
        expressionIndex,
        this._fadeWeights.at(expressionIndex)
      );
      expressionWeight += expressionMotion.getFadeInTime() == 0 ? 1 : CubismMath.getEasingSine(
        (this._userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / expressionMotion.getFadeInTime()
      );
      updated = true;
      if (motionQueueEntry.isTriggeredFadeOut()) {
        motionQueueEntry.startFadeOut(
          motionQueueEntry.getFadeOutSeconds(),
          this._userTimeSeconds
        );
      }
      ite.preIncrement();
      ++expressionIndex;
    }
    if (motions.getSize() > 1) {
      motions.at(motions.getSize() - 1).getCubismMotion();
      const latestFadeWeight = this._fadeWeights.at(
        this._fadeWeights.getSize() - 1
      );
      if (latestFadeWeight >= 1) {
        for (let i = motions.getSize() - 2; i >= 0; --i) {
          const motionQueueEntry = motions.at(i);
          csmDelete(motionQueueEntry);
          motions.remove(i);
          this._fadeWeights.remove(i);
        }
      }
    }
    if (expressionWeight > 1) {
      expressionWeight = 1;
    }
    for (let i = 0; i < this._expressionParameterValues.getSize(); ++i) {
      const expressionParameterValue = this._expressionParameterValues.at(i);
      model.setParameterValueById(
        expressionParameterValue.parameterId,
        (expressionParameterValue.overwriteValue + expressionParameterValue.additiveValue) * expressionParameterValue.multiplyValue,
        expressionWeight
      );
      expressionParameterValue.additiveValue = CubismExpressionMotion.DefaultAdditiveValue;
      expressionParameterValue.multiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
    }
    return updated;
  }
  ///< 
}
var Live2DCubismFramework$f;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismExpressionMotionManager = CubismExpressionMotionManager;
})(Live2DCubismFramework$f || (Live2DCubismFramework$f = {}));
var CubismMotionCurveTarget = /* @__PURE__ */ ((CubismMotionCurveTarget2) => {
  CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_Model"] = 0] = "CubismMotionCurveTarget_Model";
  CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_Parameter"] = 1] = "CubismMotionCurveTarget_Parameter";
  CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_PartOpacity"] = 2] = "CubismMotionCurveTarget_PartOpacity";
  return CubismMotionCurveTarget2;
})(CubismMotionCurveTarget || {});
var CubismMotionSegmentType = /* @__PURE__ */ ((CubismMotionSegmentType2) => {
  CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Linear"] = 0] = "CubismMotionSegmentType_Linear";
  CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Bezier"] = 1] = "CubismMotionSegmentType_Bezier";
  CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Stepped"] = 2] = "CubismMotionSegmentType_Stepped";
  CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_InverseStepped"] = 3] = "CubismMotionSegmentType_InverseStepped";
  return CubismMotionSegmentType2;
})(CubismMotionSegmentType || {});
class CubismMotionPoint {
  constructor() {
    this.time = 0;
    this.value = 0;
  }
  // 
}
class CubismMotionSegment {
  /**
   * @brief 
   *
   * 
   */
  constructor() {
    this.evaluate = null;
    this.basePointIndex = 0;
    this.segmentType = 0;
  }
  // 
}
class CubismMotionCurve {
  constructor() {
    this.type = 0;
    this.segmentCount = 0;
    this.baseSegmentIndex = 0;
    this.fadeInTime = 0;
    this.fadeOutTime = 0;
  }
  // []
}
class CubismMotionEvent {
  constructor() {
    this.fireTime = 0;
  }
}
class CubismMotionData {
  constructor() {
    this.duration = 0;
    this.loop = false;
    this.curveCount = 0;
    this.eventCount = 0;
    this.fps = 0;
    this.curves = new csmVector();
    this.segments = new csmVector();
    this.points = new csmVector();
    this.events = new csmVector();
  }
  // 
}
var Live2DCubismFramework$e;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMotionCurve = CubismMotionCurve;
  Live2DCubismFramework2.CubismMotionCurveTarget = CubismMotionCurveTarget;
  Live2DCubismFramework2.CubismMotionData = CubismMotionData;
  Live2DCubismFramework2.CubismMotionEvent = CubismMotionEvent;
  Live2DCubismFramework2.CubismMotionPoint = CubismMotionPoint;
  Live2DCubismFramework2.CubismMotionSegment = CubismMotionSegment;
  Live2DCubismFramework2.CubismMotionSegmentType = CubismMotionSegmentType;
})(Live2DCubismFramework$e || (Live2DCubismFramework$e = {}));
const Meta$2 = "Meta";
const Duration = "Duration";
const Loop = "Loop";
const AreBeziersRestricted = "AreBeziersRestricted";
const CurveCount = "CurveCount";
const Fps$1 = "Fps";
const TotalSegmentCount = "TotalSegmentCount";
const TotalPointCount = "TotalPointCount";
const Curves = "Curves";
const Target$1 = "Target";
const Id$2 = "Id";
const FadeInTime = "FadeInTime";
const FadeOutTime = "FadeOutTime";
const Segments = "Segments";
const UserData$1 = "UserData";
const UserDataCount$1 = "UserDataCount";
const TotalUserDataSize$1 = "TotalUserDataSize";
const Time = "Time";
const Value$1 = "Value";
class CubismMotionJson {
  /**
   * 
   * @param buffer motion3.json
   * @param size 
   */
  constructor(buffer, size2) {
    this._json = CubismJson.create(buffer, size2);
  }
  /**
   * 
   */
  release() {
    CubismJson.delete(this._json);
  }
  /**
   * 
   * @return []
   */
  getMotionDuration() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(Duration).toFloat();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isMotionLoop() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(Loop).toBoolean();
  }
  getEvaluationOptionFlag(flagType) {
    if (0 == flagType) {
      return this._json.getRoot().getValueByString(Meta$2).getValueByString(AreBeziersRestricted).toBoolean();
    }
    return false;
  }
  /**
   * 
   * @return 
   */
  getMotionCurveCount() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(CurveCount).toInt();
  }
  /**
   * 
   * @return [FPS]
   */
  getMotionFps() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(Fps$1).toFloat();
  }
  /**
   * 
   * @return 
   */
  getMotionTotalSegmentCount() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(TotalSegmentCount).toInt();
  }
  /**
   * 
   * @return 
   */
  getMotionTotalPointCount() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(TotalPointCount).toInt();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistMotionFadeInTime() {
    return !this._json.getRoot().getValueByString(Meta$2).getValueByString(FadeInTime).isNull();
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isExistMotionFadeOutTime() {
    return !this._json.getRoot().getValueByString(Meta$2).getValueByString(FadeOutTime).isNull();
  }
  /**
   * 
   * @return []
   */
  getMotionFadeInTime() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(FadeInTime).toFloat();
  }
  /**
   * 
   * @return []
   */
  getMotionFadeOutTime() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(FadeOutTime).toFloat();
  }
  /**
   * 
   * @param curveIndex 
   * @return 
   */
  getMotionCurveTarget(curveIndex) {
    return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Target$1).getRawString();
  }
  /**
   * ID
   * @param curveIndex 
   * @return ID
   */
  getMotionCurveId(curveIndex) {
    return CubismFramework.getIdManager().getId(
      this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Id$2).getRawString()
    );
  }
  /**
   * 
   * @param curveIndex 
   * @return true 
   * @return false 
   */
  isExistMotionCurveFadeInTime(curveIndex) {
    return !this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeInTime).isNull();
  }
  /**
   * 
   * @param curveIndex 
   * @return true 
   * @return false 
   */
  isExistMotionCurveFadeOutTime(curveIndex) {
    return !this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeOutTime).isNull();
  }
  /**
   * 
   * @param curveIndex 
   * @return []
   */
  getMotionCurveFadeInTime(curveIndex) {
    return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeInTime).toFloat();
  }
  /**
   * 
   * @param curveIndex 
   * @return []
   */
  getMotionCurveFadeOutTime(curveIndex) {
    return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeOutTime).toFloat();
  }
  /**
   * 
   * @param curveIndex 
   * @return 
   */
  getMotionCurveSegmentCount(curveIndex) {
    return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Segments).getVector().getSize();
  }
  /**
   * 
   * @param curveIndex 
   * @param segmentIndex 
   * @return 
   */
  getMotionCurveSegment(curveIndex, segmentIndex) {
    return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Segments).getValueByIndex(segmentIndex).toFloat();
  }
  /**
   * 
   * @return 
   */
  getEventCount() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(UserDataCount$1).toInt();
  }
  /**
   *  
   * @return 
   */
  getTotalEventValueSize() {
    return this._json.getRoot().getValueByString(Meta$2).getValueByString(TotalUserDataSize$1).toInt();
  }
  /**
   * 
   * @param userDataIndex 
   * @return []
   */
  getEventTime(userDataIndex) {
    return this._json.getRoot().getValueByString(UserData$1).getValueByIndex(userDataIndex).getValueByString(Time).toFloat();
  }
  /**
   * 
   * @param userDataIndex 
   * @return 
   */
  getEventValue(userDataIndex) {
    return new csmString(
      this._json.getRoot().getValueByString(UserData$1).getValueByIndex(userDataIndex).getValueByString(Value$1).getRawString()
    );
  }
  // motion3.json
}
var EvaluationOptionFlag = /* @__PURE__ */ ((EvaluationOptionFlag2) => {
  EvaluationOptionFlag2[EvaluationOptionFlag2["EvaluationOptionFlag_AreBeziersRistricted"] = 0] = "EvaluationOptionFlag_AreBeziersRistricted";
  return EvaluationOptionFlag2;
})(EvaluationOptionFlag || {});
var Live2DCubismFramework$d;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMotionJson = CubismMotionJson;
})(Live2DCubismFramework$d || (Live2DCubismFramework$d = {}));
const EffectNameEyeBlink = "EyeBlink";
const EffectNameLipSync = "LipSync";
const TargetNameModel = "Model";
const TargetNameParameter = "Parameter";
const TargetNamePartOpacity = "PartOpacity";
const IdNameOpacity = "Opacity";
const UseOldBeziersCurveMotion = false;
function lerpPoints(a, b2, t2) {
  const result = new CubismMotionPoint();
  result.time = a.time + (b2.time - a.time) * t2;
  result.value = a.value + (b2.value - a.value) * t2;
  return result;
}
function linearEvaluate(points, time) {
  let t2 = (time - points[0].time) / (points[1].time - points[0].time);
  if (t2 < 0) {
    t2 = 0;
  }
  return points[0].value + (points[1].value - points[0].value) * t2;
}
function bezierEvaluate(points, time) {
  let t2 = (time - points[0].time) / (points[3].time - points[0].time);
  if (t2 < 0) {
    t2 = 0;
  }
  const p01 = lerpPoints(points[0], points[1], t2);
  const p12 = lerpPoints(points[1], points[2], t2);
  const p23 = lerpPoints(points[2], points[3], t2);
  const p012 = lerpPoints(p01, p12, t2);
  const p123 = lerpPoints(p12, p23, t2);
  return lerpPoints(p012, p123, t2).value;
}
function bezierEvaluateCardanoInterpretation(points, time) {
  const x2 = time;
  const x1 = points[0].time;
  const x22 = points[3].time;
  const cx1 = points[1].time;
  const cx2 = points[2].time;
  const a = x22 - 3 * cx2 + 3 * cx1 - x1;
  const b2 = 3 * cx2 - 6 * cx1 + 3 * x1;
  const c2 = 3 * cx1 - 3 * x1;
  const d2 = x1 - x2;
  const t2 = CubismMath.cardanoAlgorithmForBezier(a, b2, c2, d2);
  const p01 = lerpPoints(points[0], points[1], t2);
  const p12 = lerpPoints(points[1], points[2], t2);
  const p23 = lerpPoints(points[2], points[3], t2);
  const p012 = lerpPoints(p01, p12, t2);
  const p123 = lerpPoints(p12, p23, t2);
  return lerpPoints(p012, p123, t2).value;
}
function steppedEvaluate(points, time) {
  return points[0].value;
}
function inverseSteppedEvaluate(points, time) {
  return points[1].value;
}
function evaluateCurve(motionData, index, time) {
  const curve = motionData.curves.at(index);
  let target = -1;
  const totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;
  let pointPosition = 0;
  for (let i = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {
    pointPosition = motionData.segments.at(i).basePointIndex + (motionData.segments.at(i).segmentType == CubismMotionSegmentType.CubismMotionSegmentType_Bezier ? 3 : 1);
    if (motionData.points.at(pointPosition).time > time) {
      target = i;
      break;
    }
  }
  if (target == -1) {
    return motionData.points.at(pointPosition).value;
  }
  const segment = motionData.segments.at(target);
  return segment.evaluate(motionData.points.get(segment.basePointIndex), time);
}
class CubismMotion extends ACubismMotion {
  /**
   * 
   *
   * @param buffer motion3.json
   * @param size 
   * @param onFinishedMotionHandler 
   * @return 
   */
  static create(buffer, size2, onFinishedMotionHandler) {
    const ret = new CubismMotion();
    try {
      ret.parse(buffer, size2);
      if (!ret._motionData) {
        CubismLogError("Failed to parse motion data - motion data is null");
        return null;
      }
      ret._sourceFrameRate = ret._motionData.fps;
      ret._loopDurationSeconds = ret._motionData.duration;
      ret._onFinishedMotion = onFinishedMotionHandler;
      return ret;
    } catch (error2) {
      CubismLogError(`Failed to create motion: ${error2}`);
      return null;
    }
  }
  /**
   * 
   * @param model             
   * @param userTimeSeconds   []
   * @param fadeWeight        
   * @param motionQueueEntry  CubismMotionQueueManager
   */
  doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry) {
    if (this._modelCurveIdEyeBlink == null) {
      this._modelCurveIdEyeBlink = CubismFramework.getIdManager().getId(EffectNameEyeBlink);
    }
    if (this._modelCurveIdLipSync == null) {
      this._modelCurveIdLipSync = CubismFramework.getIdManager().getId(EffectNameLipSync);
    }
    if (this._modelCurveIdOpacity == null) {
      this._modelCurveIdOpacity = CubismFramework.getIdManager().getId(IdNameOpacity);
    }
    let timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();
    if (timeOffsetSeconds < 0) {
      timeOffsetSeconds = 0;
    }
    let lipSyncValue = Number.MAX_VALUE;
    let eyeBlinkValue = Number.MAX_VALUE;
    const maxTargetSize = 64;
    let lipSyncFlags = 0;
    let eyeBlinkFlags = 0;
    if (this._eyeBlinkParameterIds.getSize() > maxTargetSize) {
      CubismLogDebug(
        "too many eye blink targets : {0}",
        this._eyeBlinkParameterIds.getSize()
      );
    }
    if (this._lipSyncParameterIds.getSize() > maxTargetSize) {
      CubismLogDebug(
        "too many lip sync targets : {0}",
        this._lipSyncParameterIds.getSize()
      );
    }
    const tmpFadeIn = this._fadeInSeconds <= 0 ? 1 : CubismMath.getEasingSine(
      (userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds
    );
    const tmpFadeOut = this._fadeOutSeconds <= 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine(
      (motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds
    );
    let value;
    let c2, parameterIndex;
    let time = timeOffsetSeconds;
    if (this._isLoop) {
      while (time > this._motionData.duration) {
        time -= this._motionData.duration;
      }
    }
    const curves = this._motionData.curves;
    for (c2 = 0; c2 < this._motionData.curveCount && curves.at(c2).type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c2) {
      value = evaluateCurve(this._motionData, c2, time);
      if (curves.at(c2).id == this._modelCurveIdEyeBlink) {
        eyeBlinkValue = value;
      } else if (curves.at(c2).id == this._modelCurveIdLipSync) {
        lipSyncValue = value;
      } else if (curves.at(c2).id == this._modelCurveIdOpacity) {
        this._modelOpacity = value;
        model.setModelOapcity(this.getModelOpacityValue());
      }
    }
    for (; c2 < this._motionData.curveCount && curves.at(c2).type == CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c2) {
      parameterIndex = model.getParameterIndex(curves.at(c2).id);
      if (parameterIndex == -1) {
        continue;
      }
      const sourceValue = model.getParameterValueByIndex(parameterIndex);
      value = evaluateCurve(this._motionData, c2, time);
      if (eyeBlinkValue != Number.MAX_VALUE) {
        for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < maxTargetSize; ++i) {
          if (this._eyeBlinkParameterIds.at(i) == curves.at(c2).id) {
            value *= eyeBlinkValue;
            eyeBlinkFlags |= 1 << i;
            break;
          }
        }
      }
      if (lipSyncValue != Number.MAX_VALUE) {
        for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < maxTargetSize; ++i) {
          if (this._lipSyncParameterIds.at(i) == curves.at(c2).id) {
            value += lipSyncValue;
            lipSyncFlags |= 1 << i;
            break;
          }
        }
      }
      let v2;
      if (curves.at(c2).fadeInTime < 0 && curves.at(c2).fadeOutTime < 0) {
        v2 = sourceValue + (value - sourceValue) * fadeWeight;
      } else {
        let fin;
        let fout;
        if (curves.at(c2).fadeInTime < 0) {
          fin = tmpFadeIn;
        } else {
          fin = curves.at(c2).fadeInTime == 0 ? 1 : CubismMath.getEasingSine(
            (userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / curves.at(c2).fadeInTime
          );
        }
        if (curves.at(c2).fadeOutTime < 0) {
          fout = tmpFadeOut;
        } else {
          fout = curves.at(c2).fadeOutTime == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine(
            (motionQueueEntry.getEndTime() - userTimeSeconds) / curves.at(c2).fadeOutTime
          );
        }
        const paramWeight = this._weight * fin * fout;
        v2 = sourceValue + (value - sourceValue) * paramWeight;
      }
      model.setParameterValueByIndex(parameterIndex, v2, 1);
    }
    {
      if (eyeBlinkValue != Number.MAX_VALUE) {
        for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < maxTargetSize; ++i) {
          const sourceValue = model.getParameterValueById(
            this._eyeBlinkParameterIds.at(i)
          );
          if (eyeBlinkFlags >> i & 1) {
            continue;
          }
          const v2 = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;
          model.setParameterValueById(this._eyeBlinkParameterIds.at(i), v2);
        }
      }
      if (lipSyncValue != Number.MAX_VALUE) {
        for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < maxTargetSize; ++i) {
          const sourceValue = model.getParameterValueById(
            this._lipSyncParameterIds.at(i)
          );
          if (lipSyncFlags >> i & 1) {
            continue;
          }
          const v2 = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;
          model.setParameterValueById(this._lipSyncParameterIds.at(i), v2);
        }
      }
    }
    for (; c2 < this._motionData.curveCount && curves.at(c2).type == CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c2) {
      parameterIndex = model.getParameterIndex(curves.at(c2).id);
      if (parameterIndex == -1) {
        continue;
      }
      value = evaluateCurve(this._motionData, c2, time);
      model.setParameterValueByIndex(parameterIndex, value);
    }
    if (timeOffsetSeconds >= this._motionData.duration) {
      if (this._isLoop) {
        motionQueueEntry.setStartTime(userTimeSeconds);
        if (this._isLoopFadeIn) {
          motionQueueEntry.setFadeInStartTime(userTimeSeconds);
        }
      } else {
        if (this._onFinishedMotion) {
          this._onFinishedMotion(this);
        }
        motionQueueEntry.setIsFinished(true);
      }
    }
    this._lastWeight = fadeWeight;
  }
  /**
   * 
   * @param loop 
   */
  setIsLoop(loop) {
    this._isLoop = loop;
  }
  /**
   * 
   * @return true 
   * @return false 
   */
  isLoop() {
    return this._isLoop;
  }
  /**
   * 
   * @param loopFadeIn  
   */
  setIsLoopFadeIn(loopFadeIn) {
    this._isLoopFadeIn = loopFadeIn;
  }
  /**
   * 
   *
   * @return  true    
   * @return  false   
   */
  isLoopFadeIn() {
    return this._isLoopFadeIn;
  }
  /**
   * 
   *
   * @return  []
   */
  getDuration() {
    return this._isLoop ? -1 : this._loopDurationSeconds;
  }
  /**
   * 
   *
   * @return  []
   */
  getLoopDuration() {
    return this._loopDurationSeconds;
  }
  /**
   * 
   *
   * @param parameterId     ID
   * @param value           []
   */
  setParameterFadeInTime(parameterId, value) {
    const curves = this._motionData.curves;
    for (let i = 0; i < this._motionData.curveCount; ++i) {
      if (parameterId == curves.at(i).id) {
        curves.at(i).fadeInTime = value;
        return;
      }
    }
  }
  /**
   * 
   * @param parameterId     ID
   * @param value           []
   */
  setParameterFadeOutTime(parameterId, value) {
    const curves = this._motionData.curves;
    for (let i = 0; i < this._motionData.curveCount; ++i) {
      if (parameterId == curves.at(i).id) {
        curves.at(i).fadeOutTime = value;
        return;
      }
    }
  }
  /**
   * 
   * @param    parameterId     ID
   * @return   []
   */
  getParameterFadeInTime(parameterId) {
    const curves = this._motionData.curves;
    for (let i = 0; i < this._motionData.curveCount; ++i) {
      if (parameterId == curves.at(i).id) {
        return curves.at(i).fadeInTime;
      }
    }
    return -1;
  }
  /**
   * 
   *
   * @param   parameterId     ID
   * @return   []
   */
  getParameterFadeOutTime(parameterId) {
    const curves = this._motionData.curves;
    for (let i = 0; i < this._motionData.curveCount; ++i) {
      if (parameterId == curves.at(i).id) {
        return curves.at(i).fadeOutTime;
      }
    }
    return -1;
  }
  /**
   * ID
   * @param eyeBlinkParameterIds    ID
   * @param lipSyncParameterIds     ID
   */
  setEffectIds(eyeBlinkParameterIds, lipSyncParameterIds) {
    this._eyeBlinkParameterIds = eyeBlinkParameterIds;
    this._lipSyncParameterIds = lipSyncParameterIds;
  }
  /**
   * 
   */
  constructor() {
    super();
    this._sourceFrameRate = 30;
    this._loopDurationSeconds = -1;
    this._isLoop = false;
    this._isLoopFadeIn = true;
    this._lastWeight = 0;
    this._motionData = null;
    this._modelCurveIdEyeBlink = null;
    this._modelCurveIdLipSync = null;
    this._modelCurveIdOpacity = null;
    this._eyeBlinkParameterIds = null;
    this._lipSyncParameterIds = null;
    this._modelOpacity = 1;
  }
  /**
   * 
   */
  release() {
    this._motionData = void 0;
    this._motionData = null;
  }
  /**
   * motion3.json
   *
   * @param motionJson  motion3.json
   * @param size        
   */
  parse(motionJson, size2) {
    this._motionData = new CubismMotionData();
    let json = new CubismMotionJson(motionJson, size2);
    if (!json) {
      json.release();
      json = void 0;
      return;
    }
    this._motionData.duration = json.getMotionDuration();
    this._motionData.loop = json.isMotionLoop();
    this._motionData.curveCount = json.getMotionCurveCount();
    this._motionData.fps = json.getMotionFps();
    this._motionData.eventCount = json.getEventCount();
    const areBeziersRestructed = json.getEvaluationOptionFlag(
      EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted
    );
    if (json.isExistMotionFadeInTime()) {
      this._fadeInSeconds = json.getMotionFadeInTime() < 0 ? 1 : json.getMotionFadeInTime();
    } else {
      this._fadeInSeconds = 1;
    }
    if (json.isExistMotionFadeOutTime()) {
      this._fadeOutSeconds = json.getMotionFadeOutTime() < 0 ? 1 : json.getMotionFadeOutTime();
    } else {
      this._fadeOutSeconds = 1;
    }
    this._motionData.curves.updateSize(
      this._motionData.curveCount,
      CubismMotionCurve,
      true
    );
    let totalRequiredSegments = 0;
    let totalRequiredPoints = 0;
    for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {
      const segmentCount = json.getMotionCurveSegmentCount(curveCount);
      for (let segmentPos = 0; segmentPos < segmentCount; ) {
        totalRequiredSegments++;
        if (segmentPos == 0) {
          totalRequiredPoints += 1;
          segmentPos += 2;
        } else {
          const segmentType = json.getMotionCurveSegment(curveCount, segmentPos);
          switch (segmentType) {
            case CubismMotionSegmentType.CubismMotionSegmentType_Linear:
            case CubismMotionSegmentType.CubismMotionSegmentType_Stepped:
            case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped:
              totalRequiredPoints += 1;
              segmentPos += 3;
              break;
            case CubismMotionSegmentType.CubismMotionSegmentType_Bezier:
              totalRequiredPoints += 3;
              segmentPos += 7;
              break;
            default:
              segmentPos += 3;
              totalRequiredPoints += 1;
              break;
          }
        }
      }
    }
    this._motionData.segments.updateSize(
      totalRequiredSegments,
      CubismMotionSegment,
      true
    );
    this._motionData.points.updateSize(
      totalRequiredPoints,
      CubismMotionPoint,
      true
    );
    this._motionData.events.updateSize(
      this._motionData.eventCount,
      CubismMotionEvent,
      true
    );
    let totalPointCount = 0;
    let totalSegmentCount = 0;
    for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {
      if (json.getMotionCurveTarget(curveCount) == TargetNameModel) {
        this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;
      } else if (json.getMotionCurveTarget(curveCount) == TargetNameParameter) {
        this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;
      } else if (json.getMotionCurveTarget(curveCount) == TargetNamePartOpacity) {
        this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;
      } else {
        CubismLogWarning(
          'Warning : Unable to get segment type from Curve! The number of "CurveCount" may be incorrect!'
        );
      }
      this._motionData.curves.at(curveCount).id = json.getMotionCurveId(curveCount);
      this._motionData.curves.at(curveCount).baseSegmentIndex = totalSegmentCount;
      this._motionData.curves.at(curveCount).fadeInTime = json.isExistMotionCurveFadeInTime(curveCount) ? json.getMotionCurveFadeInTime(curveCount) : -1;
      this._motionData.curves.at(curveCount).fadeOutTime = json.isExistMotionCurveFadeOutTime(curveCount) ? json.getMotionCurveFadeOutTime(curveCount) : -1;
      for (let segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount); ) {
        if (segmentPosition == 0) {
          this._motionData.segments.at(totalSegmentCount).basePointIndex = totalPointCount;
          this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition);
          this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
          totalPointCount += 1;
          segmentPosition += 2;
        } else {
          this._motionData.segments.at(totalSegmentCount).basePointIndex = totalPointCount - 1;
        }
        const segment = json.getMotionCurveSegment(
          curveCount,
          segmentPosition
        );
        const segmentType = segment;
        switch (segmentType) {
          case CubismMotionSegmentType.CubismMotionSegmentType_Linear: {
            this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Linear;
            this._motionData.segments.at(totalSegmentCount).evaluate = linearEvaluate;
            if (totalPointCount >= this._motionData.points.getSize()) {
              const newSize = Math.max(totalPointCount + 1, this._motionData.points.getSize() * 2);
              CubismLogWarning(`Expanding motion points array from ${this._motionData.points.getSize()} to ${newSize} for Linear segment`);
              this._motionData.points.updateSize(newSize, CubismMotionPoint, true);
            }
            this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
            this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
            totalPointCount += 1;
            segmentPosition += 3;
            break;
          }
          case CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {
            this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Bezier;
            if (areBeziersRestructed || UseOldBeziersCurveMotion) {
              this._motionData.segments.at(totalSegmentCount).evaluate = bezierEvaluate;
            } else {
              this._motionData.segments.at(totalSegmentCount).evaluate = bezierEvaluateCardanoInterpretation;
            }
            this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
            this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
            this._motionData.points.at(totalPointCount + 1).time = json.getMotionCurveSegment(curveCount, segmentPosition + 3);
            this._motionData.points.at(totalPointCount + 1).value = json.getMotionCurveSegment(curveCount, segmentPosition + 4);
            this._motionData.points.at(totalPointCount + 2).time = json.getMotionCurveSegment(curveCount, segmentPosition + 5);
            this._motionData.points.at(totalPointCount + 2).value = json.getMotionCurveSegment(curveCount, segmentPosition + 6);
            totalPointCount += 3;
            segmentPosition += 7;
            break;
          }
          case CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {
            this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Stepped;
            this._motionData.segments.at(totalSegmentCount).evaluate = steppedEvaluate;
            this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
            this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
            totalPointCount += 1;
            segmentPosition += 3;
            break;
          }
          case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {
            this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;
            this._motionData.segments.at(totalSegmentCount).evaluate = inverseSteppedEvaluate;
            this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
            this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
            totalPointCount += 1;
            segmentPosition += 3;
            break;
          }
          default: {
            CSM_ASSERT(0);
            break;
          }
        }
        ++this._motionData.curves.at(curveCount).segmentCount;
        ++totalSegmentCount;
      }
    }
    for (let userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {
      this._motionData.events.at(userdatacount).fireTime = json.getEventTime(userdatacount);
      this._motionData.events.at(userdatacount).value = json.getEventValue(userdatacount);
    }
    json.release();
    json = void 0;
    json = null;
  }
  /**
   * 
   *
   * 
   * 
   *
   * @param beforeCheckTimeSeconds   []
   * @param motionTimeSeconds        []
   */
  getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
    this._firedEventValues.updateSize(0);
    for (let u2 = 0; u2 < this._motionData.eventCount; ++u2) {
      if (this._motionData.events.at(u2).fireTime > beforeCheckTimeSeconds && this._motionData.events.at(u2).fireTime <= motionTimeSeconds) {
        this._firedEventValues.pushBack(
          new csmString(this._motionData.events.at(u2).value.s)
        );
      }
    }
    return this._firedEventValues;
  }
  /**
   * 
   *
   * @returns true  -> 
   *          false -> 
   */
  isExistModelOpacity() {
    for (let i = 0; i < this._motionData.curveCount; i++) {
      const curve = this._motionData.curves.at(i);
      if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
        continue;
      }
      if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
        return true;
      }
    }
    return false;
  }
  /**
   * 
   *
   * @returns success:
   */
  getModelOpacityIndex() {
    if (this.isExistModelOpacity()) {
      for (let i = 0; i < this._motionData.curveCount; i++) {
        const curve = this._motionData.curves.at(i);
        if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
          continue;
        }
        if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
          return i;
        }
      }
    }
    return -1;
  }
  /**
   * Id
   *
   * @param index 
   * @returns success:
   */
  getModelOpacityId(index) {
    if (index != -1) {
      const curve = this._motionData.curves.at(index);
      if (curve.type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
        if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
          return CubismFramework.getIdManager().getId(curve.id.getString().s);
        }
      }
    }
    return null;
  }
  /**
   * 
   *
   * @returns success:Opacity
   */
  getModelOpacityValue() {
    return this._modelOpacity;
  }
  // 
}
var Live2DCubismFramework$c;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMotion = CubismMotion;
})(Live2DCubismFramework$c || (Live2DCubismFramework$c = {}));
class CubismMotionManager extends CubismMotionQueueManager {
  /**
   * 
   */
  constructor() {
    super();
    this._currentPriority = 0;
    this._reservePriority = 0;
  }
  /**
   * 
   * @return  
   */
  getCurrentPriority() {
    return this._currentPriority;
  }
  /**
   * 
   * @return  
   */
  getReservePriority() {
    return this._reservePriority;
  }
  /**
   * 
   * @param   val     
   */
  setReservePriority(val) {
    this._reservePriority = val;
  }
  /**
   * 
   *
   * @param motion          
   * @param autoDelete      true
   * @param priority        
   * @return                IsFinished()-1
   */
  startMotionPriority(motion, autoDelete, priority) {
    if (priority == this._reservePriority) {
      this._reservePriority = 0;
    }
    this._currentPriority = priority;
    return super.startMotion(motion, autoDelete);
  }
  /**
   * 
   *
   * @param model   
   * @param deltaTimeSeconds    []
   * @return  true    
   * @return  false   
   */
  updateMotion(model, deltaTimeSeconds) {
    this._userTimeSeconds += deltaTimeSeconds;
    const updated = super.doUpdateMotion(model, this._userTimeSeconds);
    if (this.isFinished()) {
      this._currentPriority = 0;
    }
    return updated;
  }
  /**
   * 
   *
   * @param   priority    
   * @return  true    
   * @return  false   
   */
  reserveMotion(priority) {
    if (priority <= this._reservePriority || priority <= this._currentPriority) {
      return false;
    }
    this._reservePriority = priority;
    return true;
  }
  // 0
}
var Live2DCubismFramework$b;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMotionManager = CubismMotionManager;
})(Live2DCubismFramework$b || (Live2DCubismFramework$b = {}));
var CubismPhysicsTargetType = /* @__PURE__ */ ((CubismPhysicsTargetType2) => {
  CubismPhysicsTargetType2[CubismPhysicsTargetType2["CubismPhysicsTargetType_Parameter"] = 0] = "CubismPhysicsTargetType_Parameter";
  return CubismPhysicsTargetType2;
})(CubismPhysicsTargetType || {});
var CubismPhysicsSource = /* @__PURE__ */ ((CubismPhysicsSource2) => {
  CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_X"] = 0] = "CubismPhysicsSource_X";
  CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_Y"] = 1] = "CubismPhysicsSource_Y";
  CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_Angle"] = 2] = "CubismPhysicsSource_Angle";
  return CubismPhysicsSource2;
})(CubismPhysicsSource || {});
class PhysicsJsonEffectiveForces {
  constructor() {
    this.gravity = new CubismVector2(0, 0);
    this.wind = new CubismVector2(0, 0);
  }
  // 
}
class CubismPhysicsParameter {
  // 
}
class CubismPhysicsNormalization {
  // 
}
class CubismPhysicsParticle {
  constructor() {
    this.initialPosition = new CubismVector2(0, 0);
    this.position = new CubismVector2(0, 0);
    this.lastPosition = new CubismVector2(0, 0);
    this.lastGravity = new CubismVector2(0, 0);
    this.force = new CubismVector2(0, 0);
    this.velocity = new CubismVector2(0, 0);
  }
  // 
}
class CubismPhysicsSubRig {
  constructor() {
    this.normalizationPosition = new CubismPhysicsNormalization();
    this.normalizationAngle = new CubismPhysicsNormalization();
  }
  // 
}
class CubismPhysicsInput {
  constructor() {
    this.source = new CubismPhysicsParameter();
  }
  // 
}
class CubismPhysicsOutput {
  constructor() {
    this.destination = new CubismPhysicsParameter();
    this.translationScale = new CubismVector2(0, 0);
  }
  // 
}
class CubismPhysicsRig {
  constructor() {
    this.settings = new csmVector();
    this.inputs = new csmVector();
    this.outputs = new csmVector();
    this.particles = new csmVector();
    this.gravity = new CubismVector2(0, 0);
    this.wind = new CubismVector2(0, 0);
    this.fps = 0;
  }
  //FPS
}
var Live2DCubismFramework$a;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismPhysicsInput = CubismPhysicsInput;
  Live2DCubismFramework2.CubismPhysicsNormalization = CubismPhysicsNormalization;
  Live2DCubismFramework2.CubismPhysicsOutput = CubismPhysicsOutput;
  Live2DCubismFramework2.CubismPhysicsParameter = CubismPhysicsParameter;
  Live2DCubismFramework2.CubismPhysicsParticle = CubismPhysicsParticle;
  Live2DCubismFramework2.CubismPhysicsRig = CubismPhysicsRig;
  Live2DCubismFramework2.CubismPhysicsSource = CubismPhysicsSource;
  Live2DCubismFramework2.CubismPhysicsSubRig = CubismPhysicsSubRig;
  Live2DCubismFramework2.CubismPhysicsTargetType = CubismPhysicsTargetType;
  Live2DCubismFramework2.PhysicsJsonEffectiveForces = PhysicsJsonEffectiveForces;
})(Live2DCubismFramework$a || (Live2DCubismFramework$a = {}));
const Position = "Position";
const X = "X";
const Y = "Y";
const Angle = "Angle";
const Type = "Type";
const Id$1 = "Id";
const Meta$1 = "Meta";
const EffectiveForces = "EffectiveForces";
const TotalInputCount = "TotalInputCount";
const TotalOutputCount = "TotalOutputCount";
const PhysicsSettingCount = "PhysicsSettingCount";
const Gravity = "Gravity";
const Wind = "Wind";
const VertexCount = "VertexCount";
const Fps = "Fps";
const PhysicsSettings = "PhysicsSettings";
const Normalization = "Normalization";
const Minimum = "Minimum";
const Maximum = "Maximum";
const Default = "Default";
const Reflect$1 = "Reflect";
const Weight = "Weight";
const Input = "Input";
const Source = "Source";
const Output = "Output";
const Scale = "Scale";
const VertexIndex = "VertexIndex";
const Destination = "Destination";
const Vertices = "Vertices";
const Mobility = "Mobility";
const Delay = "Delay";
const Radius = "Radius";
const Acceleration = "Acceleration";
class CubismPhysicsJson {
  /**
   * 
   * @param buffer physics3.json
   * @param size 
   */
  constructor(buffer, size2) {
    this._json = CubismJson.create(buffer, size2);
  }
  /**
   * 
   */
  release() {
    CubismJson.delete(this._json);
  }
  /**
   * 
   * @return 
   */
  getGravity() {
    const ret = new CubismVector2(0, 0);
    ret.x = this._json.getRoot().getValueByString(Meta$1).getValueByString(EffectiveForces).getValueByString(Gravity).getValueByString(X).toFloat();
    ret.y = this._json.getRoot().getValueByString(Meta$1).getValueByString(EffectiveForces).getValueByString(Gravity).getValueByString(Y).toFloat();
    return ret;
  }
  /**
   * 
   * @return 
   */
  getWind() {
    const ret = new CubismVector2(0, 0);
    ret.x = this._json.getRoot().getValueByString(Meta$1).getValueByString(EffectiveForces).getValueByString(Wind).getValueByString(X).toFloat();
    ret.y = this._json.getRoot().getValueByString(Meta$1).getValueByString(EffectiveForces).getValueByString(Wind).getValueByString(Y).toFloat();
    return ret;
  }
  /**
   * FPS
   * @return FPS
   */
  getFps() {
    return this._json.getRoot().getValueByString(Meta$1).getValueByString(Fps).toFloat(0);
  }
  /**
   * 
   * @return 
   */
  getSubRigCount() {
    return this._json.getRoot().getValueByString(Meta$1).getValueByString(PhysicsSettingCount).toInt();
  }
  /**
   * 
   * @return 
   */
  getTotalInputCount() {
    return this._json.getRoot().getValueByString(Meta$1).getValueByString(TotalInputCount).toInt();
  }
  /**
   * 
   * @return 
   */
  getTotalOutputCount() {
    return this._json.getRoot().getValueByString(Meta$1).getValueByString(TotalOutputCount).toInt();
  }
  /**
   * 
   * @return 
   */
  getVertexCount() {
    return this._json.getRoot().getValueByString(Meta$1).getValueByString(VertexCount).toInt();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @return 
   */
  getNormalizationPositionMinimumValue(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Minimum).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @return 
   */
  getNormalizationPositionMaximumValue(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Maximum).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @return 
   */
  getNormalizationPositionDefaultValue(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Default).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @return 
   */
  getNormalizationAngleMinimumValue(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Minimum).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex
   * @return 
   */
  getNormalizationAngleMaximumValue(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Maximum).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @return 
   */
  getNormalizationAngleDefaultValue(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Default).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @return 
   */
  getInputCount(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getVector().getSize();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param inputIndex 
   * @return 
   */
  getInputWeight(physicsSettingIndex, inputIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Weight).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param inputIndex 
   * @return 
   */
  getInputReflect(physicsSettingIndex, inputIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Reflect$1).toBoolean();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param inputIndex 
   * @return 
   */
  getInputType(physicsSettingIndex, inputIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Type).getRawString();
  }
  /**
   * ID
   * @param physicsSettingIndex 
   * @param inputIndex 
   * @return ID
   */
  getInputSourceId(physicsSettingIndex, inputIndex) {
    return CubismFramework.getIdManager().getId(
      this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Source).getValueByString(Id$1).getRawString()
    );
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @return 
   */
  getOutputCount(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getVector().getSize();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param outputIndex 
   * @return 
   */
  getOutputVertexIndex(physicsSettingIndex, outputIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(VertexIndex).toInt();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param outputIndex 
   * @return 
   */
  getOutputAngleScale(physicsSettingIndex, outputIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Scale).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param outputIndex 
   * @return 
   */
  getOutputWeight(physicsSettingIndex, outputIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Weight).toFloat();
  }
  /**
   * ID
   * @param physicsSettingIndex 
   * @param outputIndex 
   * @return ID
   */
  getOutputDestinationId(physicsSettingIndex, outputIndex) {
    return CubismFramework.getIdManager().getId(
      this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Destination).getValueByString(Id$1).getRawString()
    );
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param outputIndex 
   * @return 
   */
  getOutputType(physicsSettingIndex, outputIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Type).getRawString();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param outputIndex 
   * @return 
   */
  getOutputReflect(physicsSettingIndex, outputIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Reflect$1).toBoolean();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @return 
   */
  getParticleCount(physicsSettingIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getVector().getSize();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param vertexIndex 
   * @return 
   */
  getParticleMobility(physicsSettingIndex, vertexIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Mobility).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param vertexIndex 
   * @return 
   */
  getParticleDelay(physicsSettingIndex, vertexIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Delay).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param vertexIndex 
   * @return 
   */
  getParticleAcceleration(physicsSettingIndex, vertexIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Acceleration).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param vertexIndex 
   * @return 
   */
  getParticleRadius(physicsSettingIndex, vertexIndex) {
    return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Radius).toFloat();
  }
  /**
   * 
   * @param physicsSettingIndex 
   * @param vertexInde 
   * @return 
   */
  getParticlePosition(physicsSettingIndex, vertexIndex) {
    const ret = new CubismVector2(0, 0);
    ret.x = this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Position).getValueByString(X).toFloat();
    ret.y = this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Position).getValueByString(Y).toFloat();
    return ret;
  }
  // physics3.json
}
var Live2DCubismFramework$9;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismPhysicsJson = CubismPhysicsJson;
})(Live2DCubismFramework$9 || (Live2DCubismFramework$9 = {}));
const PhysicsTypeTagX = "X";
const PhysicsTypeTagY = "Y";
const PhysicsTypeTagAngle = "Angle";
const AirResistance = 5;
const MaximumWeight = 100;
const MovementThreshold = 1e-3;
const MaxDeltaTime = 5;
class CubismPhysics {
  /**
   * 
   * @param buffer    physics3.json
   * @param size      
   * @return 
   */
  static create(buffer, size2) {
    const ret = new CubismPhysics();
    ret.parse(buffer, size2);
    ret._physicsRig.gravity.y = 0;
    return ret;
  }
  /**
   * 
   * @param physics 
   */
  static delete(physics) {
    if (physics != null) {
      physics.release();
      physics = null;
    }
  }
  /**
   * physics3.json
   * @param physicsJson physics3.json
   * @param size 
   */
  parse(physicsJson, size2) {
    this._physicsRig = new CubismPhysicsRig();
    let json = new CubismPhysicsJson(physicsJson, size2);
    this._physicsRig.gravity = json.getGravity();
    this._physicsRig.wind = json.getWind();
    this._physicsRig.subRigCount = json.getSubRigCount();
    this._physicsRig.fps = json.getFps();
    this._physicsRig.settings.updateSize(
      this._physicsRig.subRigCount,
      CubismPhysicsSubRig,
      true
    );
    this._physicsRig.inputs.updateSize(
      json.getTotalInputCount(),
      CubismPhysicsInput,
      true
    );
    this._physicsRig.outputs.updateSize(
      json.getTotalOutputCount(),
      CubismPhysicsOutput,
      true
    );
    this._physicsRig.particles.updateSize(
      json.getVertexCount(),
      CubismPhysicsParticle,
      true
    );
    this._currentRigOutputs.clear();
    this._previousRigOutputs.clear();
    let inputIndex = 0, outputIndex = 0, particleIndex = 0;
    for (let i = 0; i < this._physicsRig.settings.getSize(); ++i) {
      this._physicsRig.settings.at(i).normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(i);
      this._physicsRig.settings.at(i).normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(i);
      this._physicsRig.settings.at(i).normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(i);
      this._physicsRig.settings.at(i).normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(i);
      this._physicsRig.settings.at(i).normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(i);
      this._physicsRig.settings.at(i).normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(i);
      this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);
      this._physicsRig.settings.at(i).baseInputIndex = inputIndex;
      for (let j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {
        this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;
        this._physicsRig.inputs.at(inputIndex + j).weight = json.getInputWeight(
          i,
          j
        );
        this._physicsRig.inputs.at(inputIndex + j).reflect = json.getInputReflect(i, j);
        if (json.getInputType(i, j) == PhysicsTypeTagX) {
          this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;
          this._physicsRig.inputs.at(
            inputIndex + j
          ).getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;
        } else if (json.getInputType(i, j) == PhysicsTypeTagY) {
          this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;
          this._physicsRig.inputs.at(
            inputIndex + j
          ).getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;
        } else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {
          this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;
          this._physicsRig.inputs.at(
            inputIndex + j
          ).getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;
        }
        this._physicsRig.inputs.at(inputIndex + j).source.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
        this._physicsRig.inputs.at(inputIndex + j).source.id = json.getInputSourceId(i, j);
      }
      inputIndex += this._physicsRig.settings.at(i).inputCount;
      this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);
      this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;
      const currentRigOutput = new PhysicsOutput();
      currentRigOutput.outputs.resize(
        this._physicsRig.settings.at(i).outputCount
      );
      const previousRigOutput = new PhysicsOutput();
      previousRigOutput.outputs.resize(
        this._physicsRig.settings.at(i).outputCount
      );
      for (let j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {
        currentRigOutput.outputs.set(j, 0);
        previousRigOutput.outputs.set(j, 0);
        this._physicsRig.outputs.at(outputIndex + j).destinationParameterIndex = -1;
        this._physicsRig.outputs.at(outputIndex + j).vertexIndex = json.getOutputVertexIndex(i, j);
        this._physicsRig.outputs.at(outputIndex + j).angleScale = json.getOutputAngleScale(i, j);
        this._physicsRig.outputs.at(outputIndex + j).weight = json.getOutputWeight(i, j);
        this._physicsRig.outputs.at(outputIndex + j).destination.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
        this._physicsRig.outputs.at(outputIndex + j).destination.id = json.getOutputDestinationId(i, j);
        if (json.getOutputType(i, j) == PhysicsTypeTagX) {
          this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;
          this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationX;
          this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationX;
        } else if (json.getOutputType(i, j) == PhysicsTypeTagY) {
          this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;
          this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationY;
          this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationY;
        } else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {
          this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;
          this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputAngle;
          this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleAngle;
        }
        this._physicsRig.outputs.at(outputIndex + j).reflect = json.getOutputReflect(i, j);
      }
      this._currentRigOutputs.pushBack(currentRigOutput);
      this._previousRigOutputs.pushBack(previousRigOutput);
      outputIndex += this._physicsRig.settings.at(i).outputCount;
      this._physicsRig.settings.at(i).particleCount = json.getParticleCount(i);
      this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;
      for (let j = 0; j < this._physicsRig.settings.at(i).particleCount; ++j) {
        this._physicsRig.particles.at(particleIndex + j).mobility = json.getParticleMobility(i, j);
        this._physicsRig.particles.at(particleIndex + j).delay = json.getParticleDelay(i, j);
        this._physicsRig.particles.at(particleIndex + j).acceleration = json.getParticleAcceleration(i, j);
        this._physicsRig.particles.at(particleIndex + j).radius = json.getParticleRadius(i, j);
        this._physicsRig.particles.at(particleIndex + j).position = json.getParticlePosition(i, j);
      }
      particleIndex += this._physicsRig.settings.at(i).particleCount;
    }
    this.initialize();
    json.release();
    json = void 0;
    json = null;
  }
  /**
   * 
   * @param model 
   */
  stabilization(model) {
    let totalAngle;
    let weight;
    let radAngle;
    let outputValue;
    const totalTranslation = new CubismVector2();
    let currentSetting;
    let currentInputs;
    let currentOutputs;
    let currentParticles;
    const parameterValues = model.getModel().parameters.values;
    const parameterMaximumValues = model.getModel().parameters.maximumValues;
    const parameterMinimumValues = model.getModel().parameters.minimumValues;
    const parameterDefaultValues = model.getModel().parameters.defaultValues;
    if ((this._parameterCaches?.length ?? 0) < model.getParameterCount()) {
      this._parameterCaches = new Float32Array(model.getParameterCount());
    }
    if ((this._parameterInputCaches?.length ?? 0) < model.getParameterCount()) {
      this._parameterInputCaches = new Float32Array(model.getParameterCount());
    }
    for (let j = 0; j < model.getParameterCount(); ++j) {
      this._parameterCaches[j] = parameterValues[j];
      this._parameterInputCaches[j] = parameterValues[j];
    }
    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
      totalAngle = { angle: 0 };
      totalTranslation.x = 0;
      totalTranslation.y = 0;
      currentSetting = this._physicsRig.settings.at(settingIndex);
      currentInputs = this._physicsRig.inputs.get(
        currentSetting.baseInputIndex
      );
      currentOutputs = this._physicsRig.outputs.get(
        currentSetting.baseOutputIndex
      );
      currentParticles = this._physicsRig.particles.get(
        currentSetting.baseParticleIndex
      );
      for (let i = 0; i < currentSetting.inputCount; ++i) {
        weight = currentInputs[i].weight / MaximumWeight;
        if (currentInputs[i].sourceParameterIndex == -1) {
          currentInputs[i].sourceParameterIndex = model.getParameterIndex(
            currentInputs[i].source.id
          );
        }
        currentInputs[i].getNormalizedParameterValue(
          totalTranslation,
          totalAngle,
          parameterValues[currentInputs[i].sourceParameterIndex],
          parameterMinimumValues[currentInputs[i].sourceParameterIndex],
          parameterMaximumValues[currentInputs[i].sourceParameterIndex],
          parameterDefaultValues[currentInputs[i].sourceParameterIndex],
          currentSetting.normalizationPosition,
          currentSetting.normalizationAngle,
          currentInputs[i].reflect,
          weight
        );
        this._parameterCaches[currentInputs[i].sourceParameterIndex] = parameterValues[currentInputs[i].sourceParameterIndex];
      }
      radAngle = CubismMath.degreesToRadian(-totalAngle.angle);
      totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);
      totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);
      updateParticlesForStabilization(
        currentParticles,
        currentSetting.particleCount,
        totalTranslation,
        totalAngle.angle,
        this._options.wind,
        MovementThreshold * currentSetting.normalizationPosition.maximum
      );
      for (let i = 0; i < currentSetting.outputCount; ++i) {
        const particleIndex = currentOutputs[i].vertexIndex;
        if (currentOutputs[i].destinationParameterIndex == -1) {
          currentOutputs[i].destinationParameterIndex = model.getParameterIndex(
            currentOutputs[i].destination.id
          );
        }
        if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {
          continue;
        }
        let translation = new CubismVector2();
        translation = currentParticles[particleIndex].position.substract(
          currentParticles[particleIndex - 1].position
        );
        outputValue = currentOutputs[i].getValue(
          translation,
          currentParticles,
          particleIndex,
          currentOutputs[i].reflect,
          this._options.gravity
        );
        this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);
        this._previousRigOutputs.at(settingIndex).outputs.set(i, outputValue);
        const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
        const outParameterCaches = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(
          JSON.stringify(
            parameterValues.subarray(destinationParameterIndex)
          )
        ) : parameterValues.slice(destinationParameterIndex);
        updateOutputParameterValue(
          outParameterCaches,
          parameterMinimumValues[destinationParameterIndex],
          parameterMaximumValues[destinationParameterIndex],
          outputValue,
          currentOutputs[i]
        );
        for (let offset2 = destinationParameterIndex, outParamIndex = 0; offset2 < this._parameterCaches.length; offset2++, outParamIndex++) {
          parameterValues[offset2] = this._parameterCaches[offset2] = outParameterCaches[outParamIndex];
        }
      }
    }
  }
  /**
   * 
   *
   * Pendulum interpolation weights
   *
   * 
   * The result of the pendulum calculation is saved and
   * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.
   *
   * [1][2]
   * The figure shows the interpolation between [1] and [2].
   *
   * 
   * The weight of the interpolation are determined by the current time seen between
   * the latest pendulum calculation timing and the next timing.
   *
   * [2][4](3)
   * Figure shows the weight of position (3) as seen between [2] and [4].
   *
   * 
   * As an interpretation, the pendulum calculation and weights are misaligned.
   *
   * physics3.jsonFPS
   * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.
   *
   * 
   * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.
   *
   * ------------ time -------------->
   *
   *                 |+++++|------| <- weight
   * ==[1]====#=====[2]---(3)----(4)
   *          ^ output contents
   *
   * 1:_previousRigOutputs
   * 2:_currentRigOutputs
   * 3:_currentRemainTime (now rendering)
   * 4:next particles timing
   * @param model 
   * @param deltaTimeSeconds []
   */
  evaluate(model, deltaTimeSeconds) {
    let totalAngle;
    let weight;
    let radAngle;
    let outputValue;
    const totalTranslation = new CubismVector2();
    let currentSetting;
    let currentInputs;
    let currentOutputs;
    let currentParticles;
    if (0 >= deltaTimeSeconds) {
      return;
    }
    const parameterValues = model.getModel().parameters.values;
    const parameterMaximumValues = model.getModel().parameters.maximumValues;
    const parameterMinimumValues = model.getModel().parameters.minimumValues;
    const parameterDefaultValues = model.getModel().parameters.defaultValues;
    let physicsDeltaTime;
    this._currentRemainTime += deltaTimeSeconds;
    if (this._currentRemainTime > MaxDeltaTime) {
      this._currentRemainTime = 0;
    }
    if ((this._parameterCaches?.length ?? 0) < model.getParameterCount()) {
      this._parameterCaches = new Float32Array(model.getParameterCount());
    }
    if ((this._parameterInputCaches?.length ?? 0) < model.getParameterCount()) {
      this._parameterInputCaches = new Float32Array(model.getParameterCount());
      for (let j = 0; j < model.getParameterCount(); ++j) {
        this._parameterInputCaches[j] = parameterValues[j];
      }
    }
    if (this._physicsRig.fps > 0) {
      physicsDeltaTime = 1 / this._physicsRig.fps;
    } else {
      physicsDeltaTime = deltaTimeSeconds;
    }
    while (this._currentRemainTime >= physicsDeltaTime) {
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        currentSetting = this._physicsRig.settings.at(settingIndex);
        currentOutputs = this._physicsRig.outputs.get(
          currentSetting.baseOutputIndex
        );
        for (let i = 0; i < currentSetting.outputCount; ++i) {
          this._previousRigOutputs.at(settingIndex).outputs.set(
            i,
            this._currentRigOutputs.at(settingIndex).outputs.at(i)
          );
        }
      }
      const inputWeight = physicsDeltaTime / this._currentRemainTime;
      for (let j = 0; j < model.getParameterCount(); ++j) {
        this._parameterCaches[j] = this._parameterInputCaches[j] * (1 - inputWeight) + parameterValues[j] * inputWeight;
        this._parameterInputCaches[j] = this._parameterCaches[j];
      }
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        totalAngle = { angle: 0 };
        totalTranslation.x = 0;
        totalTranslation.y = 0;
        currentSetting = this._physicsRig.settings.at(settingIndex);
        currentInputs = this._physicsRig.inputs.get(
          currentSetting.baseInputIndex
        );
        currentOutputs = this._physicsRig.outputs.get(
          currentSetting.baseOutputIndex
        );
        currentParticles = this._physicsRig.particles.get(
          currentSetting.baseParticleIndex
        );
        for (let i = 0; i < currentSetting.inputCount; ++i) {
          weight = currentInputs[i].weight / MaximumWeight;
          if (currentInputs[i].sourceParameterIndex == -1) {
            currentInputs[i].sourceParameterIndex = model.getParameterIndex(
              currentInputs[i].source.id
            );
          }
          currentInputs[i].getNormalizedParameterValue(
            totalTranslation,
            totalAngle,
            this._parameterCaches[currentInputs[i].sourceParameterIndex],
            parameterMinimumValues[currentInputs[i].sourceParameterIndex],
            parameterMaximumValues[currentInputs[i].sourceParameterIndex],
            parameterDefaultValues[currentInputs[i].sourceParameterIndex],
            currentSetting.normalizationPosition,
            currentSetting.normalizationAngle,
            currentInputs[i].reflect,
            weight
          );
        }
        radAngle = CubismMath.degreesToRadian(-totalAngle.angle);
        totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);
        totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);
        updateParticles(
          currentParticles,
          currentSetting.particleCount,
          totalTranslation,
          totalAngle.angle,
          this._options.wind,
          MovementThreshold * currentSetting.normalizationPosition.maximum,
          physicsDeltaTime,
          AirResistance
        );
        for (let i = 0; i < currentSetting.outputCount; ++i) {
          const particleIndex = currentOutputs[i].vertexIndex;
          if (currentOutputs[i].destinationParameterIndex == -1) {
            currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);
          }
          if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {
            continue;
          }
          const translation = new CubismVector2();
          translation.x = currentParticles[particleIndex].position.x - currentParticles[particleIndex - 1].position.x;
          translation.y = currentParticles[particleIndex].position.y - currentParticles[particleIndex - 1].position.y;
          outputValue = currentOutputs[i].getValue(
            translation,
            currentParticles,
            particleIndex,
            currentOutputs[i].reflect,
            this._options.gravity
          );
          this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);
          const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
          const outParameterCaches = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(
            JSON.stringify(
              this._parameterCaches.subarray(destinationParameterIndex)
            )
          ) : this._parameterCaches.slice(destinationParameterIndex);
          updateOutputParameterValue(
            outParameterCaches,
            parameterMinimumValues[destinationParameterIndex],
            parameterMaximumValues[destinationParameterIndex],
            outputValue,
            currentOutputs[i]
          );
          for (let offset2 = destinationParameterIndex, outParamIndex = 0; offset2 < this._parameterCaches.length; offset2++, outParamIndex++) {
            this._parameterCaches[offset2] = outParameterCaches[outParamIndex];
          }
        }
      }
      this._currentRemainTime -= physicsDeltaTime;
    }
    const alpha = this._currentRemainTime / physicsDeltaTime;
    this.interpolate(model, alpha);
  }
  /**
   * 
   * 
   * @param model 
   * @param weight 
   */
  interpolate(model, weight) {
    let currentOutputs;
    let currentSetting;
    const parameterValues = model.getModel().parameters.values;
    const parameterMaximumValues = model.getModel().parameters.maximumValues;
    const parameterMinimumValues = model.getModel().parameters.minimumValues;
    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
      currentSetting = this._physicsRig.settings.at(settingIndex);
      currentOutputs = this._physicsRig.outputs.get(
        currentSetting.baseOutputIndex
      );
      for (let i = 0; i < currentSetting.outputCount; ++i) {
        if (currentOutputs[i].destinationParameterIndex == -1) {
          continue;
        }
        const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
        const outParameterValues = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(
          JSON.stringify(
            parameterValues.subarray(destinationParameterIndex)
          )
        ) : parameterValues.slice(destinationParameterIndex);
        updateOutputParameterValue(
          outParameterValues,
          parameterMinimumValues[destinationParameterIndex],
          parameterMaximumValues[destinationParameterIndex],
          this._previousRigOutputs.at(settingIndex).outputs.at(i) * (1 - weight) + this._currentRigOutputs.at(settingIndex).outputs.at(i) * weight,
          currentOutputs[i]
        );
        for (let offset2 = destinationParameterIndex, outParamIndex = 0; offset2 < parameterValues.length; offset2++, outParamIndex++) {
          parameterValues[offset2] = outParameterValues[outParamIndex];
        }
      }
    }
  }
  /**
   * 
   * @param options 
   */
  setOptions(options2) {
    this._options = options2;
  }
  /**
   * 
   * @return 
   */
  getOption() {
    return this._options;
  }
  /**
   * 
   */
  constructor() {
    this._physicsRig = null;
    this._options = new Options();
    this._options.gravity.y = -1;
    this._options.gravity.x = 0;
    this._options.wind.x = 0;
    this._options.wind.y = 0;
    this._currentRigOutputs = new csmVector();
    this._previousRigOutputs = new csmVector();
    this._currentRemainTime = 0;
    this._parameterCaches = null;
    this._parameterInputCaches = null;
  }
  /**
   * 
   */
  release() {
    this._physicsRig = void 0;
    this._physicsRig = null;
  }
  /**
   * 
   */
  initialize() {
    let strand;
    let currentSetting;
    let radius;
    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
      currentSetting = this._physicsRig.settings.at(settingIndex);
      strand = this._physicsRig.particles.get(currentSetting.baseParticleIndex);
      strand[0].initialPosition = new CubismVector2(0, 0);
      strand[0].lastPosition = new CubismVector2(
        strand[0].initialPosition.x,
        strand[0].initialPosition.y
      );
      strand[0].lastGravity = new CubismVector2(0, -1);
      strand[0].lastGravity.y *= -1;
      strand[0].velocity = new CubismVector2(0, 0);
      strand[0].force = new CubismVector2(0, 0);
      for (let i = 1; i < currentSetting.particleCount; ++i) {
        radius = new CubismVector2(0, 0);
        radius.y = strand[i].radius;
        strand[i].initialPosition = new CubismVector2(
          strand[i - 1].initialPosition.x + radius.x,
          strand[i - 1].initialPosition.y + radius.y
        );
        strand[i].position = new CubismVector2(
          strand[i].initialPosition.x,
          strand[i].initialPosition.y
        );
        strand[i].lastPosition = new CubismVector2(
          strand[i].initialPosition.x,
          strand[i].initialPosition.y
        );
        strand[i].lastGravity = new CubismVector2(0, -1);
        strand[i].lastGravity.y *= -1;
        strand[i].velocity = new CubismVector2(0, 0);
        strand[i].force = new CubismVector2(0, 0);
      }
    }
  }
  ///< UpdateParticles
}
class Options {
  constructor() {
    this.gravity = new CubismVector2(0, 0);
    this.wind = new CubismVector2(0, 0);
  }
  // 
}
class PhysicsOutput {
  constructor() {
    this.outputs = new csmVector(0);
  }
  // 
}
function sign(value) {
  let ret = 0;
  if (value > 0) {
    ret = 1;
  } else if (value < 0) {
    ret = -1;
  }
  return ret;
}
function getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
  targetTranslation.x += normalizeParameterValue(
    value,
    parameterMinimumValue,
    parameterMaximumValue,
    parameterDefaultValue,
    normalizationPosition.minimum,
    normalizationPosition.maximum,
    normalizationPosition.defalut,
    isInverted
  ) * weight;
}
function getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
  targetTranslation.y += normalizeParameterValue(
    value,
    parameterMinimumValue,
    parameterMaximumValue,
    parameterDefaultValue,
    normalizationPosition.minimum,
    normalizationPosition.maximum,
    normalizationPosition.defalut,
    isInverted
  ) * weight;
}
function getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {
  targetAngle.angle += normalizeParameterValue(
    value,
    parameterMinimumValue,
    parameterMaximumValue,
    parameterDefaultValue,
    normalizationAngle.minimum,
    normalizationAngle.maximum,
    normalizationAngle.defalut,
    isInverted
  ) * weight;
}
function getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {
  let outputValue = translation.x;
  if (isInverted) {
    outputValue *= -1;
  }
  return outputValue;
}
function getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {
  let outputValue = translation.y;
  if (isInverted) {
    outputValue *= -1;
  }
  return outputValue;
}
function getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {
  let outputValue;
  if (particleIndex >= 2) {
    parentGravity = particles[particleIndex - 1].position.substract(
      particles[particleIndex - 2].position
    );
  } else {
    parentGravity = parentGravity.multiplyByScaler(-1);
  }
  outputValue = CubismMath.directionToRadian(parentGravity, translation);
  if (isInverted) {
    outputValue *= -1;
  }
  return outputValue;
}
function getRangeValue(min2, max2) {
  const maxValue2 = CubismMath.max(min2, max2);
  const minValue = CubismMath.min(min2, max2);
  return CubismMath.abs(maxValue2 - minValue);
}
function getDefaultValue(min2, max2) {
  const minValue = CubismMath.min(min2, max2);
  return minValue + getRangeValue(min2, max2) / 2;
}
function getOutputScaleTranslationX(translationScale, angleScale) {
  return JSON.parse(JSON.stringify(translationScale.x));
}
function getOutputScaleTranslationY(translationScale, angleScale) {
  return JSON.parse(JSON.stringify(translationScale.y));
}
function getOutputScaleAngle(translationScale, angleScale) {
  return JSON.parse(JSON.stringify(angleScale));
}
function updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {
  let delay2;
  let radian;
  let direction = new CubismVector2(0, 0);
  let velocity = new CubismVector2(0, 0);
  let force = new CubismVector2(0, 0);
  let newDirection = new CubismVector2(0, 0);
  strand[0].position = new CubismVector2(
    totalTranslation.x,
    totalTranslation.y
  );
  const totalRadian = CubismMath.degreesToRadian(totalAngle);
  const currentGravity = CubismMath.radianToDirection(totalRadian);
  currentGravity.normalize();
  for (let i = 1; i < strandCount; ++i) {
    strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);
    strand[i].lastPosition = new CubismVector2(
      strand[i].position.x,
      strand[i].position.y
    );
    delay2 = strand[i].delay * deltaTimeSeconds * 30;
    direction = strand[i].position.substract(strand[i - 1].position);
    radian = CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) / airResistance;
    direction.x = CubismMath.cos(radian) * direction.x - direction.y * CubismMath.sin(radian);
    direction.y = CubismMath.sin(radian) * direction.x + direction.y * CubismMath.cos(radian);
    strand[i].position = strand[i - 1].position.add(direction);
    velocity = strand[i].velocity.multiplyByScaler(delay2);
    force = strand[i].force.multiplyByScaler(delay2).multiplyByScaler(delay2);
    strand[i].position = strand[i].position.add(velocity).add(force);
    newDirection = strand[i].position.substract(strand[i - 1].position);
    newDirection.normalize();
    strand[i].position = strand[i - 1].position.add(
      newDirection.multiplyByScaler(strand[i].radius)
    );
    if (CubismMath.abs(strand[i].position.x) < thresholdValue) {
      strand[i].position.x = 0;
    }
    if (delay2 != 0) {
      strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);
      strand[i].velocity = strand[i].velocity.divisionByScalar(delay2);
      strand[i].velocity = strand[i].velocity.multiplyByScaler(
        strand[i].mobility
      );
    }
    strand[i].force = new CubismVector2(0, 0);
    strand[i].lastGravity = new CubismVector2(
      currentGravity.x,
      currentGravity.y
    );
  }
}
function updateParticlesForStabilization(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue) {
  let force = new CubismVector2(0, 0);
  strand[0].position = new CubismVector2(
    totalTranslation.x,
    totalTranslation.y
  );
  const totalRadian = CubismMath.degreesToRadian(totalAngle);
  const currentGravity = CubismMath.radianToDirection(totalRadian);
  currentGravity.normalize();
  for (let i = 1; i < strandCount; ++i) {
    strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);
    strand[i].lastPosition = new CubismVector2(
      strand[i].position.x,
      strand[i].position.y
    );
    strand[i].velocity = new CubismVector2(0, 0);
    force = strand[i].force;
    force.normalize();
    force = force.multiplyByScaler(strand[i].radius);
    strand[i].position = strand[i - 1].position.add(force);
    if (CubismMath.abs(strand[i].position.x) < thresholdValue) {
      strand[i].position.x = 0;
    }
    strand[i].force = new CubismVector2(0, 0);
    strand[i].lastGravity = new CubismVector2(
      currentGravity.x,
      currentGravity.y
    );
  }
}
function updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {
  let value;
  const outputScale = output.getScale(
    output.translationScale,
    output.angleScale
  );
  value = translation * outputScale;
  if (value < parameterValueMinimum) {
    if (value < output.valueBelowMinimum) {
      output.valueBelowMinimum = value;
    }
    value = parameterValueMinimum;
  } else if (value > parameterValueMaximum) {
    if (value > output.valueExceededMaximum) {
      output.valueExceededMaximum = value;
    }
    value = parameterValueMaximum;
  }
  const weight = output.weight / MaximumWeight;
  if (weight >= 1) {
    parameterValue[0] = value;
  } else {
    value = parameterValue[0] * (1 - weight) + value * weight;
    parameterValue[0] = value;
  }
}
function normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {
  let result = 0;
  const maxValue2 = CubismMath.max(parameterMaximum, parameterMinimum);
  if (maxValue2 < value) {
    value = maxValue2;
  }
  const minValue = CubismMath.min(parameterMaximum, parameterMinimum);
  if (minValue > value) {
    value = minValue;
  }
  const minNormValue = CubismMath.min(
    normalizedMinimum,
    normalizedMaximum
  );
  const maxNormValue = CubismMath.max(
    normalizedMinimum,
    normalizedMaximum
  );
  const middleNormValue = normalizedDefault;
  const middleValue = getDefaultValue(minValue, maxValue2);
  const paramValue = value - middleValue;
  switch (sign(paramValue)) {
    case 1: {
      const nLength = maxNormValue - middleNormValue;
      const pLength = maxValue2 - middleValue;
      if (pLength != 0) {
        result = paramValue * (nLength / pLength);
        result += middleNormValue;
      }
      break;
    }
    case -1: {
      const nLength = minNormValue - middleNormValue;
      const pLength = minValue - middleValue;
      if (pLength != 0) {
        result = paramValue * (nLength / pLength);
        result += middleNormValue;
      }
      break;
    }
    case 0: {
      result = middleNormValue;
      break;
    }
  }
  return isInverted ? result : result * -1;
}
var Live2DCubismFramework$8;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismPhysics = CubismPhysics;
  Live2DCubismFramework2.Options = Options;
})(Live2DCubismFramework$8 || (Live2DCubismFramework$8 = {}));
const ColorChannelCount = 4;
const ClippingMaskMaxCountOnDefault = 36;
const ClippingMaskMaxCountOnMultiRenderTexture = 32;
class CubismClippingManager {
  /**
   * 
   */
  constructor(clippingContextFactory) {
    this._renderTextureCount = 0;
    this._clippingMaskBufferSize = 256;
    this._clippingContextListForMask = new csmVector();
    this._clippingContextListForDraw = new csmVector();
    this._channelColors = new csmVector();
    this._tmpBoundsOnModel = new csmRect();
    this._tmpMatrix = new CubismMatrix44();
    this._tmpMatrixForMask = new CubismMatrix44();
    this._tmpMatrixForDraw = new CubismMatrix44();
    this._clippingContexttConstructor = clippingContextFactory;
    let tmp = new CubismTextureColor();
    tmp.r = 1;
    tmp.g = 0;
    tmp.b = 0;
    tmp.a = 0;
    this._channelColors.pushBack(tmp);
    tmp = new CubismTextureColor();
    tmp.r = 0;
    tmp.g = 1;
    tmp.b = 0;
    tmp.a = 0;
    this._channelColors.pushBack(tmp);
    tmp = new CubismTextureColor();
    tmp.r = 0;
    tmp.g = 0;
    tmp.b = 1;
    tmp.a = 0;
    this._channelColors.pushBack(tmp);
    tmp = new CubismTextureColor();
    tmp.r = 0;
    tmp.g = 0;
    tmp.b = 0;
    tmp.a = 1;
    this._channelColors.pushBack(tmp);
  }
  /**
   * 
   */
  release() {
    for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {
      if (this._clippingContextListForMask.at(i)) {
        this._clippingContextListForMask.at(i).release();
        this._clippingContextListForMask.set(i, void 0);
      }
      this._clippingContextListForMask.set(i, null);
    }
    this._clippingContextListForMask = null;
    for (let i = 0; i < this._clippingContextListForDraw.getSize(); i++) {
      this._clippingContextListForDraw.set(i, null);
    }
    this._clippingContextListForDraw = null;
    for (let i = 0; i < this._channelColors.getSize(); i++) {
      this._channelColors.set(i, null);
    }
    this._channelColors = null;
    if (this._clearedFrameBufferFlags != null) {
      this._clearedFrameBufferFlags.clear();
    }
    this._clearedFrameBufferFlags = null;
  }
  /**
   * 
   * 
   * @param model 
   * @param renderTextureCount 
   */
  initialize(model, renderTextureCount) {
    if (renderTextureCount % 1 != 0) {
      CubismLogWarning(
        "The number of render textures must be specified as an integer. The decimal point is rounded down and corrected to an integer."
      );
      renderTextureCount = ~~renderTextureCount;
    }
    if (renderTextureCount < 1) {
      CubismLogWarning(
        "The number of render textures must be an integer greater than or equal to 1. Set the number of render textures to 1."
      );
    }
    this._renderTextureCount = renderTextureCount < 1 ? 1 : renderTextureCount;
    this._clearedFrameBufferFlags = new csmVector(
      this._renderTextureCount
    );
    for (let i = 0; i < model.getDrawableCount(); i++) {
      if (model.getDrawableMaskCounts()[i] <= 0) {
        this._clippingContextListForDraw.pushBack(null);
        continue;
      }
      let clippingContext = this.findSameClip(
        model.getDrawableMasks()[i],
        model.getDrawableMaskCounts()[i]
      );
      if (clippingContext == null) {
        clippingContext = new this._clippingContexttConstructor(
          this,
          model.getDrawableMasks()[i],
          model.getDrawableMaskCounts()[i]
        );
        this._clippingContextListForMask.pushBack(clippingContext);
      }
      clippingContext.addClippedDrawable(i);
      this._clippingContextListForDraw.pushBack(clippingContext);
    }
  }
  /**
   * 
   * 
   * NULL
   * @param drawableMasks 
   * @param drawableMaskCounts 
   * @return NULL
   */
  findSameClip(drawableMasks, drawableMaskCounts) {
    for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {
      const clippingContext = this._clippingContextListForMask.at(i);
      const count = clippingContext._clippingIdCount;
      if (count != drawableMaskCounts) {
        continue;
      }
      let sameCount = 0;
      for (let j = 0; j < count; j++) {
        const clipId = clippingContext._clippingIdList[j];
        for (let k2 = 0; k2 < count; k2++) {
          if (drawableMasks[k2] == clipId) {
            sameCount++;
            break;
          }
        }
      }
      if (sameCount == count) {
        return clippingContext;
      }
    }
    return null;
  }
  /**
   * 
   * @param model 
   * @param isRightHanded 
   */
  setupMatrixForHighPrecision(model, isRightHanded) {
    let usingClipCount = 0;
    for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
      const cc2 = this._clippingContextListForMask.at(clipIndex);
      this.calcClippedDrawTotalBounds(model, cc2);
      if (cc2._isUsing) {
        usingClipCount++;
      }
    }
    if (usingClipCount > 0) {
      this.setupLayoutBounds(0);
      if (this._clearedFrameBufferFlags.getSize() != this._renderTextureCount) {
        this._clearedFrameBufferFlags.clear();
        for (let i = 0; i < this._renderTextureCount; i++) {
          this._clearedFrameBufferFlags.pushBack(false);
        }
      } else {
        for (let i = 0; i < this._renderTextureCount; i++) {
          this._clearedFrameBufferFlags.set(i, false);
        }
      }
      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
        const clipContext = this._clippingContextListForMask.at(clipIndex);
        const allClippedDrawRect = clipContext._allClippedDrawRect;
        const layoutBoundsOnTex01 = clipContext._layoutBounds;
        const margin = 0.05;
        let scaleX = 0;
        let scaleY = 0;
        const ppu = model.getPixelsPerUnit();
        const maskPixelSize = clipContext.getClippingManager().getClippingMaskBufferSize();
        const physicalMaskWidth = layoutBoundsOnTex01.width * maskPixelSize;
        const physicalMaskHeight = layoutBoundsOnTex01.height * maskPixelSize;
        this._tmpBoundsOnModel.setRect(allClippedDrawRect);
        if (this._tmpBoundsOnModel.width * ppu > physicalMaskWidth) {
          this._tmpBoundsOnModel.expand(allClippedDrawRect.width * margin, 0);
          scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
        } else {
          scaleX = ppu / physicalMaskWidth;
        }
        if (this._tmpBoundsOnModel.height * ppu > physicalMaskHeight) {
          this._tmpBoundsOnModel.expand(
            0,
            allClippedDrawRect.height * margin
          );
          scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
        } else {
          scaleY = ppu / physicalMaskHeight;
        }
        this.createMatrixForMask(
          isRightHanded,
          layoutBoundsOnTex01,
          scaleX,
          scaleY
        );
        clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());
        clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());
      }
    }
  }
  /**
   * 
   * @param isRightHanded 
   * @param layoutBoundsOnTex01 
   * @param scaleX 
   * @param scaleY 
   */
  createMatrixForMask(isRightHanded, layoutBoundsOnTex01, scaleX, scaleY) {
    this._tmpMatrix.loadIdentity();
    {
      this._tmpMatrix.translateRelative(-1, -1);
      this._tmpMatrix.scaleRelative(2, 2);
    }
    {
      this._tmpMatrix.translateRelative(
        layoutBoundsOnTex01.x,
        layoutBoundsOnTex01.y
      );
      this._tmpMatrix.scaleRelative(scaleX, scaleY);
      this._tmpMatrix.translateRelative(
        -this._tmpBoundsOnModel.x,
        -this._tmpBoundsOnModel.y
      );
    }
    this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());
    this._tmpMatrix.loadIdentity();
    {
      this._tmpMatrix.translateRelative(
        layoutBoundsOnTex01.x,
        layoutBoundsOnTex01.y * (isRightHanded ? -1 : 1)
      );
      this._tmpMatrix.scaleRelative(
        scaleX,
        scaleY * (isRightHanded ? -1 : 1)
      );
      this._tmpMatrix.translateRelative(
        -this._tmpBoundsOnModel.x,
        -this._tmpBoundsOnModel.y
      );
    }
    this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());
  }
  /**
   * 
   * 
   * 4RGBA56RGBA2,2,1,1
   *
   * @param usingClipCount 
   */
  setupLayoutBounds(usingClipCount) {
    const useClippingMaskMaxCount = this._renderTextureCount <= 1 ? ClippingMaskMaxCountOnDefault : ClippingMaskMaxCountOnMultiRenderTexture * this._renderTextureCount;
    if (usingClipCount <= 0 || usingClipCount > useClippingMaskMaxCount) {
      if (usingClipCount > useClippingMaskMaxCount) {
        CubismLogError(
          "not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}",
          usingClipCount - useClippingMaskMaxCount,
          this._renderTextureCount,
          usingClipCount
        );
      }
      for (let index = 0; index < this._clippingContextListForMask.getSize(); index++) {
        const clipContext = this._clippingContextListForMask.at(index);
        clipContext._layoutChannelIndex = 0;
        clipContext._layoutBounds.x = 0;
        clipContext._layoutBounds.y = 0;
        clipContext._layoutBounds.width = 1;
        clipContext._layoutBounds.height = 1;
        clipContext._bufferIndex = 0;
      }
      return;
    }
    const layoutCountMaxValue = this._renderTextureCount <= 1 ? 9 : 8;
    let countPerSheetDiv = usingClipCount / this._renderTextureCount;
    const reduceLayoutTextureCount = usingClipCount % this._renderTextureCount;
    countPerSheetDiv = Math.ceil(countPerSheetDiv);
    let divCount = countPerSheetDiv / ColorChannelCount;
    const modCount = countPerSheetDiv % ColorChannelCount;
    divCount = ~~divCount;
    let curClipIndex = 0;
    for (let renderTextureIndex = 0; renderTextureIndex < this._renderTextureCount; renderTextureIndex++) {
      for (let channelIndex = 0; channelIndex < ColorChannelCount; channelIndex++) {
        let layoutCount = divCount + (channelIndex < modCount ? 1 : 0);
        const checkChannelIndex = modCount + (divCount < 1 ? -1 : 0);
        if (channelIndex == checkChannelIndex && reduceLayoutTextureCount > 0) {
          layoutCount -= !(renderTextureIndex < reduceLayoutTextureCount) ? 1 : 0;
        }
        if (layoutCount == 0) ;
        else if (layoutCount == 1) {
          const clipContext = this._clippingContextListForMask.at(curClipIndex++);
          clipContext._layoutChannelIndex = channelIndex;
          clipContext._layoutBounds.x = 0;
          clipContext._layoutBounds.y = 0;
          clipContext._layoutBounds.width = 1;
          clipContext._layoutBounds.height = 1;
          clipContext._bufferIndex = renderTextureIndex;
        } else if (layoutCount == 2) {
          for (let i = 0; i < layoutCount; i++) {
            let xpos = i % 2;
            xpos = ~~xpos;
            const cc2 = this._clippingContextListForMask.at(
              curClipIndex++
            );
            cc2._layoutChannelIndex = channelIndex;
            cc2._layoutBounds.x = xpos * 0.5;
            cc2._layoutBounds.y = 0;
            cc2._layoutBounds.width = 0.5;
            cc2._layoutBounds.height = 1;
            cc2._bufferIndex = renderTextureIndex;
          }
        } else if (layoutCount <= 4) {
          for (let i = 0; i < layoutCount; i++) {
            let xpos = i % 2;
            let ypos = i / 2;
            xpos = ~~xpos;
            ypos = ~~ypos;
            const cc2 = this._clippingContextListForMask.at(curClipIndex++);
            cc2._layoutChannelIndex = channelIndex;
            cc2._layoutBounds.x = xpos * 0.5;
            cc2._layoutBounds.y = ypos * 0.5;
            cc2._layoutBounds.width = 0.5;
            cc2._layoutBounds.height = 0.5;
            cc2._bufferIndex = renderTextureIndex;
          }
        } else if (layoutCount <= layoutCountMaxValue) {
          for (let i = 0; i < layoutCount; i++) {
            let xpos = i % 3;
            let ypos = i / 3;
            xpos = ~~xpos;
            ypos = ~~ypos;
            const cc2 = this._clippingContextListForMask.at(
              curClipIndex++
            );
            cc2._layoutChannelIndex = channelIndex;
            cc2._layoutBounds.x = xpos / 3;
            cc2._layoutBounds.y = ypos / 3;
            cc2._layoutBounds.width = 1 / 3;
            cc2._layoutBounds.height = 1 / 3;
            cc2._bufferIndex = renderTextureIndex;
          }
        } else {
          CubismLogError(
            "not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}",
            usingClipCount - useClippingMaskMaxCount,
            this._renderTextureCount,
            usingClipCount
          );
          for (let index = 0; index < layoutCount; index++) {
            const cc2 = this._clippingContextListForMask.at(
              curClipIndex++
            );
            cc2._layoutChannelIndex = 0;
            cc2._layoutBounds.x = 0;
            cc2._layoutBounds.y = 0;
            cc2._layoutBounds.width = 1;
            cc2._layoutBounds.height = 1;
            cc2._bufferIndex = 0;
          }
        }
      }
    }
  }
  /**
   * 
   * @param model 
   * @param clippingContext 
   */
  calcClippedDrawTotalBounds(model, clippingContext) {
    let clippedDrawTotalMinX = Number.MAX_VALUE;
    let clippedDrawTotalMinY = Number.MAX_VALUE;
    let clippedDrawTotalMaxX = Number.MIN_VALUE;
    let clippedDrawTotalMaxY = Number.MIN_VALUE;
    const clippedDrawCount = clippingContext._clippedDrawableIndexList.length;
    for (let clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {
      const drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];
      const drawableVertexCount = model.getDrawableVertexCount(drawableIndex);
      const drawableVertexes = model.getDrawableVertices(drawableIndex);
      let minX = Number.MAX_VALUE;
      let minY = Number.MAX_VALUE;
      let maxX = -Number.MAX_VALUE;
      let maxY = -Number.MAX_VALUE;
      const loop = drawableVertexCount * Constant.vertexStep;
      for (let pi2 = Constant.vertexOffset; pi2 < loop; pi2 += Constant.vertexStep) {
        const x2 = drawableVertexes[pi2];
        const y2 = drawableVertexes[pi2 + 1];
        if (x2 < minX) {
          minX = x2;
        }
        if (x2 > maxX) {
          maxX = x2;
        }
        if (y2 < minY) {
          minY = y2;
        }
        if (y2 > maxY) {
          maxY = y2;
        }
      }
      if (minX == Number.MAX_VALUE) {
        continue;
      }
      if (minX < clippedDrawTotalMinX) {
        clippedDrawTotalMinX = minX;
      }
      if (minY < clippedDrawTotalMinY) {
        clippedDrawTotalMinY = minY;
      }
      if (maxX > clippedDrawTotalMaxX) {
        clippedDrawTotalMaxX = maxX;
      }
      if (maxY > clippedDrawTotalMaxY) {
        clippedDrawTotalMaxY = maxY;
      }
      if (clippedDrawTotalMinX == Number.MAX_VALUE) {
        clippingContext._allClippedDrawRect.x = 0;
        clippingContext._allClippedDrawRect.y = 0;
        clippingContext._allClippedDrawRect.width = 0;
        clippingContext._allClippedDrawRect.height = 0;
        clippingContext._isUsing = false;
      } else {
        clippingContext._isUsing = true;
        const w2 = clippedDrawTotalMaxX - clippedDrawTotalMinX;
        const h2 = clippedDrawTotalMaxY - clippedDrawTotalMinY;
        clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;
        clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;
        clippingContext._allClippedDrawRect.width = w2;
        clippingContext._allClippedDrawRect.height = h2;
      }
    }
  }
  /**
   * 
   * @return 
   */
  getClippingContextListForDraw() {
    return this._clippingContextListForDraw;
  }
  /**
   * 
   * @return 
   */
  getClippingMaskBufferSize() {
    return this._clippingMaskBufferSize;
  }
  /**
   * 
   * @return 
   */
  getRenderTextureCount() {
    return this._renderTextureCount;
  }
  /**
   * RGBA
   * @param channelNo RGBA0:R, 1:G, 2:B, 3:A
   */
  getChannelFlagAsColor(channelNo) {
    return this._channelColors.at(channelNo);
  }
  /**
   * 
   * @param size 
   */
  setClippingMaskBufferSize(size2) {
    this._clippingMaskBufferSize = size2;
  }
}
let s_instance$3;
const ShaderCount = 10;
class CubismShader_WebGL {
  /**
   * 
   * @return 
   */
  static getInstance() {
    if (s_instance$3 == null) {
      s_instance$3 = new CubismShader_WebGL();
      return s_instance$3;
    }
    return s_instance$3;
  }
  /**
   * 
   */
  static deleteInstance() {
    if (s_instance$3) {
      s_instance$3.release();
      s_instance$3 = null;
    }
  }
  /**
   * private
   */
  constructor() {
    this._shaderSets = new csmVector();
  }
  /**
   * 
   */
  release() {
    this.releaseShaderProgram();
  }
  /**
   * 
   * @param renderer 
   * @param model 
   * @param index 
   */
  setupShaderProgramForDraw(renderer, model, index) {
    if (!renderer.isPremultipliedAlpha()) {
      CubismLogError("NoPremultipliedAlpha is not allowed");
    }
    if (this._shaderSets.getSize() == 0) {
      this.generateShaders();
    }
    let srcColor;
    let dstColor;
    let srcAlpha;
    let dstAlpha;
    const masked = renderer.getClippingContextBufferForDraw() != null;
    const invertedMask = model.getDrawableInvertedMaskBit(index);
    const offset2 = masked ? invertedMask ? 2 : 1 : 0;
    let shaderSet;
    switch (model.getDrawableBlendMode(index)) {
      case CubismBlendMode.CubismBlendMode_Normal:
      default:
        shaderSet = this._shaderSets.at(
          1 + offset2
        );
        srcColor = this.gl.ONE;
        dstColor = this.gl.ONE_MINUS_SRC_ALPHA;
        srcAlpha = this.gl.ONE;
        dstAlpha = this.gl.ONE_MINUS_SRC_ALPHA;
        break;
      case CubismBlendMode.CubismBlendMode_Additive:
        shaderSet = this._shaderSets.at(
          4 + offset2
        );
        srcColor = this.gl.ONE;
        dstColor = this.gl.ONE;
        srcAlpha = this.gl.ZERO;
        dstAlpha = this.gl.ONE;
        break;
      case CubismBlendMode.CubismBlendMode_Multiplicative:
        shaderSet = this._shaderSets.at(
          7 + offset2
        );
        srcColor = this.gl.DST_COLOR;
        dstColor = this.gl.ONE_MINUS_SRC_ALPHA;
        srcAlpha = this.gl.ZERO;
        dstAlpha = this.gl.ONE;
        break;
    }
    this.gl.useProgram(shaderSet.shaderProgram);
    if (renderer._bufferData.vertex == null) {
      renderer._bufferData.vertex = this.gl.createBuffer();
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.vertex);
    const vertexArray = model.getDrawableVertices(index);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);
    this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
    this.gl.vertexAttribPointer(
      shaderSet.attributePositionLocation,
      2,
      this.gl.FLOAT,
      false,
      0,
      0
    );
    if (renderer._bufferData.uv == null) {
      renderer._bufferData.uv = this.gl.createBuffer();
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
    const uvArray = model.getDrawableVertexUvs(index);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
    this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
    this.gl.vertexAttribPointer(
      shaderSet.attributeTexCoordLocation,
      2,
      this.gl.FLOAT,
      false,
      0,
      0
    );
    if (masked) {
      this.gl.activeTexture(this.gl.TEXTURE1);
      const tex = renderer.getClippingContextBufferForDraw().getClippingManager().getColorBuffer().at(renderer.getClippingContextBufferForDraw()._bufferIndex);
      this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
      this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);
      this.gl.uniformMatrix4fv(
        shaderSet.uniformClipMatrixLocation,
        false,
        renderer.getClippingContextBufferForDraw()._matrixForDraw.getArray()
      );
      const channelIndex = renderer.getClippingContextBufferForDraw()._layoutChannelIndex;
      const colorChannel = renderer.getClippingContextBufferForDraw().getClippingManager().getChannelFlagAsColor(channelIndex);
      this.gl.uniform4f(
        shaderSet.uniformChannelFlagLocation,
        colorChannel.r,
        colorChannel.g,
        colorChannel.b,
        colorChannel.a
      );
    }
    const textureNo = model.getDrawableTextureIndex(index);
    const textureId = renderer.getBindedTextures().getValue(textureNo);
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
    this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
    const matrix4x4 = renderer.getMvpMatrix();
    this.gl.uniformMatrix4fv(
      shaderSet.uniformMatrixLocation,
      false,
      matrix4x4.getArray()
    );
    const baseColor = renderer.getModelColorWithOpacity(
      model.getDrawableOpacity(index)
    );
    const multiplyColor = model.getMultiplyColor(index);
    const screenColor = model.getScreenColor(index);
    this.gl.uniform4f(
      shaderSet.uniformBaseColorLocation,
      baseColor.r,
      baseColor.g,
      baseColor.b,
      baseColor.a
    );
    this.gl.uniform4f(
      shaderSet.uniformMultiplyColorLocation,
      multiplyColor.r,
      multiplyColor.g,
      multiplyColor.b,
      multiplyColor.a
    );
    this.gl.uniform4f(
      shaderSet.uniformScreenColorLocation,
      screenColor.r,
      screenColor.g,
      screenColor.b,
      screenColor.a
    );
    if (renderer._bufferData.index == null) {
      renderer._bufferData.index = this.gl.createBuffer();
    }
    const indexArray = model.getDrawableVertexIndices(index);
    this.gl.bindBuffer(
      this.gl.ELEMENT_ARRAY_BUFFER,
      renderer._bufferData.index
    );
    this.gl.bufferData(
      this.gl.ELEMENT_ARRAY_BUFFER,
      indexArray,
      this.gl.DYNAMIC_DRAW
    );
    this.gl.blendFuncSeparate(srcColor, dstColor, srcAlpha, dstAlpha);
  }
  /**
   * 
   * @param renderer 
   * @param model 
   * @param index 
   */
  setupShaderProgramForMask(renderer, model, index) {
    if (!renderer.isPremultipliedAlpha()) {
      CubismLogError("NoPremultipliedAlpha is not allowed");
    }
    if (this._shaderSets.getSize() == 0) {
      this.generateShaders();
    }
    const shaderSet = this._shaderSets.at(
      0
      /* ShaderNames_SetupMask */
    );
    this.gl.useProgram(shaderSet.shaderProgram);
    if (renderer._bufferData.vertex == null) {
      renderer._bufferData.vertex = this.gl.createBuffer();
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.vertex);
    const vertexArray = model.getDrawableVertices(index);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);
    this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
    this.gl.vertexAttribPointer(
      shaderSet.attributePositionLocation,
      2,
      this.gl.FLOAT,
      false,
      0,
      0
    );
    if (renderer._bufferData.uv == null) {
      renderer._bufferData.uv = this.gl.createBuffer();
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
    const textureNo = model.getDrawableTextureIndex(index);
    const textureId = renderer.getBindedTextures().getValue(textureNo);
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
    this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
    if (renderer._bufferData.uv == null) {
      renderer._bufferData.uv = this.gl.createBuffer();
    }
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
    const uvArray = model.getDrawableVertexUvs(index);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
    this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
    this.gl.vertexAttribPointer(
      shaderSet.attributeTexCoordLocation,
      2,
      this.gl.FLOAT,
      false,
      0,
      0
    );
    renderer.getClippingContextBufferForMask();
    const channelIndex = renderer.getClippingContextBufferForMask()._layoutChannelIndex;
    const colorChannel = renderer.getClippingContextBufferForMask().getClippingManager().getChannelFlagAsColor(channelIndex);
    this.gl.uniform4f(
      shaderSet.uniformChannelFlagLocation,
      colorChannel.r,
      colorChannel.g,
      colorChannel.b,
      colorChannel.a
    );
    this.gl.uniformMatrix4fv(
      shaderSet.uniformClipMatrixLocation,
      false,
      renderer.getClippingContextBufferForMask()._matrixForMask.getArray()
    );
    const rect = renderer.getClippingContextBufferForMask()._layoutBounds;
    this.gl.uniform4f(
      shaderSet.uniformBaseColorLocation,
      rect.x * 2 - 1,
      rect.y * 2 - 1,
      rect.getRight() * 2 - 1,
      rect.getBottom() * 2 - 1
    );
    const multiplyColor = model.getMultiplyColor(index);
    const screenColor = model.getScreenColor(index);
    this.gl.uniform4f(
      shaderSet.uniformMultiplyColorLocation,
      multiplyColor.r,
      multiplyColor.g,
      multiplyColor.b,
      multiplyColor.a
    );
    this.gl.uniform4f(
      shaderSet.uniformScreenColorLocation,
      screenColor.r,
      screenColor.g,
      screenColor.b,
      screenColor.a
    );
    const srcColor = this.gl.ZERO;
    const dstColor = this.gl.ONE_MINUS_SRC_COLOR;
    const srcAlpha = this.gl.ZERO;
    const dstAlpha = this.gl.ONE_MINUS_SRC_ALPHA;
    if (renderer._bufferData.index == null) {
      renderer._bufferData.index = this.gl.createBuffer();
    }
    const indexArray = model.getDrawableVertexIndices(index);
    this.gl.bindBuffer(
      this.gl.ELEMENT_ARRAY_BUFFER,
      renderer._bufferData.index
    );
    this.gl.bufferData(
      this.gl.ELEMENT_ARRAY_BUFFER,
      indexArray,
      this.gl.DYNAMIC_DRAW
    );
    this.gl.blendFuncSeparate(srcColor, dstColor, srcAlpha, dstAlpha);
  }
  /**
   * 
   */
  releaseShaderProgram() {
    for (let i = 0; i < this._shaderSets.getSize(); i++) {
      this.gl.deleteProgram(this._shaderSets.at(i).shaderProgram);
      this._shaderSets.at(i).shaderProgram = 0;
      this._shaderSets.set(i, void 0);
      this._shaderSets.set(i, null);
    }
  }
  /**
   * 
   * @param vertShaderSrc 
   * @param fragShaderSrc 
   */
  generateShaders() {
    for (let i = 0; i < ShaderCount; i++) {
      this._shaderSets.pushBack(new CubismShaderSet());
    }
    this._shaderSets.at(0).shaderProgram = this.loadShaderProgram(
      vertexShaderSrcSetupMask,
      fragmentShaderSrcsetupMask
    );
    this._shaderSets.at(1).shaderProgram = this.loadShaderProgram(
      vertexShaderSrc,
      fragmentShaderSrcPremultipliedAlpha
    );
    this._shaderSets.at(2).shaderProgram = this.loadShaderProgram(
      vertexShaderSrcMasked,
      fragmentShaderSrcMaskPremultipliedAlpha
    );
    this._shaderSets.at(3).shaderProgram = this.loadShaderProgram(
      vertexShaderSrcMasked,
      fragmentShaderSrcMaskInvertedPremultipliedAlpha
    );
    this._shaderSets.at(4).shaderProgram = this._shaderSets.at(1).shaderProgram;
    this._shaderSets.at(5).shaderProgram = this._shaderSets.at(2).shaderProgram;
    this._shaderSets.at(6).shaderProgram = this._shaderSets.at(3).shaderProgram;
    this._shaderSets.at(7).shaderProgram = this._shaderSets.at(1).shaderProgram;
    this._shaderSets.at(8).shaderProgram = this._shaderSets.at(2).shaderProgram;
    this._shaderSets.at(9).shaderProgram = this._shaderSets.at(3).shaderProgram;
    this._shaderSets.at(0).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(0).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(0).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(0).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(0).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(0).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(0).uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(0).shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets.at(0).uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets.at(0).shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets.at(0).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(0).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(0).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(0).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(0).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(0).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(1).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(1).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(1).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(1).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(1).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(1).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(1).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(1).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(1).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(1).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(1).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(1).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(1).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(1).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(2).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(2).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(2).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(2).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(2).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(2).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(2).samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets.at(2).shaderProgram,
      "s_texture1"
    );
    this._shaderSets.at(2).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(2).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(2).uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(2).shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets.at(2).uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets.at(2).shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets.at(2).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(2).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(2).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(2).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(2).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(2).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(3).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(3).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(3).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(3).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(3).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(3).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(3).samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets.at(3).shaderProgram,
      "s_texture1"
    );
    this._shaderSets.at(3).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(3).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(3).uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(3).shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets.at(3).uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets.at(3).shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets.at(3).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(3).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(3).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(3).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(3).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(3).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(4).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(4).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(4).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(4).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(4).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(4).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(4).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(4).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(4).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(4).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(4).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(4).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(4).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(4).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(5).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(5).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(5).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(5).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(5).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(5).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(5).samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets.at(5).shaderProgram,
      "s_texture1"
    );
    this._shaderSets.at(5).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(5).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(5).uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(5).shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets.at(5).uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets.at(5).shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets.at(5).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(5).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(5).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(5).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(5).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(5).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(6).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(6).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(6).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(6).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(6).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(6).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(6).samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets.at(6).shaderProgram,
      "s_texture1"
    );
    this._shaderSets.at(6).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(6).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(6).uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(6).shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets.at(6).uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets.at(6).shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets.at(6).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(6).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(6).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(6).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(6).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(6).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(7).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(7).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(7).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(7).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(7).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(7).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(7).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(7).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(7).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(7).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(7).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(7).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(7).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(7).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(8).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(8).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(8).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(8).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(8).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(8).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(8).samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets.at(8).shaderProgram,
      "s_texture1"
    );
    this._shaderSets.at(8).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(8).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(8).uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(8).shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets.at(8).uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets.at(8).shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets.at(8).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(8).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(8).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(8).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(8).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(8).shaderProgram,
      "u_screenColor"
    );
    this._shaderSets.at(9).attributePositionLocation = this.gl.getAttribLocation(
      this._shaderSets.at(9).shaderProgram,
      "a_position"
    );
    this._shaderSets.at(9).attributeTexCoordLocation = this.gl.getAttribLocation(
      this._shaderSets.at(9).shaderProgram,
      "a_texCoord"
    );
    this._shaderSets.at(9).samplerTexture0Location = this.gl.getUniformLocation(
      this._shaderSets.at(9).shaderProgram,
      "s_texture0"
    );
    this._shaderSets.at(9).samplerTexture1Location = this.gl.getUniformLocation(
      this._shaderSets.at(9).shaderProgram,
      "s_texture1"
    );
    this._shaderSets.at(9).uniformMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(9).shaderProgram,
      "u_matrix"
    );
    this._shaderSets.at(9).uniformClipMatrixLocation = this.gl.getUniformLocation(
      this._shaderSets.at(9).shaderProgram,
      "u_clipMatrix"
    );
    this._shaderSets.at(9).uniformChannelFlagLocation = this.gl.getUniformLocation(
      this._shaderSets.at(9).shaderProgram,
      "u_channelFlag"
    );
    this._shaderSets.at(9).uniformBaseColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(9).shaderProgram,
      "u_baseColor"
    );
    this._shaderSets.at(9).uniformMultiplyColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(9).shaderProgram,
      "u_multiplyColor"
    );
    this._shaderSets.at(9).uniformScreenColorLocation = this.gl.getUniformLocation(
      this._shaderSets.at(9).shaderProgram,
      "u_screenColor"
    );
  }
  /**
   * 
   * @param vertexShaderSource    
   * @param fragmentShaderSource  
   * @return 
   */
  loadShaderProgram(vertexShaderSource, fragmentShaderSource) {
    let shaderProgram = this.gl.createProgram();
    let vertShader = this.compileShaderSource(
      this.gl.VERTEX_SHADER,
      vertexShaderSource
    );
    if (!vertShader) {
      CubismLogError("Vertex shader compile error!");
      return 0;
    }
    let fragShader = this.compileShaderSource(
      this.gl.FRAGMENT_SHADER,
      fragmentShaderSource
    );
    if (!fragShader) {
      CubismLogError("Vertex shader compile error!");
      return 0;
    }
    this.gl.attachShader(shaderProgram, vertShader);
    this.gl.attachShader(shaderProgram, fragShader);
    this.gl.linkProgram(shaderProgram);
    const linkStatus = this.gl.getProgramParameter(
      shaderProgram,
      this.gl.LINK_STATUS
    );
    if (!linkStatus) {
      CubismLogError("Failed to link program: {0}", shaderProgram);
      this.gl.deleteShader(vertShader);
      vertShader = 0;
      this.gl.deleteShader(fragShader);
      fragShader = 0;
      if (shaderProgram) {
        this.gl.deleteProgram(shaderProgram);
        shaderProgram = 0;
      }
      return 0;
    }
    this.gl.deleteShader(vertShader);
    this.gl.deleteShader(fragShader);
    return shaderProgram;
  }
  /**
   * 
   * @param shaderType (Vertex/Fragment)
   * @param shaderSource 
   *
   * @return 
   */
  compileShaderSource(shaderType, shaderSource) {
    const source = shaderSource;
    const shader = this.gl.createShader(shaderType);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!shader) {
      const log2 = this.gl.getShaderInfoLog(shader);
      CubismLogError("Shader compile log: {0} ", log2);
    }
    const status = this.gl.getShaderParameter(
      shader,
      this.gl.COMPILE_STATUS
    );
    if (!status) {
      this.gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  setGl(gl2) {
    this.gl = gl2;
  }
  // webgl
}
class CubismShaderSet {
  // ScreenColor
}
var ShaderNames = /* @__PURE__ */ ((ShaderNames2) => {
  ShaderNames2[ShaderNames2["ShaderNames_SetupMask"] = 0] = "ShaderNames_SetupMask";
  ShaderNames2[ShaderNames2["ShaderNames_NormalPremultipliedAlpha"] = 1] = "ShaderNames_NormalPremultipliedAlpha";
  ShaderNames2[ShaderNames2["ShaderNames_NormalMaskedPremultipliedAlpha"] = 2] = "ShaderNames_NormalMaskedPremultipliedAlpha";
  ShaderNames2[ShaderNames2["ShaderNames_NomralMaskedInvertedPremultipliedAlpha"] = 3] = "ShaderNames_NomralMaskedInvertedPremultipliedAlpha";
  ShaderNames2[ShaderNames2["ShaderNames_AddPremultipliedAlpha"] = 4] = "ShaderNames_AddPremultipliedAlpha";
  ShaderNames2[ShaderNames2["ShaderNames_AddMaskedPremultipliedAlpha"] = 5] = "ShaderNames_AddMaskedPremultipliedAlpha";
  ShaderNames2[ShaderNames2["ShaderNames_AddMaskedPremultipliedAlphaInverted"] = 6] = "ShaderNames_AddMaskedPremultipliedAlphaInverted";
  ShaderNames2[ShaderNames2["ShaderNames_MultPremultipliedAlpha"] = 7] = "ShaderNames_MultPremultipliedAlpha";
  ShaderNames2[ShaderNames2["ShaderNames_MultMaskedPremultipliedAlpha"] = 8] = "ShaderNames_MultMaskedPremultipliedAlpha";
  ShaderNames2[ShaderNames2["ShaderNames_MultMaskedPremultipliedAlphaInverted"] = 9] = "ShaderNames_MultMaskedPremultipliedAlphaInverted";
  return ShaderNames2;
})(ShaderNames || {});
const vertexShaderSrcSetupMask = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_myPos;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_clipMatrix * a_position;   v_myPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
const fragmentShaderSrcsetupMask = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_myPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;void main(){   float isInside =        step(u_baseColor.x, v_myPos.x/v_myPos.w)       * step(u_baseColor.y, v_myPos.y/v_myPos.w)       * step(v_myPos.x/v_myPos.w, u_baseColor.z)       * step(v_myPos.y/v_myPos.w, u_baseColor.w);   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;}";
const vertexShaderSrc = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;uniform mat4       u_matrix;void main(){   gl_Position = u_matrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
const vertexShaderSrcMasked = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform mat4       u_matrix;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_matrix * a_position;   v_clipPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
const fragmentShaderSrcPremultipliedAlpha = "precision mediump float;varying vec2       v_texCoord;uniform vec4       u_baseColor;uniform sampler2D  s_texture0;uniform vec4       u_multiplyColor;uniform vec4       u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 color = texColor * u_baseColor;   gl_FragColor = vec4(color.rgb, color.a);}";
const fragmentShaderSrcMaskPremultipliedAlpha = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;uniform sampler2D  s_texture1;uniform vec4       u_multiplyColor;uniform vec4       u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 col_formask = texColor * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * maskVal;   gl_FragColor = col_formask;}";
const fragmentShaderSrcMaskInvertedPremultipliedAlpha = "precision mediump float;varying vec2      v_texCoord;varying vec4      v_clipPos;uniform sampler2D s_texture0;uniform sampler2D s_texture1;uniform vec4      u_channelFlag;uniform vec4      u_baseColor;uniform vec4      u_multiplyColor;uniform vec4      u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 col_formask = texColor * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * (1.0 - maskVal);   gl_FragColor = col_formask;}";
var Live2DCubismFramework$7;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismShaderSet = CubismShaderSet;
  Live2DCubismFramework2.CubismShader_WebGL = CubismShader_WebGL;
  Live2DCubismFramework2.ShaderNames = ShaderNames;
})(Live2DCubismFramework$7 || (Live2DCubismFramework$7 = {}));
let s_viewport;
let s_fbo;
class CubismClippingManager_WebGL extends CubismClippingManager {
  /**
   * 
   * FrameBufferObject
   *
   * @return 
   */
  getMaskRenderTexture() {
    if (this._maskTexture && this._maskTexture.textures != null) {
      this._maskTexture.frameNo = this._currentFrameNo;
    } else {
      if (this._maskRenderTextures != null) {
        this._maskRenderTextures.clear();
      }
      this._maskRenderTextures = new csmVector();
      if (this._maskColorBuffers != null) {
        this._maskColorBuffers.clear();
      }
      this._maskColorBuffers = new csmVector();
      const size2 = this._clippingMaskBufferSize;
      for (let index = 0; index < this._renderTextureCount; index++) {
        this._maskColorBuffers.pushBack(this.gl.createTexture());
        this.gl.bindTexture(
          this.gl.TEXTURE_2D,
          this._maskColorBuffers.at(index)
        );
        this.gl.texImage2D(
          this.gl.TEXTURE_2D,
          0,
          this.gl.RGBA,
          size2,
          size2,
          0,
          this.gl.RGBA,
          this.gl.UNSIGNED_BYTE,
          null
        );
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_WRAP_S,
          this.gl.CLAMP_TO_EDGE
        );
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_WRAP_T,
          this.gl.CLAMP_TO_EDGE
        );
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_MIN_FILTER,
          this.gl.LINEAR
        );
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_MAG_FILTER,
          this.gl.LINEAR
        );
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this._maskRenderTextures.pushBack(this.gl.createFramebuffer());
        this.gl.bindFramebuffer(
          this.gl.FRAMEBUFFER,
          this._maskRenderTextures.at(index)
        );
        this.gl.framebufferTexture2D(
          this.gl.FRAMEBUFFER,
          this.gl.COLOR_ATTACHMENT0,
          this.gl.TEXTURE_2D,
          this._maskColorBuffers.at(index),
          0
        );
      }
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
      this._maskTexture = new CubismRenderTextureResource(
        this._currentFrameNo,
        this._maskRenderTextures
      );
    }
    return this._maskTexture.textures;
  }
  /**
   * WebGL
   * @param gl WebGL
   */
  setGL(gl2) {
    this.gl = gl2;
  }
  /**
   * 
   */
  constructor() {
    super(CubismClippingContext_WebGL);
  }
  /**
   * 
   * @param model 
   * @param renderer 
   */
  setupClippingContext(model, renderer) {
    this._currentFrameNo++;
    let usingClipCount = 0;
    for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
      const cc2 = this._clippingContextListForMask.at(clipIndex);
      this.calcClippedDrawTotalBounds(model, cc2);
      if (cc2._isUsing) {
        usingClipCount++;
      }
    }
    if (usingClipCount > 0) {
      this.gl.viewport(
        0,
        0,
        this._clippingMaskBufferSize,
        this._clippingMaskBufferSize
      );
      this._currentMaskRenderTexture = this.getMaskRenderTexture().at(0);
      renderer.preDraw();
      this.setupLayoutBounds(usingClipCount);
      this.gl.bindFramebuffer(
        this.gl.FRAMEBUFFER,
        this._currentMaskRenderTexture
      );
      if (this._clearedFrameBufferFlags.getSize() != this._renderTextureCount) {
        this._clearedFrameBufferFlags.clear();
        this._clearedFrameBufferFlags = new csmVector(
          this._renderTextureCount
        );
      }
      for (let index = 0; index < this._clearedFrameBufferFlags.getSize(); index++) {
        this._clearedFrameBufferFlags.set(index, false);
      }
      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
        const clipContext = this._clippingContextListForMask.at(clipIndex);
        const allClipedDrawRect = clipContext._allClippedDrawRect;
        const layoutBoundsOnTex01 = clipContext._layoutBounds;
        const margin = 0.05;
        let scaleX = 0;
        let scaleY = 0;
        const clipContextRenderTexture = this.getMaskRenderTexture().at(
          clipContext._bufferIndex
        );
        if (this._currentMaskRenderTexture != clipContextRenderTexture) {
          this._currentMaskRenderTexture = clipContextRenderTexture;
          renderer.preDraw();
          this.gl.bindFramebuffer(
            this.gl.FRAMEBUFFER,
            this._currentMaskRenderTexture
          );
        }
        this._tmpBoundsOnModel.setRect(allClipedDrawRect);
        this._tmpBoundsOnModel.expand(
          allClipedDrawRect.width * margin,
          allClipedDrawRect.height * margin
        );
        scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
        scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
        {
          this._tmpMatrix.loadIdentity();
          {
            this._tmpMatrix.translateRelative(-1, -1);
            this._tmpMatrix.scaleRelative(2, 2);
          }
          {
            this._tmpMatrix.translateRelative(
              layoutBoundsOnTex01.x,
              layoutBoundsOnTex01.y
            );
            this._tmpMatrix.scaleRelative(scaleX, scaleY);
            this._tmpMatrix.translateRelative(
              -this._tmpBoundsOnModel.x,
              -this._tmpBoundsOnModel.y
            );
          }
          this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());
        }
        {
          this._tmpMatrix.loadIdentity();
          {
            this._tmpMatrix.translateRelative(
              layoutBoundsOnTex01.x,
              layoutBoundsOnTex01.y
            );
            this._tmpMatrix.scaleRelative(scaleX, scaleY);
            this._tmpMatrix.translateRelative(
              -this._tmpBoundsOnModel.x,
              -this._tmpBoundsOnModel.y
            );
          }
          this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());
        }
        clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());
        clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());
        const clipDrawCount = clipContext._clippingIdCount;
        for (let i = 0; i < clipDrawCount; i++) {
          const clipDrawIndex = clipContext._clippingIdList[i];
          if (!model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {
            continue;
          }
          renderer.setIsCulling(
            model.getDrawableCulling(clipDrawIndex) != false
          );
          if (!this._clearedFrameBufferFlags.at(clipContext._bufferIndex)) {
            this.gl.clearColor(1, 1, 1, 1);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            this._clearedFrameBufferFlags.set(clipContext._bufferIndex, true);
          }
          renderer.setClippingContextBufferForMask(clipContext);
          renderer.drawMeshWebGL(model, clipDrawIndex);
        }
      }
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
      renderer.setClippingContextBufferForMask(null);
      this.gl.viewport(
        s_viewport[0],
        s_viewport[1],
        s_viewport[2],
        s_viewport[3]
      );
    }
  }
  /**
   * 
   * @return 
   */
  getColorBuffer() {
    return this._maskColorBuffers;
  }
  /**
   * 
   * @returns
   */
  getClippingMaskCount() {
    return this._clippingContextListForMask.getSize();
  }
  // WebGL
}
class CubismRenderTextureResource {
  /**
   * 
   * @param frameNo 
   * @param texture 
   */
  constructor(frameNo, texture) {
    this.frameNo = frameNo;
    this.textures = texture;
  }
  // 
}
class CubismClippingContext_WebGL extends CubismClippingContext {
  /**
   * 
   */
  constructor(manager, clippingDrawableIndices, clipCount) {
    super(clippingDrawableIndices, clipCount);
    this._owner = manager;
  }
  /**
   * 
   * @return 
   */
  getClippingManager() {
    return this._owner;
  }
  setGl(gl2) {
    this._owner.setGL(gl2);
  }
  // 
}
class CubismRendererProfile_WebGL {
  setGlEnable(index, enabled) {
    if (enabled) this.gl.enable(index);
    else this.gl.disable(index);
  }
  setGlEnableVertexAttribArray(index, enabled) {
    if (enabled) this.gl.enableVertexAttribArray(index);
    else this.gl.disableVertexAttribArray(index);
  }
  save() {
    if (this.gl == null) {
      CubismLogError(
        "'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function."
      );
      return;
    }
    this._lastArrayBufferBinding = this.gl.getParameter(
      this.gl.ARRAY_BUFFER_BINDING
    );
    this._lastElementArrayBufferBinding = this.gl.getParameter(
      this.gl.ELEMENT_ARRAY_BUFFER_BINDING
    );
    this._lastProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);
    this._lastActiveTexture = this.gl.getParameter(this.gl.ACTIVE_TEXTURE);
    this.gl.activeTexture(this.gl.TEXTURE1);
    this._lastTexture1Binding2D = this.gl.getParameter(
      this.gl.TEXTURE_BINDING_2D
    );
    this.gl.activeTexture(this.gl.TEXTURE0);
    this._lastTexture0Binding2D = this.gl.getParameter(
      this.gl.TEXTURE_BINDING_2D
    );
    this._lastVertexAttribArrayEnabled[0] = this.gl.getVertexAttrib(
      0,
      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED
    );
    this._lastVertexAttribArrayEnabled[1] = this.gl.getVertexAttrib(
      1,
      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED
    );
    this._lastVertexAttribArrayEnabled[2] = this.gl.getVertexAttrib(
      2,
      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED
    );
    this._lastVertexAttribArrayEnabled[3] = this.gl.getVertexAttrib(
      3,
      this.gl.VERTEX_ATTRIB_ARRAY_ENABLED
    );
    this._lastScissorTest = this.gl.isEnabled(this.gl.SCISSOR_TEST);
    this._lastStencilTest = this.gl.isEnabled(this.gl.STENCIL_TEST);
    this._lastDepthTest = this.gl.isEnabled(this.gl.DEPTH_TEST);
    this._lastCullFace = this.gl.isEnabled(this.gl.CULL_FACE);
    this._lastBlend = this.gl.isEnabled(this.gl.BLEND);
    this._lastFrontFace = this.gl.getParameter(this.gl.FRONT_FACE);
    this._lastColorMask = this.gl.getParameter(this.gl.COLOR_WRITEMASK);
    this._lastBlending[0] = this.gl.getParameter(this.gl.BLEND_SRC_RGB);
    this._lastBlending[1] = this.gl.getParameter(this.gl.BLEND_DST_RGB);
    this._lastBlending[2] = this.gl.getParameter(this.gl.BLEND_SRC_ALPHA);
    this._lastBlending[3] = this.gl.getParameter(this.gl.BLEND_DST_ALPHA);
    this._lastFBO = this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
    this._lastViewport = this.gl.getParameter(this.gl.VIEWPORT);
  }
  restore() {
    if (this.gl == null) {
      CubismLogError(
        "'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function."
      );
      return;
    }
    this.gl.useProgram(this._lastProgram);
    this.setGlEnableVertexAttribArray(0, this._lastVertexAttribArrayEnabled[0]);
    this.setGlEnableVertexAttribArray(1, this._lastVertexAttribArrayEnabled[1]);
    this.setGlEnableVertexAttribArray(2, this._lastVertexAttribArrayEnabled[2]);
    this.setGlEnableVertexAttribArray(3, this._lastVertexAttribArrayEnabled[3]);
    this.setGlEnable(this.gl.SCISSOR_TEST, this._lastScissorTest);
    this.setGlEnable(this.gl.STENCIL_TEST, this._lastStencilTest);
    this.setGlEnable(this.gl.DEPTH_TEST, this._lastDepthTest);
    this.setGlEnable(this.gl.CULL_FACE, this._lastCullFace);
    this.setGlEnable(this.gl.BLEND, this._lastBlend);
    this.gl.frontFace(this._lastFrontFace);
    this.gl.colorMask(
      this._lastColorMask[0],
      this._lastColorMask[1],
      this._lastColorMask[2],
      this._lastColorMask[3]
    );
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._lastArrayBufferBinding);
    this.gl.bindBuffer(
      this.gl.ELEMENT_ARRAY_BUFFER,
      this._lastElementArrayBufferBinding
    );
    this.gl.activeTexture(this.gl.TEXTURE1);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture1Binding2D);
    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture0Binding2D);
    this.gl.activeTexture(this._lastActiveTexture);
    this.gl.blendFuncSeparate(
      this._lastBlending[0],
      this._lastBlending[1],
      this._lastBlending[2],
      this._lastBlending[3]
    );
  }
  setGl(gl2) {
    this.gl = gl2;
  }
  constructor() {
    this._lastVertexAttribArrayEnabled = new Array(4);
    this._lastColorMask = new Array(4);
    this._lastBlending = new Array(4);
    this._lastViewport = new Array(4);
  }
}
class CubismRenderer_WebGL extends CubismRenderer {
  /**
   * 
   * 
   *
   * @param model 
   * @param maskBufferCount 
   */
  initialize(model, maskBufferCount = 1) {
    if (model.isUsingMasking()) {
      this._clippingManager = new CubismClippingManager_WebGL();
      this._clippingManager.initialize(model, maskBufferCount);
    }
    this._sortedDrawableIndexList.resize(model.getDrawableCount(), 0);
    super.initialize(model);
  }
  /**
   * WebGL
   * CubismRendererCubismRendererIndex
   * @param modelTextureNo 
   * @param glTextureNo WebGL
   */
  bindTexture(modelTextureNo, glTexture) {
    this._textures.setValue(modelTextureNo, glTexture);
  }
  /**
   * WebGL
   * @return 
   */
  getBindedTextures() {
    return this._textures;
  }
  /**
   * 
   * FrameBuffer
   * @param size 
   */
  setClippingMaskBufferSize(size2) {
    if (!this._model.isUsingMasking()) {
      return;
    }
    const renderTextureCount = this._clippingManager.getRenderTextureCount();
    this._clippingManager.release();
    this._clippingManager = void 0;
    this._clippingManager = null;
    this._clippingManager = new CubismClippingManager_WebGL();
    this._clippingManager.setClippingMaskBufferSize(size2);
    this._clippingManager.initialize(
      this.getModel(),
      renderTextureCount
      // 
    );
  }
  /**
   * 
   * @return 
   */
  getClippingMaskBufferSize() {
    return this._model.isUsingMasking() ? this._clippingManager.getClippingMaskBufferSize() : -1;
  }
  /**
   * 
   * @return 
   */
  getRenderTextureCount() {
    return this._model.isUsingMasking() ? this._clippingManager.getRenderTextureCount() : -1;
  }
  /**
   * 
   */
  constructor() {
    super();
    this._clippingContextBufferForMask = null;
    this._clippingContextBufferForDraw = null;
    this._rendererProfile = new CubismRendererProfile_WebGL();
    this.firstDraw = true;
    this._textures = new csmMap();
    this._sortedDrawableIndexList = new csmVector();
    this._bufferData = {
      vertex: WebGLBuffer = null,
      uv: WebGLBuffer = null,
      index: WebGLBuffer = null
    };
    this._textures.prepareCapacity(32, true);
  }
  /**
   * 
   */
  release() {
    if (this._clippingManager) {
      this._clippingManager.release();
      this._clippingManager = void 0;
      this._clippingManager = null;
    }
    if (this.gl == null) {
      return;
    }
    this.gl.deleteBuffer(this._bufferData.vertex);
    this._bufferData.vertex = null;
    this.gl.deleteBuffer(this._bufferData.uv);
    this._bufferData.uv = null;
    this.gl.deleteBuffer(this._bufferData.index);
    this._bufferData.index = null;
    this._bufferData = null;
    this._textures = null;
  }
  /**
   * 
   */
  doDrawModel() {
    if (this.gl == null) {
      CubismLogError(
        "'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function."
      );
      return;
    }
    if (this._clippingManager != null) {
      this.preDraw();
      if (this.isUsingHighPrecisionMask()) {
        this._clippingManager.setupMatrixForHighPrecision(
          this.getModel(),
          false
        );
      } else {
        this._clippingManager.setupClippingContext(this.getModel(), this);
      }
    }
    this.preDraw();
    const drawableCount = this.getModel().getDrawableCount();
    const renderOrder = this.getModel().getDrawableRenderOrders();
    for (let i = 0; i < drawableCount; ++i) {
      const order2 = renderOrder[i];
      this._sortedDrawableIndexList.set(order2, i);
    }
    for (let i = 0; i < drawableCount; ++i) {
      const drawableIndex = this._sortedDrawableIndexList.at(i);
      if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {
        continue;
      }
      const clipContext = this._clippingManager != null ? this._clippingManager.getClippingContextListForDraw().at(drawableIndex) : null;
      if (clipContext != null && this.isUsingHighPrecisionMask()) {
        if (clipContext._isUsing) {
          this.gl.viewport(
            0,
            0,
            this._clippingManager.getClippingMaskBufferSize(),
            this._clippingManager.getClippingMaskBufferSize()
          );
          this.preDraw();
          this.gl.bindFramebuffer(
            this.gl.FRAMEBUFFER,
            clipContext.getClippingManager().getMaskRenderTexture().at(clipContext._bufferIndex)
          );
          this.gl.clearColor(1, 1, 1, 1);
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        }
        {
          const clipDrawCount = clipContext._clippingIdCount;
          for (let index = 0; index < clipDrawCount; index++) {
            const clipDrawIndex = clipContext._clippingIdList[index];
            if (!this._model.getDrawableDynamicFlagVertexPositionsDidChange(
              clipDrawIndex
            )) {
              continue;
            }
            this.setIsCulling(
              this._model.getDrawableCulling(clipDrawIndex) != false
            );
            this.setClippingContextBufferForMask(clipContext);
            this.drawMeshWebGL(this._model, clipDrawIndex);
          }
        }
        {
          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
          this.setClippingContextBufferForMask(null);
          this.gl.viewport(
            s_viewport[0],
            s_viewport[1],
            s_viewport[2],
            s_viewport[3]
          );
          this.preDraw();
        }
      }
      this.setClippingContextBufferForDraw(clipContext);
      this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));
      this.drawMeshWebGL(this._model, drawableIndex);
    }
  }
  /**
   * 
   * @param model 
   * @param index 
   */
  drawMeshWebGL(model, index) {
    if (this.isCulling()) {
      this.gl.enable(this.gl.CULL_FACE);
    } else {
      this.gl.disable(this.gl.CULL_FACE);
    }
    this.gl.frontFace(this.gl.CCW);
    if (this.isGeneratingMask()) {
      CubismShader_WebGL.getInstance().setupShaderProgramForMask(
        this,
        model,
        index
      );
    } else {
      CubismShader_WebGL.getInstance().setupShaderProgramForDraw(
        this,
        model,
        index
      );
    }
    {
      const indexCount = model.getDrawableVertexIndexCount(index);
      this.gl.drawElements(
        this.gl.TRIANGLES,
        indexCount,
        this.gl.UNSIGNED_SHORT,
        0
      );
    }
    this.gl.useProgram(null);
    this.setClippingContextBufferForDraw(null);
    this.setClippingContextBufferForMask(null);
  }
  saveProfile() {
    this._rendererProfile.save();
  }
  restoreProfile() {
    this._rendererProfile.restore();
  }
  /**
   * 
   * WebGL
   */
  static doStaticRelease() {
    CubismShader_WebGL.deleteInstance();
  }
  /**
   * 
   * @param fbo 
   * @param viewport 
   */
  setRenderState(fbo, viewport) {
    s_fbo = fbo;
    s_viewport = viewport;
  }
  /**
   * 
   * 
   */
  preDraw() {
    if (this.firstDraw) {
      this.firstDraw = false;
    }
    this.gl.disable(this.gl.SCISSOR_TEST);
    this.gl.disable(this.gl.STENCIL_TEST);
    this.gl.disable(this.gl.DEPTH_TEST);
    this.gl.frontFace(this.gl.CW);
    this.gl.enable(this.gl.BLEND);
    this.gl.colorMask(true, true, true, true);
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
    if (this.getAnisotropy() > 0 && this._extension) {
      for (let i = 0; i < this._textures.getSize(); ++i) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, this._textures.getValue(i));
        this.gl.texParameterf(
          this.gl.TEXTURE_2D,
          this._extension.TEXTURE_MAX_ANISOTROPY_EXT,
          this.getAnisotropy()
        );
      }
    }
  }
  /**
   * 
   */
  setClippingContextBufferForMask(clip) {
    this._clippingContextBufferForMask = clip;
  }
  /**
   * 
   * @return 
   */
  getClippingContextBufferForMask() {
    return this._clippingContextBufferForMask;
  }
  /**
   * 
   */
  setClippingContextBufferForDraw(clip) {
    this._clippingContextBufferForDraw = clip;
  }
  /**
   * 
   * @return 
   */
  getClippingContextBufferForDraw() {
    return this._clippingContextBufferForDraw;
  }
  /**
   * 
   * @returns 
   */
  isGeneratingMask() {
    return this.getClippingContextBufferForMask() != null;
  }
  /**
   * gl
   */
  startUp(gl2) {
    this.gl = gl2;
    if (this._clippingManager) {
      this._clippingManager.setGL(gl2);
    }
    CubismShader_WebGL.getInstance().setGl(gl2);
    this._rendererProfile.setGl(gl2);
    this._extension = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic");
  }
  // webgl
}
CubismRenderer.staticRelease = () => {
  CubismRenderer_WebGL.doStaticRelease();
};
var Live2DCubismFramework$6;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismClippingContext = CubismClippingContext_WebGL;
  Live2DCubismFramework2.CubismClippingManager_WebGL = CubismClippingManager_WebGL;
  Live2DCubismFramework2.CubismRenderTextureResource = CubismRenderTextureResource;
  Live2DCubismFramework2.CubismRenderer_WebGL = CubismRenderer_WebGL;
})(Live2DCubismFramework$6 || (Live2DCubismFramework$6 = {}));
class DrawableColorData {
  constructor(isOverwritten = false, color = new CubismTextureColor()) {
    this.isOverwritten = isOverwritten;
    this.color = color;
  }
}
class PartColorData {
  constructor(isOverwritten = false, color = new CubismTextureColor()) {
    this.isOverwritten = isOverwritten;
    this.color = color;
  }
}
class DrawableCullingData {
  /**
   * 
   *
   * @param isOverwritten
   * @param isCulling
   */
  constructor(isOverwritten = false, isCulling = false) {
    this.isOverwritten = isOverwritten;
    this.isCulling = isCulling;
  }
}
class CubismModel {
  /**
   * 
   */
  update() {
    this._model.update();
    this._model.drawables.resetDynamicFlags();
  }
  /**
   * PixelsPerUnit
   * @returns PixelsPerUnit
   */
  getPixelsPerUnit() {
    if (this._model == null) {
      return 0;
    }
    return this._model.canvasinfo.PixelsPerUnit;
  }
  /**
   * 
   */
  getCanvasWidth() {
    if (this._model == null) {
      return 0;
    }
    return this._model.canvasinfo.CanvasWidth / this._model.canvasinfo.PixelsPerUnit;
  }
  /**
   * 
   */
  getCanvasHeight() {
    if (this._model == null) {
      return 0;
    }
    return this._model.canvasinfo.CanvasHeight / this._model.canvasinfo.PixelsPerUnit;
  }
  /**
   * 
   */
  saveParameters() {
    const parameterCount = this._model.parameters.count;
    const savedParameterCount = this._savedParameters.getSize();
    for (let i = 0; i < parameterCount; ++i) {
      if (i < savedParameterCount) {
        this._savedParameters.set(i, this._parameterValues[i]);
      } else {
        this._savedParameters.pushBack(this._parameterValues[i]);
      }
    }
  }
  /**
   * 
   * @param index Drawables
   * @returns drawable(RGBA)
   */
  getMultiplyColor(index) {
    if (this.getOverwriteFlagForModelMultiplyColors() || this.getOverwriteFlagForDrawableMultiplyColors(index)) {
      return this._userMultiplyColors.at(index).color;
    }
    const color = this.getDrawableMultiplyColor(index);
    return color;
  }
  /**
   * 
   * @param index Drawables
   * @returns drawable(RGBA)
   */
  getScreenColor(index) {
    if (this.getOverwriteFlagForModelScreenColors() || this.getOverwriteFlagForDrawableScreenColors(index)) {
      return this._userScreenColors.at(index).color;
    }
    const color = this.getDrawableScreenColor(index);
    return color;
  }
  /**
   * 
   * @param index Drawables
   * @param color (CubismTextureColor)
   */
  setMultiplyColorByTextureColor(index, color) {
    this.setMultiplyColorByRGBA(index, color.r, color.g, color.b, color.a);
  }
  /**
   * 
   * @param index Drawables
   * @param r R
   * @param g G
   * @param b B
   * @param a A
   */
  setMultiplyColorByRGBA(index, r2, g2, b2, a = 1) {
    this._userMultiplyColors.at(index).color.r = r2;
    this._userMultiplyColors.at(index).color.g = g2;
    this._userMultiplyColors.at(index).color.b = b2;
    this._userMultiplyColors.at(index).color.a = a;
  }
  /**
   * 
   * @param index Drawables
   * @param color (CubismTextureColor)
   */
  setScreenColorByTextureColor(index, color) {
    this.setScreenColorByRGBA(index, color.r, color.g, color.b, color.a);
  }
  /**
   * 
   * @param index Drawables
   * @param r R
   * @param g G
   * @param b B
   * @param a A
   */
  setScreenColorByRGBA(index, r2, g2, b2, a = 1) {
    this._userScreenColors.at(index).color.r = r2;
    this._userScreenColors.at(index).color.g = g2;
    this._userScreenColors.at(index).color.b = b2;
    this._userScreenColors.at(index).color.a = a;
  }
  /**
   * part
   * @param partIndex part
   * @returns part
   */
  getPartMultiplyColor(partIndex) {
    return this._userPartMultiplyColors.at(partIndex).color;
  }
  /**
   * part
   * @param partIndex part
   * @returns part
   */
  getPartScreenColor(partIndex) {
    return this._userPartScreenColors.at(partIndex).color;
  }
  /**
   * partOverwriteColor setter
   * @param partIndex part
   * @param r R
   * @param g G
   * @param b B
   * @param a A
   * @param partColors part
   * @param drawableColors partDrawable
   */
  setPartColor(partIndex, r2, g2, b2, a, partColors, drawableColors) {
    partColors.at(partIndex).color.r = r2;
    partColors.at(partIndex).color.g = g2;
    partColors.at(partIndex).color.b = b2;
    partColors.at(partIndex).color.a = a;
    if (partColors.at(partIndex).isOverwritten) {
      for (let i = 0; i < this._partChildDrawables.at(partIndex).getSize(); ++i) {
        const drawableIndex = this._partChildDrawables.at(partIndex).at(i);
        drawableColors.at(drawableIndex).color.r = r2;
        drawableColors.at(drawableIndex).color.g = g2;
        drawableColors.at(drawableIndex).color.b = b2;
        drawableColors.at(drawableIndex).color.a = a;
      }
    }
  }
  /**
   * 
   * @param partIndex part
   * @param color (CubismTextureColor)
   */
  setPartMultiplyColorByTextureColor(partIndex, color) {
    this.setPartMultiplyColorByRGBA(
      partIndex,
      color.r,
      color.g,
      color.b,
      color.a
    );
  }
  /**
   * 
   * @param partIndex part
   * @param r R
   * @param g G
   * @param b B
   * @param a A
   */
  setPartMultiplyColorByRGBA(partIndex, r2, g2, b2, a) {
    this.setPartColor(
      partIndex,
      r2,
      g2,
      b2,
      a,
      this._userPartMultiplyColors,
      this._userMultiplyColors
    );
  }
  /**
   * 
   * @param partIndex part
   * @param color (CubismTextureColor)
   */
  setPartScreenColorByTextureColor(partIndex, color) {
    this.setPartScreenColorByRGBA(
      partIndex,
      color.r,
      color.g,
      color.b,
      color.a
    );
  }
  /**
   * 
   * @param partIndex part
   * @param r R
   * @param g G
   * @param b B
   * @param a A
   */
  setPartScreenColorByRGBA(partIndex, r2, g2, b2, a) {
    this.setPartColor(
      partIndex,
      r2,
      g2,
      b2,
      a,
      this._userPartScreenColors,
      this._userScreenColors
    );
  }
  /**
   * SDK
   * @returns true -> SDK
   *          false -> 
   */
  getOverwriteFlagForModelMultiplyColors() {
    return this._isOverwrittenModelMultiplyColors;
  }
  /**
   * SDK
   * @returns true -> SDK
   *          false -> 
   */
  getOverwriteFlagForModelScreenColors() {
    return this._isOverwrittenModelScreenColors;
  }
  /**
   * SDK
   * @param value true -> SDK
   *              false -> 
   */
  setOverwriteFlagForModelMultiplyColors(value) {
    this._isOverwrittenModelMultiplyColors = value;
  }
  /**
   * SDK
   * @param value true -> SDK
   *              false -> 
   */
  setOverwriteFlagForModelScreenColors(value) {
    this._isOverwrittenModelScreenColors = value;
  }
  /**
   * SDKDrawableIndex
   * @returns true -> SDK
   *          false -> 
   */
  getOverwriteFlagForDrawableMultiplyColors(drawableindex) {
    return this._userMultiplyColors.at(drawableindex).isOverwritten;
  }
  /**
   * SDKDrawableIndex
   * @returns true -> SDK
   *          false -> 
   */
  getOverwriteFlagForDrawableScreenColors(drawableindex) {
    return this._userScreenColors.at(drawableindex).isOverwritten;
  }
  /**
   * SDKDrawableIndex
   * @param value true -> SDK
   *              false -> 
   */
  setOverwriteFlagForDrawableMultiplyColors(drawableindex, value) {
    this._userMultiplyColors.at(drawableindex).isOverwritten = value;
  }
  /**
   * SDKDrawableIndex
   * @param value true -> SDK
   *              false -> 
   */
  setOverwriteFlagForDrawableScreenColors(drawableindex, value) {
    this._userScreenColors.at(drawableindex).isOverwritten = value;
  }
  /**
   * SDKpart
   * @param partIndex part
   * @returns true    ->  SDK
   *          false   ->  
   */
  getOverwriteColorForPartMultiplyColors(partIndex) {
    return this._userPartMultiplyColors.at(partIndex).isOverwritten;
  }
  /**
   * SDKpart
   * @param partIndex part
   * @returns true    ->  SDK
   *          false   ->  
   */
  getOverwriteColorForPartScreenColors(partIndex) {
    return this._userPartScreenColors.at(partIndex).isOverwritten;
  }
  /**
   * partOverwriteFlag setter
   * @param partIndex part
   * @param value true -> SDK
   *              false -> 
   * @param partColors part
   * @param drawableColors partDrawable
   */
  setOverwriteColorForPartColors(partIndex, value, partColors, drawableColors) {
    partColors.at(partIndex).isOverwritten = value;
    for (let i = 0; i < this._partChildDrawables.at(partIndex).getSize(); ++i) {
      const drawableIndex = this._partChildDrawables.at(partIndex).at(i);
      drawableColors.at(drawableIndex).isOverwritten = value;
      if (value) {
        drawableColors.at(drawableIndex).color.r = partColors.at(partIndex).color.r;
        drawableColors.at(drawableIndex).color.g = partColors.at(partIndex).color.g;
        drawableColors.at(drawableIndex).color.b = partColors.at(partIndex).color.b;
        drawableColors.at(drawableIndex).color.a = partColors.at(partIndex).color.a;
      }
    }
  }
  /**
   * SDKpart
   * @param partIndex part
   * @param value true -> SDK
   *              false -> 
   */
  setOverwriteColorForPartMultiplyColors(partIndex, value) {
    this._userPartMultiplyColors.at(partIndex).isOverwritten = value;
    this.setOverwriteColorForPartColors(
      partIndex,
      value,
      this._userPartMultiplyColors,
      this._userMultiplyColors
    );
  }
  /**
   * SDKpart
   * @param partIndex part
   * @param value true -> SDK
   *              false -> 
   */
  setOverwriteColorForPartScreenColors(partIndex, value) {
    this._userPartScreenColors.at(partIndex).isOverwritten = value;
    this.setOverwriteColorForPartColors(
      partIndex,
      value,
      this._userPartScreenColors,
      this._userScreenColors
    );
  }
  /**
   * Drawable
   *
   * @param   drawableIndex   Drawable
   * @return  Drawable
   */
  getDrawableCulling(drawableIndex) {
    if (this.getOverwriteFlagForModelCullings() || this.getOverwriteFlagForDrawableCullings(drawableIndex)) {
      return this._userCullings.at(drawableIndex).isCulling;
    }
    const constantFlags = this._model.drawables.constantFlags;
    return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(
      constantFlags[drawableIndex]
    );
  }
  /**
   * Drawable
   *
   * @param drawableIndex Drawable
   * @param isCulling 
   */
  setDrawableCulling(drawableIndex, isCulling) {
    this._userCullings.at(drawableIndex).isCulling = isCulling;
  }
  /**
   * SDK
   *
   * @retval  true    ->  SDK
   * @retval  false   ->  
   */
  getOverwriteFlagForModelCullings() {
    return this._isOverwrittenCullings;
  }
  /**
   * SDK
   *
   * @param isOverwrittenCullings SDKtruefalse
   */
  setOverwriteFlagForModelCullings(isOverwrittenCullings) {
    this._isOverwrittenCullings = isOverwrittenCullings;
  }
  /**
   *
   * @param drawableIndex Drawable
   * @retval  true    ->  SDK
   * @retval  false   ->  
   */
  getOverwriteFlagForDrawableCullings(drawableIndex) {
    return this._userCullings.at(drawableIndex).isOverwritten;
  }
  /**
   *
   * @param drawableIndex Drawable
   * @param isOverwrittenCullings SDKtruefalse
   */
  setOverwriteFlagForDrawableCullings(drawableIndex, isOverwrittenCullings) {
    this._userCullings.at(drawableIndex).isOverwritten = isOverwrittenCullings;
  }
  /**
   * 
   *
   * @returns 
   */
  getModelOapcity() {
    return this._modelOpacity;
  }
  /**
   * 
   *
   * @param value 
   */
  setModelOapcity(value) {
    this._modelOpacity = value;
  }
  /**
   * 
   */
  getModel() {
    return this._model;
  }
  /**
   * 
   * @param partId ID
   * @return 
   */
  getPartIndex(partId) {
    let partIndex;
    const partCount = this._model.parts.count;
    for (partIndex = 0; partIndex < partCount; ++partIndex) {
      if (partId == this._partIds.at(partIndex)) {
        return partIndex;
      }
    }
    if (this._notExistPartId.isExist(partId)) {
      return this._notExistPartId.getValue(partId);
    }
    partIndex = partCount + this._notExistPartId.getSize();
    this._notExistPartId.setValue(partId, partIndex);
    this._notExistPartOpacities.appendKey(partIndex);
    return partIndex;
  }
  /**
   * ID
   *
   * @param partIndex 
   * @return ID
   */
  getPartId(partIndex) {
    const partId = this._model.parts.ids[partIndex];
    return CubismFramework.getIdManager().getId(partId);
  }
  /**
   * 
   * @return 
   */
  getPartCount() {
    const partCount = this._model.parts.count;
    return partCount;
  }
  /**
   * (Index)
   * @param partIndex 
   * @param opacity 
   */
  setPartOpacityByIndex(partIndex, opacity) {
    if (this._notExistPartOpacities.isExist(partIndex)) {
      this._notExistPartOpacities.setValue(partIndex, opacity);
      return;
    }
    CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
    this._partOpacities[partIndex] = opacity;
  }
  /**
   * (Id)
   * @param partId ID
   * @param opacity 
   */
  setPartOpacityById(partId, opacity) {
    const index = this.getPartIndex(partId);
    if (index < 0) {
      return;
    }
    this.setPartOpacityByIndex(index, opacity);
  }
  /**
   * (index)
   * @param partIndex 
   * @return 
   */
  getPartOpacityByIndex(partIndex) {
    if (this._notExistPartOpacities.isExist(partIndex)) {
      return this._notExistPartOpacities.getValue(partIndex);
    }
    CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
    return this._partOpacities[partIndex];
  }
  /**
   * (id)
   * @param partId 
   * @return 
   */
  getPartOpacityById(partId) {
    const index = this.getPartIndex(partId);
    if (index < 0) {
      return 0;
    }
    return this.getPartOpacityByIndex(index);
  }
  /**
   * 
   * @param ID
   * @return 
   */
  getParameterIndex(parameterId) {
    let parameterIndex;
    const idCount = this._model.parameters.count;
    for (parameterIndex = 0; parameterIndex < idCount; ++parameterIndex) {
      if (parameterId != this._parameterIds.at(parameterIndex)) {
        continue;
      }
      return parameterIndex;
    }
    if (this._notExistParameterId.isExist(parameterId)) {
      return this._notExistParameterId.getValue(parameterId);
    }
    parameterIndex = this._model.parameters.count + this._notExistParameterId.getSize();
    this._notExistParameterId.setValue(parameterId, parameterIndex);
    this._notExistParameterValues.appendKey(parameterIndex);
    return parameterIndex;
  }
  /**
   * 
   * @return 
   */
  getParameterCount() {
    return this._model.parameters.count;
  }
  /**
   * 
   * @param parameterIndex 
   * @return csmParameterType_Normal -> 
   *          csmParameterType_BlendShape -> 
   */
  getParameterType(parameterIndex) {
    return this._model.parameters.types[parameterIndex];
  }
  /**
   * 
   * @param parameterIndex 
   * @return 
   */
  getParameterMaximumValue(parameterIndex) {
    return this._model.parameters.maximumValues[parameterIndex];
  }
  /**
   * 
   * @param parameterIndex 
   * @return 
   */
  getParameterMinimumValue(parameterIndex) {
    return this._model.parameters.minimumValues[parameterIndex];
  }
  /**
   * 
   * @param parameterIndex 
   * @return 
   */
  getParameterDefaultValue(parameterIndex) {
    return this._model.parameters.defaultValues[parameterIndex];
  }
  /**
   * indexID
   *
   * @param parameterIndex 
   * @returns ID
   */
  getParameterId(parameterIndex) {
    return CubismFramework.getIdManager().getId(
      this._model.parameters.ids[parameterIndex]
    );
  }
  /**
   * 
   * @param parameterIndex    
   * @return 
   */
  getParameterValueByIndex(parameterIndex) {
    if (this._notExistParameterValues.isExist(parameterIndex)) {
      return this._notExistParameterValues.getValue(parameterIndex);
    }
    CSM_ASSERT(
      0 <= parameterIndex && parameterIndex < this.getParameterCount()
    );
    return this._parameterValues[parameterIndex];
  }
  /**
   * 
   * @param parameterId    ID
   * @return 
   */
  getParameterValueById(parameterId) {
    const parameterIndex = this.getParameterIndex(parameterId);
    return this.getParameterValueByIndex(parameterIndex);
  }
  /**
   * 
   * @param parameterIndex 
   * @param value 
   * @param weight 
   */
  setParameterValueByIndex(parameterIndex, value, weight = 1) {
    if (this._notExistParameterValues.isExist(parameterIndex)) {
      this._notExistParameterValues.setValue(
        parameterIndex,
        weight == 1 ? value : this._notExistParameterValues.getValue(parameterIndex) * (1 - weight) + value * weight
      );
      return;
    }
    CSM_ASSERT(
      0 <= parameterIndex && parameterIndex < this.getParameterCount()
    );
    if (this._model.parameters.maximumValues[parameterIndex] < value) {
      value = this._model.parameters.maximumValues[parameterIndex];
    }
    if (this._model.parameters.minimumValues[parameterIndex] > value) {
      value = this._model.parameters.minimumValues[parameterIndex];
    }
    this._parameterValues[parameterIndex] = weight == 1 ? value : this._parameterValues[parameterIndex] = this._parameterValues[parameterIndex] * (1 - weight) + value * weight;
  }
  /**
   * 
   * @param parameterId ID
   * @param value 
   * @param weight 
   */
  setParameterValueById(parameterId, value, weight = 1) {
    const index = this.getParameterIndex(parameterId);
    this.setParameterValueByIndex(index, value, weight);
  }
  /**
   * (index)
   * @param parameterIndex 
   * @param value 
   * @param weight 
   */
  addParameterValueByIndex(parameterIndex, value, weight = 1) {
    this.setParameterValueByIndex(
      parameterIndex,
      this.getParameterValueByIndex(parameterIndex) + value * weight
    );
  }
  /**
   * (id)
   * @param parameterId 
   * @param value 
   * @param weight 
   */
  addParameterValueById(parameterId, value, weight = 1) {
    const index = this.getParameterIndex(parameterId);
    this.addParameterValueByIndex(index, value, weight);
  }
  /**
   * 
   * @param parameterId ID
   * @param value 
   * @param weight 
   */
  multiplyParameterValueById(parameterId, value, weight = 1) {
    const index = this.getParameterIndex(parameterId);
    this.multiplyParameterValueByIndex(index, value, weight);
  }
  /**
   * 
   * @param parameterIndex 
   * @param value 
   * @param weight 
   */
  multiplyParameterValueByIndex(parameterIndex, value, weight = 1) {
    this.setParameterValueByIndex(
      parameterIndex,
      this.getParameterValueByIndex(parameterIndex) * (1 + (value - 1) * weight)
    );
  }
  /**
   * Drawable
   * @param drawableId DrawableID
   * @return Drawable
   */
  getDrawableIndex(drawableId) {
    const drawableCount = this._model.drawables.count;
    for (let drawableIndex = 0; drawableIndex < drawableCount; ++drawableIndex) {
      if (this._drawableIds.at(drawableIndex) == drawableId) {
        return drawableIndex;
      }
    }
    return -1;
  }
  /**
   * Drawable
   * @return drawable
   */
  getDrawableCount() {
    const drawableCount = this._model.drawables.count;
    return drawableCount;
  }
  /**
   * DrawableID
   * @param drawableIndex Drawable
   * @return drawableID
   */
  getDrawableId(drawableIndex) {
    const parameterIds = this._model.drawables.ids;
    return CubismFramework.getIdManager().getId(parameterIds[drawableIndex]);
  }
  /**
   * Drawable
   * @return Drawable
   */
  getDrawableRenderOrders() {
    const renderOrders = this._model.drawables.renderOrders;
    return renderOrders;
  }
  /**
   * @deprecated
   *  getDrawableTextureIndex 
   *
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableTextureIndices(drawableIndex) {
    return this.getDrawableTextureIndex(drawableIndex);
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableTextureIndex(drawableIndex) {
    const textureIndices = this._model.drawables.textureIndices;
    return textureIndices[drawableIndex];
  }
  /**
   * DrawableVertexPositions
   *
   * CubismModel.updateDrawable
   *
   * @param   drawableIndex   Drawable
   * @retval  true    DrawableCubismModel.update
   * @retval  false   DrawableCubismModel.update
   */
  getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableVertexIndexCount(drawableIndex) {
    const indexCounts = this._model.drawables.indexCounts;
    return indexCounts[drawableIndex];
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableVertexCount(drawableIndex) {
    const vertexCounts = this._model.drawables.vertexCounts;
    return vertexCounts[drawableIndex];
  }
  /**
   * Drawable
   * @param drawableIndex drawable
   * @return drawable
   */
  getDrawableVertices(drawableIndex) {
    return this.getDrawableVertexPositions(drawableIndex);
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableVertexIndices(drawableIndex) {
    const indicesArray = this._model.drawables.indices;
    return indicesArray[drawableIndex];
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableVertexPositions(drawableIndex) {
    const verticesArray = this._model.drawables.vertexPositions;
    return verticesArray[drawableIndex];
  }
  /**
   * DrawableUV
   * @param drawableIndex Drawable
   * @return drawableUV
   */
  getDrawableVertexUvs(drawableIndex) {
    const uvsArray = this._model.drawables.vertexUvs;
    return uvsArray[drawableIndex];
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableOpacity(drawableIndex) {
    const opacities = this._model.drawables.opacities;
    return opacities[drawableIndex];
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable(RGBA)
   * RGBAA0
   */
  getDrawableMultiplyColor(drawableIndex) {
    const multiplyColors = this._model.drawables.multiplyColors;
    const index = drawableIndex * 4;
    const multiplyColor = new CubismTextureColor();
    multiplyColor.r = multiplyColors[index];
    multiplyColor.g = multiplyColors[index + 1];
    multiplyColor.b = multiplyColors[index + 2];
    multiplyColor.a = multiplyColors[index + 3];
    return multiplyColor;
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable(RGBA)
   * RGBAA0
   */
  getDrawableScreenColor(drawableIndex) {
    const screenColors = this._model.drawables.screenColors;
    const index = drawableIndex * 4;
    const screenColor = new CubismTextureColor();
    screenColor.r = screenColors[index];
    screenColor.g = screenColors[index + 1];
    screenColor.b = screenColors[index + 2];
    screenColor.a = screenColors[index + 3];
    return screenColor;
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableParentPartIndex(drawableIndex) {
    return this._model.drawables.parentPartIndices[drawableIndex];
  }
  /**
   * Drawable
   * @param drawableIndex Drawable
   * @return drawable
   */
  getDrawableBlendMode(drawableIndex) {
    const constantFlags = this._model.drawables.constantFlags;
    return Live2DCubismCore.Utils.hasBlendAdditiveBit(
      constantFlags[drawableIndex]
    ) ? CubismBlendMode.CubismBlendMode_Additive : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(
      constantFlags[drawableIndex]
    ) ? CubismBlendMode.CubismBlendMode_Multiplicative : CubismBlendMode.CubismBlendMode_Normal;
  }
  /**
   * Drawable
   *
   * Drawable
   * 
   *
   * @param drawableIndex Drawable
   * @return Drawable
   */
  getDrawableInvertedMaskBit(drawableIndex) {
    const constantFlags = this._model.drawables.constantFlags;
    return Live2DCubismCore.Utils.hasIsInvertedMaskBit(
      constantFlags[drawableIndex]
    );
  }
  /**
   * Drawable
   * @return Drawable
   */
  getDrawableMasks() {
    const masks = this._model.drawables.masks;
    return masks;
  }
  /**
   * Drawable
   * @return Drawable
   */
  getDrawableMaskCounts() {
    const maskCounts = this._model.drawables.maskCounts;
    return maskCounts;
  }
  /**
   * 
   *
   * @return true 
   * @return false 
   */
  isUsingMasking() {
    for (let d2 = 0; d2 < this._model.drawables.count; ++d2) {
      if (this._model.drawables.maskCounts[d2] <= 0) {
        continue;
      }
      return true;
    }
    return false;
  }
  /**
   * Drawable
   *
   * @param drawableIndex Drawable
   * @return true Drawable
   * @return false Drawable
   */
  getDrawableDynamicFlagIsVisible(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasIsVisibleBit(dynamicFlags[drawableIndex]);
  }
  /**
   * DrawableDrawOrder
   *
   * CubismModel.updatedrawabledrawOrder
   * drawOrderartMesh01000
   * @param drawableIndex drawable
   * @return true drawableCubismModel.update
   * @return false drawableCubismModel.update
   */
  getDrawableDynamicFlagVisibilityDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * Drawable
   *
   * CubismModel.updatedrawable
   *
   * @param drawableIndex drawable
   * @return true DrawableCubismModel.update
   * @return false DrawableCubismModel.update
   */
  getDrawableDynamicFlagOpacityDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasOpacityDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * Drawable
   *
   * CubismModel.updateDrawable
   *
   * @param drawableIndex Drawable
   * @return true DrawableCubismModel.update
   * @return false DrawableCubismModel.update
   */
  getDrawableDynamicFlagRenderOrderDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * Drawable
   *
   * CubismModel.updateDrawable
   *
   * @param drawableIndex Drawable
   * @return true DrawableCubismModel.update
   * @return false DrawableCubismModel.update
   */
  getDrawableDynamicFlagBlendColorDidChange(drawableIndex) {
    const dynamicFlags = this._model.drawables.dynamicFlags;
    return Live2DCubismCore.Utils.hasBlendColorDidChangeBit(
      dynamicFlags[drawableIndex]
    );
  }
  /**
   * 
   */
  loadParameters() {
    let parameterCount = this._model.parameters.count;
    const savedParameterCount = this._savedParameters.getSize();
    if (parameterCount > savedParameterCount) {
      parameterCount = savedParameterCount;
    }
    for (let i = 0; i < parameterCount; ++i) {
      this._parameterValues[i] = this._savedParameters.at(i);
    }
  }
  /**
   * 
   */
  initialize() {
    CSM_ASSERT(this._model);
    this._parameterValues = this._model.parameters.values;
    this._partOpacities = this._model.parts.opacities;
    this._parameterMaximumValues = this._model.parameters.maximumValues;
    this._parameterMinimumValues = this._model.parameters.minimumValues;
    {
      const parameterIds = this._model.parameters.ids;
      const parameterCount = this._model.parameters.count;
      this._parameterIds.prepareCapacity(parameterCount);
      for (let i = 0; i < parameterCount; ++i) {
        this._parameterIds.pushBack(
          CubismFramework.getIdManager().getId(parameterIds[i])
        );
      }
    }
    const partCount = this._model.parts.count;
    {
      const partIds = this._model.parts.ids;
      this._partIds.prepareCapacity(partCount);
      for (let i = 0; i < partCount; ++i) {
        this._partIds.pushBack(
          CubismFramework.getIdManager().getId(partIds[i])
        );
      }
      this._userPartMultiplyColors.prepareCapacity(partCount);
      this._userPartScreenColors.prepareCapacity(partCount);
      this._partChildDrawables.prepareCapacity(partCount);
    }
    {
      const drawableIds = this._model.drawables.ids;
      const drawableCount = this._model.drawables.count;
      this._userMultiplyColors.prepareCapacity(drawableCount);
      this._userScreenColors.prepareCapacity(drawableCount);
      this._userCullings.prepareCapacity(drawableCount);
      const userCulling = new DrawableCullingData(
        false,
        false
      );
      {
        for (let i = 0; i < partCount; ++i) {
          const multiplyColor = new CubismTextureColor(
            1,
            1,
            1,
            1
          );
          const screenColor = new CubismTextureColor(
            0,
            0,
            0,
            1
          );
          const userMultiplyColor = new PartColorData(
            false,
            multiplyColor
          );
          const userScreenColor = new PartColorData(
            false,
            screenColor
          );
          this._userPartMultiplyColors.pushBack(userMultiplyColor);
          this._userPartScreenColors.pushBack(userScreenColor);
          this._partChildDrawables.pushBack(new csmVector());
          this._partChildDrawables.at(i).prepareCapacity(drawableCount);
        }
      }
      {
        for (let i = 0; i < drawableCount; ++i) {
          const multiplyColor = new CubismTextureColor(
            1,
            1,
            1,
            1
          );
          const screenColor = new CubismTextureColor(
            0,
            0,
            0,
            1
          );
          const userMultiplyColor = new DrawableColorData(
            false,
            multiplyColor
          );
          const userScreenColor = new DrawableColorData(
            false,
            screenColor
          );
          this._drawableIds.pushBack(
            CubismFramework.getIdManager().getId(drawableIds[i])
          );
          this._userMultiplyColors.pushBack(userMultiplyColor);
          this._userScreenColors.pushBack(userScreenColor);
          this._userCullings.pushBack(userCulling);
          const parentIndex = this.getDrawableParentPartIndex(i);
          if (parentIndex >= 0) {
            this._partChildDrawables.at(parentIndex).pushBack(i);
          }
        }
      }
    }
  }
  /**
   * 
   * @param model 
   */
  constructor(model) {
    this._model = model;
    this._parameterValues = null;
    this._parameterMaximumValues = null;
    this._parameterMinimumValues = null;
    this._partOpacities = null;
    this._savedParameters = new csmVector();
    this._parameterIds = new csmVector();
    this._drawableIds = new csmVector();
    this._partIds = new csmVector();
    this._isOverwrittenModelMultiplyColors = false;
    this._isOverwrittenModelScreenColors = false;
    this._isOverwrittenCullings = false;
    this._modelOpacity = 1;
    this._userMultiplyColors = new csmVector();
    this._userScreenColors = new csmVector();
    this._userCullings = new csmVector();
    this._userPartMultiplyColors = new csmVector();
    this._userPartScreenColors = new csmVector();
    this._partChildDrawables = new csmVector();
    this._notExistPartId = new csmMap();
    this._notExistParameterId = new csmMap();
    this._notExistParameterValues = new csmMap();
    this._notExistPartOpacities = new csmMap();
  }
  /**
   * 
   */
  release() {
    this._model.release();
    this._model = null;
  }
  // 
}
var Live2DCubismFramework$5;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismModel = CubismModel;
})(Live2DCubismFramework$5 || (Live2DCubismFramework$5 = {}));
class CubismMoc {
  /**
   * Moc
   */
  static create(mocBytes, shouldCheckMocConsistency) {
    let cubismMoc = null;
    if (shouldCheckMocConsistency) {
      const consistency = this.hasMocConsistency(mocBytes);
      if (!consistency) {
        CubismLogError(`Inconsistent MOC3.`);
        return cubismMoc;
      }
    }
    const moc = Live2DCubismCore.Moc.fromArrayBuffer(mocBytes);
    if (moc) {
      cubismMoc = new CubismMoc(moc);
      cubismMoc._mocVersion = Live2DCubismCore.Version.csmGetMocVersion(
        moc,
        mocBytes
      );
    }
    return cubismMoc;
  }
  /**
   * Moc
   *
   * Moc
   */
  static delete(moc) {
    moc._moc._release();
    moc._moc = null;
    moc = null;
  }
  /**
   * 
   *
   * @return Moc
   */
  createModel() {
    let cubismModel = null;
    const model = Live2DCubismCore.Model.fromMoc(
      this._moc
    );
    if (model) {
      cubismModel = new CubismModel(model);
      cubismModel.initialize();
      ++this._modelCount;
    }
    return cubismModel;
  }
  /**
   * 
   */
  deleteModel(model) {
    if (model != null) {
      model.release();
      model = null;
      --this._modelCount;
    }
  }
  /**
   * 
   */
  constructor(moc) {
    this._moc = moc;
    this._modelCount = 0;
    this._mocVersion = 0;
  }
  /**
   * 
   */
  release() {
    CSM_ASSERT(this._modelCount == 0);
    this._moc._release();
    this._moc = null;
  }
  /**
   * .moc3 Version
   */
  getLatestMocVersion() {
    return Live2DCubismCore.Version.csmGetLatestMocVersion();
  }
  /**
   * .moc3 Version
   */
  getMocVersion() {
    return this._mocVersion;
  }
  /**
   * .moc3 
   */
  static hasMocConsistency(mocBytes) {
    const isConsistent = Live2DCubismCore.Moc.prototype.hasMocConsistency(mocBytes);
    return isConsistent === 1 ? true : false;
  }
  // .moc3 Version
}
var Live2DCubismFramework$4;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismMoc = CubismMoc;
})(Live2DCubismFramework$4 || (Live2DCubismFramework$4 = {}));
const Meta = "Meta";
const UserDataCount = "UserDataCount";
const TotalUserDataSize = "TotalUserDataSize";
const UserData = "UserData";
const Target = "Target";
const Id = "Id";
const Value = "Value";
class CubismModelUserDataJson {
  /**
   * 
   * @param buffer    userdata3.json
   * @param size      
   */
  constructor(buffer, size2) {
    this._json = CubismJson.create(buffer, size2);
  }
  /**
   * 
   */
  release() {
    CubismJson.delete(this._json);
  }
  /**
   * 
   * @return 
   */
  getUserDataCount() {
    return this._json.getRoot().getValueByString(Meta).getValueByString(UserDataCount).toInt();
  }
  /**
   * 
   *
   * @return 
   */
  getTotalUserDataSize() {
    return this._json.getRoot().getValueByString(Meta).getValueByString(TotalUserDataSize).toInt();
  }
  /**
   * 
   *
   * @return 
   */
  getUserDataTargetType(i) {
    return this._json.getRoot().getValueByString(UserData).getValueByIndex(i).getValueByString(Target).getRawString();
  }
  /**
   * ID
   *
   * @param i 
   * @return ID
   */
  getUserDataId(i) {
    return CubismFramework.getIdManager().getId(
      this._json.getRoot().getValueByString(UserData).getValueByIndex(i).getValueByString(Id).getRawString()
    );
  }
  /**
   * 
   *
   * @param i 
   * @return 
   */
  getUserDataValue(i) {
    return this._json.getRoot().getValueByString(UserData).getValueByIndex(i).getValueByString(Value).getRawString();
  }
}
var Live2DCubismFramework$3;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismModelUserDataJson = CubismModelUserDataJson;
})(Live2DCubismFramework$3 || (Live2DCubismFramework$3 = {}));
const ArtMesh = "ArtMesh";
class CubismModelUserDataNode {
  // 
}
class CubismModelUserData {
  /**
   * 
   *
   * @param buffer    userdata3.json
   * @param size      
   * @return 
   */
  static create(buffer, size2) {
    const ret = new CubismModelUserData();
    ret.parseUserData(buffer, size2);
    return ret;
  }
  /**
   * 
   *
   * @param modelUserData 
   */
  static delete(modelUserData) {
    if (modelUserData != null) {
      modelUserData.release();
      modelUserData = null;
    }
  }
  /**
   * ArtMesh
   *
   * @return 
   */
  getArtMeshUserDatas() {
    return this._artMeshUserDataNode;
  }
  /**
   * userdata3.json
   *
   * @param buffer    userdata3.json
   * @param size      
   */
  parseUserData(buffer, size2) {
    let json = new CubismModelUserDataJson(
      buffer,
      size2
    );
    if (!json) {
      json.release();
      json = void 0;
      return;
    }
    const typeOfArtMesh = CubismFramework.getIdManager().getId(ArtMesh);
    const nodeCount = json.getUserDataCount();
    for (let i = 0; i < nodeCount; i++) {
      const addNode = new CubismModelUserDataNode();
      addNode.targetId = json.getUserDataId(i);
      addNode.targetType = CubismFramework.getIdManager().getId(
        json.getUserDataTargetType(i)
      );
      addNode.value = new csmString(json.getUserDataValue(i));
      this._userDataNodes.pushBack(addNode);
      if (addNode.targetType == typeOfArtMesh) {
        this._artMeshUserDataNode.pushBack(addNode);
      }
    }
    json.release();
    json = void 0;
  }
  /**
   * 
   */
  constructor() {
    this._userDataNodes = new csmVector();
    this._artMeshUserDataNode = new csmVector();
  }
  /**
   * 
   *
   * 
   */
  release() {
    for (let i = 0; i < this._userDataNodes.getSize(); ++i) {
      this._userDataNodes.set(i, null);
    }
    this._userDataNodes = null;
  }
  // 
}
var Live2DCubismFramework$2;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismModelUserData = CubismModelUserData;
  Live2DCubismFramework2.CubismModelUserDataNode = CubismModelUserDataNode;
})(Live2DCubismFramework$2 || (Live2DCubismFramework$2 = {}));
class CubismUserModel {
  /**
   * 
   *
   * 
   *
   * @return true     
   * @return false    
   */
  isInitialized() {
    return this._initialized;
  }
  /**
   * 
   *
   * 
   *
   * @param v 
   */
  setInitialized(v2) {
    this._initialized = v2;
  }
  /**
   * 
   *
   * 
   *
   * @return true     
   * @return false    
   */
  isUpdating() {
    return this._updating;
  }
  /**
   * 
   *
   * 
   *
   * @param v 
   */
  setUpdating(v2) {
    this._updating = v2;
  }
  /**
   * 
   * @param X
   * @param Y
   */
  setDragging(x2, y2) {
    this._dragManager.set(x2, y2);
  }
  /**
   * 
   * @param x X
   * @param y Y
   * @param z Z
   */
  setAcceleration(x2, y2, z2) {
    this._accelerationX = x2;
    this._accelerationY = y2;
    this._accelerationZ = z2;
  }
  /**
   * 
   * @return 
   */
  getModelMatrix() {
    return this._modelMatrix;
  }
  /**
   * 
   * @param a 
   */
  setOpacity(a) {
    this._opacity = a;
  }
  /**
   * 
   * @return 
   */
  getOpacity() {
    return this._opacity;
  }
  /**
   * 
   *
   * @param buffer    moc3
   */
  loadModel(buffer, shouldCheckMocConsistency = false, kScale = 1) {
    this._moc = CubismMoc.create(buffer, shouldCheckMocConsistency);
    if (this._moc == null) {
      CubismLogError("Failed to CubismMoc.create().");
      return;
    }
    this._model = this._moc.createModel();
    if (this._model == null) {
      CubismLogError("Failed to CreateModel().");
      return;
    }
    this._model.saveParameters();
    this._modelMatrix = new CubismModelMatrix(
      this._model.getCanvasWidth(),
      this._model.getCanvasHeight()
    );
    this._modelMatrix.scale(kScale, kScale);
  }
  /**
   * 
   * @param buffer motion3.json
   * @param size 
   * @param name 
   * @param onFinishedMotionHandler 
   * @return 
   */
  loadMotion(buffer, size2, name2, onFinishedMotionHandler) {
    if (buffer == null || size2 == 0) {
      CubismLogError("Failed to loadMotion().");
      return null;
    }
    return CubismMotion.create(buffer, size2, onFinishedMotionHandler);
  }
  /**
   * 
   * @param buffer exp
   * @param size 
   * @param name 
   */
  loadExpression(buffer, size2, name2) {
    if (buffer == null || size2 == 0) {
      CubismLogError("Failed to loadExpression().");
      return null;
    }
    return CubismExpressionMotion.create(buffer, size2);
  }
  /**
   * 
   * @param buffer pose3.json
   * @param size 
   */
  loadPose(buffer, size2) {
    if (buffer == null || size2 == 0) {
      CubismLogError("Failed to loadPose().");
      return;
    }
    this._pose = CubismPose.create(buffer, size2);
  }
  /**
   * 
   * @param buffer userdata3.json
   * @param size 
   */
  loadUserData(buffer, size2) {
    if (buffer == null || size2 == 0) {
      CubismLogError("Failed to loadUserData().");
      return;
    }
    this._modelUserData = CubismModelUserData.create(buffer, size2);
  }
  /**
   * 
   * @param buffer  physics3.json
   * @param size    
   */
  loadPhysics(buffer, size2) {
    if (buffer == null || size2 == 0) {
      CubismLogError("Failed to loadPhysics().");
      return;
    }
    this._physics = CubismPhysics.create(buffer, size2);
  }
  /**
   * 
   * @param drawableId DrawableID
   * @param pointX X
   * @param pointY Y
   * @return true 
   * @return false 
   */
  isHit(drawableId, pointX, pointY) {
    const drawIndex = this._model.getDrawableIndex(drawableId);
    if (drawIndex < 0) {
      return false;
    }
    const count = this._model.getDrawableVertexCount(drawIndex);
    const vertices = this._model.getDrawableVertices(drawIndex);
    let left = vertices[0];
    let right = vertices[0];
    let top = vertices[1];
    let bottom = vertices[1];
    for (let j = 1; j < count; ++j) {
      const x2 = vertices[Constant.vertexOffset + j * Constant.vertexStep];
      const y2 = vertices[Constant.vertexOffset + j * Constant.vertexStep + 1];
      if (x2 < left) {
        left = x2;
      }
      if (x2 > right) {
        right = x2;
      }
      if (y2 < top) {
        top = y2;
      }
      if (y2 > bottom) {
        bottom = y2;
      }
    }
    const tx = this._modelMatrix.invertTransformX(pointX);
    const ty = this._modelMatrix.invertTransformY(pointY);
    return left <= tx && tx <= right && top <= ty && ty <= bottom;
  }
  /**
   * 
   * @return 
   */
  getModel() {
    return this._model;
  }
  /**
   * 
   * @return 
   */
  getRenderer() {
    return this._renderer;
  }
  /**
   * 
   * @param maskBufferCount 
   */
  createRenderer(maskBufferCount = 1) {
    if (this._renderer) {
      this.deleteRenderer();
    }
    this._renderer = new CubismRenderer_WebGL();
    this._renderer.initialize(this._model, maskBufferCount);
  }
  /**
   * 
   */
  deleteRenderer() {
    if (this._renderer != null) {
      this._renderer.release();
      this._renderer = null;
    }
  }
  /**
   * 
   *
   * Event
   * 
   * 
   *
   * @param eventValue 
   */
  motionEventFired(eventValue) {
    CubismLogInfo("{0}", eventValue.s);
  }
  /**
   * 
   *
   * CubismMotionQueueManagerCallback
   * CubismUserModelEventFired
   *
   * @param caller 
   * @param eventValue 
   * @param customData CubismUserModel
   */
  static cubismDefaultMotionEventCallback(caller, eventValue, customData) {
    const model = customData;
    if (model != null) {
      model.motionEventFired(eventValue);
    }
  }
  /**
   * 
   */
  constructor() {
    this._moc = null;
    this._model = null;
    this._motionManager = null;
    this._expressionManager = null;
    this._eyeBlink = null;
    this._breath = null;
    this._modelMatrix = null;
    this._pose = null;
    this._dragManager = null;
    this._physics = null;
    this._modelUserData = null;
    this._initialized = false;
    this._updating = false;
    this._opacity = 1;
    this._lipsync = true;
    this._lastLipSyncValue = 0;
    this._dragX = 0;
    this._dragY = 0;
    this._accelerationX = 0;
    this._accelerationY = 0;
    this._accelerationZ = 0;
    this._mocConsistency = false;
    this._debugMode = false;
    this._renderer = null;
    this._motionManager = new CubismMotionManager();
    this._motionManager.setEventCallback(
      CubismUserModel.cubismDefaultMotionEventCallback,
      this
    );
    this._expressionManager = new CubismExpressionMotionManager();
    this._dragManager = new CubismTargetPoint();
  }
  /**
   * 
   */
  release() {
    if (this._motionManager != null) {
      this._motionManager.release();
      this._motionManager = null;
    }
    if (this._expressionManager != null) {
      this._expressionManager.release();
      this._expressionManager = null;
    }
    if (this._moc != null) {
      this._moc.deleteModel(this._model);
      this._moc.release();
      this._moc = null;
    }
    this._modelMatrix = null;
    CubismPose.delete(this._pose);
    CubismEyeBlink.delete(this._eyeBlink);
    CubismBreath.delete(this._breath);
    this._dragManager = null;
    CubismPhysics.delete(this._physics);
    CubismModelUserData.delete(this._modelUserData);
    this.deleteRenderer();
  }
  // 
}
var Live2DCubismFramework$1;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismUserModel = CubismUserModel;
})(Live2DCubismFramework$1 || (Live2DCubismFramework$1 = {}));
class LAppPal {
  /**
   *  
   *
   * @param filePath  [Path to the file to be read]
   * @return
   * {
   *      buffer,    [Read byte data]
   *      size         [File size]
   * }
   */
  static loadFileAsBytes(filePath, callback) {
    fetch(filePath).then((response) => response.arrayBuffer()).then((arrayBuffer) => callback(arrayBuffer, arrayBuffer.byteLength));
  }
  /**
   * 
   * @return [ms]
   * 
   * 
   */
  static getDeltaTime() {
    return this.s_deltaTime;
  }
  static updateTime(modifyLastFrameTime = true) {
    this.s_currentFrame = Date.now();
    this.s_deltaTime = (this.s_currentFrame - this.s_lastFrame) / 1e3;
    if (modifyLastFrameTime === true) {
      this.s_lastFrame = this.s_currentFrame;
    }
  }
  /**
   * 
   * @param message 
   * 
   * 
   */
  static printMessage(message) {
    console.log(message);
  }
  static lastUpdate = Date.now();
  static s_currentFrame = 0;
  static s_lastFrame = 0;
  static s_deltaTime = 0;
}
let s_instance$2 = null;
class LAppWavFileHandler {
  /**
   * 
   * 
   *
   * @return 
   * @deprecated  new LAppWavFileHandler() 
   */
  static getInstance() {
    if (s_instance$2 == null) {
      s_instance$2 = new LAppWavFileHandler();
    }
    return s_instance$2;
  }
  /**
   * 
   *
   * @deprecated  getInstance() 
   */
  static releaseInstance() {
    if (s_instance$2 != null) {
      s_instance$2 = void 0;
    }
    s_instance$2 = null;
  }
  update(deltaTimeSeconds) {
    let goalOffset;
    let rms;
    if (this._pcmData == null || this._sampleOffset >= this._wavFileInfo._samplesPerChannel) {
      this._lastRms = 0;
      return false;
    }
    this._userTimeSeconds += deltaTimeSeconds;
    goalOffset = Math.floor(
      this._userTimeSeconds * this._wavFileInfo._samplingRate
    );
    if (goalOffset > this._wavFileInfo._samplesPerChannel) {
      goalOffset = this._wavFileInfo._samplesPerChannel;
    }
    rms = 0;
    for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
      for (let sampleCount = this._sampleOffset; sampleCount < goalOffset; sampleCount++) {
        const pcm = this._pcmData[channelCount][sampleCount];
        rms += pcm * pcm;
      }
    }
    rms = Math.sqrt(
      rms / (this._wavFileInfo._numberOfChannels * (goalOffset - this._sampleOffset))
    );
    this._lastRms = rms;
    this._sampleOffset = goalOffset;
    return true;
  }
  start(filePath) {
    this._sampleOffset = 0;
    this._userTimeSeconds = 0;
    this._lastRms = 0;
    this.loadWavFile(filePath);
  }
  getRms() {
    return this._lastRms;
  }
  loadWavFile(filePath) {
    return new Promise((resolveValue) => {
      let ret = false;
      if (this._pcmData != null) {
        this.releasePcmData();
      }
      const asyncFileLoad = async () => {
        return fetch(filePath).then((responce) => {
          return responce.arrayBuffer();
        });
      };
      (async () => {
        this._byteReader._fileByte = await asyncFileLoad();
        this._byteReader._fileDataView = new DataView(
          this._byteReader._fileByte
        );
        this._byteReader._fileSize = this._byteReader._fileByte.byteLength;
        this._byteReader._readOffset = 0;
        if (this._byteReader._fileByte == null || this._byteReader._fileSize < 4) {
          resolveValue(false);
          return;
        }
        this._wavFileInfo._fileName = filePath;
        try {
          if (!this._byteReader.getCheckSignature("RIFF")) {
            ret = false;
            throw new Error('Cannot find Signeture "RIFF".');
          }
          this._byteReader.get32LittleEndian();
          if (!this._byteReader.getCheckSignature("WAVE")) {
            ret = false;
            throw new Error('Cannot find Signeture "WAVE".');
          }
          if (!this._byteReader.getCheckSignature("fmt ")) {
            ret = false;
            throw new Error('Cannot find Signeture "fmt".');
          }
          const fmtChunkSize = this._byteReader.get32LittleEndian();
          if (this._byteReader.get16LittleEndian() != 1) {
            ret = false;
            throw new Error("File is not linear PCM.");
          }
          this._wavFileInfo._numberOfChannels = this._byteReader.get16LittleEndian();
          this._wavFileInfo._samplingRate = this._byteReader.get32LittleEndian();
          this._byteReader.get32LittleEndian();
          this._byteReader.get16LittleEndian();
          this._wavFileInfo._bitsPerSample = this._byteReader.get16LittleEndian();
          if (fmtChunkSize > 16) {
            this._byteReader._readOffset += fmtChunkSize - 16;
          }
          while (!this._byteReader.getCheckSignature("data") && this._byteReader._readOffset < this._byteReader._fileSize) {
            this._byteReader._readOffset += this._byteReader.get32LittleEndian() + 4;
          }
          if (this._byteReader._readOffset >= this._byteReader._fileSize) {
            ret = false;
            throw new Error('Cannot find "data" Chunk.');
          }
          {
            const dataChunkSize = this._byteReader.get32LittleEndian();
            this._wavFileInfo._samplesPerChannel = dataChunkSize * 8 / (this._wavFileInfo._bitsPerSample * this._wavFileInfo._numberOfChannels);
          }
          this._pcmData = new Array(this._wavFileInfo._numberOfChannels);
          for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
            this._pcmData[channelCount] = new Float32Array(
              this._wavFileInfo._samplesPerChannel
            );
          }
          for (let sampleCount = 0; sampleCount < this._wavFileInfo._samplesPerChannel; sampleCount++) {
            for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
              this._pcmData[channelCount][sampleCount] = this.getPcmSample();
            }
          }
          ret = true;
          resolveValue(ret);
        } catch (e2) {
          console.log(e2);
        }
      })().then(() => {
        resolveValue(ret);
      });
    });
  }
  getPcmSample() {
    let pcm32;
    switch (this._wavFileInfo._bitsPerSample) {
      case 8:
        pcm32 = this._byteReader.get8() - 128;
        pcm32 <<= 24;
        break;
      case 16:
        pcm32 = this._byteReader.get16LittleEndian() << 16;
        break;
      case 24:
        pcm32 = this._byteReader.get24LittleEndian() << 8;
        break;
      default:
        pcm32 = 0;
        break;
    }
    return pcm32 / 2147483647;
  }
  /**
   * 
   *
   * @param usechannel 
   * @returns 
   */
  getPcmDataChannel(usechannel) {
    if (!this._pcmData || !(usechannel < this._pcmData.length)) {
      return null;
    }
    return Float32Array.from(this._pcmData[usechannel]);
  }
  /**
   * 
   *
   * @returns 
   */
  getWavSamplingRate() {
    if (!this._wavFileInfo || this._wavFileInfo._samplingRate < 1) {
      return null;
    }
    return this._wavFileInfo._samplingRate;
  }
  releasePcmData() {
    if (this._pcmData) {
      for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
        this._pcmData[channelCount] = void 0;
      }
      this._pcmData = null;
    }
  }
  constructor() {
    this._pcmData = null;
    this._userTimeSeconds = 0;
    this._lastRms = 0;
    this._sampleOffset = 0;
    this._wavFileInfo = new WavFileInfo();
    this._byteReader = new ByteReader();
  }
  _pcmData;
  _userTimeSeconds;
  _lastRms;
  _sampleOffset;
  _wavFileInfo;
  _byteReader;
  _loadFiletoBytes = (arrayBuffer, length2) => {
    this._byteReader._fileByte = arrayBuffer;
    this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);
    this._byteReader._fileSize = length2;
  };
}
class WavFileInfo {
  constructor() {
    this._fileName = "";
    this._numberOfChannels = 0;
    this._bitsPerSample = 0;
    this._samplingRate = 0;
    this._samplesPerChannel = 0;
  }
  _fileName;
  ///< 
  _numberOfChannels;
  ///< 
  _bitsPerSample;
  ///< 
  _samplingRate;
  ///< 
  _samplesPerChannel;
  ///< 1
}
class ByteReader {
  constructor() {
    this._fileByte = null;
    this._fileDataView = null;
    this._fileSize = 0;
    this._readOffset = 0;
  }
  /**
   * @brief 8
   * @return Csm::csmUint8 8
   */
  get8() {
    const ret = this._fileDataView.getUint8(this._readOffset);
    this._readOffset++;
    return ret;
  }
  /**
   * @brief 16
   * @return Csm::csmUint16 16
   */
  get16LittleEndian() {
    const ret = this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
    this._readOffset += 2;
    return ret;
  }
  /**
   * @brief 24
   * @return Csm::csmUint32 2424
   */
  get24LittleEndian() {
    const ret = this._fileDataView.getUint8(this._readOffset + 2) << 16 | this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
    this._readOffset += 3;
    return ret;
  }
  /**
   * @brief 32
   * @return Csm::csmUint32 32
   */
  get32LittleEndian() {
    const ret = this._fileDataView.getUint8(this._readOffset + 3) << 24 | this._fileDataView.getUint8(this._readOffset + 2) << 16 | this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
    this._readOffset += 4;
    return ret;
  }
  /**
   * @brief 
   * @param[in] reference 
   * @retval  true    
   * @retval  false   
   */
  getCheckSignature(reference) {
    const getSignature = new Uint8Array(4);
    const referenceString = new TextEncoder().encode(reference);
    if (reference.length != 4) {
      return false;
    }
    for (let signatureOffset = 0; signatureOffset < 4; signatureOffset++) {
      getSignature[signatureOffset] = this.get8();
    }
    return getSignature[0] == referenceString[0] && getSignature[1] == referenceString[1] && getSignature[2] == referenceString[2] && getSignature[3] == referenceString[3];
  }
  _fileByte;
  ///< 
  _fileDataView;
  _fileSize;
  ///< 
  _readOffset;
  ///< 
}
class LAppModel extends CubismUserModel {
  /**
   * model3.json
   * @param dir
   * @param fileName
   */
  loadAssets(dir, fileName) {
    this._modelHomeDir = dir;
    fetch(`${this._modelHomeDir}${fileName}`).then((response) => response.arrayBuffer()).then((arrayBuffer) => {
      const setting = new CubismModelSettingJson(
        arrayBuffer,
        arrayBuffer.byteLength
      );
      this._state = 1;
      this.setupModel(setting);
    }).catch((error2) => {
      CubismLogError(`Failed to load file ${this._modelHomeDir}${fileName}`);
    });
  }
  /**
   * model3.json
   * model3.json
   *
   * @param setting ICubismModelSetting
   */
  setupModel(setting) {
    this._updating = true;
    this._initialized = false;
    this._modelSetting = setting;
    const hitAreasCount = this._modelSetting.getHitAreasCount();
    console.log(`Model has ${hitAreasCount} hit areas`);
    if (this._modelSetting.getModelFileName() != "") {
      const modelFileName = this._modelSetting.getModelFileName();
      fetch(`${this._modelHomeDir}${modelFileName}`).then((response) => {
        if (response.ok) {
          return response.arrayBuffer();
        } else if (response.status >= 400) {
          CubismLogError(
            `Failed to load file ${this._modelHomeDir}${modelFileName}`
          );
          return new ArrayBuffer(0);
        }
      }).then((arrayBuffer) => {
        this.loadModel(arrayBuffer, this._mocConsistency, CurrentKScale);
        this._state = 3;
        loadCubismExpression();
      });
      this._state = 2;
    } else {
      LAppPal.printMessage("Model data does not exist.");
    }
    const loadCubismExpression = () => {
      if (this._modelSetting.getExpressionCount() > 0) {
        const count = this._modelSetting.getExpressionCount();
        for (let i = 0; i < count; i++) {
          const expressionName = this._modelSetting.getExpressionName(i);
          const expressionFileName = this._modelSetting.getExpressionFileName(i);
          fetch(`${this._modelHomeDir}${expressionFileName}`).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            } else if (response.status >= 400) {
              CubismLogError(
                `Failed to load file ${this._modelHomeDir}${expressionFileName}`
              );
              return new ArrayBuffer(0);
            }
          }).then((arrayBuffer) => {
            const motion = this.loadExpression(
              arrayBuffer,
              arrayBuffer.byteLength,
              expressionName
            );
            if (this._expressions.getValue(expressionName) != null) {
              ACubismMotion.delete(
                this._expressions.getValue(expressionName)
              );
              this._expressions.setValue(expressionName, null);
            }
            this._expressions.setValue(expressionName, motion);
            this._expressionCount++;
            if (this._expressionCount >= count) {
              this._state = 5;
              loadCubismPhysics();
            }
          });
        }
        this._state = 4;
      } else {
        this._state = 5;
        loadCubismPhysics();
      }
    };
    const loadCubismPhysics = () => {
      if (this._modelSetting.getPhysicsFileName() != "") {
        const physicsFileName = this._modelSetting.getPhysicsFileName();
        fetch(`${this._modelHomeDir}${physicsFileName}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(
              `Failed to load file ${this._modelHomeDir}${physicsFileName}`
            );
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          this.loadPhysics(arrayBuffer, arrayBuffer.byteLength);
          this._state = 7;
          loadCubismPose();
        });
        this._state = 6;
      } else {
        this._state = 7;
        loadCubismPose();
      }
    };
    const loadCubismPose = () => {
      if (this._modelSetting.getPoseFileName() != "") {
        const poseFileName = this._modelSetting.getPoseFileName();
        fetch(`${this._modelHomeDir}${poseFileName}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(
              `Failed to load file ${this._modelHomeDir}${poseFileName}`
            );
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          this.loadPose(arrayBuffer, arrayBuffer.byteLength);
          this._state = 9;
          setupEyeBlink();
        });
        this._state = 8;
      } else {
        this._state = 9;
        setupEyeBlink();
      }
    };
    const setupEyeBlink = () => {
      if (this._modelSetting.getEyeBlinkParameterCount() > 0) {
        this._eyeBlink = CubismEyeBlink.create(this._modelSetting);
        this._state = 10;
      }
      setupBreath();
    };
    const setupBreath = () => {
      this._breath = CubismBreath.create();
      const breathParameters = new csmVector();
      breathParameters.pushBack(
        new BreathParameterData(this._idParamAngleX, 0, 15, 6.5345, 0.5)
      );
      breathParameters.pushBack(
        new BreathParameterData(this._idParamAngleY, 0, 8, 3.5345, 0.5)
      );
      breathParameters.pushBack(
        new BreathParameterData(this._idParamAngleZ, 0, 10, 5.5345, 0.5)
      );
      breathParameters.pushBack(
        new BreathParameterData(this._idParamBodyAngleX, 0, 4, 15.5345, 0.5)
      );
      const idManager = CubismFramework.getIdManager();
      if (idManager) {
        const breathParameterId = idManager.getId(CubismDefaultParameterId.ParamBreath);
        if (breathParameterId) {
          breathParameters.pushBack(
            new BreathParameterData(breathParameterId, 0.5, 0.5, 3.2345, 1)
          );
        }
      }
      this._breath.setParameters(breathParameters);
      this._state = 11;
      loadUserData();
    };
    const loadUserData = () => {
      if (this._modelSetting.getUserDataFile() != "") {
        const userDataFile = this._modelSetting.getUserDataFile();
        fetch(`${this._modelHomeDir}${userDataFile}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(
              `Failed to load file ${this._modelHomeDir}${userDataFile}`
            );
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          this.loadUserData(arrayBuffer, arrayBuffer.byteLength);
          this._state = 13;
          setupEyeBlinkIds();
        });
        this._state = 12;
      } else {
        this._state = 13;
        setupEyeBlinkIds();
      }
    };
    const setupEyeBlinkIds = () => {
      const eyeBlinkIdCount = this._modelSetting.getEyeBlinkParameterCount();
      for (let i = 0; i < eyeBlinkIdCount; ++i) {
        this._eyeBlinkIds.pushBack(
          this._modelSetting.getEyeBlinkParameterId(i)
        );
      }
      this._state = 14;
      setupLipSyncIds();
    };
    const setupLipSyncIds = () => {
      const lipSyncIdCount = this._modelSetting.getLipSyncParameterCount();
      for (let i = 0; i < lipSyncIdCount; ++i) {
        this._lipSyncIds.pushBack(this._modelSetting.getLipSyncParameterId(i));
      }
      if (this._lipSyncIds.getSize() === 0) {
        console.warn('[Fallback] No LipSync IDs defined in model setting. Attempting fallback to "ParamMouthOpenY".');
        const idManager = CubismFramework.getIdManager();
        if (idManager) {
          const fallbackId = idManager.getId(CubismDefaultParameterId.ParamMouthOpenY);
          if (this._model && fallbackId && this._model.getParameterIndex(fallbackId) !== -1) {
            this._lipSyncIds.pushBack(fallbackId);
            console.log('[Fallback] Successfully added "ParamMouthOpenY" as LipSync ID.');
          } else {
            console.warn('[Fallback] Fallback ID "ParamMouthOpenY" not found in the current model or model not loaded.');
          }
        } else {
          console.warn("[Fallback] Could not access IdManager. LipSync fallback unavailable.");
        }
      }
      this._state = 15;
      setupLayout();
    };
    const setupLayout = () => {
      const layout = new csmMap();
      if (this._modelSetting == null || this._modelMatrix == null) {
        CubismLogError("Failed to setupLayout().");
        return;
      }
      this._modelSetting.getLayoutMap(layout);
      this._modelMatrix.setupFromLayout(layout);
      this._state = 16;
      loadCubismMotion();
    };
    const loadCubismMotion = () => {
      this._state = 17;
      this._model.saveParameters();
      this._allMotionCount = 0;
      this._motionCount = 0;
      const group2 = [];
      const motionGroupCount = this._modelSetting.getMotionGroupCount();
      for (let i = 0; i < motionGroupCount; i++) {
        group2[i] = this._modelSetting.getMotionGroupName(i);
        this._allMotionCount += this._modelSetting.getMotionCount(group2[i]);
      }
      if (this._allMotionCount == 0) {
        this._state = 20;
        this._motionManager.stopAllMotions();
        this._updating = false;
        this._initialized = true;
        this.createRenderer();
        this.setupTextures();
        this.getRenderer().startUp(gl);
        return;
      }
      for (let i = 0; i < motionGroupCount; i++) {
        this.preLoadMotionGroup(group2[i]);
      }
      if (motionGroupCount == 0) {
        this._state = 20;
        this._motionManager.stopAllMotions();
        this._updating = false;
        this._initialized = true;
        this.createRenderer();
        this.setupTextures();
        this.getRenderer().startUp(gl);
      }
    };
  }
  /**
   * 
   */
  setupTextures() {
    console.log("Setting up textures for model:", this._modelHomeDir);
    const usePremultiply = true;
    if (this._state == 20) {
      const textureCount = this._modelSetting.getTextureCount();
      for (let modelTextureNumber = 0; modelTextureNumber < textureCount; modelTextureNumber++) {
        if (this._modelSetting.getTextureFileName(modelTextureNumber) == "") {
          console.log("getTextureFileName null");
          continue;
        }
        let texturePath = this._modelSetting.getTextureFileName(modelTextureNumber);
        texturePath = this._modelHomeDir + texturePath;
        const onLoad = (textureInfo) => {
          this.getRenderer().bindTexture(modelTextureNumber, textureInfo.id);
          this._textureCount++;
          if (this._textureCount >= textureCount) {
            this._state = 22;
          }
        };
        LAppDelegate.getInstance().getTextureManager().createTextureFromPngFile(texturePath, usePremultiply, onLoad);
        this.getRenderer().setIsPremultipliedAlpha(usePremultiply);
      }
      this._state = 21;
    }
  }
  /**
   * 
   */
  reloadRenderer() {
    this.deleteRenderer();
    this.createRenderer();
    this.setupTextures();
  }
  /**
   * 
   */
  update() {
    if (this._state != 22) return;
    const deltaTimeSeconds = LAppPal.getDeltaTime();
    this._userTimeSeconds += deltaTimeSeconds;
    this._dragManager.update(deltaTimeSeconds);
    this._dragX = this._dragManager.getX();
    this._dragY = this._dragManager.getY();
    let motionUpdated = false;
    this._model.loadParameters();
    if (this._motionManager.isFinished()) {
      this.startRandomMotion(
        MotionGroupIdle,
        PriorityIdle
      );
    } else {
      motionUpdated = this._motionManager.updateMotion(
        this._model,
        deltaTimeSeconds
      );
    }
    this._model.saveParameters();
    if (!motionUpdated) {
      if (this._eyeBlink != null) {
        this._eyeBlink.updateParameters(this._model, deltaTimeSeconds);
      }
    }
    if (this._expressionManager != null) {
      this._expressionManager.updateMotion(this._model, deltaTimeSeconds);
    }
    this._model.addParameterValueById(this._idParamAngleX, this._dragX * 30);
    this._model.addParameterValueById(this._idParamAngleY, this._dragY * 30);
    this._model.addParameterValueById(
      this._idParamAngleZ,
      this._dragX * this._dragY * -30
    );
    this._model.addParameterValueById(
      this._idParamBodyAngleX,
      this._dragX * 10
    );
    this._model.addParameterValueById(this._idParamEyeBallX, this._dragX);
    this._model.addParameterValueById(this._idParamEyeBallY, this._dragY);
    if (this._breath != null) {
      this._breath.updateParameters(this._model, deltaTimeSeconds);
    }
    if (this._physics != null) {
      this._physics.evaluate(this._model, deltaTimeSeconds);
    }
    if (this._lipsync) {
      let value = 0;
      this._wavFileHandler.update(deltaTimeSeconds);
      value = this._wavFileHandler.getRms();
      value = Math.min(1, value * 1.5);
      const lipSyncWeight = 4;
      for (let i = 0; i < this._lipSyncIds.getSize(); ++i) {
        this._model.addParameterValueById(
          this._lipSyncIds.at(i),
          value,
          lipSyncWeight
        );
      }
    }
    if (this._pose != null) {
      this._pose.updateParameters(this._model, deltaTimeSeconds);
    }
    this._model.update();
  }
  /**
   * 
   * @param group 
   * @param no 
   * @param priority 
   * @param onFinishedMotionHandler 
   * @return isFinished()[-1]
   */
  startMotion(group2, no, priority, onFinishedMotionHandler) {
    if (priority == PriorityForce) {
      this._motionManager.setReservePriority(priority);
    } else if (!this._motionManager.reserveMotion(priority)) {
      if (this._debugMode) {
        LAppPal.printMessage("[APP]can't start motion.");
      }
      return InvalidMotionQueueEntryHandleValue;
    }
    const motionFileName = this._modelSetting.getMotionFileName(group2, no);
    const name2 = `${group2}_${no}`;
    let motion = this._motions.getValue(name2);
    let autoDelete = false;
    if (motion == null) {
      fetch(`${this._modelHomeDir}${motionFileName}`).then((response) => {
        if (response.ok) {
          return response.arrayBuffer();
        } else if (response.status >= 400) {
          CubismLogError(
            `Failed to load file ${this._modelHomeDir}${motionFileName}`
          );
          return new ArrayBuffer(0);
        }
      }).then((arrayBuffer) => {
        motion = this.loadMotion(
          arrayBuffer,
          arrayBuffer.byteLength,
          null,
          // Pass null for name here? Original code did. Let's keep it for now.
          onFinishedMotionHandler
        );
        if (motion == null) {
          return;
        }
        let fadeTime = this._modelSetting.getMotionFadeInTimeValue(
          group2,
          no
        );
        if (fadeTime >= 0) {
          motion.setFadeInTime(fadeTime);
        }
        fadeTime = this._modelSetting.getMotionFadeOutTimeValue(group2, no);
        if (fadeTime >= 0) {
          motion.setFadeOutTime(fadeTime);
        }
        motion.setEffectIds(this._eyeBlinkIds, this._lipSyncIds);
        autoDelete = true;
        this._motionManager.startMotionPriority(
          motion,
          autoDelete,
          priority
        );
      });
      return InvalidMotionQueueEntryHandleValue;
    } else {
      motion.setFinishedMotionHandler(onFinishedMotionHandler);
      return this._motionManager.startMotionPriority(
        motion,
        autoDelete,
        // Should be false for cached motions? Let's assume true based on original code.
        priority
      );
    }
  }
  /**
   * 
   * @param group 
   * @param priority 
   * @param onFinishedMotionHandler 
   * @return isFinished()[-1]
   */
  startRandomMotion(group2, priority, onFinishedMotionHandler) {
    if (this._modelSetting.getMotionCount(group2) == 0) {
      return InvalidMotionQueueEntryHandleValue;
    }
    const no = Math.floor(
      Math.random() * this._modelSetting.getMotionCount(group2)
    );
    return this.startMotion(group2, no, priority, onFinishedMotionHandler);
  }
  /**
   * 
   *
   * @param expressionId ID
   */
  setExpression(expressionId) {
    const motion = this._expressions.getValue(expressionId);
    if (this._debugMode) {
      LAppPal.printMessage(`[APP]expression: [${expressionId}]`);
    }
    if (motion != null) {
      this._expressionManager.startMotionPriority(
        motion,
        false,
        PriorityForce
      );
    } else {
      if (this._debugMode) {
        LAppPal.printMessage(`[APP]expression[${expressionId}] is null`);
      }
    }
  }
  /**
   * 
   */
  setRandomExpression() {
    if (this._expressions.getSize() == 0) {
      return;
    }
    const no = Math.floor(Math.random() * this._expressions.getSize());
    for (let i = 0; i < this._expressions.getSize(); i++) {
      if (i == no) {
        const name2 = this._expressions._keyValues[i].first;
        this.setExpression(name2);
        return;
      }
    }
  }
  /**
   * 
   */
  motionEventFired(eventValue) {
    CubismLogInfo("{0} is fired on LAppModel!!", eventValue.s);
  }
  /**
   * 
   * 
   *
   * @param hitArenaName  ID
   * @param x             X
   * @param y             Y
   */
  hitTest(hitArenaName, x2, y2) {
    if (this._opacity < 1) {
      return false;
    }
    const count = this._modelSetting.getHitAreasCount();
    for (let i = 0; i < count; i++) {
      if (this._modelSetting.getHitAreaName(i) == hitArenaName) {
        const drawId = this._modelSetting.getHitAreaId(i);
        return this.isHit(drawId, x2, y2);
      }
    }
    return false;
  }
  /**
   * Test if a point hits any part of the model's defined hit areas.
   * @param x X coordinate to test
   * @param y Y coordinate to test
   * @returns The name of the hit area if hit, otherwise null.
   */
  anyhitTest(x2, y2) {
    if (this._opacity < 1) {
      return null;
    }
    const count = this._modelSetting.getHitAreasCount();
    for (let i = 0; i < count; i++) {
      const drawId = this._modelSetting.getHitAreaId(i);
      const hit = this.isHit(drawId, x2, y2);
      if (hit) {
        const hitAreaIdHandle = this._modelSetting.getHitAreaId(i);
        const idString = hitAreaIdHandle?._id?.s;
        return idString || null;
      }
    }
    return null;
  }
  /**
   * Load motions for the model
   * @param group Motion group name
   */
  preLoadMotionGroup(group2) {
    for (let i = 0; i < this._modelSetting.getMotionCount(group2); i++) {
      const motionFileName = this._modelSetting.getMotionFileName(group2, i);
      const name2 = `${group2}_${i}`;
      if (this._debugMode) {
        LAppPal.printMessage(
          `[APP]load motion: ${motionFileName} => [${name2}]`
        );
      }
      fetch(`${this._modelHomeDir}${motionFileName}`).then((response) => {
        if (response.ok) {
          return response.arrayBuffer();
        } else if (response.status >= 400) {
          CubismLogError(
            `Failed to load file ${this._modelHomeDir}${motionFileName}`
          );
          return null;
        }
      }).then((arrayBuffer) => {
        if (!arrayBuffer) {
          this._allMotionCount--;
          return;
        }
        const tmpMotion = this.loadMotion(
          arrayBuffer,
          arrayBuffer.byteLength,
          name2
        );
        if (tmpMotion != null) {
          let fadeTime = this._modelSetting.getMotionFadeInTimeValue(
            group2,
            i
          );
          if (fadeTime >= 0) {
            tmpMotion.setFadeInTime(fadeTime);
          }
          fadeTime = this._modelSetting.getMotionFadeOutTimeValue(group2, i);
          if (fadeTime >= 0) {
            tmpMotion.setFadeOutTime(fadeTime);
          }
          tmpMotion.setEffectIds(this._eyeBlinkIds, this._lipSyncIds);
          if (this._motions.getValue(name2) != null) {
            ACubismMotion.delete(this._motions.getValue(name2));
          }
          this._motions.setValue(name2, tmpMotion);
          this._motionCount++;
          if (this._motionCount >= this._allMotionCount) {
            this._state = 20;
            this._motionManager.stopAllMotions();
            this._updating = false;
            this._initialized = true;
            this.createRenderer();
            this.setupTextures();
            this.getRenderer().startUp(gl);
          }
        } else {
          this._allMotionCount--;
        }
      }).catch((error2) => {
        CubismLogError(`Failed to load motion: ${error2}`);
        this._allMotionCount--;
      });
    }
  }
  /**
   * 
   */
  releaseMotions() {
    this._motions.clear();
  }
  /**
   * 
   */
  releaseExpressions() {
    this._expressions.clear();
  }
  /**
   * View-Projection
   */
  doDraw() {
    if (this._model == null) return;
    const viewport = [0, 0, canvas.width, canvas.height];
    this.getRenderer().setRenderState(frameBuffer, viewport);
    this.getRenderer().drawModel();
  }
  /**
   * View-Projection
   */
  draw(matrix) {
    if (this._model == null) {
      return;
    }
    if (this._state == 22) {
      matrix.multiplyByMatrix(this._modelMatrix);
      this.getRenderer().setMvpMatrix(matrix);
      this.doDraw();
    }
  }
  async hasMocConsistencyFromFile() {
    CSM_ASSERT(this._modelSetting.getModelFileName().localeCompare(``));
    if (this._modelSetting.getModelFileName() != "") {
      const modelFileName = this._modelSetting.getModelFileName();
      const response = await fetch(`${this._modelHomeDir}${modelFileName}`);
      const arrayBuffer = await response.arrayBuffer();
      this._consistency = CubismMoc.hasMocConsistency(arrayBuffer);
      if (!this._consistency) {
        CubismLogInfo("Inconsistent MOC3.");
      } else {
        CubismLogInfo("Consistent MOC3.");
      }
      return this._consistency;
    } else {
      LAppPal.printMessage("Model data does not exist.");
    }
  }
  /**
   * Test if a point hits the model's rendered area
   * This is a fallback method when no hit areas are defined
   * @param x X coordinate to test
   * @param y Y coordinate to test
   */
  isHitOnModel(x2, y2) {
    if (this._opacity < 1) {
      return false;
    }
    const drawableCount = this._model.getDrawableCount();
    const matrix = this._modelMatrix.getArray();
    const det = matrix[0] * matrix[5] - matrix[1] * matrix[4];
    if (Math.abs(det) < 1e-4) {
      return false;
    }
    const invDet = 1 / det;
    const invMatrix = {
      a: matrix[5] * invDet,
      b: -matrix[1] * invDet,
      c: -matrix[4] * invDet,
      d: matrix[0] * invDet,
      tx: (matrix[4] * matrix[13] - matrix[5] * matrix[12]) * invDet,
      ty: (matrix[1] * matrix[12] - matrix[0] * matrix[13]) * invDet
    };
    const transformedPoint = {
      x: x2 * invMatrix.a + y2 * invMatrix.c + invMatrix.tx,
      y: x2 * invMatrix.b + y2 * invMatrix.d + invMatrix.ty
    };
    for (let i = 0; i < drawableCount; i++) {
      if (!this._model.getDrawableDynamicFlagIsVisible(i)) {
        continue;
      }
      const vertices = this._model.getDrawableVertices(i);
      let minX = vertices[0];
      let minY = vertices[1];
      let maxX = vertices[0];
      let maxY = vertices[1];
      for (let j = 2; j < vertices.length; j += 2) {
        const vx = vertices[j];
        const vy = vertices[j + 1];
        minX = Math.min(minX, vx);
        minY = Math.min(minY, vy);
        maxX = Math.max(maxX, vx);
        maxY = Math.max(maxY, vy);
      }
      if (transformedPoint.x >= minX && transformedPoint.x <= maxX && transformedPoint.y >= minY && transformedPoint.y <= maxY) {
        return true;
      }
    }
    return false;
  }
  /**
   * Performs a hit test with fallback if the first one fails.
   * 
   * @param x - X coordinate to test
   * @param y - Y coordinate to test
   * @returns boolean indicating if any hit was detected
   */
  anyHitTestWithFallback(x2, y2) {
    const hitAreaName = this.anyhitTest(x2, y2);
    return hitAreaName !== null || this.isHitOnModel(x2, y2);
  }
  /**
   * Starts a tap motion based on the hit area and configuration.
   * @param hitAreaName The name of the hit area that was tapped, or null if no specific area was hit
   * @param tapMotionsConfig The tap motion configuration from modelInfo
   */
  startTapMotion(hitAreaName, tapMotionsConfig) {
    if (!tapMotionsConfig || Object.keys(tapMotionsConfig).length === 0) {
      return;
    }
    let motionsToConsider = {};
    let areaSpecificHit = false;
    if (hitAreaName && tapMotionsConfig[hitAreaName]) {
      motionsToConsider = tapMotionsConfig[hitAreaName];
      areaSpecificHit = true;
    }
    if (!areaSpecificHit) {
      motionsToConsider = {};
      Object.values(tapMotionsConfig).forEach((areaMotions) => {
        for (const [motionName, weight] of Object.entries(areaMotions)) {
          if (motionsToConsider[motionName]) {
            motionsToConsider[motionName] += Number(weight);
          } else {
            motionsToConsider[motionName] = Number(weight);
          }
        }
      });
    }
    if (Object.keys(motionsToConsider).length === 0) {
      return;
    }
    const motionGroups = Object.keys(motionsToConsider);
    const weights = Object.values(motionsToConsider).map(Number);
    const totalWeight = weights.reduce((sum, w2) => sum + (isNaN(w2) ? 0 : w2), 0);
    if (totalWeight <= 0) {
      return;
    }
    let random = Math.random() * totalWeight;
    let selectedGroupName = null;
    for (let i = 0; i < motionGroups.length; i++) {
      const weight = isNaN(weights[i]) ? 0 : weights[i];
      if (random < weight) {
        selectedGroupName = motionGroups[i];
        break;
      }
      random -= weight;
    }
    if (selectedGroupName !== null) {
      this.startRandomMotion(selectedGroupName, 3);
    }
  }
  /**
   * 
   */
  constructor() {
    super();
    this._modelSetting = null;
    this._modelHomeDir = null;
    this._userTimeSeconds = 0;
    this._eyeBlinkIds = new csmVector();
    this._lipSyncIds = new csmVector();
    this._motions = new csmMap();
    this._expressions = new csmMap();
    this._hitArea = new csmVector();
    this._userArea = new csmVector();
    const idManager = CubismFramework.getIdManager();
    if (idManager) {
      this._idParamAngleX = idManager.getId(
        CubismDefaultParameterId.ParamAngleX
      );
      this._idParamAngleY = idManager.getId(
        CubismDefaultParameterId.ParamAngleY
      );
      this._idParamAngleZ = idManager.getId(
        CubismDefaultParameterId.ParamAngleZ
      );
      this._idParamEyeBallX = idManager.getId(
        CubismDefaultParameterId.ParamEyeBallX
      );
      this._idParamEyeBallY = idManager.getId(
        CubismDefaultParameterId.ParamEyeBallY
      );
      this._idParamBodyAngleX = idManager.getId(
        CubismDefaultParameterId.ParamBodyAngleX
      );
    } else {
      this._idParamAngleX = null;
      this._idParamAngleY = null;
      this._idParamAngleZ = null;
      this._idParamEyeBallX = null;
      this._idParamEyeBallY = null;
      this._idParamBodyAngleX = null;
    }
    {
      this._mocConsistency = true;
    }
    this._state = 0;
    this._expressionCount = 0;
    this._textureCount = 0;
    this._motionCount = 0;
    this._allMotionCount = 0;
    this._wavFileHandler = new LAppWavFileHandler();
    this._consistency = false;
  }
  _modelSetting;
  // 
  _modelHomeDir;
  // 
  _userTimeSeconds;
  // []
  _eyeBlinkIds;
  // ID
  _lipSyncIds;
  // ID
  _motions;
  // 
  _expressions;
  // 
  _hitArea;
  _userArea;
  _idParamAngleX;
  // ID: ParamAngleX
  _idParamAngleY;
  // ID: ParamAngleY
  _idParamAngleZ;
  // ID: ParamAngleZ
  _idParamEyeBallX;
  // ID: ParamEyeBallX
  _idParamEyeBallY;
  // ID: ParamEyeBAllY
  _idParamBodyAngleX;
  // ID: ParamBodyAngleX
  _state;
  // 
  _expressionCount;
  // 
  _textureCount;
  // 
  _motionCount;
  // 
  _allMotionCount;
  // 
  _wavFileHandler;
  //wav
  _consistency;
  // MOC3
}
let s_instance$1 = null;
class LAppLive2DManager {
  /**
   * 
   * 
   * 
   * 
   * 
   *
   * @return 
   */
  static getInstance() {
    if (s_instance$1 == null) {
      s_instance$1 = new LAppLive2DManager();
    }
    return s_instance$1;
  }
  /**
   * 
   * 
   * 
   */
  static releaseInstance() {
    if (s_instance$1 != null) {
      s_instance$1 = void 0;
    }
    s_instance$1 = null;
  }
  /**
   * 
   *
   * @param no 
   * @return NULL
   */
  getModel(no) {
    if (no < this._models.getSize()) {
      return this._models.at(no);
    }
    return null;
  }
  /**
   * 
   */
  releaseAllModel() {
    for (let i = 0; i < this._models.getSize(); i++) {
      this._models.at(i).release();
      this._models.set(i, null);
    }
    this._models.clear();
  }
  /**
   * 
   * 
   * 
   *
   * @param x X
   * @param y Y
   */
  onDrag(x2, y2) {
    for (let i = 0; i < this._models.getSize(); i++) {
      const model = this.getModel(i);
      if (model) {
        model.setDragging(x2, y2);
      }
    }
  }
  /**
   * 
   *
   * @param x X
   * @param y Y
   */
  onTap(x2, y2) {
    for (let i = 0; i < this._models.getSize(); i++) {
      if (this._models.at(i).hitTest(HitAreaNameHead, x2, y2)) {
        this._models.at(i).setRandomExpression();
      } else if (this._models.at(i).hitTest(HitAreaNameBody, x2, y2)) {
        this._models.at(i).startRandomMotion(
          MotionGroupTapBody,
          PriorityNormal,
          this._finishedMotion
        );
      }
    }
  }
  /**
   * 
   * 
   */
  onUpdate() {
    const { width, height } = canvas;
    const modelCount = this._models.getSize();
    for (let i = 0; i < modelCount; ++i) {
      const projection = new CubismMatrix44();
      const model = this.getModel(i);
      if (model.getModel()) {
        if (model.getModel().getCanvasWidth() > 1 && width < height) {
          model.getModelMatrix().setWidth(2);
          projection.scale(1, width / height);
        } else {
          projection.scale(height / width, 1);
        }
        if (this._viewMatrix != null) {
          projection.multiplyByMatrix(this._viewMatrix);
        }
      }
      model.update();
      model.draw(projection);
    }
  }
  /**
   * 
   * 
   */
  nextScene() {
    const no = (this._sceneIndex + 1) % ModelDirSize;
    this.changeScene(no);
  }
  /**
   * 
   * 
   */
  changeScene(index) {
    this._sceneIndex = index;
    const model = ModelDir[index];
    const modelPath = ResourcesPath + model + "/";
    let modelJsonName = ModelFileNames && ModelFileNames[index] ? ModelFileNames[index] : ModelDir[index];
    modelJsonName += ".model3.json";
    this.releaseAllModel();
    this._models.pushBack(new LAppModel());
    this._models.at(0).loadAssets(modelPath, modelJsonName);
  }
  setViewMatrix(m2) {
    for (let i = 0; i < 16; i++) {
      this._viewMatrix.getArray()[i] = m2.getArray()[i];
    }
  }
  /**
   * 
   */
  constructor() {
    this._viewMatrix = new CubismMatrix44();
    this._models = new csmVector();
    this._sceneIndex = 0;
    this.changeScene(this._sceneIndex);
  }
  _viewMatrix;
  // view
  _models;
  // 
  _sceneIndex;
  // 
  // 
  _finishedMotion = (self2) => {
    LAppPal.printMessage("Motion Finished:");
    console.log(self2);
  };
}
class LAppTextureManager {
  /**
   * 
   */
  constructor() {
    this._textures = new csmVector();
  }
  /**
   * 
   */
  release() {
    for (let ite = this._textures.begin(); ite.notEqual(this._textures.end()); ite.preIncrement()) {
      gl.deleteTexture(ite.ptr().id);
    }
    this._textures = null;
  }
  /**
   * 
   *
   * @param fileName 
   * @param usePremultiply Premult
   * @return null
   */
  createTextureFromPngFile(fileName, usePremultiply, callback) {
    for (let ite = this._textures.begin(); ite.notEqual(this._textures.end()); ite.preIncrement()) {
      if (ite.ptr().fileName == fileName && ite.ptr().usePremultply == usePremultiply) {
        ite.ptr().img = new Image();
        ite.ptr().img.addEventListener("load", () => callback(ite.ptr()), {
          passive: true
        });
        ite.ptr().img.src = fileName;
        return;
      }
    }
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.addEventListener(
      "load",
      () => {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(
          gl.TEXTURE_2D,
          gl.TEXTURE_MIN_FILTER,
          gl.LINEAR_MIPMAP_LINEAR
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        if (usePremultiply) {
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
        }
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          img
        );
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.bindTexture(gl.TEXTURE_2D, null);
        const textureInfo = new TextureInfo();
        if (textureInfo != null) {
          textureInfo.fileName = fileName;
          textureInfo.width = img.width;
          textureInfo.height = img.height;
          textureInfo.id = tex;
          textureInfo.img = img;
          textureInfo.usePremultply = usePremultiply;
          this._textures.pushBack(textureInfo);
        }
        callback(textureInfo);
      },
      { passive: true }
    );
    img.src = fileName;
  }
  /**
   * 
   *
   * 
   */
  releaseTextures() {
    for (let i = 0; i < this._textures.getSize(); i++) {
      this._textures.set(i, null);
    }
    this._textures.clear();
  }
  /**
   * 
   *
   * 
   * @param texture 
   */
  releaseTextureByTexture(texture) {
    for (let i = 0; i < this._textures.getSize(); i++) {
      if (this._textures.at(i).id != texture) {
        continue;
      }
      this._textures.set(i, null);
      this._textures.remove(i);
      break;
    }
  }
  /**
   * 
   *
   * 
   * @param fileName 
   */
  releaseTextureByFilePath(fileName) {
    for (let i = 0; i < this._textures.getSize(); i++) {
      if (this._textures.at(i).fileName == fileName) {
        this._textures.set(i, null);
        this._textures.remove(i);
        break;
      }
    }
  }
  _textures;
}
class TextureInfo {
  img;
  // 
  id = null;
  // 
  width = 0;
  // 
  height = 0;
  // 
  usePremultply;
  // Premult
  fileName;
  // 
}
class CubismViewMatrix extends CubismMatrix44 {
  /**
   * 
   */
  constructor() {
    super();
    this._screenLeft = 0;
    this._screenRight = 0;
    this._screenTop = 0;
    this._screenBottom = 0;
    this._maxLeft = 0;
    this._maxRight = 0;
    this._maxTop = 0;
    this._maxBottom = 0;
    this._maxScale = 0;
    this._minScale = 0;
  }
  /**
   * 
   *
   * @param x X
   * @param y Y
   */
  adjustTranslate(x2, y2) {
    if (this._tr[0] * this._maxLeft + (this._tr[12] + x2) > this._screenLeft) {
      x2 = this._screenLeft - this._tr[0] * this._maxLeft - this._tr[12];
    }
    if (this._tr[0] * this._maxRight + (this._tr[12] + x2) < this._screenRight) {
      x2 = this._screenRight - this._tr[0] * this._maxRight - this._tr[12];
    }
    if (this._tr[5] * this._maxTop + (this._tr[13] + y2) < this._screenTop) {
      y2 = this._screenTop - this._tr[5] * this._maxTop - this._tr[13];
    }
    if (this._tr[5] * this._maxBottom + (this._tr[13] + y2) > this._screenBottom) {
      y2 = this._screenBottom - this._tr[5] * this._maxBottom - this._tr[13];
    }
    const tr1 = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      x2,
      y2,
      0,
      1
    ]);
    CubismMatrix44.multiply(tr1, this._tr, this._tr);
  }
  /**
   * 
   *
   * @param cx X
   * @param cy Y
   * @param scale 
   */
  adjustScale(cx2, cy, scale) {
    const maxScale = this.getMaxScale();
    const minScale = this.getMinScale();
    const targetScale = scale * this._tr[0];
    if (targetScale < minScale) {
      if (this._tr[0] > 0) {
        scale = minScale / this._tr[0];
      }
    } else if (targetScale > maxScale) {
      if (this._tr[0] > 0) {
        scale = maxScale / this._tr[0];
      }
    }
    const tr1 = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      cx2,
      cy,
      0,
      1
    ]);
    const tr2 = new Float32Array([
      scale,
      0,
      0,
      0,
      0,
      scale,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    const tr3 = new Float32Array([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      -cx2,
      -cy,
      0,
      1
    ]);
    CubismMatrix44.multiply(tr3, this._tr, this._tr);
    CubismMatrix44.multiply(tr2, this._tr, this._tr);
    CubismMatrix44.multiply(tr1, this._tr, this._tr);
  }
  /**
   * 
   *
   * @param left      X
   * @param right     X
   * @param bottom    Y
   * @param top       Y
   */
  setScreenRect(left, right, bottom, top) {
    this._screenLeft = left;
    this._screenRight = right;
    this._screenBottom = bottom;
    this._screenTop = top;
  }
  /**
   * 
   * @param left      X
   * @param right     X
   * @param bottom    Y
   * @param top       Y
   */
  setMaxScreenRect(left, right, bottom, top) {
    this._maxLeft = left;
    this._maxRight = right;
    this._maxTop = top;
    this._maxBottom = bottom;
  }
  /**
   * 
   * @param maxScale 
   */
  setMaxScale(maxScale) {
    this._maxScale = maxScale;
  }
  /**
   * 
   * @param minScale 
   */
  setMinScale(minScale) {
    this._minScale = minScale;
  }
  /**
   * 
   * @return 
   */
  getMaxScale() {
    return this._maxScale;
  }
  /**
   * 
   * @return 
   */
  getMinScale() {
    return this._minScale;
  }
  /**
   * 
   *
   * @return true 
   * @return false 
   */
  isMaxScale() {
    return this.getScaleX() >= this._maxScale;
  }
  /**
   * 
   *
   * @return true 
   * @return false 
   */
  isMinScale() {
    return this.getScaleX() <= this._minScale;
  }
  /**
   * 
   * @return X
   */
  getScreenLeft() {
    return this._screenLeft;
  }
  /**
   * 
   * @return X
   */
  getScreenRight() {
    return this._screenRight;
  }
  /**
   * Y
   * @return Y
   */
  getScreenBottom() {
    return this._screenBottom;
  }
  /**
   * Y
   * @return Y
   */
  getScreenTop() {
    return this._screenTop;
  }
  /**
   * X
   * @return X
   */
  getMaxLeft() {
    return this._maxLeft;
  }
  /**
   * X
   * @return X
   */
  getMaxRight() {
    return this._maxRight;
  }
  /**
   * Y
   * @return Y
   */
  getMaxBottom() {
    return this._maxBottom;
  }
  /**
   * Y
   * @return Y
   */
  getMaxTop() {
    return this._maxTop;
  }
  // 
}
var Live2DCubismFramework;
((Live2DCubismFramework2) => {
  Live2DCubismFramework2.CubismViewMatrix = CubismViewMatrix;
})(Live2DCubismFramework || (Live2DCubismFramework = {}));
class TouchManager {
  /**
   * 
   */
  constructor() {
    this._startX = 0;
    this._startY = 0;
    this._lastX = 0;
    this._lastY = 0;
    this._lastX1 = 0;
    this._lastY1 = 0;
    this._lastX2 = 0;
    this._lastY2 = 0;
    this._lastTouchDistance = 0;
    this._deltaX = 0;
    this._deltaY = 0;
    this._scale = 1;
    this._touchSingle = false;
    this._flipAvailable = false;
  }
  getCenterX() {
    return this._lastX;
  }
  getCenterY() {
    return this._lastY;
  }
  getDeltaX() {
    return this._deltaX;
  }
  getDeltaY() {
    return this._deltaY;
  }
  getStartX() {
    return this._startX;
  }
  getStartY() {
    return this._startY;
  }
  getScale() {
    return this._scale;
  }
  getX() {
    return this._lastX;
  }
  getY() {
    return this._lastY;
  }
  getX1() {
    return this._lastX1;
  }
  getY1() {
    return this._lastY1;
  }
  getX2() {
    return this._lastX2;
  }
  getY2() {
    return this._lastY2;
  }
  isSingleTouch() {
    return this._touchSingle;
  }
  isFlickAvailable() {
    return this._flipAvailable;
  }
  disableFlick() {
    this._flipAvailable = false;
  }
  /**
   * 
   * @param deviceX x
   * @param deviceY y
   */
  touchesBegan(deviceX, deviceY) {
    this._lastX = deviceX;
    this._lastY = deviceY;
    this._startX = deviceX;
    this._startY = deviceY;
    this._lastTouchDistance = -1;
    this._flipAvailable = true;
    this._touchSingle = true;
  }
  /**
   * 
   * @param deviceX x
   * @param deviceY y
   */
  touchesMoved(deviceX, deviceY) {
    this._lastX = deviceX;
    this._lastY = deviceY;
    this._lastTouchDistance = -1;
    this._touchSingle = true;
  }
  /**
   * 
   * @return 
   */
  getFlickDistance() {
    return this.calculateDistance(
      this._startX,
      this._startY,
      this._lastX,
      this._lastY
    );
  }
  /**
   * 
   *
   * @param x1 x
   * @param y1 y
   * @param x2 x
   * @param y2 y
   */
  calculateDistance(x1, y1, x2, y2) {
    return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
  }
  /**
   * 
   * 
   *
   * @param v1 
   * @param v2 
   *
   * @return 
   */
  calculateMovingAmount(v1, v2) {
    if (v1 > 0 != v2 > 0) {
      return 0;
    }
    const sign2 = v1 > 0 ? 1 : -1;
    const absoluteValue1 = Math.abs(v1);
    const absoluteValue2 = Math.abs(v2);
    return sign2 * (absoluteValue1 < absoluteValue2 ? absoluteValue1 : absoluteValue2);
  }
  _startY;
  // x
  _startX;
  // y
  _lastX;
  // x
  _lastY;
  // y
  _lastX1;
  // x
  _lastY1;
  // y
  _lastX2;
  // x
  _lastY2;
  // y
  _lastTouchDistance;
  // 2
  _deltaX;
  // x
  _deltaY;
  // y
  _scale;
  // 1
  _touchSingle;
  // true
  _flipAvailable;
  // 
}
class LAppView {
  /**
   * 
   */
  constructor() {
    this._programId = null;
    this._back = null;
    this._touchManager = new TouchManager();
    this._deviceToScreen = new CubismMatrix44();
    this._viewMatrix = new CubismViewMatrix();
  }
  /**
   * 
   */
  initialize() {
    if (!canvas) {
      console.warn("Canvas is null, cannot initialize LAppView");
      return;
    }
    const { width, height } = canvas;
    const ratio = width / height;
    const left = -ratio;
    const right = ratio;
    const bottom = ViewLogicalLeft;
    const top = ViewLogicalRight;
    this._viewMatrix.setScreenRect(left, right, bottom, top);
    this._viewMatrix.scale(ViewScale, ViewScale);
    this._deviceToScreen.loadIdentity();
    if (width > height) {
      const screenW = Math.abs(right - left);
      this._deviceToScreen.scaleRelative(screenW / width, -screenW / width);
    } else {
      const screenH = Math.abs(top - bottom);
      this._deviceToScreen.scaleRelative(screenH / height, -screenH / height);
    }
    this._deviceToScreen.translateRelative(-width * 0.5, -height * 0.5);
    this._viewMatrix.setMaxScale(ViewMaxScale);
    this._viewMatrix.setMinScale(ViewMinScale);
    this._viewMatrix.setMaxScreenRect(
      ViewLogicalMaxLeft,
      ViewLogicalMaxRight,
      ViewLogicalMaxBottom,
      ViewLogicalMaxTop
    );
  }
  /**
   * 
   */
  release() {
    this._viewMatrix = null;
    this._touchManager = null;
    this._deviceToScreen = null;
    this._back.release();
    this._back = null;
    gl.deleteProgram(this._programId);
    this._programId = null;
  }
  /**
   * 
   */
  render() {
    gl.useProgram(this._programId);
    if (this._back) {
      this._back.render(this._programId);
    }
    gl.flush();
    const live2DManager = LAppLive2DManager.getInstance();
    live2DManager.setViewMatrix(this._viewMatrix);
    live2DManager.onUpdate();
  }
  /**
   * 
   */
  initializeSprite() {
    canvas.width;
    canvas.height;
    LAppDelegate.getInstance().getTextureManager();
    if (this._programId == null) {
      this._programId = LAppDelegate.getInstance().createShader();
    }
  }
  /**
   * 
   *
   * @param pointX X
   * @param pointY Y
   */
  onTouchesBegan(pointX, pointY) {
    this._touchManager.touchesBegan(
      pointX * window.devicePixelRatio,
      pointY * window.devicePixelRatio
    );
  }
  /**
   * 
   *
   * @param pointX X
   * @param pointY Y
   */
  onTouchesMoved(pointX, pointY) {
    const viewX = this.transformViewX(this._touchManager.getX());
    const viewY = this.transformViewY(this._touchManager.getY());
    this._touchManager.touchesMoved(
      pointX * window.devicePixelRatio,
      pointY * window.devicePixelRatio
    );
    const live2DManager = LAppLive2DManager.getInstance();
    live2DManager.onDrag(viewX, viewY);
  }
  /**
   * 
   *
   * @param pointX X
   * @param pointY Y
   */
  onTouchesEnded(pointX, pointY) {
    const live2DManager = LAppLive2DManager.getInstance();
    live2DManager.onDrag(0, 0);
    {
      const x2 = this._deviceToScreen.transformX(
        this._touchManager.getX()
      );
      const y2 = this._deviceToScreen.transformY(
        this._touchManager.getY()
      );
      live2DManager.onTap(x2, y2);
    }
  }
  /**
   * XView
   *
   * @param deviceX X
   */
  transformViewX(deviceX) {
    const screenX = this._deviceToScreen.transformX(deviceX);
    return this._viewMatrix.invertTransformX(screenX);
  }
  /**
   * YView
   *
   * @param deviceY Y
   */
  transformViewY(deviceY) {
    const screenY = this._deviceToScreen.transformY(deviceY);
    return this._viewMatrix.invertTransformY(screenY);
  }
  /**
   * XScreen
   * @param deviceX X
   */
  transformScreenX(deviceX) {
    return this._deviceToScreen.transformX(deviceX);
  }
  /**
   * YScreen
   *
   * @param deviceY Y
   */
  transformScreenY(deviceY) {
    return this._deviceToScreen.transformY(deviceY);
  }
  _touchManager;
  // 
  _deviceToScreen;
  // 
  _viewMatrix;
  // viewMatrix
  _programId;
  // ID
  _back;
  // 
  // _gear: LAppSprite; // 
  _changeModel;
  // 
  _isClick;
  // 
}
let s_instance = null;
let frameBuffer = null;
class LAppDelegate {
  /**
   * 
   * 
   * 
   * 
   * 
   *
   * @return 
   */
  static getInstance() {
    if (s_instance == null) {
      s_instance = new LAppDelegate();
    }
    return s_instance;
  }
  /**
   * 
   * 
   * 
   * 
   */
  static releaseInstance() {
    if (s_instance != null) {
      s_instance.release();
    }
    s_instance = null;
  }
  /**
   * Initialize the application.
   */
  initialize() {
    {
      this._resizeCanvas();
    }
    if (!frameBuffer) {
      frameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    }
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    const supportTouch = "ontouchend" in canvas;
    if (supportTouch) {
      canvas.addEventListener("touchstart", onTouchBegan, { passive: true });
      canvas.addEventListener("touchmove", onTouchMoved, { passive: true });
      canvas.addEventListener("touchend", onTouchEnded, { passive: true });
      canvas.addEventListener("touchcancel", onTouchCancel, { passive: true });
    } else {
      canvas.addEventListener("mousedown", onClickBegan, { passive: true });
      canvas.addEventListener("mousemove", onMouseMoved, { passive: true });
      canvas.addEventListener("mouseup", onClickEnded, { passive: true });
    }
    this._view.initialize();
    this.initializeCubism();
    return true;
  }
  /**
   * Resize canvas and re-initialize view.
   */
  onResize() {
    this._resizeCanvas();
    if (this._view && canvas) {
      this._view.initialize();
      this._view.initializeSprite();
      const manager = LAppLive2DManager.getInstance();
      if (manager) {
        const model = manager.getModel(0);
        if (model) {
          const width = canvas.width;
          const height = canvas.height;
          if (width > 0 && height > 0) {
            if (model.setPosition) {
              model.setPosition(width / 2, height / 2);
            }
          }
        }
      }
    }
  }
  /**
   * 
   */
  release() {
    this._textureManager.release();
    this._textureManager = null;
    this._view.release();
    this._view = null;
    LAppLive2DManager.releaseInstance();
    CubismFramework.dispose();
  }
  /**
   * 
   * 
   */
  run() {
    const loop = () => {
      if (s_instance == null) {
        return;
      }
      {
        LAppPal.updateTime(false);
        if (LAppPal.getDeltaTime() < 1 / LIMITED_FRAME_RATE) {
          requestAnimationFrame(loop);
          return;
        }
      }
      LAppPal.updateTime(true);
      gl.clearColor(0, 0, 0, 1);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      gl.clearDepth(1);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      this._view.render();
      requestAnimationFrame(loop);
    };
    loop();
  }
  /**
   * 
   * 
   */
  createShader() {
    const vertexShaderId = gl.createShader(gl.VERTEX_SHADER);
    if (vertexShaderId == null) {
      LAppPal.printMessage("failed to create vertexShader");
      return null;
    }
    const vertexShader = "precision mediump float;attribute vec3 position;attribute vec2 uv;varying vec2 vuv;void main(void){   gl_Position = vec4(position, 1.0);   vuv = uv;}";
    gl.shaderSource(vertexShaderId, vertexShader);
    gl.compileShader(vertexShaderId);
    const fragmentShaderId = gl.createShader(gl.FRAGMENT_SHADER);
    if (fragmentShaderId == null) {
      LAppPal.printMessage("failed to create fragmentShader");
      return null;
    }
    const fragmentShader = "precision mediump float;varying vec2 vuv;uniform sampler2D texture;void main(void){   gl_FragColor = texture2D(texture, vuv);}";
    gl.shaderSource(fragmentShaderId, fragmentShader);
    gl.compileShader(fragmentShaderId);
    const programId = gl.createProgram();
    gl.attachShader(programId, vertexShaderId);
    gl.attachShader(programId, fragmentShaderId);
    gl.deleteShader(vertexShaderId);
    gl.deleteShader(fragmentShaderId);
    gl.linkProgram(programId);
    gl.useProgram(programId);
    return programId;
  }
  /**
   * View
   */
  getView() {
    return this._view;
  }
  getTextureManager() {
    return this._textureManager;
  }
  /**
   * 
   * 
   */
  constructor() {
    this._captured = false;
    this._mouseX = 0;
    this._mouseY = 0;
    this._isEnd = false;
    this._cubismOption = new Option();
    this._view = new LAppView();
    this._textureManager = new LAppTextureManager();
  }
  /**
   * Cubism SDK
   */
  initializeCubism() {
    this._cubismOption.logFunction = LAppPal.printMessage;
    this._cubismOption.loggingLevel = CubismLoggingLevel;
    CubismFramework.startUp(this._cubismOption);
    CubismFramework.initialize();
    LAppLive2DManager.getInstance();
    LAppPal.updateTime();
    this._view.initializeSprite();
  }
  /**
   * Resize the canvas to fill the screen.
   */
  _resizeCanvas() {
    if (!canvas) {
      console.warn("Canvas is null, skipping resize");
      return;
    }
    canvas.width = canvas.clientWidth * window.devicePixelRatio;
    canvas.height = canvas.clientHeight * window.devicePixelRatio;
    if (gl) {
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
  }
  _cubismOption;
  // Cubism SDK Option
  _view;
  // View  // 
  _captured;
  //  // 
  _mouseX;
  // X // X
  _mouseY;
  // Y // Y
  _isEnd;
  // APP // APP
  _textureManager;
  //  // 
}
function onClickBegan(e2) {
  if (!LAppDelegate.getInstance()._view) {
    LAppPal.printMessage("view notfound");
    return;
  }
  LAppDelegate.getInstance()._captured = true;
  const posX = e2.pageX;
  const posY = e2.pageY;
  LAppDelegate.getInstance()._view.onTouchesBegan(posX, posY);
}
function onMouseMoved(e2) {
  if (!LAppDelegate.getInstance()._captured) {
    return;
  }
  if (!LAppDelegate.getInstance()._view) {
    LAppPal.printMessage("view notfound");
    return;
  }
  const rect = e2.target.getBoundingClientRect();
  const posX = e2.clientX - rect.left;
  const posY = e2.clientY - rect.top;
  LAppDelegate.getInstance()._view.onTouchesMoved(posX, posY);
}
function onClickEnded(e2) {
  LAppDelegate.getInstance()._captured = false;
  if (!LAppDelegate.getInstance()._view) {
    LAppPal.printMessage("view notfound");
    return;
  }
  const rect = e2.target.getBoundingClientRect();
  const posX = e2.clientX - rect.left;
  const posY = e2.clientY - rect.top;
  LAppDelegate.getInstance()._view.onTouchesEnded(posX, posY);
}
function onTouchBegan(e2) {
  if (!LAppDelegate.getInstance()._view) {
    LAppPal.printMessage("view notfound");
    return;
  }
  LAppDelegate.getInstance()._captured = true;
  const posX = e2.changedTouches[0].pageX;
  const posY = e2.changedTouches[0].pageY;
  LAppDelegate.getInstance()._view.onTouchesBegan(posX, posY);
}
function onTouchMoved(e2) {
  if (!LAppDelegate.getInstance()._captured) {
    return;
  }
  if (!LAppDelegate.getInstance()._view) {
    LAppPal.printMessage("view notfound");
    return;
  }
  const rect = e2.target.getBoundingClientRect();
  const posX = e2.changedTouches[0].clientX - rect.left;
  const posY = e2.changedTouches[0].clientY - rect.top;
  LAppDelegate.getInstance()._view.onTouchesMoved(posX, posY);
}
function onTouchEnded(e2) {
  LAppDelegate.getInstance()._captured = false;
  if (!LAppDelegate.getInstance()._view) {
    LAppPal.printMessage("view notfound");
    return;
  }
  const rect = e2.target.getBoundingClientRect();
  const posX = e2.changedTouches[0].clientX - rect.left;
  const posY = e2.changedTouches[0].clientY - rect.top;
  LAppDelegate.getInstance()._view.onTouchesEnded(posX, posY);
}
function onTouchCancel(e2) {
  LAppDelegate.getInstance()._captured = false;
  if (!LAppDelegate.getInstance()._view) {
    LAppPal.printMessage("view notfound");
    return;
  }
  const rect = e2.target.getBoundingClientRect();
  const posX = e2.changedTouches[0].clientX - rect.left;
  const posY = e2.changedTouches[0].clientY - rect.top;
  LAppDelegate.getInstance()._view.onTouchesEnded(posX, posY);
}
function initializeLive2D() {
  console.log(
    "Initializing Live2D with resourcePath:",
    ResourcesPath
  );
  console.log("Model directories:", ModelDir);
  if (LAppDelegate.getInstance()) {
    LAppLive2DManager.releaseInstance();
  }
  if (!LAppGlManager.getInstance() || !LAppDelegate.getInstance().initialize()) {
    console.error("Failed to initialize Live2D");
    return;
  }
  LAppDelegate.getInstance().run();
  window.getLive2DManager = () => LAppLive2DManager.getInstance();
  if (!window.getLAppAdapter) {
    console.log("Setting up getLAppAdapter function");
    const { LAppAdapter: LAppAdapter2 } = require("./lappadapter");
    window.getLAppAdapter = () => LAppAdapter2.getInstance();
  }
  if (window.api?.setIgnoreMouseEvent) {
    const parent = document.getElementById("live2d");
    parent?.addEventListener("pointermove", (e2) => {
      const model = LAppLive2DManager.getInstance().getModel(0);
      const view = LAppDelegate.getInstance().getView();
      const x2 = view?._deviceToScreen.transformX(e2.x);
      const y2 = view?._deviceToScreen.transformY(e2.y);
      window.api.setIgnoreMouseEvent(!model?.anyhitTest(x2, y2) && !model?.isHitOnModel(x2, y2));
    });
    parent?.addEventListener("pointerdown", (e2) => {
      const model = LAppLive2DManager.getInstance().getModel(0);
      const view = LAppDelegate.getInstance().getView();
      const x2 = view?._deviceToScreen.transformX(e2.x);
      const y2 = view?._deviceToScreen.transformY(e2.y);
      const hitAreaName = model?.anyhitTest(x2, y2);
      const isHit = hitAreaName !== null || model?.isHitOnModel(x2, y2);
      console.log("Model clicked:", isHit, hitAreaName ? `in area: ${hitAreaName}` : "");
    });
  }
}
window.addEventListener(
  "beforeunload",
  () => LAppDelegate.releaseInstance(),
  { passive: true }
);
window.addEventListener(
  "resize",
  () => {
    {
      LAppDelegate.getInstance().onResize();
    }
  },
  { passive: true }
);
window.initializeLive2D = initializeLive2D;
const TAP_DURATION_THRESHOLD_MS = 200;
const DRAG_DISTANCE_THRESHOLD_PX = 5;
function parseModelUrl(url) {
  try {
    const baseOrigin = typeof window !== "undefined" ? window.location.origin : FALLBACK_BASE_URL;
    const urlObj = new URL(url, baseOrigin);
    const { pathname } = urlObj;
    const lastSlashIndex = pathname.lastIndexOf("/");
    if (lastSlashIndex === -1) {
      throw new Error("Invalid model URL format");
    }
    const fullFileName = pathname.substring(lastSlashIndex + 1);
    const modelFileName = fullFileName.replace(".model3.json", "");
    const secondLastSlashIndex = pathname.lastIndexOf("/", lastSlashIndex - 1);
    if (secondLastSlashIndex === -1) {
      throw new Error("Invalid model URL format");
    }
    const modelDir = pathname.substring(secondLastSlashIndex + 1, lastSlashIndex);
    const baseUrl = `${urlObj.protocol}//${urlObj.host}${pathname.substring(0, secondLastSlashIndex + 1)}`;
    return { baseUrl, modelDir, modelFileName };
  } catch (error2) {
    console.error("Error parsing model URL:", error2);
    return { baseUrl: "", modelDir: "", modelFileName: "" };
  }
}
const useLive2DModel = ({
  modelInfo,
  canvasRef
}) => {
  const { mode } = useMode();
  const isPet = mode === "pet";
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const [position2, setPosition] = reactExports.useState({ x: 0, y: 0 });
  const dragStartPos = reactExports.useRef({ x: 0, y: 0 });
  const modelStartPos = reactExports.useRef({ x: 0, y: 0 });
  const modelPositionRef = reactExports.useRef({ x: 0, y: 0 });
  const prevModelUrlRef = reactExports.useRef(null);
  const isHoveringModelRef = reactExports.useRef(false);
  const electronApi = window.electron;
  const mouseDownTimeRef = reactExports.useRef(0);
  const mouseDownPosRef = reactExports.useRef({ x: 0, y: 0 });
  const isPotentialTapRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const currentUrl = modelInfo?.url;
    const sdkScale = window.LAppDefine?.CurrentKScale;
    const modelScale = modelInfo?.kScale !== void 0 ? Number(modelInfo.kScale) : void 0;
    const needsUpdate = currentUrl && (currentUrl !== prevModelUrlRef.current || sdkScale !== void 0 && modelScale !== void 0 && sdkScale !== modelScale);
    if (needsUpdate) {
      prevModelUrlRef.current = currentUrl;
      try {
        const { baseUrl, modelDir, modelFileName } = parseModelUrl(currentUrl);
        if (baseUrl && modelDir) {
          updateModelConfig(baseUrl, modelDir, modelFileName, Number(modelInfo.kScale));
          setTimeout(() => {
            if (window.LAppLive2DManager?.releaseInstance) {
              window.LAppLive2DManager.releaseInstance();
            }
            initializeLive2D();
          }, 500);
        }
      } catch (error2) {
        console.error("Error processing model URL:", error2);
      }
    }
  }, [modelInfo?.url, modelInfo?.kScale]);
  const getModelPosition = reactExports.useCallback(() => {
    const adapter = window.getLAppAdapter?.();
    if (adapter) {
      const model = adapter.getModel();
      if (model && model._modelMatrix) {
        const matrix = model._modelMatrix.getArray();
        return {
          x: matrix[12],
          y: matrix[13]
        };
      }
    }
    return { x: 0, y: 0 };
  }, []);
  reactExports.useCallback((x2, y2) => {
    const adapter = window.getLAppAdapter?.();
    if (adapter) {
      const model = adapter.getModel();
      if (model && model._modelMatrix) {
        const matrix = model._modelMatrix.getArray();
        const newMatrix = [...matrix];
        newMatrix[12] = x2;
        newMatrix[13] = y2;
        model._modelMatrix.setMatrix(newMatrix);
        modelPositionRef.current = { x: x2, y: y2 };
      }
    }
  }, []);
  reactExports.useEffect(() => {
    const timer = setTimeout(() => {
      const currentPos = getModelPosition();
      modelPositionRef.current = currentPos;
      setPosition(currentPos);
    }, 500);
    return () => clearTimeout(timer);
  }, [modelInfo?.url, getModelPosition]);
  const getCanvasScale = reactExports.useCallback(() => {
    const canvas2 = document.getElementById("canvas");
    if (!canvas2) return { width: 1, height: 1, scale: 1 };
    const { width } = canvas2;
    const { height } = canvas2;
    const scale = width / canvas2.clientWidth;
    return { width, height, scale };
  }, []);
  reactExports.useCallback((screenX, screenY) => {
    const { width, height, scale } = getCanvasScale();
    const x2 = screenX * scale / width * 2 - 1;
    const y2 = -(screenY * scale / height) * 2 + 1;
    return { x: x2, y: y2 };
  }, [getCanvasScale]);
  const handleMouseDown = reactExports.useCallback((e2) => {
    const adapter = window.getLAppAdapter?.();
    if (!adapter || !canvasRef.current) return;
    const model = adapter.getModel();
    const view = LAppDelegate.getInstance().getView();
    if (!view || !model) return;
    const canvas2 = canvasRef.current;
    const rect = canvas2.getBoundingClientRect();
    const x2 = e2.clientX - rect.left;
    const y2 = e2.clientY - rect.top;
    const scale = canvas2.width / canvas2.clientWidth;
    const scaledX = x2 * scale;
    const scaledY = y2 * scale;
    const modelX = view._deviceToScreen.transformX(scaledX);
    const modelY = view._deviceToScreen.transformY(scaledY);
    const hitAreaName = model.anyhitTest(modelX, modelY);
    const isHitOnModel = model.isHitOnModel(modelX, modelY);
    if (hitAreaName !== null || isHitOnModel) {
      mouseDownTimeRef.current = Date.now();
      mouseDownPosRef.current = { x: e2.clientX, y: e2.clientY };
      isPotentialTapRef.current = true;
      setIsDragging(false);
      if (model._modelMatrix) {
        const matrix = model._modelMatrix.getArray();
        modelStartPos.current = { x: matrix[12], y: matrix[13] };
      }
    }
  }, [canvasRef, modelInfo]);
  const handleMouseMove = reactExports.useCallback((e2) => {
    const adapter = window.getLAppAdapter?.();
    const view = LAppDelegate.getInstance().getView();
    const model = adapter?.getModel();
    if (isPotentialTapRef.current && adapter && view && model && canvasRef.current) {
      const timeElapsed = Date.now() - mouseDownTimeRef.current;
      const deltaX = e2.clientX - mouseDownPosRef.current.x;
      const deltaY = e2.clientY - mouseDownPosRef.current.y;
      const distanceMoved = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (distanceMoved > DRAG_DISTANCE_THRESHOLD_PX || timeElapsed > TAP_DURATION_THRESHOLD_MS && distanceMoved > 1) {
        isPotentialTapRef.current = false;
        setIsDragging(true);
        const canvas2 = canvasRef.current;
        const rect = canvas2.getBoundingClientRect();
        dragStartPos.current = {
          x: mouseDownPosRef.current.x - rect.left,
          y: mouseDownPosRef.current.y - rect.top
        };
      }
    }
    if (isDragging && adapter && view && model && canvasRef.current) {
      const canvas2 = canvasRef.current;
      const rect = canvas2.getBoundingClientRect();
      const currentX = e2.clientX - rect.left;
      const currentY = e2.clientY - rect.top;
      const scale = canvas2.width / canvas2.clientWidth;
      const startScaledX = dragStartPos.current.x * scale;
      const startScaledY = dragStartPos.current.y * scale;
      const startModelX = view._deviceToScreen.transformX(startScaledX);
      const startModelY = view._deviceToScreen.transformY(startScaledY);
      const currentScaledX = currentX * scale;
      const currentScaledY = currentY * scale;
      const currentModelX = view._deviceToScreen.transformX(currentScaledX);
      const currentModelY = view._deviceToScreen.transformY(currentScaledY);
      const dx = currentModelX - startModelX;
      const dy = currentModelY - startModelY;
      const newX = modelStartPos.current.x + dx;
      const newY = modelStartPos.current.y + dy;
      if (adapter.setModelPosition) {
        adapter.setModelPosition(newX, newY);
      } else if (model._modelMatrix) {
        const matrix = model._modelMatrix.getArray();
        const newMatrix = [...matrix];
        newMatrix[12] = newX;
        newMatrix[13] = newY;
        model._modelMatrix.setMatrix(newMatrix);
      }
      modelPositionRef.current = { x: newX, y: newY };
      setPosition({ x: newX, y: newY });
    }
    if (isPet && !isDragging && !isPotentialTapRef.current && electronApi && adapter && view && model && canvasRef.current) {
      const canvas2 = canvasRef.current;
      const rect = canvas2.getBoundingClientRect();
      const x2 = e2.clientX - rect.left;
      const y2 = e2.clientY - rect.top;
      const scale = canvas2.width / canvas2.clientWidth;
      const scaledX = x2 * scale;
      const scaledY = y2 * scale;
      const modelX = view._deviceToScreen.transformX(scaledX);
      const modelY = view._deviceToScreen.transformY(scaledY);
      const currentHitState = model.anyhitTest(modelX, modelY) !== null || model.isHitOnModel(modelX, modelY);
      if (currentHitState !== isHoveringModelRef.current) {
        isHoveringModelRef.current = currentHitState;
        electronApi.ipcRenderer.send("update-component-hover", "live2d-model", currentHitState);
      }
    }
  }, [isPet, isDragging, electronApi, canvasRef]);
  const handleMouseUp = reactExports.useCallback((e2) => {
    const adapter = window.getLAppAdapter?.();
    const model = adapter?.getModel();
    const view = LAppDelegate.getInstance().getView();
    if (isDragging) {
      setIsDragging(false);
      if (adapter) {
        const currentModel = adapter.getModel();
        if (currentModel && currentModel._modelMatrix) {
          const matrix = currentModel._modelMatrix.getArray();
          const finalPos = { x: matrix[12], y: matrix[13] };
          modelPositionRef.current = finalPos;
          modelStartPos.current = finalPos;
          setPosition(finalPos);
        }
      }
    } else if (isPotentialTapRef.current && adapter && model && view && canvasRef.current) {
      const timeElapsed = Date.now() - mouseDownTimeRef.current;
      const deltaX = e2.clientX - mouseDownPosRef.current.x;
      const deltaY = e2.clientY - mouseDownPosRef.current.y;
      const distanceMoved = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (timeElapsed < TAP_DURATION_THRESHOLD_MS && distanceMoved < DRAG_DISTANCE_THRESHOLD_PX) {
        const allowTapMotion = modelInfo?.pointerInteractive !== false;
        if (allowTapMotion && modelInfo?.tapMotions) {
          const canvas2 = canvasRef.current;
          const rect = canvas2.getBoundingClientRect();
          const scale = canvas2.width / canvas2.clientWidth;
          const downX = (mouseDownPosRef.current.x - rect.left) * scale;
          const downY = (mouseDownPosRef.current.y - rect.top) * scale;
          const modelX = view._deviceToScreen.transformX(downX);
          const modelY = view._deviceToScreen.transformY(downY);
          const hitAreaName = model.anyhitTest(modelX, modelY);
          model.startTapMotion(hitAreaName, modelInfo.tapMotions);
        }
      }
    }
    isPotentialTapRef.current = false;
  }, [isDragging, canvasRef, modelInfo]);
  const handleMouseLeave = reactExports.useCallback(() => {
    if (isDragging) {
      handleMouseUp({});
    }
    if (isPotentialTapRef.current) {
      isPotentialTapRef.current = false;
    }
    if (isPet && electronApi && isHoveringModelRef.current) {
      isHoveringModelRef.current = false;
      electronApi.ipcRenderer.send("update-component-hover", "live2d-model", false);
    }
  }, [isPet, isDragging, electronApi, handleMouseUp]);
  reactExports.useEffect(() => {
    if (!isPet && electronApi && isHoveringModelRef.current) {
      isHoveringModelRef.current = false;
    }
  }, [isPet, electronApi]);
  reactExports.useEffect(() => {
    const playMotion = (motionGroup, motionIndex = 0, priority = 3) => {
      const adapter = window.getLAppAdapter?.();
      if (!adapter) {
        console.error("Live2D adapter not available");
        return false;
      }
      const model = adapter.getModel();
      if (!model) {
        console.error("Live2D model not available");
        return false;
      }
      try {
        console.log(`Playing motion: group="${motionGroup}", index=${motionIndex}, priority=${priority}`);
        const result = model.startMotion(motionGroup, motionIndex, priority);
        console.log("Motion start result:", result);
        return result;
      } catch (error2) {
        console.error("Error playing motion:", error2);
        return false;
      }
    };
    const playRandomMotion = (motionGroup, priority = 3) => {
      const adapter = window.getLAppAdapter?.();
      if (!adapter) {
        console.error("Live2D adapter not available");
        return false;
      }
      const model = adapter.getModel();
      if (!model) {
        console.error("Live2D model not available");
        return false;
      }
      try {
        console.log(`Playing random motion from group: "${motionGroup}", priority=${priority}`);
        const result = model.startRandomMotion(motionGroup, priority);
        console.log("Random motion start result:", result);
        return result;
      } catch (error2) {
        console.error("Error playing random motion:", error2);
        return false;
      }
    };
    const getMotionInfo = () => {
      const adapter = window.getLAppAdapter?.();
      if (!adapter) {
        console.error("Live2D adapter not available");
        return null;
      }
      const model = adapter.getModel();
      if (!model) {
        console.error("Live2D model not available");
        return null;
      }
      try {
        const motionGroups = [];
        const setting = model._modelSetting;
        if (setting) {
          const groups = setting._json?.FileReferences?.Motions;
          if (groups) {
            for (const groupName in groups) {
              const motions = groups[groupName];
              motionGroups.push({
                name: groupName,
                count: motions.length,
                motions: motions.map((motion, index) => ({
                  index,
                  file: motion.File
                }))
              });
            }
          }
        }
        console.log("Available motion groups:", motionGroups);
        return motionGroups;
      } catch (error2) {
        console.error("Error getting motion info:", error2);
        return null;
      }
    };
    window.Live2DDebug = {
      playMotion,
      playRandomMotion,
      getMotionInfo,
      // Helper functions
      help: () => {
        console.log(`
Live2D Motion Debug Functions:
- Live2DDebug.getMotionInfo() - Get all available motion groups and their motions
- Live2DDebug.playMotion(group, index, priority) - Play specific motion
- Live2DDebug.playRandomMotion(group, priority) - Play random motion from group  
- Live2DDebug.help() - Show this help

Example usage:
Live2DDebug.getMotionInfo()  // See available motions
Live2DDebug.playMotion("", 0)  // Play first motion from default group
Live2DDebug.playRandomMotion("")  // Play random motion from default group
        `);
      }
    };
    console.log("Live2D Debug functions exposed to window.Live2DDebug");
    console.log("Type Live2DDebug.help() for usage information");
    return () => {
      delete window.Live2DDebug;
    };
  }, []);
  return {
    position: position2,
    isDragging,
    handlers: {
      onMouseDown: handleMouseDown,
      onMouseMove: handleMouseMove,
      onMouseUp: handleMouseUp,
      onMouseLeave: handleMouseLeave
    }
  };
};
const MIN_SCALE = 0.1;
const MAX_SCALE = 5;
const EASING_FACTOR = 0.3;
const WHEEL_SCALE_STEP = 0.03;
const DEFAULT_SCALE = 1;
const applyScale = (scale) => {
  try {
    const manager = LAppLive2DManager.getInstance();
    if (!manager) return;
    const model = manager.getModel(0);
    if (!model) return;
    model._modelMatrix.scale(scale, scale);
  } catch (error2) {
    console.debug("Model not ready for scaling yet");
  }
};
const useLive2DResize = ({
  containerRef,
  modelInfo,
  showSidebar
}) => {
  const { mode } = useMode();
  const isPet = mode === "pet";
  const animationFrameIdRef = reactExports.useRef(null);
  const canvasRef = reactExports.useRef(null);
  const isResizingRef = reactExports.useRef(false);
  const initialScale = modelInfo?.kScale || DEFAULT_SCALE;
  const lastScaleRef = reactExports.useRef(initialScale);
  const targetScaleRef = reactExports.useRef(initialScale);
  const animationFrameRef = reactExports.useRef();
  const isAnimatingRef = reactExports.useRef(false);
  const hasAppliedInitialScale = reactExports.useRef(false);
  const lastContainerDimensionsRef = reactExports.useRef({ width: 0, height: 0 });
  const prevSidebarStateRef = reactExports.useRef(showSidebar);
  reactExports.useEffect(() => {
    const newInitialScale = modelInfo?.kScale || DEFAULT_SCALE;
    lastScaleRef.current = newInitialScale;
    targetScaleRef.current = newInitialScale;
    hasAppliedInitialScale.current = false;
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      isAnimatingRef.current = false;
    }
    const resizeHandle = requestAnimationFrame(() => {
      handleResize();
    });
    return () => cancelAnimationFrame(resizeHandle);
  }, [modelInfo?.url, modelInfo?.kScale]);
  const animateEase = reactExports.useCallback(() => {
    const clampedTargetScale = Math.max(
      MIN_SCALE,
      Math.min(MAX_SCALE, targetScaleRef.current)
    );
    const currentScale = lastScaleRef.current;
    const diff = clampedTargetScale - currentScale;
    const newScale = currentScale + diff * EASING_FACTOR;
    applyScale(newScale);
    lastScaleRef.current = newScale;
    animationFrameRef.current = requestAnimationFrame(animateEase);
  }, []);
  const handleWheel = reactExports.useCallback((e2) => {
    e2.preventDefault();
    if (!modelInfo?.scrollToResize) return;
    const direction = e2.deltaY > 0 ? -1 : 1;
    const increment = WHEEL_SCALE_STEP * direction;
    const currentActualScale = lastScaleRef.current;
    const newTargetScale = Math.max(
      MIN_SCALE,
      Math.min(MAX_SCALE, currentActualScale + increment)
    );
    targetScaleRef.current = newTargetScale;
    if (!isAnimatingRef.current) {
      isAnimatingRef.current = true;
      animationFrameRef.current = requestAnimationFrame(animateEase);
    }
  }, [modelInfo?.scrollToResize, animateEase]);
  const beforeResize = reactExports.useCallback(() => {
    const canvas2 = canvasRef.current;
    if (!canvas2) return;
    isResizingRef.current = true;
    if (animationFrameIdRef.current !== null) {
      cancelAnimationFrame(animationFrameIdRef.current);
      animationFrameIdRef.current = null;
    }
  }, []);
  const handleResize = reactExports.useCallback(() => {
    const canvas2 = canvasRef.current;
    if (!canvas2) {
      return;
    }
    if (!isResizingRef.current) {
      beforeResize();
    }
    try {
      const containerBounds = containerRef.current?.getBoundingClientRect();
      const { width, height } = isPet ? { width: window.innerWidth, height: window.innerHeight } : containerBounds || { width: 0, height: 0 };
      const lastDimensions = lastContainerDimensionsRef.current;
      const sidebarChanged = prevSidebarStateRef.current !== showSidebar;
      const dimensionsChanged = Math.abs(lastDimensions.width - width) > 1 || Math.abs(lastDimensions.height - height) > 1;
      const hasChanged = dimensionsChanged || sidebarChanged;
      if (!hasChanged && hasAppliedInitialScale.current) {
        isResizingRef.current = false;
        return;
      }
      lastContainerDimensionsRef.current = { width, height };
      prevSidebarStateRef.current = showSidebar;
      if (!containerBounds && !isPet) {
        console.warn("[Resize] Container bounds not available in window mode.");
      }
      if (width === 0 || height === 0) {
        console.warn("[Resize] Width or Height is zero, skipping canvas/delegate update.");
        isResizingRef.current = false;
        return;
      }
      const dpr = window.devicePixelRatio || 1;
      canvas2.width = Math.round(width * dpr);
      canvas2.height = Math.round(height * dpr);
      canvas2.style.width = `${width}px`;
      canvas2.style.height = `${height}px`;
      const delegate = LAppDelegate.getInstance();
      if (delegate) {
        delegate.onResize();
      } else {
        console.warn("[Resize] LAppDelegate instance not found.");
      }
      isResizingRef.current = false;
    } catch (error2) {
      isResizingRef.current = false;
    }
  }, [isPet, containerRef, modelInfo?.kScale, modelInfo?.initialXshift, modelInfo?.initialYshift, showSidebar, beforeResize, canvasRef]);
  reactExports.useEffect(() => {
    if (prevSidebarStateRef.current !== showSidebar) {
      if (animationFrameIdRef.current !== null) {
        cancelAnimationFrame(animationFrameIdRef.current);
      }
      animationFrameIdRef.current = requestAnimationFrame(() => {
        handleResize();
        animationFrameIdRef.current = null;
      });
    }
  }, [showSidebar, handleResize]);
  reactExports.useEffect(() => {
    const canvasElement = canvasRef.current;
    if (canvasElement) {
      canvasElement.addEventListener("wheel", handleWheel, { passive: false });
      return () => {
        canvasElement.removeEventListener("wheel", handleWheel);
      };
    }
    return void 0;
  }, [handleWheel, canvasRef]);
  reactExports.useEffect(() => () => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = void 0;
    }
    if (animationFrameIdRef.current !== null) {
      cancelAnimationFrame(animationFrameIdRef.current);
      animationFrameIdRef.current = null;
    }
  }, []);
  reactExports.useEffect(() => {
    const containerElement = containerRef.current;
    if (!containerElement) {
      return void 0;
    }
    if (animationFrameIdRef.current !== null) cancelAnimationFrame(animationFrameIdRef.current);
    animationFrameIdRef.current = requestAnimationFrame(() => {
      handleResize();
      animationFrameIdRef.current = null;
    });
    const observer = new ResizeObserver(() => {
      if (!isResizingRef.current) {
        if (animationFrameIdRef.current !== null) cancelAnimationFrame(animationFrameIdRef.current);
        animationFrameIdRef.current = requestAnimationFrame(() => {
          handleResize();
          animationFrameIdRef.current = null;
        });
      }
    });
    observer.observe(containerElement);
    return () => {
      if (animationFrameIdRef.current !== null) {
        cancelAnimationFrame(animationFrameIdRef.current);
        animationFrameIdRef.current = null;
      }
      observer.disconnect();
    };
  }, [containerRef, handleResize]);
  reactExports.useEffect(() => {
    const handleWindowResize = () => {
      if (!isResizingRef.current) {
        if (animationFrameIdRef.current !== null) cancelAnimationFrame(animationFrameIdRef.current);
        animationFrameIdRef.current = requestAnimationFrame(() => {
          handleResize();
          animationFrameIdRef.current = null;
        });
      }
    };
    window.addEventListener("resize", handleWindowResize);
    return () => {
      window.removeEventListener("resize", handleWindowResize);
      if (animationFrameIdRef.current !== null) {
        cancelAnimationFrame(animationFrameIdRef.current);
        animationFrameIdRef.current = null;
      }
    };
  }, [handleResize]);
  return { canvasRef, handleResize };
};
const Live2D = reactExports.memo(
  ({ showSidebar }) => {
    const { forceIgnoreMouse } = useForceIgnoreMouse();
    const { modelInfo } = useLive2DConfig();
    const { mode } = useMode();
    const internalContainerRef = reactExports.useRef(null);
    const { aiState: aiState2 } = useAiState();
    const { resetExpression } = useLive2DExpression();
    const isPet = mode === "pet";
    const { canvasRef } = useLive2DResize({
      containerRef: internalContainerRef,
      modelInfo,
      showSidebar
    });
    const { isDragging, handlers: handlers2 } = useLive2DModel({
      modelInfo,
      canvasRef
    });
    useIpcHandlers();
    useInterrupt();
    useAudioTask();
    reactExports.useEffect(() => {
      if (aiState2 === AiStateEnum.IDLE) {
        const lappAdapter = window.getLAppAdapter?.();
        if (lappAdapter) {
          resetExpression(lappAdapter, modelInfo);
        }
      }
    }, [aiState2, modelInfo, resetExpression]);
    const handlePointerDown = (e2) => {
      handlers2.onMouseDown(e2);
    };
    const handleContextMenu = (e2) => {
      if (!isPet) {
        return;
      }
      e2.preventDefault();
      console.log(
        "[ContextMenu] (Pet Mode) Right-click detected, requesting menu..."
      );
      window.api?.showContextMenu?.();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: internalContainerRef,
        id: "live2d-internal-wrapper",
        style: {
          width: "100%",
          height: "100%",
          pointerEvents: isPet && forceIgnoreMouse ? "none" : "auto",
          overflow: "hidden",
          position: "relative",
          cursor: isDragging ? "grabbing" : "default"
        },
        onPointerDown: handlePointerDown,
        onContextMenu: handleContextMenu,
        ...handlers2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "canvas",
          {
            id: "canvas",
            ref: canvasRef,
            style: {
              width: "100%",
              height: "100%",
              pointerEvents: isPet && forceIgnoreMouse ? "none" : "auto",
              display: "block",
              cursor: isDragging ? "grabbing" : "default"
            }
          }
        )
      }
    );
  }
);
Live2D.displayName = "Live2D";
function useSwitchCharacter() {
  const { sendMessage } = useWebSocket();
  const { confName, getFilenameByName } = useConfig();
  const { interrupt } = useInterrupt();
  const { stopMic } = useVAD();
  const { setSubtitleText } = useSubtitle();
  const { setAiState } = useAiState();
  const { setModelInfo } = useLive2DConfig();
  const switchCharacter = reactExports.useCallback((fileName) => {
    const currentFilename = getFilenameByName(confName);
    if (currentFilename === fileName) {
      console.log("Skipping character switch - same configuration file");
      return;
    }
    setSubtitleText("New Character Loading...");
    interrupt();
    stopMic();
    setAiState("loading");
    setModelInfo(void 0);
    sendMessage({
      type: "switch-config",
      file: fileName
    });
    console.log("Switch Character fileName: ", fileName);
  }, [confName, getFilenameByName, sendMessage, interrupt, stopMic, setSubtitleText, setAiState]);
  return { switchCharacter };
}
const isString = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve2, reject2) => {
    res = resolve2;
    rej = reject2;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a, s, t2) => {
  a.forEach((m2) => {
    if (s[m2]) t2[m2] = s[m2];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString(object);
const getLastOfPath = (object, path2, Empty) => {
  const stack = !isString(path2) ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path2, newValue) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k2] = newValue;
    return;
  }
  let e2 = path2[path2.length - 1];
  let p2 = path2.slice(0, path2.length - 1);
  let last2 = getLastOfPath(object, p2, Object);
  while (last2.obj === void 0 && p2.length) {
    e2 = `${p2[p2.length - 1]}.${e2}`;
    p2 = p2.slice(0, p2.length - 1);
    last2 = getLastOfPath(object, p2, Object);
    if (last2?.obj && typeof last2.obj[`${last2.k}.${e2}`] !== "undefined") {
      last2.obj = void 0;
    }
  }
  last2.obj[`${last2.k}.${e2}`] = newValue;
};
const pushPath = (object, path2, newValue, concat) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2, Object);
  obj[k2] = obj[k2] || [];
  obj[k2].push(newValue);
};
const getPath = (object, path2) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2);
  if (!obj) return void 0;
  if (!Object.prototype.hasOwnProperty.call(obj, k2)) return void 0;
  return obj[k2];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0) return true;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki2 = key.indexOf(keySeparator);
    if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path2]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path2)) return void 0;
    return obj[path2];
  }
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next2;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next2 = current[nextPath];
      if (next2 !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next2) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next2;
  }
  return current;
};
const getCleanedCode = (code) => code?.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options2);
  }
  init(concreteLogger) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options2.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options2;
    this.debug = options2.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix2, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix2}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName2) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName2}:`
      },
      ...this.options
    });
  }
  clone(options2) {
    options2 = options2 || this.options;
    options2.prefix = options2.prefix || this.prefix;
    return new Logger(this.logger, options2);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener3) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener3) || 0;
      this.observers[event].set(listener3, numListeners + 1);
    });
    return this;
  }
  off(event, listener3) {
    if (!this.observers[event]) return;
    if (!listener3) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener3);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options2;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key) {
    let options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (isString(key) && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result = getPath(this.data, path2);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value);
    if (!options2.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m2 in resources) {
      if (isString(resources[m2]) || Array.isArray(resources[m2])) this.addResource(lng, ns, m2, resources[m2], {
        silent: true
      });
    }
    if (!options2.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options2.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path2, pack);
    if (!options2.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle(processors, value, key, options2, translator) {
    processors.forEach((processor) => {
      value = this.processors[processor]?.process(value, key, options2, translator) ?? value;
    });
    return value;
  }
};
const checkedLoadedFor = {};
const shouldHandleAsObject = (res) => !isString(res) && typeof res !== "boolean" && typeof res !== "number";
class Translator extends EventEmitter {
  constructor(services) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options2;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key == null) {
      return false;
    }
    const resolved = this.resolve(key, options2);
    return resolved?.res !== void 0;
  }
  extractFromKey(key, opt) {
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    let namespaces = opt.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts2 = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts2[0]) > -1) namespaces = parts2.shift();
      key = parts2.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, opt, lastKey) {
    if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
      opt = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") opt = {
      ...opt
    };
    if (!opt) opt = {};
    if (keys == null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = opt.returnDetails !== void 0 ? opt.returnDetails : this.options.returnDetails;
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], opt);
    const namespace2 = namespaces[namespaces.length - 1];
    const lng = opt.lng || this.language;
    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = opt.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace2}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace2,
            usedParams: this.getUsedParamsDetails(opt)
          };
        }
        return `${namespace2}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace2,
          usedParams: this.getUsedParamsDetails(opt)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, opt);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = opt.joinArrays !== void 0 ? opt.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = opt.count !== void 0 && !isString(opt.count);
    const hasDefaultValue = Translator.hasDefaultValue(opt);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
      ordinal: false
    }) : "";
    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!opt.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...opt,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r2;
          resolved.usedParams = this.getUsedParamsDetails(opt);
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            if (hasDefaultValue && !res) {
              copy2[m2] = this.translate(deepKey, {
                ...opt,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m2] : void 0,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy2[m2] = this.translate(deepKey, {
                ...opt,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy2[m2] === deepKey) copy2[m2] = resForObjHndl[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, opt, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace2, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk2 = this.resolve(key, {
            ...opt,
            keySeparator: false
          });
          if (fk2 && fk2.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
        } else {
          lngs.push(opt.lng || this.language);
        }
        const send = (l2, k2, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace2, k2, defaultForMissing, updateMissing, opt);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace2, k2, defaultForMissing, updateMissing, opt);
          }
          this.emit("missingKey", l2, namespace2, k2, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, opt);
              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, opt, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace2}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace2}:${key}` : key, usedDefault ? res : void 0);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(opt);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, opt, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...opt
      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!opt.skipInterpolation) {
      if (opt.interpolation) this.interpolator.init({
        ...opt,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...opt.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== void 0 ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb2 = res.match(this.interpolator.nestingRegexp);
        nestBef = nb2 && nb2.length;
      }
      let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) opt.nest = false;
      }
      if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;
      if (opt.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey?.[0] === args[0] && !opt.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, opt);
      if (opt.interpolation) this.interpolator.reset();
    }
    const postProcess = opt.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(opt)
        },
        ...opt
      } : opt, this);
    }
    return res;
  }
  resolve(keys) {
    let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k2) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k2, opt);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = opt.count !== void 0 && !isString(opt.count);
      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
      const needsContextHandling = opt.context !== void 0 && (isString(opt.context) || typeof opt.context === "number") && opt.context !== "";
      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${opt.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, opt);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options2);
    return this.resourceStore.getResource(code, ns, key, options2);
  }
  getUsedParamsDetails() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options2.replace && !isString(options2.replace);
    let data = useOptionsReplaceForData ? options2.replace : options2;
    if (useOptionsReplaceForData && typeof options2.count !== "undefined") {
      data.count = options2.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options2) {
    const prefix2 = "defaultValue";
    for (const option in options2) {
      if (Object.prototype.hasOwnProperty.call(options2, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options2[option]) {
        return true;
      }
    }
    return false;
  }
}
class LanguageUtil {
  constructor(options2) {
    this.options = options2;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p2 = code.split("-");
    if (p2.length === 2) return null;
    p2.pop();
    if (p2[p2.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p2.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p2 = code.split("-");
    return this.formatLanguageCode(p2[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e2) {
      }
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngScOnly = this.getScriptPartFromCode(code);
        if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2) return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
      }
    };
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc2) => {
      if (codes.indexOf(fc2) < 0) addCode(this.formatLanguageCode(fc2));
    });
    return codes;
  }
}
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const dummyRule = {
  select: (count) => count === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class PluralResolver {
  constructor(languageUtils) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options2.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options2);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let rule = this.getRule(code, options2);
    if (!rule) rule = this.getRule("dev", options2);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options2).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let rule = this.getRule(code, options2);
    if (!rule) rule = this.getRule("dev", options2);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options2.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count) {
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options2);
    if (rule) {
      return `${this.options.prepend}${options2.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count, options2);
  }
}
const deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && isString(key)) {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = options2?.interpolation?.format || ((value) => value);
    this.init(options2);
  }
  init() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options2.interpolation) options2.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$12,
      escapeValue,
      useRawValueToEscape,
      prefix: prefix2,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options2.interpolation;
    this.escape = escape$12 !== void 0 ? escape$12 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix2 ? regexEscape(prefix2) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options2) {
    let match2;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options2,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p2 = key.split(this.formatSeparator);
      const k2 = p2.shift().trim();
      const f2 = p2.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
        ...options2,
        ...data,
        interpolationkey: k2
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options2?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options2?.interpolation?.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match2 = todo.regex.exec(str)) {
        const matchedVar = match2[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match2, options2);
            value = isString(temp) ? temp : "";
          } else if (options2 && Object.prototype.hasOwnProperty.call(options2, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match2[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match2[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match2[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc2) {
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match2;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c2 = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c2[1]}`;
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match2 = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options2
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
        const r2 = match2[1].split(this.formatSeparator).map((elem) => elem.trim());
        match2[1] = r2.shift();
        formatters = r2;
        doReduce = true;
      }
      value = fc2(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
      if (value && match2[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match2[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v2, f2) => this.format(v2, f2, options2.lng, {
          ...options2,
          interpolationkey: match2[1].trim()
        }), value.trim());
      }
      str = str.replace(match2[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    const optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache2 = {};
  return (val, lng, options2) => {
    let optForCache = options2;
    if (options2 && options2.interpolationkey && options2.formatParams && options2.formatParams[options2.interpolationkey] && options2[options2.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options2.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache2[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options2);
      cache2[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options2;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options2);
  }
  init(services) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options2.interpolation.formatSeparator || ",";
  }
  add(name2, fc2) {
    this.formats[name2.toLowerCase().trim()] = fc2;
  }
  addCached(name2, fc2) {
    this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc2);
  }
  format(value, format, lng) {
    let options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f2) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f2);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options2?.formatParams?.[options2.interpolationkey] || {};
          const l2 = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options2,
            ...valOptions
          });
        } catch (error2) {
          this.logger.warn(error2);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
}
const removePending = (q2, name2) => {
  if (q2.pending[name2] !== void 0) {
    delete q2.pending[name2];
    q2.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store2, services) {
    let options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store2;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options2.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options2.maxRetries >= 0 ? options2.maxRetries : 5;
    this.retryTimeout = options2.retryTimeout >= 1 ? options2.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options2.backend, options2);
  }
  queueLoad(languages, namespaces, options2, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name2 = `${lng}|${ns}`;
        if (!options2.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name2] = 2;
        } else if (this.state[name2] < 0) ;
        else if (this.state[name2] === 1) {
          if (pending[name2] === void 0) pending[name2] = true;
        } else {
          this.state[name2] = 1;
          hasAllNamespaces = false;
          if (pending[name2] === void 0) pending[name2] = true;
          if (toLoad[name2] === void 0) toLoad[name2] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name2, err, data) {
    const s = name2.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name2] = err ? -1 : 2;
    if (err && data) this.state[name2] = 0;
    const loaded2 = {};
    this.queue.forEach((q2) => {
      pushPath(q2.loaded, [lng], ns);
      removePending(q2, name2);
      if (err) q2.errors.push(err);
      if (q2.pendingCount === 0 && !q2.done) {
        Object.keys(q2.loaded).forEach((l2) => {
          if (!loaded2[l2]) loaded2[l2] = {};
          const loadedKeys = q2.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded2[l2][n2] === void 0) loaded2[l2][n2] = true;
            });
          }
        });
        q2.done = true;
        if (q2.errors.length) {
          q2.callback(q2.errors);
        } else {
          q2.callback();
        }
      }
    });
    this.emit("loaded", loaded2);
    this.queue = this.queue.filter((q2) => !q2.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next2 = this.waitingReads.shift();
        this.read(next2.lng, next2.ns, next2.fcName, next2.tried, next2.wait, next2.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc2 = this.backend[fcName].bind(this.backend);
    if (fc2.length === 2) {
      try {
        const r2 = fc2(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r2);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc2(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options2, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name2) => {
      this.loadOne(name2);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name2) {
    let prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name2.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix2}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix2}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name2, err, data);
    });
  }
  saveMissing(languages, namespace2, key, fallbackValue, isUpdate) {
    let options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace2)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace2}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend?.create) {
      const opts = {
        ...options2,
        isUpdate
      };
      const fc2 = this.backend.create.bind(this.backend);
      if (fc2.length < 6) {
        try {
          let r2;
          if (fc2.length === 5) {
            r2 = fc2(languages, namespace2, key, fallbackValue, opts);
          } else {
            r2 = fc2(languages, namespace2, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc2(languages, namespace2, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace2, key, fallbackValue);
  }
}
const get$1 = () => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options2 = args[3] || args[2];
      Object.keys(options2).forEach((key) => {
        ret[key] = options2[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options2) => {
  if (isString(options2.ns)) options2.ns = [options2.ns];
  if (isString(options2.fallbackLng)) options2.fallbackLng = [options2.fallbackLng];
  if (isString(options2.fallbackNS)) options2.fallbackNS = [options2.fallbackNS];
  if (options2.supportedLngs?.indexOf?.("cimode") < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  if (typeof options2.initImmediate === "boolean") options2.initAsync = options2.initImmediate;
  return options2;
};
const noop$2 = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options2);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options2.isClone) {
      if (!this.options.initAsync) {
        this.init(options2, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options2, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    if (options2.defaultNS == null && options2.ns) {
      if (isString(options2.ns)) {
        options2.defaultNS = options2.ns;
      } else if (options2.ns.indexOf("translation") < 0) {
        options2.defaultNS = options2.ns[0];
      }
    }
    const defOpts = get$1();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options2)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options2.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options2.keySeparator;
    }
    if (options2.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options2.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init) m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop$2;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$2;
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append2 = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l2) => {
          if (l2 === "cimode") return;
          if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append2(l2));
      } else {
        append2(usedLng);
      }
      this.options.preload?.forEach?.((l2) => append2(l2));
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop$2;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module2) {
    if (!module2) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module2.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module2.type === "backend") {
      this.modules.backend = module2;
    }
    if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
      this.modules.logger = module2;
    }
    if (module2.type === "languageDetector") {
      this.modules.languageDetector = module2;
    }
    if (module2.type === "i18nFormat") {
      this.modules.i18nFormat = module2;
    }
    if (module2.type === "postProcessor") {
      postProcessor.addPostProcessor(module2);
    }
    if (module2.type === "formatter") {
      this.modules.formatter = module2;
    }
    if (module2.type === "3rdParty") {
      this.modules.external.push(module2);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages) return;
    if (["cimode", "dev"].indexOf(l2) > -1) return;
    for (let li2 = 0; li2 < this.languages.length; li2++) {
      const lngInLngs = this.languages[li2];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
    if (!this.resolvedLanguage && this.languages.indexOf(l2) < 0 && this.store.hasLanguageSomeTranslations(l2)) {
      this.resolvedLanguage = l2;
      if (this.languages.indexOf(l2) < 0) this.languages.unshift(l2);
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done = (err, l2) => {
      if (l2) {
        if (this.isLanguageChangingTo === lng) {
          setLngProps(l2);
          this.translator.changeLanguage(l2);
          this.isLanguageChangingTo = void 0;
          this.emit("languageChanged", l2);
          this.logger.log("languageChanged", l2);
        }
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const fl2 = isString(lngs) ? lngs : lngs && lngs[0];
      const l2 = this.store.hasLanguageSomeTranslations(fl2) ? fl2 : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [lngs] : lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language) this.translator.changeLanguage(l2);
        this.services.languageDetector?.cacheUserLanguage?.(l2);
      }
      this.loadResources(l2, (err) => {
        done(err, l2);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let o;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        o = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        o = {
          ...opts
        };
      }
      o.lng = o.lng || fixedT.lng;
      o.lngs = o.lngs || fixedT.lngs;
      o.ns = o.ns || fixedT.ns;
      if (o.keyPrefix !== "") o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (o.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k2) => `${o.keyPrefix}${keySeparator}${k2}`);
      } else {
        resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, o);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.translator?.translate(...args);
  }
  exists() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options2.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options2.precheck) {
      const preResult = options2.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get$1());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options2, callback);
  }
  cloneInstance() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$2;
    const forkResourceStore = options2.forkResourceStore;
    if (forkResourceStore) delete options2.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options2,
      ...{
        isClone: true
      }
    };
    const clone2 = new I18n(mergedOptions);
    if (options2.debug !== void 0 || options2.prefix !== void 0) {
      clone2.logger = clone2.logger.clone(options2);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone2[m2] = this[m2];
    });
    clone2.services = {
      ...this.services
    };
    clone2.services.utils = {
      hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev2, l2) => {
        prev2[l2] = {
          ...this.store.data[l2]
        };
        return Object.keys(prev2[l2]).reduce((acc, n2) => {
          acc[n2] = {
            ...prev2[l2][n2]
          };
          return acc;
        }, {});
      }, {});
      clone2.store = new ResourceStore(clonedData, mergedOptions);
      clone2.services.resourceStore = clone2.store;
    }
    clone2.translator = new Translator(clone2.services, mergedOptions);
    clone2.translator.on("*", function(event) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }
      clone2.emit(event, ...args);
    });
    clone2.init(mergedOptions, callback);
    clone2.translator.options = mergedOptions;
    clone2.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
    };
    return clone2;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const IMAGE_COMPRESSION_QUALITY_KEY = "appImageCompressionQuality";
const DEFAULT_IMAGE_COMPRESSION_QUALITY = 0.8;
const IMAGE_MAX_WIDTH_KEY = "appImageMaxWidth";
const DEFAULT_IMAGE_MAX_WIDTH = 0;
const loadInitialCompressionQuality = () => {
  const storedQuality = localStorage.getItem(IMAGE_COMPRESSION_QUALITY_KEY);
  if (storedQuality) {
    const quality = parseFloat(storedQuality);
    if (!Number.isNaN(quality) && quality >= 0.1 && quality <= 1) {
      return quality;
    }
  }
  return DEFAULT_IMAGE_COMPRESSION_QUALITY;
};
const loadInitialImageMaxWidth = () => {
  const storedMaxWidth = localStorage.getItem(IMAGE_MAX_WIDTH_KEY);
  if (storedMaxWidth) {
    const maxWidth = parseInt(storedMaxWidth, 10);
    if (!Number.isNaN(maxWidth) && maxWidth >= 0) {
      return maxWidth;
    }
  }
  return DEFAULT_IMAGE_MAX_WIDTH;
};
const useGeneralSettings = ({
  bgUrlContext,
  confName,
  setConfName,
  baseUrl,
  wsUrl,
  onWsUrlChange,
  onBaseUrlChange,
  onSave,
  onCancel
}) => {
  const { showSubtitle, setShowSubtitle } = useSubtitle();
  const { setUseCameraBackground } = bgUrlContext || {};
  const { startBackgroundCamera, stopBackgroundCamera } = useCamera();
  const { configFiles, getFilenameByName } = useConfig();
  const { switchCharacter } = useSwitchCharacter();
  const getCurrentBgKey = () => {
    if (!bgUrlContext?.backgroundUrl) return [];
    const currentBgUrl = bgUrlContext.backgroundUrl;
    const path2 = currentBgUrl.replace(baseUrl, "");
    return path2.startsWith("/bg/") ? [path2] : [];
  };
  const getCurrentCharacterFilename = () => {
    if (!confName) return [];
    const filename = getFilenameByName(confName);
    return filename ? [filename] : [];
  };
  const initialSettings = {
    language: [instance.language || "en"],
    customBgUrl: !bgUrlContext?.backgroundUrl?.includes("/bg/") ? bgUrlContext?.backgroundUrl || "" : "",
    selectedBgUrl: getCurrentBgKey(),
    backgroundUrl: bgUrlContext?.backgroundUrl || "",
    selectedCharacterPreset: getCurrentCharacterFilename(),
    useCameraBackground: bgUrlContext?.useCameraBackground || false,
    wsUrl: wsUrl || defaultWsUrl,
    baseUrl: baseUrl || defaultBaseUrl,
    showSubtitle,
    imageCompressionQuality: loadInitialCompressionQuality(),
    imageMaxWidth: loadInitialImageMaxWidth()
  };
  const [settings2, setSettings] = reactExports.useState(initialSettings);
  const [originalSettings, setOriginalSettings] = reactExports.useState(initialSettings);
  const originalConfName = confName;
  reactExports.useEffect(() => {
    setShowSubtitle(settings2.showSubtitle);
    const newBgUrl = settings2.customBgUrl || settings2.selectedBgUrl[0];
    if (newBgUrl && bgUrlContext) {
      const fullUrl = newBgUrl.startsWith("http") ? newBgUrl : `${baseUrl}${newBgUrl}`;
      bgUrlContext.setBackgroundUrl(fullUrl);
    }
    onWsUrlChange(settings2.wsUrl);
    onBaseUrlChange(settings2.baseUrl);
    if (settings2.language && settings2.language[0] && settings2.language[0] !== instance.language) {
      instance.changeLanguage(settings2.language[0]);
    }
    localStorage.setItem(IMAGE_COMPRESSION_QUALITY_KEY, settings2.imageCompressionQuality.toString());
    localStorage.setItem(IMAGE_MAX_WIDTH_KEY, settings2.imageMaxWidth.toString());
  }, [settings2, bgUrlContext, baseUrl, onWsUrlChange, onBaseUrlChange, setShowSubtitle]);
  reactExports.useEffect(() => {
    if (confName) {
      const filename = getFilenameByName(confName);
      if (filename) {
        const newSettings = {
          ...settings2,
          selectedCharacterPreset: [filename]
        };
        setSettings(newSettings);
        setOriginalSettings(newSettings);
      }
    }
  }, [confName]);
  reactExports.useEffect(() => {
    if (!onSave || !onCancel) return;
    const cleanupSave = onSave(() => {
      handleSave();
    });
    const cleanupCancel = onCancel(() => {
      handleCancel();
    });
    return () => {
      cleanupSave?.();
      cleanupCancel?.();
    };
  }, [onSave, onCancel]);
  const handleSettingChange = (key, value) => {
    setSettings((prev2) => ({ ...prev2, [key]: value }));
    if (key === "wsUrl") {
      onWsUrlChange(value);
    }
    if (key === "baseUrl") {
      onBaseUrlChange(value);
    }
    if (key === "language" && Array.isArray(value) && value.length > 0) {
      instance.changeLanguage(value[0]);
    }
  };
  const handleSave = () => {
    setOriginalSettings(settings2);
  };
  const handleCancel = () => {
    setSettings(originalSettings);
    setShowSubtitle(originalSettings.showSubtitle);
    if (bgUrlContext) {
      bgUrlContext.setBackgroundUrl(originalSettings.backgroundUrl);
      bgUrlContext.setUseCameraBackground(originalSettings.useCameraBackground);
    }
    onWsUrlChange(originalSettings.wsUrl);
    onBaseUrlChange(originalSettings.baseUrl);
    if (originalConfName) {
      setConfName(originalConfName);
    }
    if (originalSettings.useCameraBackground) {
      startBackgroundCamera();
    } else {
      stopBackgroundCamera();
    }
  };
  const handleCharacterPresetChange = (value) => {
    const selectedFilename = value[0];
    const selectedConfig = configFiles.find((config2) => config2.filename === selectedFilename);
    const currentFilename = confName ? getFilenameByName(confName) : "";
    handleSettingChange("selectedCharacterPreset", value);
    if (currentFilename === selectedFilename) {
      return;
    }
    if (selectedConfig) {
      switchCharacter(selectedFilename);
    }
  };
  const handleCameraToggle = async (checked) => {
    if (!setUseCameraBackground) return;
    if (checked) {
      try {
        await startBackgroundCamera();
        handleSettingChange("useCameraBackground", true);
        setUseCameraBackground(true);
      } catch (error2) {
        console.error("Failed to start camera:", error2);
        handleSettingChange("useCameraBackground", false);
        setUseCameraBackground(false);
      }
    } else {
      stopBackgroundCamera();
      handleSettingChange("useCameraBackground", false);
      setUseCameraBackground(false);
    }
  };
  return {
    settings: settings2,
    handleSettingChange,
    handleSave,
    handleCancel,
    handleCameraToggle,
    handleCharacterPresetChange,
    showSubtitle,
    setShowSubtitle
  };
};
function HiQuestionMarkCircle(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 20 20", "fill": "currentColor", "aria-hidden": "true" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z", "clipRule": "evenodd" }, "child": [] }] })(props);
}
const Field = reactExports.forwardRef(
  (props, ref) => {
    const {
      label,
      children,
      helperText,
      errorText,
      optionalText,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(FieldRoot, { ref, ...rest, children: [
      label && /* @__PURE__ */ jsxRuntimeExports.jsxs(FieldLabel, { children: [
        label,
        /* @__PURE__ */ jsxRuntimeExports.jsx(FieldRequiredIndicator, { fallback: optionalText })
      ] }),
      children,
      helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FieldHelperText, { children: helperText }),
      errorText && /* @__PURE__ */ jsxRuntimeExports.jsx(FieldErrorText, { children: errorText })
    ] });
  }
);
const Switch = reactExports.forwardRef(
  (props, ref) => {
    const {
      inputProps,
      children,
      rootRef,
      trackLabel,
      thumbLabel,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRoot, { ref: rootRef, ...rest, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchHiddenInput, { ref, ...inputProps }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchControl, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, { children: thumbLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumbIndicator, { fallback: thumbLabel?.off, children: thumbLabel?.on }) }),
        trackLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchIndicator, { fallback: trackLabel.off, children: trackLabel.on })
      ] }),
      children != null && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchLabel, { children })
    ] });
  }
);
const Tooltip = reactExports.forwardRef(
  (props, ref) => {
    const {
      showArrow,
      children,
      disabled,
      portalled,
      content,
      contentProps,
      portalRef,
      ...rest
    } = props;
    if (disabled) return children;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipRoot, { ...rest, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { disabled: !portalled, container: portalRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipPositioner, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipContent, { ref, ...contentProps, children: [
        showArrow && /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipArrow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipArrowTip, {}) }),
        content
      ] }) }) })
    ] });
  }
);
const SelectTrigger = reactExports.forwardRef((props, ref) => {
  const { children, clearable, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectControl, { ...rest, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger$1, { ref, children }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectIndicatorGroup, { children: [
      clearable && /* @__PURE__ */ jsxRuntimeExports.jsx(SelectClearTrigger, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIndicator, {})
    ] })
  ] });
});
const SelectClearTrigger = reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectClearTrigger$1, { asChild: true, ...props, ref, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  CloseButton,
  {
    size: "xs",
    variant: "plain",
    focusVisibleRing: "inside",
    focusRingWidth: "2px",
    pointerEvents: "auto"
  }
) }));
const SelectContent = reactExports.forwardRef((props, ref) => {
  const { portalled = true, portalRef, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { disabled: !portalled, container: portalRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectPositioner, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent$1, { ...rest, ref }) }) });
});
const SelectItem = reactExports.forwardRef((props, ref) => {
  const { item, children, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem$1, { item, ...rest, ref, children: [
    children,
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemIndicator, {})
  ] }, item.value);
});
const SelectValueText = reactExports.forwardRef((props, ref) => {
  const { children, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValueText$1, { ...rest, ref, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContext, { children: (select) => {
    const items = select.selectedItems;
    if (items.length === 0) return props.placeholder;
    if (children) return children(items);
    if (items.length === 1) return select.collection.stringifyItem(items[0]);
    return `${items.length} selected`;
  } }) });
});
const SelectRoot = reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  SelectRoot$1,
  {
    ...props,
    ref,
    positioning: { sameWidth: true, ...props.positioning },
    children: props.asChild ? props.children : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectHiddenSelect, {}),
      props.children
    ] })
  }
));
reactExports.forwardRef((props, ref) => {
  const { children, label, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItemGroup, { ...rest, ref, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemGroupLabel, { children: label }),
    children
  ] });
});
function HelpIcon({ content }) {
  const [isHovering, setIsHovering] = reactExports.useState(false);
  const handleMouseEnter = () => setIsHovering(true);
  const handleMouseLeave = () => setIsHovering(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Tooltip,
    {
      showArrow: true,
      content: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { fontSize: "sm", maxW: "300px", lineHeight: "1.4", children: content }),
      open: isHovering,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          as: HiQuestionMarkCircle,
          color: "gray.400",
          _hover: { color: "gray.600" },
          cursor: "help",
          w: "16px",
          h: "16px",
          ml: "2",
          transition: "color 0.2s",
          onMouseEnter: handleMouseEnter,
          onMouseLeave: handleMouseLeave
        }
      )
    }
  );
}
function SelectField({
  label,
  value,
  onChange,
  collection: collection2,
  placeholder
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      ...settingStyles.general.field,
      label: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...settingStyles.general.field.label, children: label }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        SelectRoot,
        {
          ...settingStyles.general.select.root,
          collection: collection2,
          value,
          onValueChange: (e2) => onChange(e2.value),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { ...settingStyles.general.select.trigger, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValueText, { placeholder }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: collection2.items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { item, children: item.label }, item.value)) })
          ]
        }
      )
    }
  );
}
function NumberField({
  label,
  value,
  onChange,
  min: min2,
  max: max2,
  step,
  allowMouseWheel,
  help
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      ...settingStyles.common.field,
      label: /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...settingStyles.common.fieldLabel, children: label }),
        help && /* @__PURE__ */ jsxRuntimeExports.jsx(HelpIcon, { content: help })
      ] }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NumberInputRoot,
        {
          ...settingStyles.common.numberInput.root,
          value: value.toString(),
          onValueChange: (details) => onChange(details.value),
          min: min2,
          max: max2,
          step,
          allowMouseWheel,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputInput, { ...settingStyles.common.numberInput.input }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(NumberInputControl, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputIncrementTrigger, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(NumberInputDecrementTrigger, {})
            ] })
          ]
        }
      )
    }
  );
}
function SwitchField({ label, checked, onChange, help }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      ...settingStyles.common.field,
      label: /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...settingStyles.common.fieldLabel, children: label }),
        help && /* @__PURE__ */ jsxRuntimeExports.jsx(HelpIcon, { content: help })
      ] }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Switch,
        {
          ...settingStyles.common.switch,
          checked,
          onCheckedChange: (details) => onChange(details.checked)
        }
      )
    }
  );
}
function InputField({
  label,
  value,
  onChange,
  placeholder,
  help
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      ...settingStyles.general.field,
      label: /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { align: "center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...settingStyles.general.field.label, children: label }),
        help && /* @__PURE__ */ jsxRuntimeExports.jsx(HelpIcon, { content: help })
      ] }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$1,
        {
          ...settingStyles.general.input,
          placeholder,
          value,
          onChange: (e2) => onChange(e2.target.value)
        }
      )
    }
  );
}
const useCollections = () => {
  const { backgroundFiles } = useBgUrl() || {};
  const { configFiles } = useConfig();
  const languages = createListCollection({
    items: [
      { label: "English", value: "en" },
      { label: "", value: "zh" }
    ]
  });
  const backgrounds = createListCollection({
    items: backgroundFiles?.map((filename) => ({
      label: String(filename),
      value: `/bg/${filename}`
    })) || []
  });
  const characterPresets = createListCollection({
    items: configFiles.map((config2) => ({
      label: config2.name,
      value: config2.filename
    }))
  });
  return {
    languages,
    backgrounds,
    characterPresets
  };
};
function General({ onSave, onCancel }) {
  const { t: t2, i18n } = useTranslation();
  const bgUrlContext = useBgUrl();
  const { confName, setConfName } = useConfig();
  const { wsUrl, setWsUrl, baseUrl, setBaseUrl } = useWebSocket();
  const collections = useCollections();
  const {
    settings: settings2,
    handleSettingChange,
    handleCameraToggle,
    handleCharacterPresetChange,
    showSubtitle,
    setShowSubtitle
  } = useGeneralSettings({
    bgUrlContext,
    confName,
    setConfName,
    baseUrl,
    wsUrl,
    onWsUrlChange: setWsUrl,
    onBaseUrlChange: setBaseUrl,
    onSave,
    onCancel
  });
  if (settings2.language[0] !== i18n.language) {
    handleSettingChange("language", [i18n.language]);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectField,
      {
        label: t2("settings.general.language"),
        value: settings2.language,
        onChange: (value) => handleSettingChange("language", value),
        collection: collections.languages,
        placeholder: t2("settings.general.language")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.general.useCameraBackground"),
        checked: settings2.useCameraBackground,
        onChange: handleCameraToggle
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.general.showSubtitle"),
        checked: showSubtitle,
        onChange: setShowSubtitle
      }
    ),
    !settings2.useCameraBackground && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectField,
        {
          label: t2("settings.general.backgroundImage"),
          value: settings2.selectedBgUrl,
          onChange: (value) => handleSettingChange("selectedBgUrl", value),
          collection: collections.backgrounds,
          placeholder: t2("settings.general.backgroundImage")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        InputField,
        {
          label: t2("settings.general.customBgUrl"),
          value: settings2.customBgUrl,
          onChange: (value) => handleSettingChange("customBgUrl", value),
          placeholder: t2("settings.general.customBgUrlPlaceholder")
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectField,
      {
        label: t2("settings.general.characterPreset"),
        value: settings2.selectedCharacterPreset,
        onChange: handleCharacterPresetChange,
        collection: collections.characterPresets,
        placeholder: confName || t2("settings.general.characterPreset")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputField,
      {
        label: t2("settings.general.wsUrl"),
        value: settings2.wsUrl,
        onChange: (value) => handleSettingChange("wsUrl", value),
        placeholder: "Enter WebSocket URL"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputField,
      {
        label: t2("settings.general.baseUrl"),
        value: settings2.baseUrl,
        onChange: (value) => handleSettingChange("baseUrl", value),
        placeholder: "Enter Base URL"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputField,
      {
        label: t2("settings.general.imageCompressionQuality"),
        value: settings2.imageCompressionQuality.toString(),
        onChange: (value) => {
          const quality = parseFloat(value);
          if (!Number.isNaN(quality) && quality >= 0.1 && quality <= 1) {
            handleSettingChange("imageCompressionQuality", quality);
          } else if (value === "") {
            handleSettingChange("imageCompressionQuality", settings2.imageCompressionQuality);
          }
        },
        help: t2("settings.general.imageCompressionQualityHelp")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputField,
      {
        label: t2("settings.general.imageMaxWidth"),
        value: settings2.imageMaxWidth.toString(),
        onChange: (value) => {
          const maxWidth = parseInt(value, 10);
          if (!Number.isNaN(maxWidth) && maxWidth >= 0) {
            handleSettingChange("imageMaxWidth", maxWidth);
          } else if (value === "") {
            handleSettingChange("imageMaxWidth", settings2.imageMaxWidth);
          }
        },
        help: t2("settings.general.imageMaxWidthHelp")
      }
    )
  ] });
}
const useLive2dSettings = () => {
  const Live2DConfigContext2 = useLive2DConfig();
  const initialModelInfo = {
    url: "",
    kScale: 0.5,
    initialXshift: 0,
    initialYshift: 0,
    emotionMap: {},
    scrollToResize: true
  };
  const [modelInfo, setModelInfoState] = reactExports.useState(
    Live2DConfigContext2?.modelInfo || initialModelInfo
  );
  const [originalModelInfo, setOriginalModelInfo] = reactExports.useState(
    Live2DConfigContext2?.modelInfo || initialModelInfo
  );
  reactExports.useEffect(() => {
    if (Live2DConfigContext2?.modelInfo) {
      if (JSON.stringify(Live2DConfigContext2.modelInfo) !== JSON.stringify(originalModelInfo)) {
        setOriginalModelInfo(Live2DConfigContext2.modelInfo);
        setModelInfoState(Live2DConfigContext2.modelInfo);
      }
    }
  }, [Live2DConfigContext2?.modelInfo]);
  reactExports.useEffect(() => {
    if (Live2DConfigContext2 && modelInfo) {
      Live2DConfigContext2.setModelInfo(modelInfo);
    }
  }, [modelInfo.pointerInteractive, modelInfo.scrollToResize]);
  const handleInputChange = (key, value) => {
    setModelInfoState((prev2) => ({ ...prev2, [key]: value }));
  };
  const handleSave = () => {
    if (Live2DConfigContext2 && modelInfo) {
      setOriginalModelInfo(modelInfo);
    }
  };
  const handleCancel = () => {
    setModelInfoState(originalModelInfo);
    if (Live2DConfigContext2 && originalModelInfo) {
      Live2DConfigContext2.setModelInfo(originalModelInfo);
    }
  };
  return {
    modelInfo,
    handleInputChange,
    handleSave,
    handleCancel
  };
};
function live2D({ onSave, onCancel }) {
  const { t: t2 } = useTranslation();
  const {
    modelInfo,
    handleInputChange,
    handleSave,
    handleCancel
  } = useLive2dSettings();
  reactExports.useEffect(() => {
    if (!onSave || !onCancel) return;
    const cleanupSave = onSave(handleSave);
    const cleanupCancel = onCancel(handleCancel);
    return () => {
      cleanupSave?.();
      cleanupCancel?.();
    };
  }, [onSave, onCancel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.live2d.pointerInteractive"),
        checked: modelInfo.pointerInteractive ?? false,
        onChange: (checked) => handleInputChange("pointerInteractive", checked)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.live2d.scrollToResize"),
        checked: modelInfo.scrollToResize ?? true,
        onChange: (checked) => handleInputChange("scrollToResize", checked)
      }
    )
  ] });
}
const useASRSettings = () => {
  const {
    settings: settings2,
    updateSettings,
    autoStopMic,
    setAutoStopMic,
    autoStartMicOn,
    setAutoStartMicOn,
    autoStartMicOnConvEnd,
    setAutoStartMicOnConvEnd
  } = useVAD();
  const localSettingsRef = reactExports.useRef(settings2);
  const originalSettingsRef = reactExports.useRef(settings2);
  const originalAutoStopMicRef = reactExports.useRef(autoStopMic);
  const originalAutoStartMicOnRef = reactExports.useRef(autoStartMicOn);
  const originalAutoStartMicOnConvEndRef = reactExports.useRef(autoStartMicOnConvEnd);
  const [localVoiceInterruption, setLocalVoiceInterruption] = reactExports.useState(autoStopMic);
  const [localAutoStartMic, setLocalAutoStartMic] = reactExports.useState(autoStartMicOn);
  const [localAutoStartMicOnConvEnd, setLocalAutoStartMicOnConvEnd] = reactExports.useState(autoStartMicOnConvEnd);
  const [, forceUpdate] = React.useReducer((x2) => x2 + 1, 0);
  reactExports.useEffect(() => {
    setLocalVoiceInterruption(autoStopMic);
    setLocalAutoStartMic(autoStartMicOn);
    setLocalAutoStartMicOnConvEnd(autoStartMicOnConvEnd);
  }, [autoStopMic, autoStartMicOn, autoStartMicOnConvEnd]);
  const handleInputChange = (key, value) => {
    if (value === "" || value === "-") {
      localSettingsRef.current = { ...localSettingsRef.current, [key]: value };
    } else {
      const parsed = Number(value);
      if (!isNaN(parsed)) {
        localSettingsRef.current = { ...localSettingsRef.current, [key]: parsed };
      }
    }
    forceUpdate();
  };
  const handleVoiceInterruptionChange = (value) => {
    setLocalVoiceInterruption(value);
    setAutoStopMic(value);
  };
  const handleAutoStartMicChange = (value) => {
    setLocalAutoStartMic(value);
    setAutoStartMicOn(value);
  };
  const handleAutoStartMicOnConvEndChange = (value) => {
    setLocalAutoStartMicOnConvEnd(value);
    setAutoStartMicOnConvEnd(value);
  };
  const handleSave = () => {
    updateSettings(localSettingsRef.current);
    originalSettingsRef.current = localSettingsRef.current;
    originalAutoStopMicRef.current = localVoiceInterruption;
    originalAutoStartMicOnRef.current = localAutoStartMic;
    originalAutoStartMicOnConvEndRef.current = localAutoStartMicOnConvEnd;
  };
  const handleCancel = () => {
    localSettingsRef.current = originalSettingsRef.current;
    setLocalVoiceInterruption(originalAutoStopMicRef.current);
    setLocalAutoStartMic(originalAutoStartMicOnRef.current);
    setAutoStopMic(originalAutoStopMicRef.current);
    setAutoStartMicOn(originalAutoStartMicOnRef.current);
    setLocalAutoStartMicOnConvEnd(originalAutoStartMicOnConvEndRef.current);
    setAutoStartMicOnConvEnd(originalAutoStartMicOnConvEndRef.current);
    forceUpdate();
  };
  return {
    localSettings: localSettingsRef.current,
    autoStopMic: localVoiceInterruption,
    autoStartMicOn: localAutoStartMic,
    autoStartMicOnConvEnd: localAutoStartMicOnConvEnd,
    setAutoStopMic: handleVoiceInterruptionChange,
    setAutoStartMicOn: handleAutoStartMicChange,
    setAutoStartMicOnConvEnd: handleAutoStartMicOnConvEndChange,
    handleInputChange,
    handleSave,
    handleCancel
  };
};
function ASR({ onSave, onCancel }) {
  const { t: t2 } = useTranslation();
  const {
    localSettings,
    autoStopMic,
    autoStartMicOn,
    autoStartMicOnConvEnd,
    setAutoStopMic,
    setAutoStartMicOn,
    setAutoStartMicOnConvEnd,
    handleInputChange,
    handleSave,
    handleCancel
  } = useASRSettings();
  reactExports.useEffect(() => {
    if (!onSave || !onCancel) return;
    const cleanupSave = onSave(handleSave);
    const cleanupCancel = onCancel(handleCancel);
    return () => {
      cleanupSave?.();
      cleanupCancel?.();
    };
  }, [onSave, onCancel, handleSave, handleCancel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.asr.autoStopMic"),
        checked: autoStopMic,
        onChange: setAutoStopMic
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.asr.autoStartMicOnConvEnd"),
        checked: autoStartMicOnConvEnd,
        onChange: setAutoStartMicOnConvEnd
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.asr.autoStartMicOn"),
        checked: autoStartMicOn,
        onChange: setAutoStartMicOn
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberField,
      {
        label: t2("settings.asr.positiveSpeechThreshold"),
        help: t2("settings.asr.positiveSpeechThresholdDesc"),
        value: localSettings.positiveSpeechThreshold,
        onChange: (value) => handleInputChange("positiveSpeechThreshold", value),
        min: 1,
        max: 100
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberField,
      {
        label: t2("settings.asr.negativeSpeechThreshold"),
        help: t2("settings.asr.negativeSpeechThresholdDesc"),
        value: localSettings.negativeSpeechThreshold,
        onChange: (value) => handleInputChange("negativeSpeechThreshold", value),
        min: 0,
        max: 100
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberField,
      {
        label: t2("settings.asr.redemptionFrames"),
        help: t2("settings.asr.redemptionFramesDesc"),
        value: localSettings.redemptionFrames,
        onChange: (value) => handleInputChange("redemptionFrames", value),
        min: 1,
        max: 100
      }
    )
  ] });
}
function TTS() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: " " });
}
function useTriggerSpeak() {
  const { sendMessage } = useWebSocket();
  const { captureAllMedia } = useMediaCapture();
  const sendTriggerSignal = reactExports.useCallback(
    async (actualIdleTime) => {
      const images = await captureAllMedia();
      sendMessage({
        type: "ai-speak-signal",
        idle_time: actualIdleTime,
        images
      });
    },
    [sendMessage, captureAllMedia]
  );
  return {
    sendTriggerSignal
  };
}
const defaultSettings$1 = {
  allowProactiveSpeak: false,
  idleSecondsToSpeak: 5,
  allowButtonTrigger: false
};
const ProactiveSpeakContext = reactExports.createContext(null);
function ProactiveSpeakProvider({ children }) {
  const [settings2, setSettings] = useLocalStorage(
    "proactiveSpeakSettings",
    defaultSettings$1
  );
  const { aiState: aiState2 } = useAiState();
  const { sendTriggerSignal } = useTriggerSpeak();
  const idleTimerRef = reactExports.useRef(null);
  const idleStartTimeRef = reactExports.useRef(null);
  const clearIdleTimer = reactExports.useCallback(() => {
    if (idleTimerRef.current) {
      clearTimeout(idleTimerRef.current);
      idleTimerRef.current = null;
    }
    idleStartTimeRef.current = null;
  }, []);
  const startIdleTimer = reactExports.useCallback(() => {
    clearIdleTimer();
    if (!settings2.allowProactiveSpeak) return;
    idleStartTimeRef.current = Date.now();
    idleTimerRef.current = setTimeout(() => {
      const actualIdleTime = (Date.now() - idleStartTimeRef.current) / 1e3;
      sendTriggerSignal(actualIdleTime);
    }, settings2.idleSecondsToSpeak * 1e3);
  }, [settings2.allowProactiveSpeak, settings2.idleSecondsToSpeak, sendTriggerSignal, clearIdleTimer]);
  reactExports.useEffect(() => {
    if (aiState2 === AiStateEnum.IDLE) {
      startIdleTimer();
    } else {
      clearIdleTimer();
    }
  }, [aiState2, startIdleTimer, clearIdleTimer]);
  reactExports.useEffect(() => () => {
    clearIdleTimer();
  }, [clearIdleTimer]);
  const updateSettings = reactExports.useCallback((newSettings) => {
    setSettings(newSettings);
  }, [setSettings]);
  const contextValue = reactExports.useMemo(() => ({
    settings: settings2,
    updateSettings
  }), [settings2, updateSettings]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProactiveSpeakContext.Provider, { value: contextValue, children });
}
function useProactiveSpeak() {
  const context = reactExports.useContext(ProactiveSpeakContext);
  if (!context) {
    throw new Error("useProactiveSpeak must be used within a ProactiveSpeakProvider");
  }
  return context;
}
function useAgentSettings({ onSave, onCancel } = {}) {
  const { settings: persistedSettings, updateSettings } = useProactiveSpeak();
  const [tempSettings, setTempSettings] = reactExports.useState({
    allowProactiveSpeak: persistedSettings.allowProactiveSpeak,
    idleSecondsToSpeak: persistedSettings.idleSecondsToSpeak,
    allowButtonTrigger: persistedSettings.allowButtonTrigger
  });
  const [originalSettings, setOriginalSettings] = reactExports.useState({
    ...persistedSettings
  });
  reactExports.useEffect(() => {
    if (persistedSettings) {
      setOriginalSettings(persistedSettings);
      setTempSettings(persistedSettings);
    }
  }, [persistedSettings]);
  const handleAllowProactiveSpeakChange = reactExports.useCallback((checked) => {
    setTempSettings((prev2) => ({
      ...prev2,
      allowProactiveSpeak: checked
    }));
  }, []);
  const handleIdleSecondsChange = reactExports.useCallback((value) => {
    setTempSettings((prev2) => ({
      ...prev2,
      idleSecondsToSpeak: value
    }));
  }, []);
  const handleAllowButtonTriggerChange = reactExports.useCallback((checked) => {
    setTempSettings((prev2) => ({
      ...prev2,
      allowButtonTrigger: checked
    }));
  }, []);
  const handleSave = reactExports.useCallback(() => {
    updateSettings(tempSettings);
    setOriginalSettings(tempSettings);
  }, [updateSettings, tempSettings]);
  const handleCancel = reactExports.useCallback(() => {
    setTempSettings(originalSettings);
    updateSettings(originalSettings);
  }, [originalSettings, updateSettings]);
  reactExports.useEffect(() => {
    if (!onSave || !onCancel) return;
    const cleanupSave = onSave(handleSave);
    const cleanupCancel = onCancel(handleCancel);
    return () => {
      cleanupSave?.();
      cleanupCancel?.();
    };
  }, [onSave, onCancel, handleSave, handleCancel]);
  return {
    settings: tempSettings,
    handleAllowProactiveSpeakChange,
    handleIdleSecondsChange,
    handleAllowButtonTriggerChange
  };
}
function Agent({ onSave, onCancel }) {
  const { t: t2 } = useTranslation();
  const {
    settings: settings2,
    handleAllowProactiveSpeakChange,
    handleIdleSecondsChange,
    handleAllowButtonTriggerChange
  } = useAgentSettings({ onSave, onCancel });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.agent.allowProactiveSpeak"),
        checked: settings2.allowProactiveSpeak,
        onChange: handleAllowProactiveSpeakChange
      }
    ),
    settings2.allowProactiveSpeak && /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberField,
      {
        label: t2("settings.agent.idleSecondsToSpeak"),
        value: settings2.idleSecondsToSpeak,
        onChange: (value) => handleIdleSecondsChange(Number(value)),
        min: 0,
        step: 0.1,
        allowMouseWheel: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SwitchField,
      {
        label: t2("settings.agent.allowButtonTrigger"),
        checked: settings2.allowButtonTrigger,
        onChange: handleAllowButtonTriggerChange
      }
    )
  ] });
}
function FaGithub(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 496 512" }, "child": [{ "tag": "path", "attr": { "d": "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" }, "child": [] }] })(props);
}
function FaBook(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M448 360V24c0-13.3-10.7-24-24-24H96C43 0 0 43 0 96v320c0 53 43 96 96 96h328c13.3 0 24-10.7 24-24v-16c0-7.5-3.5-14.3-8.9-18.7-4.2-15.4-4.2-59.3 0-74.7 5.4-4.3 8.9-11.1 8.9-18.6zM128 134c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm0 64c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm253.4 250H96c-17.7 0-32-14.3-32-32 0-17.6 14.4-32 32-32h285.4c-1.9 17.1-1.9 46.9 0 64z" }, "child": [] }] })(props);
}
function FaCheck(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z" }, "child": [] }] })(props);
}
function FaTimes(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 352 512" }, "child": [{ "tag": "path", "attr": { "d": "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z" }, "child": [] }] })(props);
}
function FaTools(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M501.1 395.7L384 278.6c-23.1-23.1-57.6-27.6-85.4-13.9L192 158.1V96L64 0 0 64l96 128h62.1l106.6 106.6c-13.6 27.8-9.2 62.3 13.9 85.4l117.1 117.1c14.6 14.6 38.2 14.6 52.7 0l52.7-52.7c14.5-14.6 14.5-38.2 0-52.7zM331.7 225c28.3 0 54.9 11 74.9 31l19.4 19.4c15.8-6.9 30.8-16.5 43.8-29.5 37.1-37.1 49.7-89.3 37.9-136.7-2.2-9-13.5-12.1-20.1-5.5l-74.4 74.4-67.9-11.3L334 98.9l74.4-74.4c6.6-6.6 3.4-17.9-5.7-20.2-47.4-11.7-99.6.9-136.6 37.9-28.5 28.5-41.9 66.1-41.2 103.6l82.1 82.1c8.1-1.9 16.5-2.9 24.7-2.9zm-103.9 82l-56.7-56.7L18.7 402.8c-25 25-25 65.5 0 90.5s65.5 25 90.5 0l123.6-123.6c-7.6-19.9-9.9-41.6-5-62.7zM64 472c-13.2 0-24-10.8-24-24 0-13.3 10.7-24 24-24s24 10.7 24 24c0 13.2-10.7 24-24 24z" }, "child": [] }] })(props);
}
const Button$1 = reactExports.forwardRef(
  (props, ref) => {
    const {
      loading,
      disabled,
      loadingText,
      children,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { disabled: loading || disabled, ref, ...rest, children: loading && !loadingText ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AbsoluteCenter, { display: "inline-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "inherit", color: "inherit" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Span, { opacity: 0, children })
    ] }) : loading && loadingText ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "inherit", color: "inherit" }),
      loadingText
    ] }) : children });
  }
);
function About() {
  const { t: t2 } = useTranslation();
  const openExternalLink = (url) => {
    window.open(url, "_blank");
  };
  const appVersion = "1.2.1";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { ...settingStyles.common.container, gap: 3, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Heading, { size: "md", mb: 1, children: t2("settings.about.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { fontWeight: "bold", mb: 0, children: t2("settings.about.version") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: appVersion })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { borderTop: "1px solid", borderColor: "whiteAlpha.200", pt: 2, mt: 1 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { mt: 1, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { fontWeight: "bold", mb: 1, children: t2("settings.about.projectLinks") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { mt: 1, gap: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button$1,
          {
            size: "sm",
            onClick: () => openExternalLink(
              "https://github.com/Open-LLM-VTuber/Open-LLM-VTuber-Web"
            ),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { as: FaGithub, mr: 2 }),
              " ",
              t2("settings.about.github")
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button$1,
          {
            size: "sm",
            onClick: () => openExternalLink("https://docs.llmvtuber.com"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { as: FaBook, mr: 2 }),
              " ",
              t2("settings.about.documentation")
            ]
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { borderTop: "1px solid", borderColor: "whiteAlpha.200", pt: 2, mt: 1 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { mt: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "xs", colorPalette: "blue", onClick: () => openExternalLink("https://github.com/Open-LLM-VTuber/Open-LLM-VTuber-Web/blob/main/LICENSE"), children: t2("settings.about.viewLicense") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { mt: 1, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { fontWeight: "bold", mb: 0, children: t2("settings.about.copyright") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { children: [
        " ",
        (/* @__PURE__ */ new Date()).getFullYear(),
        " Open LLM VTuber Team"
      ] })
    ] })
  ] });
}
function SettingUI({ open, onClose }) {
  const { t: t2 } = useTranslation();
  const [saveHandlers, setSaveHandlers] = reactExports.useState([]);
  const [cancelHandlers, setCancelHandlers] = reactExports.useState([]);
  const [activeTab, setActiveTab] = reactExports.useState("general");
  const handleSaveCallback = reactExports.useCallback((handler) => {
    setSaveHandlers((prev2) => [...prev2, handler]);
    return () => {
      setSaveHandlers((prev2) => prev2.filter((h2) => h2 !== handler));
    };
  }, []);
  const handleCancelCallback = reactExports.useCallback((handler) => {
    setCancelHandlers((prev2) => [...prev2, handler]);
    return () => {
      setCancelHandlers((prev2) => prev2.filter((h2) => h2 !== handler));
    };
  }, []);
  const handleSave = reactExports.useCallback(() => {
    saveHandlers.forEach((handler) => handler());
    onClose();
  }, [saveHandlers, onClose]);
  const handleCancel = reactExports.useCallback(() => {
    cancelHandlers.forEach((handler) => handler());
    onClose();
  }, [cancelHandlers, onClose]);
  const tabsContent = reactExports.useMemo(
    () => /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsContentGroup, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "general", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        General,
        {
          onSave: handleSaveCallback,
          onCancel: handleCancelCallback
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "live2d", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        live2D,
        {
          onSave: handleSaveCallback,
          onCancel: handleCancelCallback
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "asr", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ASR, { onSave: handleSaveCallback, onCancel: handleCancelCallback }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "tts", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TTS, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "agent", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Agent,
        {
          onSave: handleSaveCallback,
          onCancel: handleCancelCallback
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "about", ...settingStyles.settingUI.tabs.content, children: /* @__PURE__ */ jsxRuntimeExports.jsx(About, {}) })
    ] }),
    [handleSaveCallback, handleCancelCallback]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    DrawerRoot$1,
    {
      open,
      onOpenChange: (e2) => e2.open ? null : onClose(),
      placement: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBackdrop$1, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerContent$1, { ...settingStyles.settingUI.drawerContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerHeader$1, { ...settingStyles.settingUI.drawerHeader, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTitle$1, { ...settingStyles.settingUI.drawerTitle, children: t2("common.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...settingStyles.settingUI.closeButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerCloseTrigger$1, { asChild: true, onClick: handleCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButton, { size: "sm", color: "white" }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBody$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            TabsRoot,
            {
              defaultValue: "general",
              value: activeTab,
              onValueChange: (details) => setActiveTab(details.value),
              ...settingStyles.settingUI.tabs.root,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { ...settingStyles.settingUI.tabs.list, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "general",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: t2("settings.tabs.general")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "live2d",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: t2("settings.tabs.live2d")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "asr",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: t2("settings.tabs.asr")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "tts",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: t2("settings.tabs.tts")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "agent",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: t2("settings.tabs.agent")
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabsTrigger,
                    {
                      value: "about",
                      ...settingStyles.settingUI.tabs.trigger,
                      children: t2("settings.tabs.about")
                    }
                  )
                ] }),
                tabsContent
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerFooter$1, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { colorPalette: "red", onClick: handleCancel, children: t2("common.cancel") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { colorPalette: "blue", onClick: handleSave, children: t2("common.save") })
          ] })
        ] })
      ]
    }
  );
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var prefix = "cs";
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames2() {
      var classes = "";
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg) {
          classes = appendClass(classes, parseValue2(arg));
        }
      }
      return classes;
    }
    function parseValue2(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        return arg;
      }
      if (typeof arg !== "object") {
        return "";
      }
      if (Array.isArray(arg)) {
        return classNames2.apply(null, arg);
      }
      if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
        return arg.toString();
      }
      var classes = "";
      for (var key in arg) {
        if (hasOwn2.call(arg, key) && arg[key]) {
          classes = appendClass(classes, key);
        }
      }
      return classes;
    }
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    if (module2.exports) {
      classNames2.default = classNames2;
      module2.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
var StatusEnum = ["available", "unavailable", "away", "dnd", "invisible", "eager"];
var SizeEnum = ["xs", "sm", "md", "lg", "fluid"];
function _typeof$h(o) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$h(o);
}
var _excluded$w = ["status", "size", "className", "name", "selected", "children"];
function _extends$v() {
  _extends$v = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$v.apply(this, arguments);
}
function _defineProperty$f(obj, key, value) {
  key = _toPropertyKey$e(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$e(t2) {
  var i = _toPrimitive$e(t2, "string");
  return "symbol" == _typeof$h(i) ? i : String(i);
}
function _toPrimitive$e(t2, r2) {
  if ("object" != _typeof$h(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$h(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$w(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$w(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$w(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Status = function Status2(_ref2) {
  var status = _ref2.status, _ref$size = _ref2.size, size2 = _ref$size === void 0 ? "md" : _ref$size, className = _ref2.className, name2 = _ref2.name, selected = _ref2.selected, children = _ref2.children, rest = _objectWithoutProperties$w(_ref2, _excluded$w);
  var cName2 = "".concat(prefix, "-status");
  var bullet = /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__bullet")
  });
  var named = name2 || children;
  return /* @__PURE__ */ React.createElement("div", _extends$v({}, rest, {
    "aria-selected": selected === true ? "" : null,
    className: classNames(cName2, "".concat(cName2, "--").concat(size2), "".concat(cName2, "--").concat(status), _defineProperty$f({}, "".concat(cName2, "--selected"), selected), _defineProperty$f({}, "".concat(cName2, "--named"), named), className)
  }), bullet, named && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__name")
  }, name2 ? name2 : children));
};
function _typeof$g(o) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$g(o);
}
var _excluded$v = ["name", "src", "size", "status", "className", "active", "children"];
function _extends$u() {
  _extends$u = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$u.apply(this, arguments);
}
function _defineProperty$e(obj, key, value) {
  key = _toPropertyKey$d(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$d(t2) {
  var i = _toPrimitive$d(t2, "string");
  return "symbol" == _typeof$g(i) ? i : String(i);
}
function _toPrimitive$d(t2, r2) {
  if ("object" != _typeof$g(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$g(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$v(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$v(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$v(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function AvatarInner(_ref2, ref) {
  var _ref$name = _ref2.name, name2 = _ref$name === void 0 ? "" : _ref$name, _ref$src = _ref2.src, src = _ref$src === void 0 ? "" : _ref$src, _ref$size = _ref2.size, size2 = _ref$size === void 0 ? "md" : _ref$size, status = _ref2.status, className = _ref2.className, _ref$active = _ref2.active, active2 = _ref$active === void 0 ? false : _ref$active, children = _ref2.children, rest = _objectWithoutProperties$v(_ref2, _excluded$v);
  var cName2 = "".concat(prefix, "-avatar");
  var sizeClass = typeof size2 !== "undefined" ? " ".concat(cName2, "--").concat(size2) : "";
  var avatarRef = reactExports.useRef();
  reactExports.useImperativeHandle(ref, function() {
    return {
      focus: function focus() {
        return avatarRef.current.focus();
      }
    };
  });
  return /* @__PURE__ */ React.createElement("div", _extends$u({
    ref: avatarRef
  }, rest, {
    className: classNames("".concat(cName2).concat(sizeClass), _defineProperty$e({}, "".concat(cName2, "--active"), active2), className)
  }), children ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("img", {
    src,
    alt: name2
  }), typeof status === "string" && /* @__PURE__ */ React.createElement(Status, {
    status,
    size: size2
  }), " "));
}
var Avatar = /* @__PURE__ */ reactExports.forwardRef(AvatarInner);
Avatar.displayName = "Avatar";
Avatar.propTypes = {
  /** Primary content */
  children: PropTypes.node,
  /**
   * User name/nickname/full name for displaying initials and image alt description
   */
  name: PropTypes.string,
  /** Avatar image source */
  src: PropTypes.string,
  /** Size */
  size: PropTypes.oneOf(SizeEnum),
  /** Status. */
  status: PropTypes.oneOf(StatusEnum),
  /** Active */
  active: PropTypes.bool,
  /** Additional classes. */
  className: PropTypes.string
};
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$d(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty$d(obj, key, value) {
  key = _toPropertyKey$c(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$c(t2) {
  var i = _toPrimitive$c(t2, "string");
  return "symbol" == _typeof$f(i) ? i : String(i);
}
function _toPrimitive$c(t2, r2) {
  if ("object" != _typeof$f(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$f(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _typeof$f(o) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$f(o);
}
var noop$1 = function noop2() {
};
var isChildrenNil = function isChildrenNil2(children) {
  return children === null || children === void 0 || Array.isArray(children) && children.length === 0;
};
var getChildren = function getChildren2(children, types) {
  var ret = [];
  var strTypes = types.map(function(t2) {
    return t2.displayName || t2.name;
  });
  React.Children.toArray(children).forEach(function(item) {
    var idx = types.indexOf(item.type);
    if (idx !== -1) {
      ret[idx] = item;
    } else {
      var _item$props$as, _item$props, _item$props2;
      var is = (_item$props$as = item === null || item === void 0 ? void 0 : (_item$props = item.props) === null || _item$props === void 0 ? void 0 : _item$props.as) !== null && _item$props$as !== void 0 ? _item$props$as : item === null || item === void 0 ? void 0 : (_item$props2 = item.props) === null || _item$props2 === void 0 ? void 0 : _item$props2.is;
      var typeofIs = _typeof$f(is);
      if (typeofIs === "function") {
        var fIdx = types.indexOf(is);
        if (fIdx !== -1) {
          ret[fIdx] = /* @__PURE__ */ React.cloneElement(item, _objectSpread$1(_objectSpread$1({}, item.props), {}, {
            as: null
          }));
        }
      } else if (typeofIs === "object") {
        var typeName = is.name || is.displayName;
        var tIdx = strTypes.indexOf(typeName);
        if (tIdx !== -1) {
          ret[tIdx] = /* @__PURE__ */ React.cloneElement(item, _objectSpread$1(_objectSpread$1({}, item.props), {}, {
            as: null
          }));
        }
      } else if (typeofIs === "string") {
        var sIdx = strTypes.indexOf(is);
        if (sIdx !== -1) {
          ret[sIdx] = item;
        }
      }
    }
  });
  return ret;
};
var getComponentName = function getComponentName2(component) {
  if (typeof component === "string") {
    return component;
  }
  if ("type" in component) {
    var componentType = _typeof$f(component.type);
    if (componentType === "function" || componentType === "object") {
      if ("displayName" in component.type) {
        return component.type.displayName;
      }
      if ("name" in component.type) {
        return component.type.name;
      }
    } else if (componentType === "string") {
      return component.type;
    }
    return "undefined";
  }
  return "undefined";
};
var allowedChildren = function allowedChildren2(allowedTypes) {
  return function(props, propName, componentName) {
    var allowedTypesAsStrings = allowedTypes.map(function(t2) {
      return t2.name || t2.displayName;
    });
    var forbidden = React.Children.toArray(props[propName]).find(function(item) {
      if (typeof item === "string" && item.trim().length === 0) {
        return false;
      }
      if (allowedTypes.indexOf(item.type) === -1) {
        var _item$props3, _item$props4;
        var is = (item === null || item === void 0 ? void 0 : (_item$props3 = item.props) === null || _item$props3 === void 0 ? void 0 : _item$props3.as) || (item === null || item === void 0 ? void 0 : (_item$props4 = item.props) === null || _item$props4 === void 0 ? void 0 : _item$props4.is);
        var typeofIs = _typeof$f(is);
        if (typeofIs === "function") {
          return allowedTypes.indexOf(is) === -1;
        } else if (typeofIs === "object") {
          var typeName2 = is.name || is.displayName;
          return allowedTypesAsStrings.indexOf(typeName2) === -1;
        } else if (typeofIs === "string") {
          return allowedTypesAsStrings.indexOf(is) === -1;
        } else {
          return true;
        }
      }
      return void 0;
    });
    if (typeof forbidden !== "undefined") {
      var typeName = getComponentName(forbidden);
      var allowedNames = allowedTypes.map(function(t2) {
        return t2.name || t2.displayName;
      }).join(", ");
      var errMessage = '"'.concat(typeName, '" is not a valid child for ').concat(componentName, ". Allowed types: ").concat(allowedNames);
      return new Error(errMessage);
    }
  };
};
var _excluded$u = ["children", "size", "className", "max", "activeIndex", "hoverToFront"];
function _extends$t() {
  _extends$t = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$t.apply(this, arguments);
}
function _objectWithoutProperties$u(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$u(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$u(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var AvatarGroup = function AvatarGroup2(_ref2) {
  var children = _ref2.children, _ref$size = _ref2.size, size2 = _ref$size === void 0 ? "md" : _ref$size, className = _ref2.className, max2 = _ref2.max, activeIndex = _ref2.activeIndex, hoverToFront = _ref2.hoverToFront, rest = _objectWithoutProperties$u(_ref2, _excluded$u);
  var cName2 = "".concat(prefix, "-avatar-group");
  var avatars = typeof max2 === "number" && React.Children.count(children) > max2 ? React.Children.toArray(children).reverse().slice(0, max2) : React.Children.toArray(children).reverse();
  var reversedActiveIndex = typeof activeIndex === "number" ? avatars.length - activeIndex - 1 : void 0;
  return /* @__PURE__ */ React.createElement("div", _extends$t({}, rest, {
    className: classNames(cName2, "".concat(cName2, "--").concat(size2), className)
  }), avatars.map(function(a, i) {
    var newProps = typeof reversedActiveIndex === "number" ? {
      active: reversedActiveIndex === i
    } : {};
    if (hoverToFront === true) {
      newProps.className = classNames("".concat(prefix, "-avatar--active-on-hover"), a.props.className);
    }
    return /* @__PURE__ */ React.cloneElement(a, newProps);
  }));
};
AvatarGroup.displayName = "AvatarGroup";
var _excluded$t = ["children", "className", "icon", "border", "labelPosition"];
function _extends$s() {
  _extends$s = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$s.apply(this, arguments);
}
function _objectWithoutProperties$t(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$t(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$t(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Button = function Button22(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$icon = _ref2.icon, icon2 = _ref$icon === void 0 ? void 0 : _ref$icon, _ref$border = _ref2.border, border = _ref$border === void 0 ? false : _ref$border, _ref$labelPosition = _ref2.labelPosition, labelPosition = _ref$labelPosition === void 0 ? void 0 : _ref$labelPosition, rest = _objectWithoutProperties$t(_ref2, _excluded$t);
  var cName2 = "".concat(prefix, "-button");
  var lPos = typeof labelPosition !== "undefined" ? labelPosition : "right";
  var labelPositionClassName = React.Children.count(children) > 0 ? "".concat(cName2, "--").concat(lPos) : "";
  var borderClassName = border === true ? "".concat(cName2, "--border") : "";
  return /* @__PURE__ */ React.createElement("button", _extends$s({}, rest, {
    className: classNames(cName2, labelPositionClassName, borderClassName, className)
  }), lPos === "left" && children, icon2, lPos === "right" && children);
};
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
function _typeof$e(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$e = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$e = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$e(obj);
}
function _classCallCheck$4(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
  return Constructor;
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$c(target, key, source[key]);
    });
  }
  return target;
}
function _slicedToArray$7(arr2, i) {
  return _arrayWithHoles$7(arr2) || _iterableToArrayLimit$7(arr2, i) || _nonIterableRest$7();
}
function _arrayWithHoles$7(arr2) {
  if (Array.isArray(arr2)) return arr2;
}
function _iterableToArrayLimit$7(arr2, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr2[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _nonIterableRest$7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
var noop = function noop22() {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop,
  measure: noop
};
try {
  if (typeof window !== "undefined") _WINDOW = window;
  if (typeof document !== "undefined") _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined") _PERFORMANCE = performance;
} catch (e2) {
}
var _ref = _WINDOW.navigator || {}, _ref$userAgent = _ref.userAgent, userAgent = _ref$userAgent === void 0 ? "" : _ref$userAgent;
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var PERFORMANCE = _PERFORMANCE;
!!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var DEFAULT_FAMILY_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
(function() {
  try {
    return true;
  } catch (e2) {
    return false;
  }
})();
var DUOTONE_CLASSES = {
  GROUP: "group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "") return true;
  if (val === "false") return false;
  if (val === "true") return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  var attrs = [["data-family-prefix", "familyPrefix"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach(function(_ref2) {
    var _ref22 = _slicedToArray$7(_ref2, 2), attr = _ref22[0], key = _ref22[1];
    var val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var _default = {
  familyPrefix: DEFAULT_FAMILY_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
var _config = _objectSpread({}, _default, initial);
if (!_config.autoReplaceSvg) _config.observeMutations = false;
var config = _objectSpread({}, _config);
WINDOW.FontAwesomeConfig = config;
var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];
var functions = [];
var listener = function listener2() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener2);
  loaded = 1;
  functions.map(function(fn) {
    return fn();
  });
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", listener);
}
var PENDING = "pending";
var SETTLED = "settled";
var FULFILLED = "fulfilled";
var REJECTED = "rejected";
var NOOP = function NOOP2() {
};
var isNode = typeof global !== "undefined" && typeof global.process !== "undefined" && typeof global.process.emit === "function";
var asyncSetTimer = typeof setImmediate === "undefined" ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;
function asyncFlush() {
  for (var i = 0; i < asyncQueue.length; i++) {
    asyncQueue[i][0](asyncQueue[i][1]);
  }
  asyncQueue = [];
  asyncTimer = false;
}
function asyncCall(callback, arg) {
  asyncQueue.push([callback, arg]);
  if (!asyncTimer) {
    asyncTimer = true;
    asyncSetTimer(asyncFlush, 0);
  }
}
function invokeResolver(resolver, promise) {
  function resolvePromise(value) {
    resolve(promise, value);
  }
  function rejectPromise(reason) {
    reject(promise, reason);
  }
  try {
    resolver(resolvePromise, rejectPromise);
  } catch (e2) {
    rejectPromise(e2);
  }
}
function invokeCallback(subscriber) {
  var owner = subscriber.owner;
  var settled = owner._state;
  var value = owner._data;
  var callback = subscriber[settled];
  var promise = subscriber.then;
  if (typeof callback === "function") {
    settled = FULFILLED;
    try {
      value = callback(value);
    } catch (e2) {
      reject(promise, e2);
    }
  }
  if (!handleThenable(promise, value)) {
    if (settled === FULFILLED) {
      resolve(promise, value);
    }
    if (settled === REJECTED) {
      reject(promise, value);
    }
  }
}
function handleThenable(promise, value) {
  var resolved;
  try {
    if (promise === value) {
      throw new TypeError("A promises callback cannot return that same promise.");
    }
    if (value && (typeof value === "function" || _typeof$e(value) === "object")) {
      var then2 = value.then;
      if (typeof then2 === "function") {
        then2.call(value, function(val) {
          if (!resolved) {
            resolved = true;
            if (value === val) {
              fulfill(promise, val);
            } else {
              resolve(promise, val);
            }
          }
        }, function(reason) {
          if (!resolved) {
            resolved = true;
            reject(promise, reason);
          }
        });
        return true;
      }
    }
  } catch (e2) {
    if (!resolved) {
      reject(promise, e2);
    }
    return true;
  }
  return false;
}
function resolve(promise, value) {
  if (promise === value || !handleThenable(promise, value)) {
    fulfill(promise, value);
  }
}
function fulfill(promise, value) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = value;
    asyncCall(publishFulfillment, promise);
  }
}
function reject(promise, reason) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = reason;
    asyncCall(publishRejection, promise);
  }
}
function publish(promise) {
  promise._then = promise._then.forEach(invokeCallback);
}
function publishFulfillment(promise) {
  promise._state = FULFILLED;
  publish(promise);
}
function publishRejection(promise) {
  promise._state = REJECTED;
  publish(promise);
  if (!promise._handled && isNode) {
    global.process.emit("unhandledRejection", promise._data, promise);
  }
}
function notifyRejectionHandled(promise) {
  global.process.emit("rejectionHandled", promise);
}
function P(resolver) {
  if (typeof resolver !== "function") {
    throw new TypeError("Promise resolver " + resolver + " is not a function");
  }
  if (this instanceof P === false) {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }
  this._then = [];
  invokeResolver(resolver, this);
}
P.prototype = {
  constructor: P,
  _state: PENDING,
  _then: null,
  _data: void 0,
  _handled: false,
  then: function then(onFulfillment, onRejection) {
    var subscriber = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: onFulfillment,
      rejected: onRejection
    };
    if ((onRejection || onFulfillment) && !this._handled) {
      this._handled = true;
      if (this._state === REJECTED && isNode) {
        asyncCall(notifyRejectionHandled, this);
      }
    }
    if (this._state === FULFILLED || this._state === REJECTED) {
      asyncCall(invokeCallback, subscriber);
    } else {
      this._then.push(subscriber);
    }
    return subscriber.then;
  },
  catch: function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};
P.all = function(promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError("You must pass an array to Promise.all().");
  }
  return new P(function(resolve2, reject2) {
    var results = [];
    var remaining = 0;
    function resolver(index) {
      remaining++;
      return function(value) {
        results[index] = value;
        if (!--remaining) {
          resolve2(results);
        }
      };
    }
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];
      if (promise && typeof promise.then === "function") {
        promise.then(resolver(i), reject2);
      } else {
        results[i] = promise;
      }
    }
    if (!remaining) {
      resolve2(results);
    }
  });
};
P.race = function(promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError("You must pass an array to Promise.race().");
  }
  return new P(function(resolve2, reject2) {
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];
      if (promise && typeof promise.then === "function") {
        promise.then(resolve2, reject2);
      } else {
        resolve2(promise);
      }
    }
  });
};
P.resolve = function(value) {
  if (value && _typeof$e(value) === "object" && value.constructor === P) {
    return value;
  }
  return new P(function(resolve2) {
    resolve2(value);
  });
};
P.reject = function(reason) {
  return new P(function(resolve2, reject2) {
    reject2(reason);
  });
};
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css2) {
  if (!css2 || !IS_DOM) {
    return;
  }
  var style = DOCUMENT.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css2;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;
  for (var i = headChildren.length - 1; i > -1; i--) {
    var child = headChildren[i];
    var tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style, beforeChild);
  return css2;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  var size2 = 12;
  var id2 = "";
  while (size2-- > 0) {
    id2 += idPool[Math.random() * 62 | 0];
  }
  return id2;
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function(acc, attributeName) {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce(function(acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName], ";");
  }, "");
}
function transformIsMeaningful(transform2) {
  return transform2.size !== meaninglessTransform.size || transform2.x !== meaninglessTransform.x || transform2.y !== meaninglessTransform.y || transform2.rotate !== meaninglessTransform.rotate || transform2.flipX || transform2.flipY;
}
function transformForSvg(_ref2) {
  var transform2 = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
  var innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path2 = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path: path2
  };
}
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
function makeIconMasking(_ref2) {
  var children = _ref2.children, attributes = _ref2.attributes, main = _ref2.main, mask = _ref2.mask, explicitMaskId = _ref2.maskId, transform2 = _ref2.transform;
  var mainWidth = main.width, mainPath = main.icon;
  var maskWidth = mask.width, maskPath = mask.icon;
  var trans = transformForSvg({
    transform: transform2,
    containerWidth: maskWidth,
    iconWidth: mainWidth
  });
  var maskRect = {
    tag: "rect",
    attributes: _objectSpread({}, ALL_SPACE, {
      fill: "white"
    })
  };
  var maskInnerGroupChildrenMixin = mainPath.children ? {
    children: mainPath.children.map(fillBlack)
  } : {};
  var maskInnerGroup = {
    tag: "g",
    attributes: _objectSpread({}, trans.inner),
    children: [fillBlack(_objectSpread({
      tag: mainPath.tag,
      attributes: _objectSpread({}, mainPath.attributes, trans.path)
    }, maskInnerGroupChildrenMixin))]
  };
  var maskOuterGroup = {
    tag: "g",
    attributes: _objectSpread({}, trans.outer),
    children: [maskInnerGroup]
  };
  var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
  var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
  var maskTag = {
    tag: "mask",
    attributes: _objectSpread({}, ALL_SPACE, {
      id: maskId,
      maskUnits: "userSpaceOnUse",
      maskContentUnits: "userSpaceOnUse"
    }),
    children: [maskRect, maskOuterGroup]
  };
  var defs = {
    tag: "defs",
    children: [{
      tag: "clipPath",
      attributes: {
        id: clipId
      },
      children: deGroup(maskPath)
    }, maskTag]
  };
  children.push(defs, {
    tag: "rect",
    attributes: _objectSpread({
      fill: "currentColor",
      "clip-path": "url(#".concat(clipId, ")"),
      mask: "url(#".concat(maskId, ")")
    }, ALL_SPACE)
  });
  return {
    children,
    attributes
  };
}
function makeIconStandard(_ref2) {
  var children = _ref2.children, attributes = _ref2.attributes, main = _ref2.main, transform2 = _ref2.transform, styles2 = _ref2.styles;
  var styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  if (transformIsMeaningful(transform2)) {
    var trans = transformForSvg({
      transform: transform2,
      containerWidth: main.width,
      iconWidth: main.width
    });
    children.push({
      tag: "g",
      attributes: _objectSpread({}, trans.outer),
      children: [{
        tag: "g",
        attributes: _objectSpread({}, trans.inner),
        children: [{
          tag: main.icon.tag,
          children: main.icon.children,
          attributes: _objectSpread({}, main.icon.attributes, trans.path)
        }]
      }]
    });
  } else {
    children.push(main.icon);
  }
  return {
    children,
    attributes
  };
}
function asIcon(_ref2) {
  var children = _ref2.children, main = _ref2.main, mask = _ref2.mask, attributes = _ref2.attributes, styles2 = _ref2.styles, transform2 = _ref2.transform;
  if (transformIsMeaningful(transform2) && main.found && !mask.found) {
    var width = main.width, height = main.height;
    var offset2 = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles(_objectSpread({}, styles2, {
      "transform-origin": "".concat(offset2.x + transform2.x / 16, "em ").concat(offset2.y + transform2.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes,
    children
  }];
}
function asSymbol(_ref2) {
  var prefix2 = _ref2.prefix, iconName = _ref2.iconName, children = _ref2.children, attributes = _ref2.attributes, symbol = _ref2.symbol;
  var id2 = symbol === true ? "".concat(prefix2, "-").concat(config.familyPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: _objectSpread({}, attributes, {
        id: id2
      }),
      children
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons, main = _params$icons.main, mask = _params$icons.mask, prefix2 = params.prefix, iconName = params.iconName, transform2 = params.transform, symbol = params.symbol, title = params.title, maskId = params.maskId, titleId = params.titleId, extra = params.extra, _params$watchable = params.watchable, watchable = _params$watchable === void 0 ? false : _params$watchable;
  var _ref2 = mask.found ? mask : main, width = _ref2.width, height = _ref2.height;
  var isUploadedIcon = prefix2 === "fak";
  var widthClass = isUploadedIcon ? "" : "fa-w-".concat(Math.ceil(width / height * 16));
  var attrClass = [config.replacementClass, iconName ? "".concat(config.familyPrefix, "-").concat(iconName) : "", widthClass].filter(function(c2) {
    return extra.classes.indexOf(c2) === -1;
  }).filter(function(c2) {
    return c2 !== "" || !!c2;
  }).concat(extra.classes).join(" ");
  var content = {
    children: [],
    attributes: _objectSpread({}, extra.attributes, {
      "data-prefix": prefix2,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    })
  };
  var uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) content.children.push({
    tag: "title",
    attributes: {
      id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
    },
    children: [title]
  });
  var args = _objectSpread({}, content, {
    prefix: prefix2,
    iconName,
    main,
    mask,
    maskId,
    transform: transform2,
    symbol,
    styles: _objectSpread({}, uploadedIconWidthStyle, extra.styles)
  });
  var _ref22 = mask.found && main.found ? makeIconMasking(args) : makeIconStandard(args), children = _ref22.children, attributes = _ref22.attributes;
  args.children = children;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {};
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject), length2 = keys.length, iterator3 = fn, i, key, result;
  if (initialValue === void 0) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }
  for (; i < length2; i++) {
    key = keys[i];
    result = iterator3(result, subject[key], key, subject);
  }
  return result;
};
function defineIcons(prefix2, icons) {
  var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks, skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = Object.keys(icons).reduce(function(acc, iconName) {
    var icon2 = icons[iconName];
    var expanded = !!icon2.icon;
    if (expanded) {
      acc[icon2.iconName] = icon2.icon;
    } else {
      acc[iconName] = icon2;
    }
    return acc;
  }, {});
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix2, normalized);
  } else {
    namespace.styles[prefix2] = _objectSpread({}, namespace.styles[prefix2] || {}, normalized);
  }
  if (prefix2 === "fas") {
    defineIcons("fa", icons);
  }
}
var styles = namespace.styles, shims = namespace.shims;
var build = function build2() {
  var lookup = function lookup2(reducer) {
    return reduce(styles, function(o, style, prefix2) {
      o[prefix2] = reduce(style, reducer, {});
      return o;
    }, {});
  };
  lookup(function(acc, icon2, iconName) {
    if (icon2[3]) {
      acc[icon2[3]] = iconName;
    }
    return acc;
  });
  lookup(function(acc, icon2, iconName) {
    var ligatures = icon2[2];
    acc[iconName] = iconName;
    ligatures.forEach(function(ligature) {
      acc[ligature] = iconName;
    });
    return acc;
  });
  var hasRegular = "far" in styles;
  reduce(shims, function(acc, shim) {
    var oldName = shim[0];
    var prefix2 = shim[1];
    var iconName = shim[2];
    if (prefix2 === "far" && !hasRegular) {
      prefix2 = "fas";
    }
    acc[oldName] = {
      prefix: prefix2,
      iconName
    };
    return acc;
  }, {});
};
build();
namespace.styles;
function iconFromMapping(mapping, prefix2, iconName) {
  if (mapping && mapping[prefix2] && mapping[prefix2][iconName]) {
    return {
      prefix: prefix2,
      iconName,
      icon: mapping[prefix2][iconName]
    };
  }
}
function toHtml(abstractNodes) {
  var tag = abstractNodes.tag, _abstractNodes$attrib = abstractNodes.attributes, attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib, _abstractNodes$childr = abstractNodes.children, children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
var parseTransformString = function parseTransformString2(transformString) {
  var transform2 = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  if (!transformString) {
    return transform2;
  } else {
    return transformString.toLowerCase().split(" ").reduce(function(acc, n2) {
      var parts2 = n2.toLowerCase().split("-");
      var first2 = parts2[0];
      var rest = parts2.slice(1).join("-");
      if (first2 && rest === "h") {
        acc.flipX = true;
        return acc;
      }
      if (first2 && rest === "v") {
        acc.flipY = true;
        return acc;
      }
      rest = parseFloat(rest);
      if (isNaN(rest)) {
        return acc;
      }
      switch (first2) {
        case "grow":
          acc.size = acc.size + rest;
          break;
        case "shrink":
          acc.size = acc.size - rest;
          break;
        case "left":
          acc.x = acc.x - rest;
          break;
        case "right":
          acc.x = acc.x + rest;
          break;
        case "up":
          acc.y = acc.y - rest;
          break;
        case "down":
          acc.y = acc.y + rest;
          break;
        case "rotate":
          acc.rotate = acc.rotate + rest;
          break;
      }
      return acc;
    }, transform2);
  }
};
function MissingIcon(error2) {
  this.name = "MissingIcon";
  this.message = error2 || "Icon unavailable";
  this.stack = new Error().stack;
}
MissingIcon.prototype = Object.create(Error.prototype);
MissingIcon.prototype.constructor = MissingIcon;
var FILL = {
  fill: "currentColor"
};
var ANIMATION_BASE = {
  attributeType: "XML",
  repeatCount: "indefinite",
  dur: "2s"
};
({
  attributes: _objectSpread({}, FILL, {
    d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
  })
});
var OPACITY_ANIMATE = _objectSpread({}, ANIMATION_BASE, {
  attributeName: "opacity"
});
({
  attributes: _objectSpread({}, FILL, {
    cx: "256",
    cy: "364",
    r: "28"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, ANIMATION_BASE, {
      attributeName: "r",
      values: "28;14;28;28;14;28;"
    })
  }, {
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "1;0;1;1;0;1;"
    })
  }]
});
({
  attributes: _objectSpread({}, FILL, {
    opacity: "1",
    d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "1;0;0;0;0;1;"
    })
  }]
});
({
  attributes: _objectSpread({}, FILL, {
    opacity: "0",
    d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "0;0;1;1;0;0;"
    })
  }]
});
namespace.styles;
function asFoundIcon(icon2) {
  var width = icon2[0];
  var height = icon2[1];
  var _icon$slice = icon2.slice(4), _icon$slice2 = _slicedToArray$7(_icon$slice, 1), vectorData = _icon$slice2[0];
  var element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
namespace.styles;
var baseStyles = 'svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse {\n  color: #fff;\n}';
function css() {
  var dfp = DEFAULT_FAMILY_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.familyPrefix;
  var rc2 = config.replacementClass;
  var s = baseStyles;
  if (fp !== dfp || rc2 !== drc) {
    var dPatt = new RegExp("\\.".concat(dfp, "\\-"), "g");
    var customPropPatt = new RegExp("\\--".concat(dfp, "\\-"), "g");
    var rPatt = new RegExp("\\.".concat(drc), "g");
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc2));
  }
  return s;
}
var Library = /* @__PURE__ */ function() {
  function Library2() {
    _classCallCheck$4(this, Library2);
    this.definitions = {};
  }
  _createClass$4(Library2, [{
    key: "add",
    value: function add2() {
      var _this = this;
      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }
      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function(key) {
        _this.definitions[key] = _objectSpread({}, _this.definitions[key] || {}, additions[key]);
        defineIcons(key, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function(key) {
        var _normalized$key = normalized[key], prefix2 = _normalized$key.prefix, iconName = _normalized$key.iconName, icon2 = _normalized$key.icon;
        if (!additions[prefix2]) additions[prefix2] = {};
        additions[prefix2][iconName] = icon2;
      });
      return additions;
    }
  }]);
  return Library2;
}();
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
function apiObject(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function get2() {
      return val.abstract.map(function(a) {
        return toHtml(a);
      });
    }
  });
  Object.defineProperty(val, "node", {
    get: function get2() {
      if (!IS_DOM) return;
      var container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function findIconDefinition(iconLookup) {
  var _iconLookup$prefix = iconLookup.prefix, prefix2 = _iconLookup$prefix === void 0 ? "fa" : _iconLookup$prefix, iconName = iconLookup.iconName;
  if (!iconName) return;
  return iconFromMapping(library.definitions, prefix2, iconName) || iconFromMapping(namespace.styles, prefix2, iconName);
}
function resolveIcons(next2) {
  return function(maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next2(iconDefinition, _objectSpread({}, params, {
      mask
    }));
  };
}
var library = new Library();
var _cssInserted = false;
var parse = {
  transform: function transform(transformString) {
    return parseTransformString(transformString);
  }
};
var icon = resolveIcons(function(iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$transform = params.transform, transform2 = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$symbol = params.symbol, symbol = _params$symbol === void 0 ? false : _params$symbol, _params$mask = params.mask, mask = _params$mask === void 0 ? null : _params$mask, _params$maskId = params.maskId, maskId = _params$maskId === void 0 ? null : _params$maskId, _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$titleId = params.titleId, titleId = _params$titleId === void 0 ? null : _params$titleId, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition) return;
  var prefix2 = iconDefinition.prefix, iconName = iconDefinition.iconName, icon2 = iconDefinition.icon;
  return apiObject(_objectSpread({
    type: "icon"
  }, iconDefinition), function() {
    ensureCss();
    if (config.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon2),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix2,
      iconName,
      transform: _objectSpread({}, meaninglessTransform, transform2),
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
});
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty$b(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$d(obj);
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose$s(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties$s(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$s(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr2) {
  return _arrayWithoutHoles(arr2) || _iterableToArray(arr2) || _unsupportedIterableToArray$7(arr2) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr2) {
  if (Array.isArray(arr2)) return _arrayLikeToArray$7(arr2);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) arr22[i] = arr2[i];
  return arr22;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function classList(props) {
  var _classes;
  var beat = props.beat, fade = props.fade, beatFade = props.beatFade, bounce = props.bounce, shake = props.shake, flash = props.flash, spin = props.spin, spinPulse = props.spinPulse, spinReverse = props.spinReverse, pulse = props.pulse, fixedWidth = props.fixedWidth, inverse = props.inverse, border = props.border, listItem = props.listItem, flip2 = props.flip, size2 = props.size, rotation = props.rotation, pull = props.pull;
  var classes = (_classes = {
    "fa-beat": beat,
    "fa-fade": fade,
    "fa-beat-fade": beatFade,
    "fa-bounce": bounce,
    "fa-shake": shake,
    "fa-flash": flash,
    "fa-spin": spin,
    "fa-spin-reverse": spinReverse,
    "fa-spin-pulse": spinPulse,
    "fa-pulse": pulse,
    "fa-fw": fixedWidth,
    "fa-inverse": inverse,
    "fa-border": border,
    "fa-li": listItem,
    "fa-flip": flip2 === true,
    "fa-flip-horizontal": flip2 === "horizontal" || flip2 === "both",
    "fa-flip-vertical": flip2 === "vertical" || flip2 === "both"
  }, _defineProperty$b(_classes, "fa-".concat(size2), typeof size2 !== "undefined" && size2 !== null), _defineProperty$b(_classes, "fa-rotate-".concat(rotation), typeof rotation !== "undefined" && rotation !== null && rotation !== 0), _defineProperty$b(_classes, "fa-pull-".concat(pull), typeof pull !== "undefined" && pull !== null), _defineProperty$b(_classes, "fa-swap-opacity", props.swapOpacity), _classes);
  return Object.keys(classes).map(function(key) {
    return classes[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
function _isNumerical(obj) {
  obj = obj - 0;
  return obj === obj;
}
function camelize(string) {
  if (_isNumerical(string)) {
    return string;
  }
  string = string.replace(/[\-_\s]+(.)?/g, function(match2, chr) {
    return chr ? chr.toUpperCase() : "";
  });
  return string.substr(0, 1).toLowerCase() + string.substr(1);
}
var _excluded$1$1 = ["style"];
function capitalize(val) {
  return val.charAt(0).toUpperCase() + val.slice(1);
}
function styleToObject(style) {
  return style.split(";").map(function(s) {
    return s.trim();
  }).filter(function(s) {
    return s;
  }).reduce(function(acc, pair) {
    var i = pair.indexOf(":");
    var prop = camelize(pair.slice(0, i));
    var value = pair.slice(i + 1).trim();
    prop.startsWith("webkit") ? acc[capitalize(prop)] = value : acc[prop] = value;
    return acc;
  }, {});
}
function convert(createElement, element) {
  var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof element === "string") {
    return element;
  }
  var children = (element.children || []).map(function(child) {
    return convert(createElement, child);
  });
  var mixins = Object.keys(element.attributes || {}).reduce(function(acc, key) {
    var val = element.attributes[key];
    switch (key) {
      case "class":
        acc.attrs["className"] = val;
        delete element.attributes["class"];
        break;
      case "style":
        acc.attrs["style"] = styleToObject(val);
        break;
      default:
        if (key.indexOf("aria-") === 0 || key.indexOf("data-") === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }
    }
    return acc;
  }, {
    attrs: {}
  });
  var _extraProps$style = extraProps.style, existingStyle = _extraProps$style === void 0 ? {} : _extraProps$style, remaining = _objectWithoutProperties$s(extraProps, _excluded$1$1);
  mixins.attrs["style"] = _objectSpread2(_objectSpread2({}, mixins.attrs["style"]), existingStyle);
  return createElement.apply(void 0, [element.tag, _objectSpread2(_objectSpread2({}, mixins.attrs), remaining)].concat(_toConsumableArray(children)));
}
var PRODUCTION = false;
try {
  PRODUCTION = true;
} catch (e2) {
}
function log() {
  if (!PRODUCTION && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function normalizeIconArgs(icon2) {
  if (icon2 && _typeof$d(icon2) === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
    return icon2;
  }
  if (parse.icon) {
    return parse.icon(icon2);
  }
  if (icon2 === null) {
    return null;
  }
  if (icon2 && _typeof$d(icon2) === "object" && icon2.prefix && icon2.iconName) {
    return icon2;
  }
  if (Array.isArray(icon2) && icon2.length === 2) {
    return {
      prefix: icon2[0],
      iconName: icon2[1]
    };
  }
  if (typeof icon2 === "string") {
    return {
      prefix: "fas",
      iconName: icon2
    };
  }
}
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty$b({}, key, value) : {};
}
var _excluded$s = ["forwardedRef"];
function FontAwesomeIcon(_ref2) {
  var forwardedRef = _ref2.forwardedRef, props = _objectWithoutProperties$s(_ref2, _excluded$s);
  var iconArgs = props.icon, maskArgs = props.mask, symbol = props.symbol, className = props.className, title = props.title, titleId = props.titleId, maskId = props.maskId;
  var iconLookup = normalizeIconArgs(iconArgs);
  var classes = objectWithKey("classes", [].concat(_toConsumableArray(classList(props)), _toConsumableArray(className.split(" "))));
  var transform2 = objectWithKey("transform", typeof props.transform === "string" ? parse.transform(props.transform) : props.transform);
  var mask = objectWithKey("mask", normalizeIconArgs(maskArgs));
  var renderedIcon = icon(iconLookup, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes), transform2), mask), {}, {
    symbol,
    title,
    titleId,
    maskId
  }));
  if (!renderedIcon) {
    log("Could not find icon", iconLookup);
    return null;
  }
  var abstract = renderedIcon.abstract;
  var extraProps = {
    ref: forwardedRef
  };
  Object.keys(props).forEach(function(key) {
    if (!FontAwesomeIcon.defaultProps.hasOwnProperty(key)) {
      extraProps[key] = props[key];
    }
  });
  return convertCurry(abstract[0], extraProps);
}
FontAwesomeIcon.displayName = "FontAwesomeIcon";
FontAwesomeIcon.propTypes = {
  beat: PropTypes.bool,
  border: PropTypes.bool,
  beatFade: PropTypes.bool,
  bounce: PropTypes.bool,
  className: PropTypes.string,
  fade: PropTypes.bool,
  flash: PropTypes.bool,
  mask: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.string]),
  maskId: PropTypes.string,
  fixedWidth: PropTypes.bool,
  inverse: PropTypes.bool,
  flip: PropTypes.oneOf([true, false, "horizontal", "vertical", "both"]),
  icon: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.string]),
  listItem: PropTypes.bool,
  pull: PropTypes.oneOf(["right", "left"]),
  pulse: PropTypes.bool,
  rotation: PropTypes.oneOf([0, 90, 180, 270]),
  shake: PropTypes.bool,
  size: PropTypes.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: PropTypes.bool,
  spinPulse: PropTypes.bool,
  spinReverse: PropTypes.bool,
  symbol: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  title: PropTypes.string,
  titleId: PropTypes.string,
  transform: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  swapOpacity: PropTypes.bool
};
FontAwesomeIcon.defaultProps = {
  border: false,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: false,
  inverse: false,
  flip: false,
  icon: null,
  listItem: false,
  pull: null,
  pulse: false,
  rotation: null,
  size: null,
  spin: false,
  spinPulse: false,
  spinReverse: false,
  beat: false,
  fade: false,
  beatFade: false,
  bounce: false,
  shake: false,
  symbol: false,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: false
};
var convertCurry = convert.bind(null, React.createElement);
var faArrowUp = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "arrow-up";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f062";
  var svgPathData = "M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faArrowUp = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faArrowUp);
var faArrowRight = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "arrow-right";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f061";
  var svgPathData = "M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faArrowRight = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faArrowRight);
var faArrowDown = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "arrow-down";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f063";
  var svgPathData = "M413.1 222.5l22.2 22.2c9.4 9.4 9.4 24.6 0 33.9L241 473c-9.4 9.4-24.6 9.4-33.9 0L12.7 278.6c-9.4-9.4-9.4-24.6 0-33.9l22.2-22.2c9.5-9.5 25-9.3 34.3.4L184 343.4V56c0-13.3 10.7-24 24-24h32c13.3 0 24 10.7 24 24v287.4l114.8-120.5c9.3-9.8 24.8-10 34.3-.4z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faArrowDown = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faArrowDown);
var faArrowLeft = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "arrow-left";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f060";
  var svgPathData = "M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faArrowLeft = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faArrowLeft);
var _excluded$r = ["className", "direction", "children"];
function _extends$r() {
  _extends$r = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$r.apply(this, arguments);
}
function _objectWithoutProperties$r(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$r(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$r(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ArrowButton = function ArrowButton2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$direction = _ref2.direction, direction = _ref$direction === void 0 ? "right" : _ref$direction, children = _ref2.children, rest = _objectWithoutProperties$r(_ref2, _excluded$r);
  var cName2 = "".concat(prefix, "-button--arrow");
  var icon2 = function() {
    if (direction === "up") {
      return faArrowUp.faArrowUp;
    } else if (direction === "right") {
      return faArrowRight.faArrowRight;
    } else if (direction === "down") {
      return faArrowDown.faArrowDown;
    } else if (direction === "left") {
      return faArrowLeft.faArrowLeft;
    }
  }();
  return /* @__PURE__ */ React.createElement(Button, _extends$r({}, rest, {
    className: classNames(cName2, className),
    icon: /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
      icon: icon2
    })
  }), children);
};
var faEllipsisV = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "ellipsis-v";
  var width = 192;
  var height = 512;
  var ligatures = [];
  var unicode = "f142";
  var svgPathData = "M96 184c39.8 0 72 32.2 72 72s-32.2 72-72 72-72-32.2-72-72 32.2-72 72-72zM24 80c0 39.8 32.2 72 72 72s72-32.2 72-72S135.8 8 96 8 24 40.2 24 80zm0 352c0 39.8 32.2 72 72 72s72-32.2 72-72-32.2-72-72-72-72 32.2-72 72z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faEllipsisV = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faEllipsisV);
var faPaperPlane = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "paper-plane";
  var width = 512;
  var height = 512;
  var ligatures = [];
  var unicode = "f1d8";
  var svgPathData = "M476 3.2L12.5 270.6c-18.1 10.4-15.8 35.6 2.2 43.2L121 358.4l287.3-253.2c5.5-4.9 13.3 2.6 8.6 8.3L176 407v80.5c0 23.6 28.5 32.9 42.5 15.8L282 426l124.6 52.2c14.2 6 30.4-2.9 33-18.2l72-432C515 7.8 493.3-6.8 476 3.2z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faPaperPlane = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faPaperPlane);
var _excluded$q = ["className", "children"];
function _extends$q() {
  _extends$q = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$q.apply(this, arguments);
}
function _objectWithoutProperties$q(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$q(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$q(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var SendButton = function SendButton2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, children = _ref2.children, rest = _objectWithoutProperties$q(_ref2, _excluded$q);
  var cName2 = "".concat(prefix, "-button--send");
  return /* @__PURE__ */ React.createElement(Button, _extends$q({}, rest, {
    className: classNames(cName2, className),
    icon: /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
      icon: faPaperPlane.faPaperPlane
    })
  }), children);
};
var faPaperclip = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var prefix2 = "fas";
  var iconName = "paperclip";
  var width = 448;
  var height = 512;
  var ligatures = [];
  var unicode = "f0c6";
  var svgPathData = "M43.246 466.142c-58.43-60.289-57.341-157.511 1.386-217.581L254.392 34c44.316-45.332 116.351-45.336 160.671 0 43.89 44.894 43.943 117.329 0 162.276L232.214 383.128c-29.855 30.537-78.633 30.111-107.982-.998-28.275-29.97-27.368-77.473 1.452-106.953l143.743-146.835c6.182-6.314 16.312-6.422 22.626-.241l22.861 22.379c6.315 6.182 6.422 16.312.241 22.626L171.427 319.927c-4.932 5.045-5.236 13.428-.648 18.292 4.372 4.634 11.245 4.711 15.688.165l182.849-186.851c19.613-20.062 19.613-52.725-.011-72.798-19.189-19.627-49.957-19.637-69.154 0L90.39 293.295c-34.763 35.56-35.299 93.12-1.191 128.313 34.01 35.093 88.985 35.137 123.058.286l172.06-175.999c6.177-6.319 16.307-6.433 22.626-.256l22.877 22.364c6.319 6.177 6.434 16.307.256 22.626l-172.06 175.998c-59.576 60.938-155.943 60.216-214.77-.485z";
  exports2.definition = {
    prefix: prefix2,
    iconName,
    icon: [
      width,
      height,
      ligatures,
      unicode,
      svgPathData
    ]
  };
  exports2.faPaperclip = exports2.definition;
  exports2.prefix = prefix2;
  exports2.iconName = iconName;
  exports2.width = width;
  exports2.height = height;
  exports2.ligatures = ligatures;
  exports2.unicode = unicode;
  exports2.svgPathData = svgPathData;
})(faPaperclip);
var _excluded$p = ["className", "children"];
function _extends$p() {
  _extends$p = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$p.apply(this, arguments);
}
function _objectWithoutProperties$p(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$p(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$p(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var AttachmentButton = function AttachmentButton2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, children = _ref2.children, rest = _objectWithoutProperties$p(_ref2, _excluded$p);
  var cName2 = "".concat(prefix, "-button--attachment");
  return /* @__PURE__ */ React.createElement(Button, _extends$p({}, rest, {
    className: classNames(cName2, className),
    icon: /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
      icon: faPaperclip.faPaperclip
    })
  }), children);
};
var _excluded$o = ["onClick", "children", "className"];
function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$o.apply(this, arguments);
}
function _objectWithoutProperties$o(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$o(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$o(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationHeaderBack = function ConversationHeaderBack2(_ref2) {
  var _ref$onClick = _ref2.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$o(_ref2, _excluded$o);
  var cName2 = "".concat(prefix, "-conversation-header__back");
  return /* @__PURE__ */ React.createElement("div", _extends$o({}, rest, {
    className: classNames(cName2, className)
  }), typeof children !== "undefined" ? children : /* @__PURE__ */ React.createElement(ArrowButton, {
    direction: "left",
    onClick
  }));
};
ConversationHeaderBack.displayName = "ConversationHeader.Back";
var _excluded$n = ["children", "className"];
function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$n.apply(this, arguments);
}
function _objectWithoutProperties$n(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$n(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$n(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationHeaderActions = function ConversationHeaderActions2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$n(_ref2, _excluded$n);
  var cName2 = "".concat(prefix, "-conversation-header__actions");
  return /* @__PURE__ */ React.createElement("section", _extends$n({}, rest, {
    className: classNames(cName2, className)
  }), children);
};
ConversationHeaderActions.displayName = "ConversationHeader.Actions";
var _excluded$m = ["userName", "info", "children", "className"];
function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$m.apply(this, arguments);
}
function _objectWithoutProperties$m(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$m(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$m(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationHeaderContent = function ConversationHeaderContent2(_ref2) {
  var _ref$userName = _ref2.userName, userName = _ref$userName === void 0 ? "" : _ref$userName, _ref$info = _ref2.info, info = _ref$info === void 0 ? "" : _ref$info, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$m(_ref2, _excluded$m);
  var cName2 = "".concat(prefix, "-conversation-header__content");
  return /* @__PURE__ */ React.createElement("div", _extends$m({}, rest, {
    className: classNames(cName2, className)
  }), typeof children !== "undefined" ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-conversation-header__user-name")
  }, userName), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-conversation-header__info")
  }, info)));
};
ConversationHeaderContent.displayName = "ConversationHeader.Content";
var _excluded$l = ["children", "className"];
function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$l.apply(this, arguments);
}
function _slicedToArray$6(arr2, i) {
  return _arrayWithHoles$6(arr2) || _iterableToArrayLimit$6(arr2, i) || _unsupportedIterableToArray$6(arr2, i) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) arr22[i] = arr2[i];
  return arr22;
}
function _iterableToArrayLimit$6(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a = [], f2 = true, o = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
    } catch (r22) {
      o = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles$6(arr2) {
  if (Array.isArray(arr2)) return arr2;
}
function _objectWithoutProperties$l(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$l(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$l(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationHeader = function ConversationHeader2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$l(_ref2, _excluded$l);
  var cName2 = "".concat(prefix, "-conversation-header");
  var _getChildren = getChildren(children, [ConversationHeaderBack, Avatar, AvatarGroup, ConversationHeaderContent, ConversationHeaderActions]), _getChildren2 = _slicedToArray$6(_getChildren, 5), back = _getChildren2[0], avatar = _getChildren2[1], avatarGroup = _getChildren2[2], content = _getChildren2[3], actions = _getChildren2[4];
  return /* @__PURE__ */ React.createElement("div", _extends$l({}, rest, {
    className: classNames(cName2, className)
  }), back, avatar && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__avatar")
  }, avatar), !avatar && avatarGroup && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__avatar")
  }, avatarGroup), content, actions);
};
ConversationHeader.displayName = "ConversationHeader";
ConversationHeader.Back = ConversationHeaderBack;
ConversationHeader.Actions = ConversationHeaderActions;
ConversationHeader.Content = ConversationHeaderContent;
/*!
 * perfect-scrollbar v1.5.0
 * Copyright 2020 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function get(element) {
  return getComputedStyle(element);
}
function set(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === "number") {
      val = val + "px";
    }
    element.style[key] = val;
  }
  return element;
}
function div(className) {
  var div2 = document.createElement("div");
  div2.className = className;
  return div2;
}
var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function matches(element, query) {
  if (!elMatches) {
    throw new Error("No element matching method supported");
  }
  return elMatches.call(element, query);
}
function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}
function queryChildren(element, selector) {
  return Array.prototype.filter.call(element.children, function(child) {
    return matches(child, selector);
  });
}
var cls = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function thumb(x2) {
      return "ps__thumb-" + x2;
    },
    rail: function rail(x2) {
      return "ps__rail-" + x2;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function active(x2) {
      return "ps--active-" + x2;
    },
    scrolling: function scrolling(x2) {
      return "ps--scrolling-" + x2;
    }
  }
};
var scrollingClassTimeout = {
  x: null,
  y: null
};
function addScrollingClass(i, x2) {
  var classList2 = i.element.classList;
  var className = cls.state.scrolling(x2);
  if (classList2.contains(className)) {
    clearTimeout(scrollingClassTimeout[x2]);
  } else {
    classList2.add(className);
  }
}
function removeScrollingClass(i, x2) {
  scrollingClassTimeout[x2] = setTimeout(function() {
    return i.isAlive && i.element.classList.remove(cls.state.scrolling(x2));
  }, i.settings.scrollingThreshold);
}
function setScrollingClassInstantly(i, x2) {
  addScrollingClass(i, x2);
  removeScrollingClass(i, x2);
}
var EventElement = function EventElement2(element) {
  this.element = element;
  this.handlers = {};
};
var prototypeAccessors = {
  isEmpty: {
    configurable: true
  }
};
EventElement.prototype.bind = function bind(eventName, handler) {
  if (typeof this.handlers[eventName] === "undefined") {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  var evts = ["touchstart", "wheel", "touchmove"];
  if (evts.indexOf(eventName) !== -1) {
    this.element.addEventListener(eventName, handler, {
      passive: false
    });
  } else {
    this.element.addEventListener(eventName, handler, false);
  }
};
EventElement.prototype.unbind = function unbind(eventName, target) {
  var this$1$1 = this;
  this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};
EventElement.prototype.unbindAll = function unbindAll() {
  for (var name2 in this.handlers) {
    this.unbind(name2);
  }
};
prototypeAccessors.isEmpty.get = function() {
  var this$1$1 = this;
  return Object.keys(this.handlers).every(function(key) {
    return this$1$1.handlers[key].length === 0;
  });
};
Object.defineProperties(EventElement.prototype, prototypeAccessors);
var EventManager = function EventManager2() {
  this.eventElements = [];
};
EventManager.prototype.eventElement = function eventElement(element) {
  var ee2 = this.eventElements.filter(function(ee3) {
    return ee3.element === element;
  })[0];
  if (!ee2) {
    ee2 = new EventElement(element);
    this.eventElements.push(ee2);
  }
  return ee2;
};
EventManager.prototype.bind = function bind2(element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};
EventManager.prototype.unbind = function unbind2(element, eventName, handler) {
  var ee2 = this.eventElement(element);
  ee2.unbind(eventName, handler);
  if (ee2.isEmpty) {
    this.eventElements.splice(this.eventElements.indexOf(ee2), 1);
  }
};
EventManager.prototype.unbindAll = function unbindAll2() {
  this.eventElements.forEach(function(e2) {
    return e2.unbindAll();
  });
  this.eventElements = [];
};
EventManager.prototype.once = function once(element, eventName, handler) {
  var ee2 = this.eventElement(element);
  var onceHandler = function onceHandler2(evt) {
    ee2.unbind(eventName, onceHandler2);
    handler(evt);
  };
  ee2.bind(eventName, onceHandler);
};
function createEvent(name2) {
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(name2);
  } else {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(name2, false, false, void 0);
    return evt;
  }
}
function processScrollDiff(i, axis, diff, useScrollingClass, forceFireReachEvent, disableOnYReachWhenNoScroll) {
  if (useScrollingClass === void 0) useScrollingClass = true;
  if (forceFireReachEvent === void 0) forceFireReachEvent = false;
  var fields;
  if (axis === "top") {
    fields = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
  } else if (axis === "left") {
    fields = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"];
  } else {
    throw new Error("A proper axis should be provided");
  }
  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent, disableOnYReachWhenNoScroll);
}
function processScrollDiff$1(i, diff, ref, useScrollingClass, forceFireReachEvent, disableOnYReachWhenNoScroll) {
  var contentHeight = ref[0];
  var containerHeight = ref[1];
  var scrollTop = ref[2];
  var y2 = ref[3];
  var up = ref[4];
  var down = ref[5];
  if (useScrollingClass === void 0) useScrollingClass = true;
  if (forceFireReachEvent === void 0) forceFireReachEvent = false;
  var element = i.element;
  i.reach[y2] = null;
  var eventFlag = disableOnYReachWhenNoScroll === true ? i[contentHeight] !== i[containerHeight] : true;
  if (eventFlag && element[scrollTop] < 1) {
    i.reach[y2] = "start";
  }
  if (eventFlag && element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y2] = "end";
  }
  if (diff) {
    element.dispatchEvent(createEvent("ps-scroll-" + y2));
    if (diff < 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + up));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + down));
    }
    if (useScrollingClass) {
      setScrollingClassInstantly(i, y2);
    }
  }
  if (i.reach[y2] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent("ps-" + y2 + "-reach-" + i.reach[y2]));
  }
}
function toInt(x2) {
  return parseInt(x2, 10) || 0;
}
function isEditable(el2) {
  return matches(el2, "input,[contenteditable]") || matches(el2, "select,[contenteditable]") || matches(el2, "textarea,[contenteditable]") || matches(el2, "button,[contenteditable]");
}
function outerWidth(element) {
  var styles2 = get(element);
  return toInt(styles2.width) + toInt(styles2.paddingLeft) + toInt(styles2.paddingRight) + toInt(styles2.borderLeftWidth) + toInt(styles2.borderRightWidth);
}
var env = {
  isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints
};
function updateGeometry(i) {
  var element = i.element;
  var roundedScrollTop = Math.floor(element.scrollTop);
  var rect = element.getBoundingClientRect();
  i.containerWidth = Math.round(rect.width);
  i.containerHeight = Math.round(rect.height);
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;
  if (!element.contains(i.scrollbarXRail)) {
    queryChildren(element, cls.element.rail("x")).forEach(function(el2) {
      return remove(el2);
    });
    element.appendChild(i.scrollbarXRail);
  }
  if (!element.contains(i.scrollbarYRail)) {
    queryChildren(element, cls.element.rail("y")).forEach(function(el2) {
      return remove(el2);
    });
    element.appendChild(i.scrollbarYRail);
  }
  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(i, toInt(i.railXWidth * i.containerWidth / i.contentWidth));
    i.scrollbarXLeft = toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
  } else {
    i.scrollbarXActive = false;
  }
  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(i, toInt(i.railYHeight * i.containerHeight / i.contentHeight));
    i.scrollbarYTop = toInt(roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
  } else {
    i.scrollbarYActive = false;
  }
  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }
  updateCss(element, i);
  if (i.scrollbarXActive) {
    element.classList.add(cls.state.active("x"));
  } else {
    element.classList.remove(cls.state.active("x"));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;
  }
  if (i.scrollbarYActive) {
    element.classList.add(cls.state.active("y"));
  } else {
    element.classList.remove(cls.state.active("y"));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
}
function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}
function updateCss(element, i) {
  var xRailOffset = {
    width: i.railXWidth
  };
  var roundedScrollTop = Math.floor(element.scrollTop);
  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }
  set(i.scrollbarXRail, xRailOffset);
  var yRailOffset = {
    top: roundedScrollTop,
    height: i.railYHeight
  };
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth - 9;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  set(i.scrollbarYRail, yRailOffset);
  set(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth
  });
  set(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth
  });
}
function clickRail(i) {
  i.element;
  i.event.bind(i.scrollbarY, "mousedown", function(e2) {
    return e2.stopPropagation();
  });
  i.event.bind(i.scrollbarYRail, "mousedown", function(e2) {
    var positionTop = e2.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i.scrollbarYTop ? 1 : -1;
    i.element.scrollTop += direction * i.containerHeight;
    updateGeometry(i);
    e2.stopPropagation();
  });
  i.event.bind(i.scrollbarX, "mousedown", function(e2) {
    return e2.stopPropagation();
  });
  i.event.bind(i.scrollbarXRail, "mousedown", function(e2) {
    var positionLeft = e2.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
    i.element.scrollLeft += direction * i.containerWidth;
    updateGeometry(i);
    e2.stopPropagation();
  });
}
function dragThumb(i) {
  bindMouseScrollHandler(i, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"]);
  bindMouseScrollHandler(i, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"]);
}
function bindMouseScrollHandler(i, ref) {
  var containerHeight = ref[0];
  var contentHeight = ref[1];
  var pageY = ref[2];
  var railYHeight = ref[3];
  var scrollbarY = ref[4];
  var scrollbarYHeight = ref[5];
  var scrollTop = ref[6];
  var y2 = ref[7];
  var scrollbarYRail = ref[8];
  var element = i.element;
  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;
  function mouseMoveHandler(e2) {
    if (e2.touches && e2.touches[0]) {
      e2[pageY] = e2.touches[0].pageY;
    }
    element[scrollTop] = startingScrollTop + scrollBy * (e2[pageY] - startingMousePageY);
    addScrollingClass(i, y2);
    updateGeometry(i);
    e2.stopPropagation();
    e2.preventDefault();
  }
  function mouseUpHandler() {
    removeScrollingClass(i, y2);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, "mousemove", mouseMoveHandler);
  }
  function bindMoves(e2, touchMode) {
    startingScrollTop = element[scrollTop];
    if (touchMode && e2.touches) {
      e2[pageY] = e2.touches[0].pageY;
    }
    startingMousePageY = e2[pageY];
    scrollBy = (i[contentHeight] - i[containerHeight]) / (i[railYHeight] - i[scrollbarYHeight]);
    if (!touchMode) {
      i.event.bind(i.ownerDocument, "mousemove", mouseMoveHandler);
      i.event.once(i.ownerDocument, "mouseup", mouseUpHandler);
      e2.preventDefault();
    } else {
      i.event.bind(i.ownerDocument, "touchmove", mouseMoveHandler);
    }
    i[scrollbarYRail].classList.add(cls.state.clicking);
    e2.stopPropagation();
  }
  i.event.bind(i[scrollbarY], "mousedown", function(e2) {
    bindMoves(e2);
  });
  i.event.bind(i[scrollbarY], "touchstart", function(e2) {
    bindMoves(e2, true);
  });
}
function keyboard(i) {
  var element = i.element;
  var elementHovered = function elementHovered2() {
    return matches(element, ":hover");
  };
  var scrollbarFocused = function scrollbarFocused2() {
    return matches(i.scrollbarX, ":focus") || matches(i.scrollbarY, ":focus");
  };
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
        return !i.settings.wheelPropagation;
      }
    }
    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }
  i.event.bind(i.ownerDocument, "keydown", function(e2) {
    if (e2.isDefaultPrevented && e2.isDefaultPrevented() || e2.defaultPrevented) {
      return;
    }
    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }
    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === "IFRAME") {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }
    var deltaX = 0;
    var deltaY = 0;
    switch (e2.which) {
      case 37:
        if (e2.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e2.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38:
        if (e2.metaKey) {
          deltaY = i.contentHeight;
        } else if (e2.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39:
        if (e2.metaKey) {
          deltaX = i.contentWidth;
        } else if (e2.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40:
        if (e2.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e2.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32:
        if (e2.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }
        break;
      case 33:
        deltaY = i.containerHeight;
        break;
      case 34:
        deltaY = -i.containerHeight;
        break;
      case 36:
        deltaY = i.contentHeight;
        break;
      case 35:
        deltaY = -i.contentHeight;
        break;
      default:
        return;
    }
    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }
    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i);
    if (shouldPreventDefault(deltaX, deltaY)) {
      e2.preventDefault();
    }
  });
}
function wheel(i) {
  var element = i.element;
  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
    var hitsBound;
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }
    return hitsBound ? !i.settings.wheelPropagation : true;
  }
  function getDeltaFromEvent(e2) {
    var deltaX = e2.deltaX;
    var deltaY = -1 * e2.deltaY;
    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      deltaX = -1 * e2.wheelDeltaX / 6;
      deltaY = e2.wheelDeltaY / 6;
    }
    if (e2.deltaMode && e2.deltaMode === 1) {
      deltaX *= 10;
      deltaY *= 10;
    }
    if (deltaX !== deltaX && deltaY !== deltaY) {
      deltaX = 0;
      deltaY = e2.wheelDelta;
    }
    if (e2.shiftKey) {
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!env.isWebKit && element.querySelector("select:focus")) {
      return true;
    }
    if (!element.contains(target)) {
      return false;
    }
    var cursor2 = target;
    while (cursor2 && cursor2 !== element) {
      if (cursor2.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get(cursor2);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor2.scrollHeight - cursor2.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor2.scrollTop > 0 && deltaY < 0 || cursor2.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor2.scrollWidth - cursor2.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor2.scrollLeft > 0 && deltaX < 0 || cursor2.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor2 = cursor2.parentNode;
    }
    return false;
  }
  function mousewheelHandler(e2) {
    var ref = getDeltaFromEvent(e2);
    var deltaX = ref[0];
    var deltaY = ref[1];
    if (shouldBeConsumedByChild(e2.target, deltaX, deltaY)) {
      return;
    }
    var shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      element.scrollTop -= deltaY * i.settings.wheelSpeed;
      element.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      if (deltaY) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      if (deltaX) {
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }
    updateGeometry(i);
    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e2.ctrlKey) {
      e2.stopPropagation();
      e2.preventDefault();
    }
  }
  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element, "wheel", mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element, "mousewheel", mousewheelHandler);
  }
}
function touch(i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }
  var element = i.element;
  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = Math.ceil(element.scrollLeft);
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);
    if (!i.settings.wheelPropagation) {
      return true;
    }
    if (magnitudeY > magnitudeX) {
      if (i.settings.suppressScrollY) {
        return false;
      }
      if (deltaY > 0) {
        return scrollTop !== 0;
      }
      if (deltaY < 0) {
        return scrollTop < i.contentHeight - i.containerHeight;
      }
    } else if (magnitudeX > magnitudeY) {
      if (i.settings.suppressScrollX) {
        return false;
      }
      if (deltaX > 0) {
        return scrollLeft !== 0;
      }
      if (deltaY < 0) {
        return scrollLeft < i.contentWidth - i.containerWidth;
      }
    }
    return true;
  }
  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;
    updateGeometry(i);
  }
  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  function getTouch(e2) {
    if (e2.targetTouches) {
      return e2.targetTouches[0];
    } else {
      return e2;
    }
  }
  function shouldHandle(e2) {
    if (e2.pointerType && e2.pointerType === "pen" && e2.buttons === 0) {
      return false;
    }
    if (e2.targetTouches && e2.targetTouches.length === 1) {
      return true;
    }
    if (e2.pointerType && e2.pointerType !== "mouse" && e2.pointerType !== e2.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e2) {
    if (!shouldHandle(e2)) {
      return;
    }
    var touch2 = getTouch(e2);
    startOffset.pageX = touch2.pageX;
    startOffset.pageY = touch2.pageY;
    startTime = (/* @__PURE__ */ new Date()).getTime();
    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }
    var cursor2 = target;
    while (cursor2 && cursor2 !== element) {
      if (cursor2.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get(cursor2);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor2.scrollHeight - cursor2.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor2.scrollTop > 0 && deltaY < 0 || cursor2.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor2.scrollWidth - cursor2.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor2.scrollLeft > 0 && deltaX < 0 || cursor2.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor2 = cursor2.parentNode;
    }
    return false;
  }
  function touchMove(e2) {
    if (shouldHandle(e2)) {
      var touch2 = getTouch(e2);
      var currentOffset = {
        pageX: touch2.pageX,
        pageY: touch2.pageY
      };
      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;
      if (shouldBeConsumedByChild(e2.target, differenceX, differenceY)) {
        return;
      }
      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }
      if (e2.cancelable && shouldPrevent(differenceX, differenceY)) {
        e2.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }
        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }
        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }
        applyTouchMove(speed.x * 30, speed.y * 30);
        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }
  if (env.supportsTouch) {
    i.event.bind(element, "touchstart", touchStart);
    i.event.bind(element, "touchmove", touchMove);
    i.event.bind(element, "touchend", touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element, "pointerdown", touchStart);
      i.event.bind(element, "pointermove", touchMove);
      i.event.bind(element, "pointerup", touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element, "MSPointerDown", touchStart);
      i.event.bind(element, "MSPointerMove", touchMove);
      i.event.bind(element, "MSPointerUp", touchEnd);
    }
  }
}
var defaultSettings = function defaultSettings2() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: false,
    suppressScrollY: false,
    swipeEasing: true,
    useBothWheelAxes: false,
    wheelPropagation: true,
    wheelSpeed: 1
  };
};
var handlers = {
  "click-rail": clickRail,
  "drag-thumb": dragThumb,
  keyboard,
  wheel,
  touch
};
var PerfectScrollbar = function PerfectScrollbar2(element, userSettings) {
  var this$1$1 = this;
  if (userSettings === void 0) userSettings = {};
  if (typeof element === "string") {
    element = document.querySelector(element);
  }
  if (!element || !element.nodeName) {
    throw new Error("no element is specified to initialize PerfectScrollbar");
  }
  this.element = element;
  element.classList.add(cls.main);
  this.settings = defaultSettings();
  for (var key in userSettings) {
    this.settings[key] = userSettings[key];
  }
  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;
  var focus = function focus2() {
    return element.classList.add(cls.state.focus);
  };
  var blur = function blur2() {
    return element.classList.remove(cls.state.focus);
  };
  this.isRtl = get(element).direction === "rtl";
  if (this.isRtl === true) {
    element.classList.add(cls.rtl);
  }
  this.isNegativeScroll = function() {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  }();
  this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;
  this.scrollbarXRail = div(cls.element.rail("x"));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb("x"));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarX, "focus", focus);
  this.event.bind(this.scrollbarX, "blur", blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  set(this.scrollbarXRail, {
    display: "block"
  });
  this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set(this.scrollbarXRail, {
    display: ""
  });
  this.railXWidth = null;
  this.railXRatio = null;
  this.scrollbarYRail = div(cls.element.rail("y"));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb("y"));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarY, "focus", focus);
  this.event.bind(this.scrollbarY, "blur", blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set(this.scrollbarYRail, {
    display: "block"
  });
  this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set(this.scrollbarYRail, {
    display: ""
  });
  this.railYHeight = null;
  this.railYRatio = null;
  this.reach = {
    x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  };
  this.isAlive = true;
  this.settings.handlers.forEach(function(handlerName) {
    return handlers[handlerName](this$1$1);
  });
  this.lastScrollTop = Math.floor(element.scrollTop);
  this.lastScrollLeft = element.scrollLeft;
  this.event.bind(this.element, "scroll", function(e2) {
    return this$1$1.onScroll(e2);
  });
  updateGeometry(this);
};
PerfectScrollbar.prototype.update = function update(disableOnYReachWhenNoScroll) {
  if (!this.isAlive) {
    return;
  }
  this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
  set(this.scrollbarXRail, {
    display: "block"
  });
  set(this.scrollbarYRail, {
    display: "block"
  });
  this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
  this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom);
  set(this.scrollbarXRail, {
    display: "none"
  });
  set(this.scrollbarYRail, {
    display: "none"
  });
  updateGeometry(this);
  processScrollDiff(this, "top", 0, false, true, disableOnYReachWhenNoScroll);
  processScrollDiff(this, "left", 0, false, true, disableOnYReachWhenNoScroll);
  set(this.scrollbarXRail, {
    display: ""
  });
  set(this.scrollbarYRail, {
    display: ""
  });
};
PerfectScrollbar.prototype.onScroll = function onScroll(e2) {
  if (!this.isAlive) {
    return;
  }
  updateGeometry(this);
  processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(this, "left", this.element.scrollLeft - this.lastScrollLeft);
  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};
PerfectScrollbar.prototype.destroy = function destroy() {
  if (!this.isAlive) {
    return;
  }
  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;
  this.isAlive = false;
};
PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
  this.element.className = this.element.className.split(" ").filter(function(name2) {
    return !name2.match(/^ps([-_].+|)$/);
  }).join(" ");
};
function _typeof$c(o) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$c(o);
}
var _excluded$k = ["className", "style", "option", "options", "containerRef", "onScrollY", "onScrollX", "onScrollUp", "onScrollDown", "onScrollLeft", "onScrollRight", "onYReachStart", "onYReachEnd", "onXReachStart", "onXReachEnd", "component", "onSync", "children"];
function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$k.apply(this, arguments);
}
function _objectWithoutProperties$k(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$k(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$k(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$3(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$b(descriptor.key), descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$b(t2) {
  var i = _toPrimitive$b(t2, "string");
  return "symbol" == _typeof$c(i) ? i : String(i);
}
function _toPrimitive$b(t2, r2) {
  if ("object" != _typeof$c(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$c(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t2);
}
function _callSuper$3(t2, o, e2) {
  return o = _getPrototypeOf$3(o), _possibleConstructorReturn$3(t2, _isNativeReflectConstruct$3() ? Reflect.construct(o, e2 || [], _getPrototypeOf$3(t2).constructor) : o.apply(t2, e2));
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
function _isNativeReflectConstruct$3() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t22) {
  }
  return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
    o2.__proto__ = p22;
    return o2;
  };
  return _setPrototypeOf$3(o, p2);
}
var handlerNameByEvent = {
  "ps-scroll-y": "onScrollY",
  "ps-scroll-x": "onScrollX",
  "ps-scroll-up": "onScrollUp",
  "ps-scroll-down": "onScrollDown",
  "ps-scroll-left": "onScrollLeft",
  "ps-scroll-right": "onScrollRight",
  "ps-y-reach-start": "onYReachStart",
  "ps-y-reach-end": "onYReachEnd",
  "ps-x-reach-start": "onXReachStart",
  "ps-x-reach-end": "onXReachEnd"
};
Object.freeze(handlerNameByEvent);
var ScrollBar = /* @__PURE__ */ function(_Component) {
  _inherits$3(ScrollBar2, _Component);
  function ScrollBar2(props) {
    var _this;
    _classCallCheck$3(this, ScrollBar2);
    _this = _callSuper$3(this, ScrollBar2, [props]);
    _this.handleRef = _this.handleRef.bind(_assertThisInitialized$3(_this));
    _this._handlerByEvent = {};
    return _this;
  }
  _createClass$3(ScrollBar2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.option) {
        console.warn('react-perfect-scrollbar: the "option" prop has been deprecated in favor of "options"');
      }
      this._ps = new PerfectScrollbar(this._container, this.props.options || this.props.option);
      this._updateEventHook();
      this._updateClassName();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this._updateEventHook(prevProps);
      this.updateScroll();
      if (prevProps.className !== this.props.className) {
        this._updateClassName();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this2 = this;
      Object.keys(this._handlerByEvent).forEach(function(key) {
        var value = _this2._handlerByEvent[key];
        if (value) {
          _this2._container.removeEventListener(key, value, false);
        }
      });
      this._handlerByEvent = {};
      this._ps.destroy();
      this._ps = null;
    }
  }, {
    key: "_updateEventHook",
    value: function _updateEventHook() {
      var _this3 = this;
      var prevProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Object.keys(handlerNameByEvent).forEach(function(key) {
        var callback = _this3.props[handlerNameByEvent[key]];
        var prevCallback = prevProps[handlerNameByEvent[key]];
        if (callback !== prevCallback) {
          if (prevCallback) {
            var prevHandler = _this3._handlerByEvent[key];
            _this3._container.removeEventListener(key, prevHandler, false);
            _this3._handlerByEvent[key] = null;
          }
          if (callback) {
            var handler = function handler2() {
              return callback(_this3._container);
            };
            _this3._container.addEventListener(key, handler, false);
            _this3._handlerByEvent[key] = handler;
          }
        }
      });
    }
  }, {
    key: "_updateClassName",
    value: function _updateClassName() {
      var className = this.props.className;
      var psClassNames = this._container.className.split(" ").filter(function(name2) {
        return name2.match(/^ps([-_].+|)$/);
      }).join(" ");
      if (this._container) {
        this._container.className = "scrollbar-container".concat(className ? " ".concat(className) : "").concat(psClassNames ? " ".concat(psClassNames) : "");
      }
    }
  }, {
    key: "updateScroll",
    value: function updateScroll() {
      var onSync = this.props.onSync;
      if (typeof onSync === "function") {
        onSync(this._ps);
      } else {
        this._ps.update();
      }
    }
  }, {
    key: "handleRef",
    value: function handleRef(ref) {
      var _this$props$container, _this$props;
      this._container = ref;
      (_this$props$container = (_this$props = this.props).containerRef) === null || _this$props$container === void 0 ? void 0 : _this$props$container.call(_this$props, ref);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props;
      _this$props2.className;
      var style = _this$props2.style;
      _this$props2.option;
      _this$props2.options;
      _this$props2.containerRef;
      _this$props2.onScrollY;
      _this$props2.onScrollX;
      _this$props2.onScrollUp;
      _this$props2.onScrollDown;
      _this$props2.onScrollLeft;
      _this$props2.onScrollRight;
      _this$props2.onYReachStart;
      _this$props2.onYReachEnd;
      _this$props2.onXReachStart;
      _this$props2.onXReachEnd;
      var component = _this$props2.component;
      _this$props2.onSync;
      var children = _this$props2.children, remainProps = _objectWithoutProperties$k(_this$props2, _excluded$k);
      var Comp = typeof component === "undefined" ? "div" : component;
      return /* @__PURE__ */ React.createElement(Comp, _extends$k({
        style,
        ref: this.handleRef
      }, remainProps), children);
    }
  }]);
  return ScrollBar2;
}(reactExports.Component);
function _typeof$b(o) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$b(o);
}
var _excluded$j = ["className", "variant", "children"];
function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$j.apply(this, arguments);
}
function _defineProperty$a(obj, key, value) {
  key = _toPropertyKey$a(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$a(t2) {
  var i = _toPrimitive$a(t2, "string");
  return "symbol" == _typeof$b(i) ? i : String(i);
}
function _toPrimitive$a(t2, r2) {
  if ("object" != _typeof$b(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$b(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$j(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$j(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$j(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Loader = function Loader22(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? void 0 : _ref$className, _ref$variant = _ref2.variant, variant = _ref$variant === void 0 ? "default" : _ref$variant, children = _ref2.children, rest = _objectWithoutProperties$j(_ref2, _excluded$j);
  var cName2 = "".concat(prefix, "-loader");
  var textClass = React.Children.count(children) > 0 ? "".concat(cName2, "--content") : "";
  return /* @__PURE__ */ React.createElement("div", _extends$j({}, rest, {
    className: classNames(cName2, textClass, _defineProperty$a({}, "".concat(cName2, "--variant-").concat(variant), variant !== "default"), className),
    role: "status"
  }), children);
};
function _typeof$a(o) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$a(o);
}
var _excluded$i = ["className", "children", "blur", "grayscale"];
function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$i.apply(this, arguments);
}
function _defineProperty$9(obj, key, value) {
  key = _toPropertyKey$9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$9(t2) {
  var i = _toPrimitive$9(t2, "string");
  return "symbol" == _typeof$a(i) ? i : String(i);
}
function _toPrimitive$9(t2, r2) {
  if ("object" != _typeof$a(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$a(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$i(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$i(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$i(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Overlay = function Overlay2(_ref2) {
  var _ref$className = _ref2.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, _ref$blur = _ref2.blur, blur = _ref$blur === void 0 ? false : _ref$blur, _ref$grayscale = _ref2.grayscale, grayscale = _ref$grayscale === void 0 ? false : _ref$grayscale, rest = _objectWithoutProperties$i(_ref2, _excluded$i);
  var cName2 = "".concat(prefix, "-overlay");
  var blurClass = "".concat(cName2, "--blur");
  var grayscaleClass = "".concat(cName2, "--grayscale");
  return /* @__PURE__ */ React.createElement("div", _extends$i({}, rest, {
    className: classNames(cName2, _defineProperty$9({}, blurClass, blur), _defineProperty$9({}, grayscaleClass, grayscale), className)
  }), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content")
  }, children));
};
var _excluded$h = ["sender", "sentTime", "children", "className"];
function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$h.apply(this, arguments);
}
function _objectWithoutProperties$h(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$h(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$h(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageHeader = function MessageHeader2(_ref2) {
  var _ref$sender = _ref2.sender, sender = _ref$sender === void 0 ? "" : _ref$sender, _ref$sentTime = _ref2.sentTime, sentTime = _ref$sentTime === void 0 ? "" : _ref$sentTime, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$h(_ref2, _excluded$h);
  var cName2 = "".concat(prefix, "-message__header");
  return /* @__PURE__ */ React.createElement("div", _extends$h({}, rest, {
    className: classNames(cName2, className)
  }), typeof children !== "undefined" ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-message__sender-name")
  }, sender), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-message__sent-time")
  }, sentTime)));
};
MessageHeader.displayName = "Message.Header";
var _excluded$g = ["sender", "sentTime", "children", "className"];
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
function _objectWithoutProperties$g(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$g(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$g(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageFooter = function MessageFooter2(_ref2) {
  var _ref$sender = _ref2.sender, sender = _ref$sender === void 0 ? "" : _ref$sender, _ref$sentTime = _ref2.sentTime, sentTime = _ref$sentTime === void 0 ? "" : _ref$sentTime, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$g(_ref2, _excluded$g);
  var cName2 = "".concat(prefix, "-message__footer");
  return /* @__PURE__ */ React.createElement("div", _extends$g({}, rest, {
    className: classNames(cName2, className)
  }), typeof children !== "undefined" ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-message__sender-name")
  }, sender), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(prefix, "-message__sent-time")
  }, sentTime)));
};
MessageFooter.displayName = "Message.Footer";
var MessageCustomContent = function MessageCustomContent2(_ref2) {
  var children = _ref2.children, className = _ref2.className;
  var cName2 = "".concat(prefix, "-message__custom-content");
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(cName2, className)
  }, children);
};
MessageCustomContent.displayName = "Message.CustomContent";
var MessageImageContent = function MessageImageContent2(_ref2) {
  var src = _ref2.src, width = _ref2.width, height = _ref2.height, alt = _ref2.alt, className = _ref2.className;
  var cName2 = "".concat(prefix, "-message__image-content");
  var style = {
    width: typeof width === "number" ? "".concat(width, "px") : typeof width === "string" ? width : void 0,
    height: typeof height === "number" ? "".concat(height, "px") : typeof height === "string" ? height : void 0
  };
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(cName2, className)
  }, /* @__PURE__ */ React.createElement("img", {
    src,
    style,
    alt
  }));
};
MessageImageContent.displayName = "Message.ImageContent";
var MessageHtmlContent = function MessageHtmlContent2(_ref2) {
  var html = _ref2.html, className = _ref2.className;
  var cName2 = "".concat(prefix, "-message__html-content");
  var createMarkup = function createMarkup2() {
    return {
      __html: html
    };
  };
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(cName2, className),
    dangerouslySetInnerHTML: createMarkup()
  });
};
MessageHtmlContent.displayName = "Message.HtmlContent";
var MessageTextContent = function MessageTextContent2(_ref2) {
  var text = _ref2.text, className = _ref2.className, children = _ref2.children;
  var cName2 = "".concat(prefix, "-message__text-content");
  var content = children !== null && children !== void 0 ? children : text;
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(cName2, className)
  }, content);
};
MessageTextContent.displayName = "Message.TextContent";
var _excluded$f = ["model", "avatarSpacer", "avatarPosition", "type", "payload", "children", "className"];
function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$f.apply(this, arguments);
}
function _defineProperty$8(obj, key, value) {
  key = _toPropertyKey$8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$8(t2) {
  var i = _toPrimitive$8(t2, "string");
  return "symbol" == _typeof$9(i) ? i : String(i);
}
function _toPrimitive$8(t2, r2) {
  if ("object" != _typeof$9(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$9(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _typeof$9(o) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$9(o);
}
function _slicedToArray$5(arr2, i) {
  return _arrayWithHoles$5(arr2) || _iterableToArrayLimit$5(arr2, i) || _unsupportedIterableToArray$5(arr2, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) arr22[i] = arr2[i];
  return arr22;
}
function _iterableToArrayLimit$5(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a = [], f2 = true, o = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
    } catch (r22) {
      o = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles$5(arr2) {
  if (Array.isArray(arr2)) return arr2;
}
function _objectWithoutProperties$f(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$f(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$f(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Message = function Message2(_ref2) {
  var _ref22, _ref3;
  var _ref$model = _ref2.model, _ref$model$message = _ref$model.message, message = _ref$model$message === void 0 ? "" : _ref$model$message, _ref$model$sentTime = _ref$model.sentTime, sentTime = _ref$model$sentTime === void 0 ? "" : _ref$model$sentTime, _ref$model$sender = _ref$model.sender, sender = _ref$model$sender === void 0 ? "" : _ref$model$sender, _ref$model$direction = _ref$model.direction, direction = _ref$model$direction === void 0 ? 1 : _ref$model$direction, position2 = _ref$model.position, modelType = _ref$model.type, modelPayload = _ref$model.payload, _ref$avatarSpacer = _ref2.avatarSpacer, avatarSpacer = _ref$avatarSpacer === void 0 ? false : _ref$avatarSpacer, _ref$avatarPosition = _ref2.avatarPosition, avatarPosition = _ref$avatarPosition === void 0 ? void 0 : _ref$avatarPosition, _ref$type = _ref2.type, type = _ref$type === void 0 ? "html" : _ref$type, argPayload = _ref2.payload, children = _ref2.children, className = _ref2.className, rest = _objectWithoutProperties$f(_ref2, _excluded$f);
  var cName2 = "".concat(prefix, "-message");
  var _getChildren = getChildren(children, [Avatar, MessageHeader, MessageFooter, MessageHtmlContent, MessageTextContent, MessageImageContent, MessageCustomContent]), _getChildren2 = _slicedToArray$5(_getChildren, 7), avatar = _getChildren2[0], header = _getChildren2[1], footer2 = _getChildren2[2], htmlContent = _getChildren2[3], textContent = _getChildren2[4], imageContent = _getChildren2[5], customContent = _getChildren2[6];
  var directionClass = function() {
    if (direction === 0 || direction === "incoming") {
      return "".concat(cName2, "--incoming");
    } else if (direction === 1 || direction === "outgoing") {
      return "".concat(cName2, "--outgoing");
    }
  }();
  var avatarPositionClass = function(position22) {
    var classPrefix = "".concat(cName2, "--avatar-");
    if (position22 === 0 || position22 === "top-left" || position22 === "tl") {
      return "".concat(classPrefix, "tl");
    } else if (position22 === 1 || position22 === "top-right" || position22 === "tr") {
      return "".concat(classPrefix, "tr");
    } else if (position22 === 2 || position22 === "bottom-right" || position22 === "br") {
      return "".concat(classPrefix, "br");
    } else if (position22 === 3 || position22 === "bottom-left" || position22 === "bl") {
      return "".concat(classPrefix, "bl");
    } else if (position22 === 4 || position22 === "center-left" || position22 === "cl") {
      return "".concat(classPrefix, "cl");
    } else if (position22 === 5 || position22 === "center-right" || position22 === "cr") {
      return "".concat(classPrefix, "cr");
    }
  }(avatarPosition);
  var positionClass = function(position22) {
    var classPrefix = "".concat(prefix, "-message--");
    if (position22 === "single" || position22 === 0) {
      return "".concat(classPrefix, "single");
    } else if (position22 === "first" || position22 === 1) {
      return "".concat(classPrefix, "first");
    } else if (position22 === "normal" || position22 === 2) {
      return "";
    } else if (position22 === "last" || position22 === 3) {
      return "".concat(classPrefix, "last");
    }
  }(position2);
  var ariaLabel = function() {
    if ((sender === null || sender === void 0 ? void 0 : sender.length) > 0 && (sentTime === null || sentTime === void 0 ? void 0 : sentTime.length) > 0) {
      return "".concat(sender, ": ").concat(sentTime);
    } else if ((sender === null || sender === void 0 ? void 0 : sender.length) > 0 && (typeof sentTime === "undefined" || (sentTime === null || sentTime === void 0 ? void 0 : sentTime.length) === 0)) {
      return sender;
    } else {
      return null;
    }
  }();
  var childContent = (_ref22 = (_ref3 = htmlContent !== null && htmlContent !== void 0 ? htmlContent : textContent) !== null && _ref3 !== void 0 ? _ref3 : imageContent) !== null && _ref22 !== void 0 ? _ref22 : customContent;
  var messageContent = childContent !== null && childContent !== void 0 ? childContent : function() {
    var messageType = modelType !== null && modelType !== void 0 ? modelType : type;
    var payloadFromModel = modelPayload !== null && modelPayload !== void 0 ? modelPayload : message;
    var payload = payloadFromModel !== null && payloadFromModel !== void 0 ? payloadFromModel : argPayload;
    var payloadName = _typeof$9(payload) === "object" ? getComponentName(payload) : "";
    if (messageType === "html" && payloadName !== "Message.CustomContent") {
      return /* @__PURE__ */ React.createElement(MessageHtmlContent, {
        html: payload
      });
    } else if (messageType === "text") {
      return /* @__PURE__ */ React.createElement(MessageTextContent, {
        text: payload
      });
    } else if (messageType === "image") {
      return /* @__PURE__ */ React.createElement(MessageImageContent, payload);
    } else if (messageType === "custom" || payloadName === "Message.CustomContent") {
      return payload;
    }
  }();
  return /* @__PURE__ */ React.createElement("section", _extends$f({}, rest, {
    "aria-label": ariaLabel,
    className: classNames(cName2, directionClass, _defineProperty$8({}, "".concat(cName2, "--avatar-spacer"), avatarSpacer), positionClass, avatarPositionClass, className)
  }, _defineProperty$8({}, "data-".concat(prefix, "-message"), "")), typeof avatar !== "undefined" && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__avatar")
  }, avatar), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content-wrapper")
  }, header, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content")
  }, messageContent), footer2));
};
Message.Header = MessageHeader;
Message.HtmlContent = MessageHtmlContent;
Message.TextContent = MessageTextContent;
Message.ImageContent = MessageImageContent;
Message.CustomContent = MessageCustomContent;
Message.Footer = MessageFooter;
var _excluded$e = ["children", "className"];
function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
function _objectWithoutProperties$e(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$e(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$e(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageGroupHeader = function MessageGroupHeader2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$e(_ref2, _excluded$e);
  var cName2 = "".concat(prefix, "-message-group__header");
  return /* @__PURE__ */ React.createElement("div", _extends$e({}, rest, {
    className: classNames(cName2, className)
  }), children);
};
MessageGroupHeader.displayName = "MessageGroup.Header";
var _excluded$d = ["children", "className"];
function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
function _objectWithoutProperties$d(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$d(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$d(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageGroupFooter = function MessageGroupFooter2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$d(_ref2, _excluded$d);
  var cName2 = "".concat(prefix, "-message-group__footer");
  return /* @__PURE__ */ React.createElement("div", _extends$d({}, rest, {
    className: classNames(cName2, className)
  }), children);
};
MessageGroupFooter.displayName = "MessageGroup.Footer";
var _excluded$c = ["children", "className"];
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
function _objectWithoutProperties$c(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$c(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$c(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageGroupMessages = function MessageGroupMessages2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$c(_ref2, _excluded$c);
  var cName2 = "".concat(prefix, "-message-group");
  return /* @__PURE__ */ React.createElement("div", _extends$c({}, rest, {
    className: classNames("".concat(cName2, "__messages"), className)
  }), children);
};
MessageGroupMessages.displayName = "MessageGroup.Messages";
function _typeof$8(o) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$8(o);
}
var _excluded$b = ["direction", "avatarPosition", "sender", "sentTime", "children", "className"];
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
function _defineProperty$7(obj, key, value) {
  key = _toPropertyKey$7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$7(t2) {
  var i = _toPrimitive$7(t2, "string");
  return "symbol" == _typeof$8(i) ? i : String(i);
}
function _toPrimitive$7(t2, r2) {
  if ("object" != _typeof$8(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$8(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray$4(arr2, i) {
  return _arrayWithHoles$4(arr2) || _iterableToArrayLimit$4(arr2, i) || _unsupportedIterableToArray$4(arr2, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) arr22[i] = arr2[i];
  return arr22;
}
function _iterableToArrayLimit$4(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a = [], f2 = true, o = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
    } catch (r22) {
      o = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles$4(arr2) {
  if (Array.isArray(arr2)) return arr2;
}
function _objectWithoutProperties$b(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$b(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageGroup = function MessageGroup2(_ref2) {
  var _ref$direction = _ref2.direction, direction = _ref$direction === void 0 ? "incoming" : _ref$direction, _ref$avatarPosition = _ref2.avatarPosition, avatarPosition = _ref$avatarPosition === void 0 ? void 0 : _ref$avatarPosition, _ref$sender = _ref2.sender, sender = _ref$sender === void 0 ? "" : _ref$sender, _ref$sentTime = _ref2.sentTime, sentTime = _ref$sentTime === void 0 ? "" : _ref$sentTime, children = _ref2.children, className = _ref2.className, rest = _objectWithoutProperties$b(_ref2, _excluded$b);
  var cName2 = "".concat(prefix, "-message-group");
  var directionClass = function() {
    if (direction === 0 || direction === "incoming") {
      return "".concat(cName2, "--incoming");
    } else if (direction === 1 || direction === "outgoing") {
      return "".concat(cName2, "--outgoing");
    }
  }();
  var avatarPositionClass = function() {
    var prefix2 = "".concat(cName2, "--avatar-");
    if (typeof avatarPosition === "string") {
      if (avatarPosition === "tl" || avatarPosition === "top-left" || avatarPosition === "tr" || avatarPosition === "top-right" || avatarPosition === "bl" || avatarPosition === "bottom-right" || avatarPosition === "br" || avatarPosition === "bottom-right" || avatarPosition === "cl" || avatarPosition === "center-left" || avatarPosition === "cr" || avatarPosition === "center-right") {
        return "".concat(prefix2).concat(avatarPosition);
      }
    }
  }();
  var _getChildren = getChildren(children, [Avatar, MessageGroupHeader, MessageGroupFooter, MessageGroupMessages]), _getChildren2 = _slicedToArray$4(_getChildren, 4), avatar = _getChildren2[0], header = _getChildren2[1], footer2 = _getChildren2[2], messages2 = _getChildren2[3];
  var ariaLabel = function() {
    if (sender.length > 0 && sentTime.length > 0) {
      return "".concat(sender, ": ").concat(sentTime);
    } else if (sender.length > 0 && sentTime.length === 0) {
      return sender;
    } else {
      return null;
    }
  }();
  return /* @__PURE__ */ React.createElement("section", _extends$b({
    "aria-label": ariaLabel
  }, rest, {
    className: classNames(cName2, directionClass, avatarPositionClass, className)
  }, _defineProperty$7({}, "data-".concat(prefix, "-message-group"), "")), typeof avatar !== "undefined" && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__avatar")
  }, avatar), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content")
  }, header, messages2, footer2));
};
MessageGroup.Header = MessageGroupHeader;
MessageGroup.Footer = MessageGroupFooter;
MessageGroup.Messages = MessageGroupMessages;
var _excluded$a = ["content", "as", "children", "className"];
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function _objectWithoutProperties$a(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$a(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageSeparator = function MessageSeparator2(_ref2) {
  var _ref$content = _ref2.content, content = _ref$content === void 0 ? void 0 : _ref$content, _ref$as = _ref2.as, as = _ref$as === void 0 ? "div" : _ref$as, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$a(_ref2, _excluded$a);
  var cName2 = "".concat(prefix, "-message-separator");
  var Tag = function() {
    if (typeof as === "string" && as.length > 0) {
      return as;
    } else {
      return "div";
    }
  }();
  return /* @__PURE__ */ React.createElement(Tag, _extends$a({}, rest, {
    className: classNames(cName2, className)
  }), isChildrenNil(children) === true ? content : children);
};
var _excluded$9 = ["className", "children"];
function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
function _objectWithoutProperties$9(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$9(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MessageListContent = function MessageListContent2(_ref2) {
  var className = _ref2.className, children = _ref2.children, rest = _objectWithoutProperties$9(_ref2, _excluded$9);
  return /* @__PURE__ */ React.createElement("div", _extends$9({}, rest, {
    className
  }), children);
};
MessageListContent.displayName = "MessageList.Content";
var _excluded$8 = ["children", "typingIndicator", "loading", "loadingMore", "loadingMorePosition", "onYReachStart", "onYReachEnd", "className", "disableOnYReachWhenNoScroll", "scrollBehavior", "autoScrollToBottom", "autoScrollToBottomOnMount"];
function _typeof$7(o) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$7(o);
}
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
function _slicedToArray$3(arr2, i) {
  return _arrayWithHoles$3(arr2) || _iterableToArrayLimit$3(arr2, i) || _unsupportedIterableToArray$3(arr2, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) arr22[i] = arr2[i];
  return arr22;
}
function _iterableToArrayLimit$3(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a = [], f2 = true, o = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
    } catch (r22) {
      o = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles$3(arr2) {
  if (Array.isArray(arr2)) return arr2;
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$6(descriptor.key), descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$2(t2, o, e2) {
  return o = _getPrototypeOf$2(o), _possibleConstructorReturn$2(t2, _isNativeReflectConstruct$2() ? Reflect.construct(o, e2 || [], _getPrototypeOf$2(t2).constructor) : o.apply(t2, e2));
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _isNativeReflectConstruct$2() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t22) {
  }
  return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
    o2.__proto__ = p22;
    return o2;
  };
  return _setPrototypeOf$2(o, p2);
}
function _defineProperty$6(obj, key, value) {
  key = _toPropertyKey$6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$6(t2) {
  var i = _toPrimitive$6(t2, "string");
  return "symbol" == _typeof$7(i) ? i : String(i);
}
function _toPrimitive$6(t2, r2) {
  if ("object" != _typeof$7(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$7(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var MessageListInner = /* @__PURE__ */ function(_React$Component) {
  _inherits$2(MessageListInner2, _React$Component);
  function MessageListInner2(props) {
    var _this;
    _classCallCheck$2(this, MessageListInner2);
    _this = _callSuper$2(this, MessageListInner2, [props]);
    _defineProperty$6(_assertThisInitialized$2(_this), "handleResize", function() {
      if (_this.containerRef.current.clientHeight < _this.lastClientHeight) {
        _this.scrollToEnd(_this.props.scrollBehavior);
      }
      _this.scrollRef.current.updateScroll();
    });
    _defineProperty$6(_assertThisInitialized$2(_this), "handleContainerResize", function() {
      if (_this.resizeTicking === false) {
        window.requestAnimationFrame(function() {
          var list = _this.containerRef.current;
          if (list) {
            var currentHeight = list.clientHeight;
            var diff = currentHeight - _this.lastClientHeight;
            if (diff >= 1) {
              if (_this.preventScrollTop === false) {
                list.scrollTop = Math.round(list.scrollTop) - diff;
              }
            } else {
              list.scrollTop = list.scrollTop - diff;
            }
            _this.lastClientHeight = list.clientHeight;
            _this.scrollRef.current.updateScroll();
          }
          _this.resizeTicking = false;
        });
        _this.resizeTicking = true;
      }
    });
    _defineProperty$6(_assertThisInitialized$2(_this), "isSticked", function() {
      var list = _this.containerRef.current;
      return list.scrollHeight === Math.round(list.scrollTop + list.clientHeight);
    });
    _defineProperty$6(_assertThisInitialized$2(_this), "handleScroll", function() {
      if (_this.scrollTicking === false) {
        window.requestAnimationFrame(function() {
          if (_this.noScroll === false) {
            _this.preventScrollTop = _this.isSticked();
          } else {
            _this.noScroll = false;
          }
          _this.scrollTicking = false;
        });
        _this.scrollTicking = true;
      }
    });
    _defineProperty$6(_assertThisInitialized$2(_this), "getLastMessageOrGroup", function() {
      var lastElement = _this.containerRef.current.querySelector("[data-".concat(prefix, "-message-list]>[data-").concat(prefix, "-message]:last-of-type,[data-").concat(prefix, "-message-list]>[data-").concat(prefix, "-message-group]:last-of-type"));
      var lastMessageInGroup = lastElement === null || lastElement === void 0 ? void 0 : lastElement.querySelector("[data-".concat(prefix, "-message]:last-of-type"));
      return {
        lastElement,
        lastMessageInGroup
      };
    });
    _this.scrollPointRef = /* @__PURE__ */ React.createRef();
    _this.containerRef = /* @__PURE__ */ React.createRef();
    _this.scrollRef = /* @__PURE__ */ React.createRef();
    _this.lastClientHeight = 0;
    _this.preventScrollTop = false;
    _this.resizeObserver = void 0;
    _this.scrollTicking = false;
    _this.resizeTicking = false;
    _this.noScroll = void 0;
    return _this;
  }
  _createClass$2(MessageListInner2, [{
    key: "getSnapshotBeforeUpdate",
    value: function getSnapshotBeforeUpdate() {
      var list = this.containerRef.current;
      var topHeight = Math.round(list.scrollTop + list.clientHeight);
      var sticky = list.scrollHeight === topHeight || list.scrollHeight + 1 === topHeight || list.scrollHeight - 1 === topHeight;
      return {
        sticky,
        clientHeight: list.clientHeight,
        scrollHeight: list.scrollHeight,
        lastMessageOrGroup: this.getLastMessageOrGroup(),
        diff: list.scrollHeight - list.scrollTop
      };
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.autoScrollToBottomOnMount === true) {
        this.scrollToEnd(this.props.scrollBehavior);
      }
      this.lastClientHeight = this.containerRef.current.clientHeight;
      window.addEventListener("resize", this.handleResize);
      if (typeof window.ResizeObserver === "function") {
        this.resizeObserver = new ResizeObserver(this.handleContainerResize);
        this.resizeObserver.observe(this.containerRef.current);
      }
      this.containerRef.current.addEventListener("scroll", this.handleScroll);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState, snapshot2) {
      var autoScrollToBottom = this.props.autoScrollToBottom;
      if (typeof snapshot2 !== "undefined") {
        var list = this.containerRef.current;
        var _this$getLastMessageO = this.getLastMessageOrGroup(), lastElement = _this$getLastMessageO.lastElement, lastMessageInGroup = _this$getLastMessageO.lastMessageInGroup;
        if (lastElement === snapshot2.lastMessageOrGroup.lastElement) {
          if (typeof lastMessageInGroup === "undefined" || lastMessageInGroup === snapshot2.lastMessageOrGroup.lastMessageInGroup) {
            list.scrollTop = list.scrollHeight - snapshot2.diff + (this.lastClientHeight - list.clientHeight);
          }
        }
        if (snapshot2.sticky === true) {
          if (autoScrollToBottom === true) {
            this.scrollToEnd(this.props.scrollBehavior);
          }
          this.preventScrollTop = true;
        } else {
          if (snapshot2.clientHeight < this.lastClientHeight) {
            var sHeight = list.scrollTop + this.lastClientHeight;
            if (list.scrollHeight === sHeight || list.scrollHeight + 1 === sHeight || list.scrollHeight - 1 === sHeight) {
              if (autoScrollToBottom === true) {
                this.scrollToEnd(this.props.scrollBehavior);
                this.preventScrollTop = true;
              }
            } else {
              this.preventScrollTop = false;
            }
          } else {
            this.preventScrollTop = false;
            if (lastElement === snapshot2.lastMessageOrGroup.lastElement) {
              if (typeof lastMessageInGroup === "undefined" || lastMessageInGroup === snapshot2.lastMessageOrGroup.lastMessageInGroup) {
                if (list.scrollTop === 0 && list.scrollHeight > snapshot2.scrollHeight) {
                  list.scrollTop = list.scrollHeight - snapshot2.scrollHeight;
                }
              }
            }
          }
        }
        this.lastClientHeight = snapshot2.clientHeight;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener("resize", this.handleResize);
      if (typeof this.resizeObserver !== "undefined") {
        this.resizeObserver.disconnect();
      }
      this.containerRef.current.removeEventListener("scroll", this.handleScroll);
    }
  }, {
    key: "scrollToEnd",
    value: function scrollToEnd() {
      var scrollBehavior = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.scrollBehavior;
      var list = this.containerRef.current;
      var scrollPoint = this.scrollPointRef.current;
      var parentRect = list.getBoundingClientRect();
      var childRect = scrollPoint.getBoundingClientRect();
      var scrollOffset = childRect.top + list.scrollTop - parentRect.top;
      if (list.scrollBy) {
        list.scrollBy({
          top: scrollOffset,
          behavior: scrollBehavior
        });
      } else {
        list.scrollTop = scrollOffset;
      }
      this.lastClientHeight = list.clientHeight;
      this.noScroll = true;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props, children = _this$props.children, typingIndicator = _this$props.typingIndicator, loading = _this$props.loading, loadingMore = _this$props.loadingMore, loadingMorePosition = _this$props.loadingMorePosition, onYReachStart = _this$props.onYReachStart, onYReachEnd = _this$props.onYReachEnd, className = _this$props.className, disableOnYReachWhenNoScroll = _this$props.disableOnYReachWhenNoScroll;
      _this$props.scrollBehavior;
      _this$props.autoScrollToBottom;
      _this$props.autoScrollToBottomOnMount;
      var rest = _objectWithoutProperties$8(_this$props, _excluded$8);
      var cName2 = "".concat(prefix, "-message-list");
      var _getChildren = getChildren(children, [MessageListContent]), _getChildren2 = _slicedToArray$3(_getChildren, 1), customContent = _getChildren2[0];
      return /* @__PURE__ */ React.createElement("div", _extends$8({}, rest, {
        className: classNames(cName2, className)
      }), loadingMore && /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(cName2, "__loading-more"), _defineProperty$6({}, "".concat(cName2, "__loading-more--bottom"), loadingMorePosition === "bottom"))
      }, /* @__PURE__ */ React.createElement(Loader, null)), loading && /* @__PURE__ */ React.createElement(Overlay, null, /* @__PURE__ */ React.createElement(Loader, null)), /* @__PURE__ */ React.createElement(ScrollBar, _extends$8({
        onYReachStart,
        onYReachEnd,
        onSync: function onSync(ps) {
          return ps.update(disableOnYReachWhenNoScroll);
        },
        className: "".concat(cName2, "__scroll-wrapper"),
        ref: this.scrollRef,
        containerRef: function containerRef(ref) {
          return _this2.containerRef.current = ref;
        },
        options: {
          suppressScrollX: true
        }
      }, _defineProperty$6({}, "data-".concat(prefix, "-message-list"), ""), {
        style: {
          overscrollBehaviorY: "none",
          overflowAnchor: "auto",
          touchAction: "none"
        }
      }), customContent ? customContent : children, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(cName2, "__scroll-to"),
        ref: this.scrollPointRef
      })), typeof typingIndicator !== "undefined" && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(cName2, "__typing-indicator-container")
      }, typingIndicator));
    }
  }]);
  return MessageListInner2;
}(React.Component);
MessageListInner.displayName = "MessageList";
function MessageListFunc(props, ref) {
  var msgListRef = reactExports.useRef();
  var scrollToBottom = function scrollToBottom2(scrollBehavior) {
    return msgListRef.current.scrollToEnd(scrollBehavior);
  };
  reactExports.useImperativeHandle(ref, function() {
    return {
      scrollToBottom
    };
  });
  return /* @__PURE__ */ React.createElement(MessageListInner, _extends$8({
    ref: msgListRef
  }, props));
}
var MessageList = /* @__PURE__ */ reactExports.forwardRef(MessageListFunc);
MessageList.propTypes = {
  /**
   * Primary content. Message elements
   * Allowed components:
   *
   * * &lt;Message /&gt;
   * * &lt;MessageGroup /&gt;
   * * &lt;MessageSeparator /&gt;
   * * &lt;MessageListContent /&gt;
   */
  children: allowedChildren([Message, MessageGroup, MessageSeparator, MessageListContent]),
  /** Typing indicator element. */
  typingIndicator: PropTypes.node,
  /** Loading flag. */
  loading: PropTypes.bool,
  /** Loading more flag for infinity scroll. */
  loadingMore: PropTypes.bool,
  /** Loading more loader position. */
  loadingMorePosition: PropTypes.oneOf(["top", "bottom"]),
  /**
   * This is fired when the scrollbar reaches the beginning on the y axis.<br/>
   * It can be used to load previous messages using the infinite scroll.
   */
  onYReachStart: PropTypes.func,
  /**
   * This is fired when the scrollbar reaches the end on the y axis.<br/>
   * It can be used to load next messages using the infinite scroll.
   */
  onYReachEnd: PropTypes.func,
  /**
   * Disables onYReachStart and onYReachEnd events from being fired<br />
   * when the list is not scrollable.
   * This is set to false by default for backward compatibility.
   */
  disableOnYReachWhenNoScroll: PropTypes.bool,
  /**
   * Auto scroll to bottom
   */
  autoScrollToBottom: PropTypes.bool,
  /**
   * Auto scroll to bottom on mount
   */
  autoScrollToBottomOnMount: PropTypes.bool,
  /**
   * Scroll behavior
   * https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions/behavior
   */
  scrollBehavior: PropTypes.oneOf(["auto", "smooth"]),
  /** Additional classes. */
  className: PropTypes.string
};
MessageList.defaultProps = {
  typingIndicator: void 0,
  loading: false,
  loadingMore: false,
  loadingMorePosition: "top",
  disableOnYReachWhenNoScroll: false,
  autoScrollToBottom: true,
  autoScrollToBottomOnMount: true,
  scrollBehavior: "auto"
};
MessageListInner.defaultProps = MessageList.defaultProps;
MessageList.Content = MessageListContent;
function _typeof$6(o) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$6(o);
}
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$5(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper$1(t2, o, e2) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t2, _isNativeReflectConstruct$1() ? Reflect.construct(o, e2 || [], _getPrototypeOf$1(t2).constructor) : o.apply(t2, e2));
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _isNativeReflectConstruct$1() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t22) {
  }
  return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
    o2.__proto__ = p22;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _defineProperty$5(obj, key, value) {
  key = _toPropertyKey$5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$5(t2) {
  var i = _toPrimitive$5(t2, "string");
  return "symbol" == _typeof$6(i) ? i : String(i);
}
function _toPrimitive$5(t2, r2) {
  if ("object" != _typeof$6(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$6(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var replaceCaret = function replaceCaret2(el2, activateAfterChange) {
  var isTargetFocused = document.activeElement === el2;
  var target = document.createTextNode("");
  el2.appendChild(target);
  if (target !== null && target.nodeValue !== null && (isTargetFocused || activateAfterChange)) {
    var sel = window.getSelection();
    if (sel !== null) {
      var range = document.createRange();
      range.setStart(target, target.nodeValue.length);
      range.collapse(true);
      sel.removeAllRanges();
      sel.addRange(range);
    }
  }
};
var ContentEditable = /* @__PURE__ */ function(_Component) {
  _inherits$1(ContentEditable2, _Component);
  function ContentEditable2(props) {
    var _this;
    _classCallCheck$1(this, ContentEditable2);
    _this = _callSuper$1(this, ContentEditable2, [props]);
    _defineProperty$5(_assertThisInitialized$1(_this), "innerHTML", function() {
      var _assertThisInitialize = _assertThisInitialized$1(_this), value = _assertThisInitialize.props.value;
      return {
        __html: typeof value !== "undefined" ? value : ""
      };
    });
    _defineProperty$5(_assertThisInitialized$1(_this), "handleKeyPress", function(evt) {
      var _assertThisInitialize2 = _assertThisInitialized$1(_this), onKeyPress = _assertThisInitialize2.props.onKeyPress;
      onKeyPress === null || onKeyPress === void 0 ? void 0 : onKeyPress(evt);
    });
    _defineProperty$5(_assertThisInitialized$1(_this), "handleInput", function(evt) {
      var _assertThisInitialize3 = _assertThisInitialized$1(_this), onChange = _assertThisInitialize3.props.onChange;
      var target = evt.target;
      onChange === null || onChange === void 0 ? void 0 : onChange(target.innerHTML, target.textContent, target.innerText);
    });
    _this.msgRef = /* @__PURE__ */ React.createRef();
    return _this;
  }
  _createClass$1(ContentEditable2, [{
    key: "focus",
    value: (
      // Public API
      function focus() {
        if (typeof this.msgRef.current !== "undefined") {
          this.msgRef.current.focus();
        }
      }
    )
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.autoFocus === true) {
        this.msgRef.current.focus();
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var msgRef = this.msgRef, _this$props = this.props, placeholder = _this$props.placeholder, disabled = _this$props.disabled, activateAfterChange = _this$props.activateAfterChange;
      if (typeof msgRef.current === "undefined") {
        return true;
      }
      if (nextProps.value !== msgRef.current.innerHTML) {
        return true;
      }
      return placeholder !== nextProps.placeholder || disabled !== nextProps.disabled || activateAfterChange !== nextProps.activateAfterChange;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var msgRef = this.msgRef, _this$props2 = this.props, value = _this$props2.value, activateAfterChange = _this$props2.activateAfterChange;
      if (value !== msgRef.current.innerHTML) {
        msgRef.current.innerHTML = typeof value === "string" ? value : "";
      }
      replaceCaret(msgRef.current, activateAfterChange);
    }
  }, {
    key: "render",
    value: function render() {
      var msgRef = this.msgRef, handleInput = this.handleInput, handleKeyPress = this.handleKeyPress, innerHTML = this.innerHTML, _this$props3 = this.props, placeholder = _this$props3.placeholder, disabled = _this$props3.disabled, className = _this$props3.className, ph2 = typeof placeholder === "string" ? placeholder : "";
      return /* @__PURE__ */ React.createElement("div", {
        ref: msgRef,
        className,
        contentEditable: disabled === false,
        disabled,
        "data-placeholder": ph2,
        onInput: handleInput,
        onKeyPress: handleKeyPress,
        dangerouslySetInnerHTML: innerHTML()
      });
    }
  }]);
  return ContentEditable2;
}(reactExports.Component);
function _typeof$5(o) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$5(o);
}
var _excluded$7 = ["fancyScroll", "children", "forwardedRef"], _excluded2 = ["value", "onSend", "onChange", "autoFocus", "placeholder", "fancyScroll", "className", "activateAfterChange", "disabled", "sendDisabled", "sendOnReturnDisabled", "attachDisabled", "sendButton", "attachButton", "onAttachClick"];
function _defineProperty$4(obj, key, value) {
  key = _toPropertyKey$4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$2(arr2, i) {
  return _arrayWithHoles$2(arr2) || _iterableToArrayLimit$2(arr2, i) || _unsupportedIterableToArray$2(arr2, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) arr22[i] = arr2[i];
  return arr22;
}
function _iterableToArrayLimit$2(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a = [], f2 = true, o = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
    } catch (r22) {
      o = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles$2(arr2) {
  if (Array.isArray(arr2)) return arr2;
}
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$4(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$4(t2) {
  var i = _toPrimitive$4(t2, "string");
  return "symbol" == _typeof$5(i) ? i : String(i);
}
function _toPrimitive$4(t2, r2) {
  if ("object" != _typeof$5(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$5(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _callSuper(t2, o, e2) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o, e2 || [], _getPrototypeOf(t2).constructor) : o.apply(t2, e2));
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t22) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
    o2.__proto__ = p22;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function editorContainer() {
  var Container = /* @__PURE__ */ function(_Component) {
    _inherits(Container2, _Component);
    function Container2() {
      _classCallCheck(this, Container2);
      return _callSuper(this, Container2, arguments);
    }
    _createClass(Container2, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, fancyScroll = _this$props.fancyScroll, children = _this$props.children, forwardedRef = _this$props.forwardedRef, rest = _objectWithoutProperties$7(_this$props, _excluded$7);
        return /* @__PURE__ */ React.createElement(React.Fragment, null, fancyScroll === true && /* @__PURE__ */ React.createElement(ScrollBar, _extends$7({
          ref: function ref(elRef) {
            return forwardedRef.current = elRef;
          }
        }, rest, {
          options: {
            suppressScrollX: true
          }
        }), children), fancyScroll === false && /* @__PURE__ */ React.createElement("div", _extends$7({
          ref: forwardedRef
        }, rest), children));
      }
    }]);
    return Container2;
  }(reactExports.Component);
  return /* @__PURE__ */ React.forwardRef(function(props, ref) {
    return /* @__PURE__ */ React.createElement(Container, _extends$7({
      forwardedRef: ref
    }, props));
  });
}
var EditorContainer = editorContainer();
var useControllableState = function useControllableState2(value, initialValue) {
  var initial2 = typeof value !== "undefined" ? value : initialValue;
  var _useState = reactExports.useState(initial2), _useState2 = _slicedToArray$2(_useState, 2), stateValue = _useState2[0], setStateValue = _useState2[1];
  var effectiveValue = typeof value !== "undefined" ? value : stateValue;
  return [effectiveValue, function(newValue) {
    setStateValue(newValue);
  }];
};
function MessageInputInner(_ref2, ref) {
  var _ref$value = _ref2.value, value = _ref$value === void 0 ? void 0 : _ref$value, _ref$onSend = _ref2.onSend, onSend = _ref$onSend === void 0 ? noop$1 : _ref$onSend, _ref$onChange = _ref2.onChange, onChange = _ref$onChange === void 0 ? noop$1 : _ref$onChange, _ref$autoFocus = _ref2.autoFocus, autoFocus = _ref$autoFocus === void 0 ? false : _ref$autoFocus, _ref$placeholder = _ref2.placeholder, placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder, _ref$fancyScroll = _ref2.fancyScroll, fancyScroll = _ref$fancyScroll === void 0 ? true : _ref$fancyScroll, className = _ref2.className, _ref$activateAfterCha = _ref2.activateAfterChange, activateAfterChange = _ref$activateAfterCha === void 0 ? false : _ref$activateAfterCha, _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, sendDisabled = _ref2.sendDisabled, _ref$sendOnReturnDisa = _ref2.sendOnReturnDisabled, sendOnReturnDisabled = _ref$sendOnReturnDisa === void 0 ? false : _ref$sendOnReturnDisa, _ref$attachDisabled = _ref2.attachDisabled, attachDisabled = _ref$attachDisabled === void 0 ? false : _ref$attachDisabled, _ref$sendButton = _ref2.sendButton, sendButton = _ref$sendButton === void 0 ? true : _ref$sendButton, _ref$attachButton = _ref2.attachButton, attachButton = _ref$attachButton === void 0 ? true : _ref$attachButton, _ref$onAttachClick = _ref2.onAttachClick, onAttachClick = _ref$onAttachClick === void 0 ? noop$1 : _ref$onAttachClick, rest = _objectWithoutProperties$7(_ref2, _excluded2);
  var scrollRef = reactExports.useRef();
  var msgRef = reactExports.useRef();
  var _useControllableState = useControllableState(value, ""), _useControllableState2 = _slicedToArray$2(_useControllableState, 2), stateValue = _useControllableState2[0], setStateValue = _useControllableState2[1];
  var _useControllableState3 = useControllableState(sendDisabled, true), _useControllableState4 = _slicedToArray$2(_useControllableState3, 2), stateSendDisabled = _useControllableState4[0], setStateSendDisabled = _useControllableState4[1];
  var focus = function focus2() {
    if (typeof msgRef.current !== "undefined") {
      msgRef.current.focus();
    }
  };
  reactExports.useImperativeHandle(ref, function() {
    return {
      focus
    };
  });
  reactExports.useEffect(function() {
    if (autoFocus === true) {
      focus();
    }
  }, []);
  reactExports.useEffect(function() {
    if (typeof scrollRef.current.updateScroll === "function") {
      scrollRef.current.updateScroll();
    }
  });
  var getContent = function getContent2() {
    var contentEditableRef = msgRef.current.msgRef.current;
    return [contentEditableRef.textContent, contentEditableRef.innerText, contentEditableRef.cloneNode(true).childNodes];
  };
  var send = function send2() {
    if (stateValue.length > 0) {
      if (value === void 0) {
        setStateValue("");
      }
      if (typeof sendDisabled === "undefined") {
        setStateSendDisabled(true);
      }
      var content = getContent();
      onSend(stateValue, content[0], content[1], content[2]);
    }
  };
  var handleKeyPress = function handleKeyPress2(evt) {
    if (evt.key === "Enter" && evt.shiftKey === false && sendOnReturnDisabled === false) {
      evt.preventDefault();
      send();
    }
  };
  var handleChange = function handleChange2(innerHTML, textContent, innerText) {
    setStateValue(innerHTML);
    if (typeof sendDisabled === "undefined") {
      setStateSendDisabled(textContent.length === 0);
    }
    if (typeof scrollRef.current.updateScroll === "function") {
      scrollRef.current.updateScroll();
    }
    var content = getContent();
    onChange(innerHTML, textContent, innerText, content[2]);
  };
  var cName2 = "".concat(prefix, "-message-input"), ph2 = typeof placeholder === "string" ? placeholder : "";
  return /* @__PURE__ */ React.createElement("div", _extends$7({}, rest, {
    className: classNames(cName2, _defineProperty$4({}, "".concat(cName2, "--disabled"), disabled), className)
  }), attachButton === true && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__tools")
  }, /* @__PURE__ */ React.createElement(AttachmentButton, {
    onClick: onAttachClick,
    disabled: disabled === true || attachDisabled === true
  })), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__content-editor-wrapper")
  }, /* @__PURE__ */ React.createElement(EditorContainer, {
    fancyScroll,
    ref: scrollRef,
    className: "".concat(cName2, "__content-editor-container")
  }, /* @__PURE__ */ React.createElement(ContentEditable, {
    ref: msgRef,
    className: "".concat(cName2, "__content-editor"),
    disabled,
    placeholder: ph2,
    onKeyPress: handleKeyPress,
    onChange: handleChange,
    activateAfterChange,
    value: stateValue
  }))), sendButton === true && /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName2, "__tools")
  }, /* @__PURE__ */ React.createElement(SendButton, {
    onClick: send,
    disabled: disabled === true || stateSendDisabled === true
  })));
}
var MessageInput$1 = /* @__PURE__ */ reactExports.forwardRef(MessageInputInner);
MessageInput$1.displayName = "MessageInput";
MessageInput$1.propTypes = {
  /** Value. */
  value: PropTypes.string,
  /** Placeholder. */
  placeholder: PropTypes.string,
  /** A input can show it is currently unable to be interacted with. */
  disabled: PropTypes.bool,
  /** Prevent that the input message is sent on a return press */
  sendOnReturnDisabled: PropTypes.bool,
  /** Send button can be disabled.<br>
   * It's state is tracked by component, but it can be forced */
  sendDisabled: PropTypes.bool,
  /**
   * Fancy scroll
   * This property is set in constructor, and is not changing when component update.
   */
  fancyScroll: PropTypes.bool,
  /**
   * Sets focus element and caret at the end of input<br>
   * when value is changed programmatically (e.g) from button click and element is not active
   */
  activateAfterChange: PropTypes.bool,
  /** Set focus after mount. */
  autoFocus: PropTypes.bool,
  /**
   * onChange handler<br>
   * @param {String} innerHtml
   * @param {String} textContent
   * @param {String} innerText
   * @param {NodeList} nodes
   */
  onChange: PropTypes.func,
  /**
   * onSend handler<br>
   * @param {String} innerHtml
   * @param {String} textContent
   * @param {String} innerText
   * @param {NodeList} nodes
   */
  onSend: PropTypes.func,
  /** Additional classes. */
  className: PropTypes.string,
  /** Show send button */
  sendButton: PropTypes.bool,
  /** Show add attachment button */
  attachButton: PropTypes.bool,
  /** Disable add attachment button */
  attachDisabled: PropTypes.bool,
  /**
   * onAttachClick handler
   */
  onAttachClick: PropTypes.func
};
var _excluded$6 = ["className", "children"];
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var InputToolbox = function InputToolbox2(_ref2) {
  var className = _ref2.className, children = _ref2.children, rest = _objectWithoutProperties$6(_ref2, _excluded$6);
  var cName2 = "".concat(prefix, "-input-toolbox");
  return /* @__PURE__ */ React.createElement("div", _extends$6({}, rest, {
    className: classNames(cName2, className)
  }), children);
};
InputToolbox.displayName = "InputToolbox";
var _excluded$5 = ["children", "className"];
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function _slicedToArray$1(arr2, i) {
  return _arrayWithHoles$1(arr2) || _iterableToArrayLimit$1(arr2, i) || _unsupportedIterableToArray$1(arr2, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) arr22[i] = arr2[i];
  return arr22;
}
function _iterableToArrayLimit$1(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a = [], f2 = true, o = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
    } catch (r22) {
      o = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles$1(arr2) {
  if (Array.isArray(arr2)) return arr2;
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ChatContainer = function ChatContainer2(_ref2) {
  var _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$5(_ref2, _excluded$5);
  var cName2 = "".concat(prefix, "-chat-container");
  var _getChildren = getChildren(children, [ConversationHeader, MessageList, MessageInput$1, InputToolbox]), _getChildren2 = _slicedToArray$1(_getChildren, 4), header = _getChildren2[0], messageList = _getChildren2[1], messageInput = _getChildren2[2], inputToolbox = _getChildren2[3];
  return /* @__PURE__ */ React.createElement("div", _extends$5({}, rest, {
    className: classNames(cName2, className)
  }), header, messageList, messageInput, inputToolbox);
};
var cName = "".concat(prefix, "-conversation");
function _typeof$4(o) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$4(o);
}
var _excluded$4 = ["children", "className", "visible"];
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _defineProperty$3(obj, key, value) {
  key = _toPropertyKey$3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$3(t2) {
  var i = _toPrimitive$3(t2, "string");
  return "symbol" == _typeof$4(i) ? i : String(i);
}
function _toPrimitive$3(t2, r2) {
  if ("object" != _typeof$4(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$4(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var ConversationOperations = function ConversationOperations2(_ref2) {
  var children = _ref2.children, className = _ref2.className, visible = _ref2.visible, rest = _objectWithoutProperties$4(_ref2, _excluded$4);
  return /* @__PURE__ */ React.createElement("div", _extends$4({}, rest, {
    className: classNames("".concat(cName, "__operations"), _defineProperty$3({}, "".concat(cName, "__operations--visible"), visible), className)
  }), React.Children.count(children) > 0 ? children : /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
    icon: faEllipsisV.faEllipsisV
  }));
};
ConversationOperations.displayName = "Conversation.Operations";
var _excluded$3 = ["lastSenderName", "info", "name", "children", "className"];
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _typeof$3(o) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3(o);
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var LastSenderName = function LastSenderName2(_ref2) {
  var name2 = _ref2.name;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName, "__last-sender")
  }, name2), ":");
};
var InfoContent = function InfoContent2(_ref2) {
  var info = _ref2.info;
  return /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName, "__info-content")
  }, info);
};
var ConversationContent = function ConversationContent2(_ref3) {
  var lastSenderName = _ref3.lastSenderName, info = _ref3.info, name2 = _ref3.name, children = _ref3.children, className = _ref3.className, rest = _objectWithoutProperties$3(_ref3, _excluded$3);
  var typeofLastSenderName = _typeof$3(lastSenderName);
  return /* @__PURE__ */ React.createElement("div", _extends$3({}, rest, {
    className: classNames("".concat(cName, "__content"), className)
  }), React.Children.count(children) > 0 ? children : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName, "__name")
  }, name2), /* @__PURE__ */ React.createElement("div", {
    className: "".concat(cName, "__info")
  }, typeofLastSenderName !== "undefined" ? /* @__PURE__ */ React.createElement(React.Fragment, null, typeofLastSenderName === "string" ? /* @__PURE__ */ React.createElement(LastSenderName, {
    name: lastSenderName
  }) : lastSenderName, " ") : null, typeof info !== "undefined" && /* @__PURE__ */ React.createElement(InfoContent, {
    info
  }))));
};
ConversationContent.displayName = "Conversation.Content";
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
var _excluded$2 = ["responsive", "children", "className"];
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$2(t2) {
  var i = _toPrimitive$2(t2, "string");
  return "symbol" == _typeof$2(i) ? i : String(i);
}
function _toPrimitive$2(t2, r2) {
  if ("object" != _typeof$2(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$2(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var MainContainer = function MainContainer2(_ref2) {
  var _ref$responsive = _ref2.responsive, responsive = _ref$responsive === void 0 ? false : _ref$responsive, _ref$children = _ref2.children, children = _ref$children === void 0 ? void 0 : _ref$children, className = _ref2.className, rest = _objectWithoutProperties$2(_ref2, _excluded$2);
  var cName2 = "".concat(prefix, "-main-container");
  return /* @__PURE__ */ React.createElement("div", _extends$2({}, rest, {
    className: classNames(cName2, _defineProperty$2({}, "".concat(cName2, "--responsive"), responsive), className)
  }), children);
};
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
var faSearch = {
  prefix: "fas",
  iconName: "search",
  icon: [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"]
};
var faTimes = {
  prefix: "fas",
  iconName: "times",
  icon: [352, 512, [], "f00d", "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]
};
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
var _excluded$1 = ["placeholder", "value", "onChange", "onClearClick", "className", "disabled"];
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$1(t2) {
  var i = _toPrimitive$1(t2, "string");
  return "symbol" == _typeof$1(i) ? i : String(i);
}
function _toPrimitive$1(t2, r2) {
  if ("object" != _typeof$1(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof$1(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _slicedToArray(arr2, i) {
  return _arrayWithHoles(arr2) || _iterableToArrayLimit(arr2, i) || _unsupportedIterableToArray(arr2, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr2, len) {
  if (len == null || len > arr2.length) len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++) arr22[i] = arr2[i];
  return arr22;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n2, i, u2, a = [], f2 = true, o = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
    } catch (r22) {
      o = true, n2 = r22;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o) throw n2;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr2) {
  if (Array.isArray(arr2)) return arr2;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var useControlledOrNot = function useControlledOrNot2(initialValue, value) {
  if (typeof value === "undefined") {
    return reactExports.useState(initialValue);
  } else {
    return [value, function() {
    }];
  }
};
function SearchInner(_ref2, ref) {
  var _ref$placeholder = _ref2.placeholder, placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder, _ref$value = _ref2.value, value = _ref$value === void 0 ? void 0 : _ref$value, _ref$onChange = _ref2.onChange, onChange = _ref$onChange === void 0 ? function() {
  } : _ref$onChange, _ref$onClearClick = _ref2.onClearClick, onClearClick = _ref$onClearClick === void 0 ? function() {
  } : _ref$onClearClick, className = _ref2.className, _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, rest = _objectWithoutProperties$1(_ref2, _excluded$1);
  var cName2 = "".concat(prefix, "-search");
  var isControlled = reactExports.useMemo(function() {
    return typeof value !== "undefined";
  }, []);
  var _useControlledOrNot = useControlledOrNot("", value), _useControlledOrNot2 = _slicedToArray(_useControlledOrNot, 2), searchValue = _useControlledOrNot2[0], setSearchValue = _useControlledOrNot2[1];
  var _useState = reactExports.useState(isControlled ? searchValue.length > 0 : false), _useState2 = _slicedToArray(_useState, 2), clearActive = _useState2[0], setClearActive = _useState2[1];
  if (isControlled !== (typeof value !== "undefined")) {
    throw "Search: Changing from controlled to uncontrolled component and vice versa is not allowed";
  }
  var inputRef = reactExports.useRef(void 0);
  var focus = function focus2() {
    if (typeof inputRef.current !== "undefined") {
      inputRef.current.focus();
    }
  };
  reactExports.useImperativeHandle(ref, function() {
    return {
      focus
    };
  });
  var handleChange = function handleChange2(e2) {
    var value2 = e2.target.value;
    setClearActive(value2.length > 0);
    if (isControlled === false) {
      setSearchValue(value2);
    }
    onChange(value2);
  };
  var handleClearClick = function handleClearClick2() {
    if (isControlled === false) {
      setSearchValue("");
    }
    setClearActive(false);
    onClearClick();
  };
  return /* @__PURE__ */ React.createElement("div", _extends$1({}, rest, {
    className: classNames(cName2, _defineProperty$1({}, "".concat(cName2, "--disabled"), disabled), className)
  }), /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
    icon: faSearch,
    className: "".concat(cName2, "__search-icon")
  }), /* @__PURE__ */ React.createElement("input", {
    ref: inputRef,
    type: "text",
    className: "".concat(cName2, "__input"),
    placeholder,
    onChange: handleChange,
    disabled,
    value: searchValue
  }), /* @__PURE__ */ React.createElement(FontAwesomeIcon, {
    icon: faTimes,
    className: classNames("".concat(cName2, "__clear-icon"), _defineProperty$1({}, "".concat(cName2, "__clear-icon--active"), clearActive)),
    onClick: handleClearClick
  }));
}
var Search = /* @__PURE__ */ reactExports.forwardRef(SearchInner);
Search.displayName = "Search";
Search.propTypes = {
  /** Placeholder. */
  placeholder: PropTypes.string,
  /** Current value of the search input. Creates a controlled component */
  value: PropTypes.string,
  /** OnInput handler. */
  onChange: PropTypes.func,
  /** OnClearClick handler. */
  onClearClick: PropTypes.func,
  /** Additional classes. */
  className: PropTypes.string,
  /** Disabled */
  disabled: PropTypes.bool
};
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var _excluded = ["className", "children", "size", "selected", "onChange", "itemsTabIndex"];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2);
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function StatusListInner(_ref2, ref) {
  var className = _ref2.className, children = _ref2.children, size2 = _ref2.size, selected = _ref2.selected, _ref$onChange = _ref2.onChange, onChange = _ref$onChange === void 0 ? noop$1 : _ref$onChange, itemsTabIndex = _ref2.itemsTabIndex, rest = _objectWithoutProperties(_ref2, _excluded);
  var cName2 = "".concat(prefix, "-status-list");
  var listRef = reactExports.useRef();
  reactExports.useImperativeHandle(ref, function() {
    return {
      focus: function focus(idx) {
        var items = Array.from(listRef.current.querySelectorAll("li"));
        var directChild = items.filter(function(item) {
          return item.parentNode === listRef.current;
        });
        if (typeof directChild[idx] !== "undefined") {
          directChild[idx].focus();
        }
      }
    };
  });
  var tabIndex = itemsTabIndex;
  return /* @__PURE__ */ React.createElement("ul", _extends({
    ref: listRef
  }, rest, {
    className: classNames(cName2, className, _defineProperty({}, "".concat(cName2, "--").concat(size2), size2))
  }), React.Children.map(children, function(item) {
    var newProps = {};
    if (selected) {
      newProps.selected = item.props.status === selected;
    }
    if (onChange) {
      newProps.onClick = function(evt) {
        onChange(item.props.status);
        if (item.onClick) {
          item.onClick(evt);
        }
      };
    }
    var onKeyPress = function onKeyPress2(evt) {
      if (onChange) {
        if (evt.key === "Enter" && evt.shiftKey === false && evt.altKey === false) {
          onChange(item.props.status);
        }
      }
    };
    var tIndex = function() {
      if (typeof tabIndex === "number") {
        if (tabIndex > 0) {
          return tabIndex++;
        } else {
          return tabIndex;
        }
      } else {
        return void 0;
      }
    }();
    return /* @__PURE__ */ React.createElement("li", {
      tabIndex: tIndex,
      onKeyPress
    }, /* @__PURE__ */ React.cloneElement(item, newProps));
  }));
}
var StatusList = /* @__PURE__ */ reactExports.forwardRef(StatusListInner);
StatusList.displayName = "StatusList";
StatusList.propTypes = {
  /**
   * Primary content.
   * Allowed components:
   *
   * * &lt;Status /&gt;
   */
  children: allowedChildren([Status]),
  /** Selected element */
  selected: PropTypes.oneOf(StatusEnum),
  /** Size */
  size: PropTypes.oneOf(SizeEnum),
  /** tabindex value for items. Any positive integer will be treated as start index for counting. Zero and negative values will be applied to all items */
  itemsTabIndex: PropTypes.number,
  /** Additional classes. */
  className: PropTypes.string,
  /** onChange handler */
  onChange: PropTypes.func
};
function ChatHistoryPanel() {
  const { t: t2 } = useTranslation();
  const { messages: messages2 } = useChatHistory();
  const { confName } = useConfig();
  const { baseUrl } = useWebSocket();
  const userName = "Me";
  const validMessages = messages2.filter(
    (msg) => msg.content || // Keep messages with content
    msg.type === "tool_call_status" && msg.status === "running" || // Keep running tools
    msg.type === "tool_call_status" && msg.status === "completed" || // Keep completed tools
    msg.type === "tool_call_status" && msg.status === "error"
    // Keep error tools
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      h: "full",
      overflow: "hidden",
      bg: "gray.900",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Global, { styles: chatPanelStyles }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MainContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChatContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MessageList, { children: validMessages.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            color: "whiteAlpha.500",
            fontSize: "sm",
            children: t2("sidebar.noMessages")
          }
        ) : validMessages.map((msg) => {
          if (msg.type === "tool_call_status") {
            return (
              // Render Tool Call Indicator using msg properties
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Flex,
                {
                  ...sidebarStyles.toolCallIndicator.container,
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Icon,
                      {
                        as: FaTools,
                        ...sidebarStyles.toolCallIndicator.icon
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...sidebarStyles.toolCallIndicator.text, children: msg.status === "running" ? `${msg.name} is using tool ${msg.tool_name}` : `${msg.name} used tool ${msg.tool_name}` }),
                    msg.status === "running" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Spinner,
                      {
                        size: "xs",
                        color: sidebarStyles.toolCallIndicator.spinner.color,
                        ml: sidebarStyles.toolCallIndicator.spinner.ml
                      }
                    ),
                    msg.status === "completed" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Icon,
                      {
                        as: FaCheck,
                        ...sidebarStyles.toolCallIndicator.completedIcon
                      }
                    ),
                    msg.status === "error" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Icon,
                      {
                        as: FaTimes,
                        ...sidebarStyles.toolCallIndicator.errorIcon
                      }
                    )
                  ]
                },
                msg.id
              )
            );
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Message,
            {
              model: {
                message: msg.content,
                sentTime: msg.timestamp,
                sender: msg.role === "ai" ? msg.name || confName || "AI" : userName,
                direction: msg.role === "ai" ? "incoming" : "outgoing",
                position: "single"
              },
              avatarPosition: msg.role === "ai" ? "tl" : "tr",
              avatarSpacer: false,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { children: msg.role === "ai" ? msg.avatar ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: `${baseUrl}/avatars/${msg.avatar}`,
                  alt: "avatar",
                  style: { width: "100%", height: "100%", borderRadius: "50%" },
                  onError: (e2) => {
                    const target = e2.target;
                    const fallbackName = msg.name || confName || "A";
                    target.outerHTML = `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; border-radius: 50%; background-color: var(--chakra-colors-blue-500); color: white; font-size: 14px;">${fallbackName[0].toUpperCase()}</div>`;
                  }
                }
              ) : msg.name && msg.name[0].toUpperCase() || confName && confName[0].toUpperCase() || "A" : userName[0].toUpperCase() })
            },
            msg.id
          );
        }) }) }) })
      ]
    }
  );
}
const useCameraPanel = () => {
  const videoRef = reactExports.useRef(null);
  const [error2, setError] = reactExports.useState("");
  const [isHovering, setIsHovering] = reactExports.useState(false);
  const {
    isStreaming,
    stream,
    startCamera,
    stopCamera
  } = useCamera();
  const toggleCamera = async () => {
    try {
      if (isStreaming) {
        stopCamera();
      } else {
        await startCamera();
      }
      setError("");
    } catch (error22) {
      let errorMessage = "Unable to access camera";
      if (error22 instanceof Error) {
        errorMessage = error22.message;
      }
      setError(errorMessage);
    }
  };
  const handleMouseEnter = () => setIsHovering(true);
  const handleMouseLeave = () => setIsHovering(false);
  return {
    videoRef,
    error: error2,
    isHovering,
    isStreaming,
    stream,
    toggleCamera,
    handleMouseEnter,
    handleMouseLeave
  };
};
function LiveIndicator() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { color: "red.500", display: "flex", alignItems: "center", gap: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { w: "8px", h: "8px", borderRadius: "full", bg: "red.500", animation: "pulse 2s infinite" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { fontSize: "sm", children: t2("sidebar.live") })
  ] });
}
function CameraPlaceholder() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      position: "absolute",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: 2,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FiCamera, { size: 24 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { color: "whiteAlpha.600", fontSize: "sm", textAlign: "center", children: t2("footer.cameraControl") })
      ]
    }
  );
}
function VideoStream$1({
  videoRef,
  isStreaming
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "video",
    {
      ref: videoRef,
      autoPlay: true,
      playsInline: true,
      muted: true,
      style: sidebarStyles.cameraPanel.video,
      ...isStreaming ? {} : { display: "none" }
    }
  );
}
function CameraPanel() {
  const { t: t2 } = useTranslation();
  const {
    videoRef,
    error: error2,
    isHovering,
    isStreaming,
    stream,
    toggleCamera,
    handleMouseEnter,
    handleMouseLeave
  } = useCameraPanel();
  reactExports.useEffect(() => {
    if (videoRef.current) {
      videoRef.current.srcObject = stream;
    }
  }, [stream]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.cameraPanel.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.cameraPanel.header, children: isStreaming && /* @__PURE__ */ jsxRuntimeExports.jsx(LiveIndicator, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tooltip,
      {
        showArrow: true,
        content: isStreaming ? t2("footer.cameraStopping") : t2("footer.cameraControl"),
        open: isHovering && !error2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            ...sidebarStyles.cameraPanel.videoContainer,
            onClick: toggleCamera,
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            cursor: "pointer",
            position: "relative",
            _hover: {
              bg: "whiteAlpha.100"
            },
            children: error2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { color: "red.300", fontSize: "sm", textAlign: "center", children: error2 }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(VideoStream$1, { videoRef, isStreaming }),
              !isStreaming && /* @__PURE__ */ jsxRuntimeExports.jsx(CameraPlaceholder, {})
            ] })
          }
        )
      }
    )
  ] });
}
function useCaptureScreen() {
  const videoRef = reactExports.useRef(null);
  const [isHovering, setIsHovering] = reactExports.useState(false);
  const { stream, isStreaming, error: error2, startCapture, stopCapture } = useScreenCaptureContext();
  const toggleCapture = () => {
    if (isStreaming) {
      stopCapture();
    } else {
      startCapture();
    }
  };
  const handleMouseEnter = () => setIsHovering(true);
  const handleMouseLeave = () => setIsHovering(false);
  reactExports.useEffect(() => {
    if (videoRef.current) {
      videoRef.current.srcObject = stream;
    }
  }, [stream]);
  return {
    videoRef,
    error: error2,
    isHovering,
    isStreaming,
    stream,
    toggleCapture,
    handleMouseEnter,
    handleMouseLeave
  };
}
function ScreenIndicator() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { color: "red.500", display: "flex", alignItems: "center", gap: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        w: "8px",
        h: "8px",
        borderRadius: "full",
        bg: "red.500",
        animation: "pulse 2s infinite"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { fontSize: "sm", children: t2("sidebar.screen") })
  ] });
}
function ScreenPlaceholder() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      position: "absolute",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: 2,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FiMonitor, { size: 24 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { color: "whiteAlpha.600", fontSize: "sm", textAlign: "center", children: t2("footer.screenControl") })
      ]
    }
  );
}
function VideoStream({
  videoRef,
  isStreaming
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "video",
    {
      ref: videoRef,
      autoPlay: true,
      playsInline: true,
      muted: true,
      style: sidebarStyles.screenPanel.video,
      ...isStreaming ? {} : { display: "none" }
    }
  );
}
function ScreenPanel() {
  const { t: t2 } = useTranslation();
  const {
    videoRef,
    error: error2,
    isHovering,
    isStreaming,
    toggleCapture,
    handleMouseEnter,
    handleMouseLeave
  } = useCaptureScreen();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.screenPanel.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.screenPanel.header, children: isStreaming && /* @__PURE__ */ jsxRuntimeExports.jsx(ScreenIndicator, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tooltip,
      {
        showArrow: true,
        content: isStreaming ? t2("footer.screenStopping") : t2("footer.screenControl"),
        open: isHovering && !error2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            ...sidebarStyles.screenPanel.screenContainer,
            onClick: toggleCapture,
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            cursor: "pointer",
            position: "relative",
            _hover: {
              bg: "whiteAlpha.100"
            },
            children: error2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { color: "red.300", fontSize: "sm", textAlign: "center", children: error2 }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(VideoStream, { videoRef, isStreaming }),
              !isStreaming && /* @__PURE__ */ jsxRuntimeExports.jsx(ScreenPlaceholder, {})
            ] })
          }
        )
      }
    )
  ] });
}
const BrowserContext = reactExports.createContext({
  browserViewData: null,
  setBrowserViewData: () => {
  },
  clearBrowserViewData: () => {
  }
});
function BrowserProvider({ children }) {
  const [browserViewData, setBrowserViewDataState] = reactExports.useState(null);
  const setBrowserViewData = reactExports.useCallback((data) => {
    setBrowserViewDataState(data);
  }, []);
  const clearBrowserViewData = reactExports.useCallback(() => {
    setBrowserViewDataState(null);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    BrowserContext.Provider,
    {
      value: {
        browserViewData,
        setBrowserViewData,
        clearBrowserViewData
      },
      children
    }
  );
}
function useBrowser() {
  const context = reactExports.useContext(BrowserContext);
  if (!context) {
    throw new Error("useBrowser must be used within a BrowserProvider");
  }
  return context;
}
function BrowserPlaceholder() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      position: "absolute",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: 2,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FiGlobe, { size: 24 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { color: "whiteAlpha.600", fontSize: "sm", textAlign: "center", children: t2("sidebar.noBrowserSession") })
      ]
    }
  );
}
function BrowserPanel() {
  const { t: t2 } = useTranslation();
  const { browserViewData } = useBrowser();
  const [isHovering, setIsHovering] = reactExports.useState(false);
  const handleMouseEnter = () => setIsHovering(true);
  const handleMouseLeave = () => setIsHovering(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.browserPanel.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.browserPanel.header, children: browserViewData && /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { fontSize: "sm", color: "blue.300", children: t2("sidebar.browserSession") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Tooltip,
      {
        showArrow: true,
        content: browserViewData ? "Interactive browser view" : t2("sidebar.noBrowserSession"),
        open: isHovering,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            ...sidebarStyles.browserPanel.browserContainer,
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            position: "relative",
            children: browserViewData ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "iframe",
              {
                src: browserViewData.debuggerFullscreenUrl,
                style: sidebarStyles.browserPanel.iframe,
                sandbox: "allow-same-origin allow-scripts",
                allow: "clipboard-read; clipboard-write"
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserPlaceholder, {})
          }
        )
      }
    )
  ] });
}
function BottomTab() {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TabsRoot,
    {
      defaultValue: "camera",
      variant: "plain",
      ...sidebarStyles.bottomTab.container,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { ...sidebarStyles.bottomTab.list, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "camera", ...sidebarStyles.bottomTab.trigger, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FiCamera, {}),
            t2("sidebar.camera")
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "screen", ...sidebarStyles.bottomTab.trigger, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FiMonitor, {}),
            t2("sidebar.screen")
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "browser", ...sidebarStyles.bottomTab.trigger, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FiGlobe, {}),
            t2("sidebar.browser")
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "camera", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraPanel, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "screen", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScreenPanel, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "browser", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserPanel, {}) })
      ]
    }
  );
}
const minutesInMonth = 43200;
const minutesInDay = 1440;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}
function toDate(argument, context) {
  return constructFrom(argument, argument);
}
let defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function normalizeDates(context, ...dates) {
  const normalize2 = constructFrom.bind(
    null,
    context || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize2);
}
function compareAsc(dateLeft, dateRight) {
  const diff = +toDate(dateLeft) - +toDate(dateRight);
  if (diff < 0) return -1;
  else if (diff > 0) return 1;
  return diff;
}
function constructNow(date) {
  return constructFrom(date, Date.now());
}
function differenceInCalendarMonths(laterDate, earlierDate, options2) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options2?.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}
function getRoundingMethod(method) {
  return (number) => {
    const round2 = method ? Math[method] : Math.trunc;
    const result = round2(number);
    return result === 0 ? 0 : result;
  };
}
function differenceInMilliseconds(laterDate, earlierDate) {
  return +toDate(laterDate) - +toDate(earlierDate);
}
function endOfDay(date, options2) {
  const _date = toDate(date);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date, options2) {
  const _date = toDate(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function isLastDayOfMonth(date, options2) {
  const _date = toDate(date);
  return +endOfDay(_date) === +endOfMonth(_date);
}
function differenceInMonths(laterDate, earlierDate, options2) {
  const [laterDate_, workingLaterDate, earlierDate_] = normalizeDates(
    options2?.in,
    laterDate,
    laterDate,
    earlierDate
  );
  const sign2 = compareAsc(workingLaterDate, earlierDate_);
  const difference = Math.abs(
    differenceInCalendarMonths(workingLaterDate, earlierDate_)
  );
  if (difference < 1) return 0;
  if (workingLaterDate.getMonth() === 1 && workingLaterDate.getDate() > 27)
    workingLaterDate.setDate(30);
  workingLaterDate.setMonth(workingLaterDate.getMonth() - sign2 * difference);
  let isLastMonthNotFull = compareAsc(workingLaterDate, earlierDate_) === -sign2;
  if (isLastDayOfMonth(laterDate_) && difference === 1 && compareAsc(laterDate_, earlierDate_) === 1) {
    isLastMonthNotFull = false;
  }
  const result = sign2 * (difference - +isLastMonthNotFull);
  return result === 0 ? 0 : result;
}
function differenceInSeconds(laterDate, earlierDate, options2) {
  const diff = differenceInMilliseconds(laterDate, earlierDate) / 1e3;
  return getRoundingMethod(options2?.roundingMethod)(diff);
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance$1 = (token2, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2?.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options2 = {}) => {
    const width = options2.width ? String(options2.width) : args.defaultWidth;
    const format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative = (token2, _date, _baseDate, _options) => formatRelativeLocale[token2];
function buildLocalizeFn(args) {
  return (value, options2) => {
    const context = options2?.context ? String(options2.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options2?.width ? String(options2.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options2?.width ? String(options2.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options2 = {}) => {
    const width = options2.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options2.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options2.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options2 = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function formatDistance(laterDate, earlierDate, options2) {
  const defaultOptions2 = getDefaultOptions();
  const locale = options2?.locale ?? defaultOptions2.locale ?? enUS;
  const minutesInAlmostTwoDays = 2520;
  const comparison = compareAsc(laterDate, earlierDate);
  if (isNaN(comparison)) throw new RangeError("Invalid time value");
  const localizeOptions = Object.assign({}, options2, {
    addSuffix: options2?.addSuffix,
    comparison
  });
  const [laterDate_, earlierDate_] = normalizeDates(
    options2?.in,
    ...comparison > 0 ? [earlierDate, laterDate] : [laterDate, earlierDate]
  );
  const seconds = differenceInSeconds(earlierDate_, laterDate_);
  const offsetInSeconds = (getTimezoneOffsetInMilliseconds(earlierDate_) - getTimezoneOffsetInMilliseconds(laterDate_)) / 1e3;
  const minutes = Math.round((seconds - offsetInSeconds) / 60);
  let months;
  if (minutes < 2) {
    if (options2?.includeSeconds) {
      if (seconds < 5) {
        return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }
  } else if (minutes < 45) {
    return locale.formatDistance("xMinutes", minutes, localizeOptions);
  } else if (minutes < 90) {
    return locale.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes < minutesInDay) {
    const hours = Math.round(minutes / 60);
    return locale.formatDistance("aboutXHours", hours, localizeOptions);
  } else if (minutes < minutesInAlmostTwoDays) {
    return locale.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes < minutesInMonth) {
    const days = Math.round(minutes / minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);
  } else if (minutes < minutesInMonth * 2) {
    months = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("aboutXMonths", months, localizeOptions);
  }
  months = differenceInMonths(earlierDate_, laterDate_);
  if (months < 12) {
    const nearestMonth = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    const monthsSinceStartOfYear = months % 12;
    const years = Math.trunc(months / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale.formatDistance("aboutXYears", years, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale.formatDistance("overXYears", years, localizeOptions);
    } else {
      return locale.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}
function formatDistanceToNow(date, options2) {
  return formatDistance(date, constructNow(date), options2);
}
const DrawerContent = reactExports.forwardRef((props, ref) => {
  const {
    children,
    portalled = true,
    portalRef,
    offset: offset2,
    ...rest
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { disabled: !portalled, container: portalRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerPositioner, { padding: offset2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerContent$1, { ref, ...rest, asChild: false, children }) }) });
});
const DrawerCloseTrigger = reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  DrawerCloseTrigger$1,
  {
    position: "absolute",
    top: "2",
    insetEnd: "2",
    ...props,
    asChild: true,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButton, { size: "sm", ref })
  }
));
const DrawerTrigger = DrawerTrigger$1;
const DrawerRoot = DrawerRoot$1;
const DrawerFooter = DrawerFooter$1;
const DrawerHeader = DrawerHeader$1;
const DrawerBody = DrawerBody$1;
const DrawerBackdrop = DrawerBackdrop$1;
const DrawerTitle = DrawerTitle$1;
const DrawerActionTrigger = DrawerActionTrigger$1;
const useHistoryDrawer = () => {
  const { t: t2 } = useTranslation();
  const [open, setOpen] = reactExports.useState(false);
  const {
    historyList,
    currentHistoryUid,
    setCurrentHistoryUid,
    setHistoryList,
    messages: messages2,
    updateHistoryList
  } = useChatHistory();
  const { sendMessage } = useWebSocket();
  const fetchAndSetHistory = (uid) => {
    if (!uid || uid === currentHistoryUid) return;
    if (currentHistoryUid && messages2.length > 0) {
      const latestMessage = messages2[messages2.length - 1];
      updateHistoryList(currentHistoryUid, latestMessage);
    }
    setCurrentHistoryUid(uid);
    sendMessage({
      type: "fetch-and-set-history",
      history_uid: uid
    });
  };
  const deleteHistory = (uid) => {
    if (uid === currentHistoryUid) {
      toaster.create({
        title: t2("error.cannotDeleteCurrentHistory"),
        type: "warning",
        duration: 2e3
      });
      return;
    }
    sendMessage({
      type: "delete-history",
      history_uid: uid
    });
    setHistoryList(historyList.filter((history2) => history2.uid !== uid));
  };
  const getLatestMessageContent = (history2) => {
    if (history2.uid === currentHistoryUid && messages2.length > 0) {
      const latestMessage = messages2[messages2.length - 1];
      return {
        content: latestMessage.content,
        timestamp: latestMessage.timestamp
      };
    }
    return {
      content: history2.latest_message?.content || "",
      timestamp: history2.timestamp
    };
  };
  return {
    open,
    setOpen,
    historyList,
    currentHistoryUid,
    fetchAndSetHistory,
    deleteHistory,
    getLatestMessageContent
  };
};
const HistoryItem = reactExports.memo(({
  isSelected,
  latestMessage,
  onSelect,
  onDelete,
  isDeleteDisabled
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      ...sidebarStyles.historyDrawer.historyItem,
      ...isSelected ? sidebarStyles.historyDrawer.historyItemSelected : {},
      onClick: onSelect,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.historyDrawer.historyHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.historyDrawer.timestamp, children: latestMessage.timestamp ? formatDistanceToNow(new Date(latestMessage.timestamp), { addSuffix: true }) : t2("history.noMessages") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$2,
            {
              onClick: onDelete,
              disabled: isDeleteDisabled,
              ...sidebarStyles.historyDrawer.deleteButton,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiTrash2, {})
            }
          )
        ] }),
        latestMessage.content && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.historyDrawer.messagePreview, children: latestMessage.content })
      ]
    }
  );
});
HistoryItem.displayName = "HistoryItem";
function HistoryDrawer({ children }) {
  const { t: t2 } = useTranslation();
  const {
    open,
    setOpen,
    historyList,
    currentHistoryUid,
    fetchAndSetHistory,
    deleteHistory,
    getLatestMessageContent
  } = useHistoryDrawer();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    DrawerRoot,
    {
      open,
      onOpenChange: (e2) => setOpen(e2.open),
      placement: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBackdrop, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTrigger, { asChild: true, children }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerContent, { style: sidebarStyles.historyDrawer.drawer.content, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTitle, { style: sidebarStyles.historyDrawer.drawer.title, children: t2("history.chatHistoryList") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerCloseTrigger, { style: sidebarStyles.historyDrawer.drawer.closeButton })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.historyDrawer.listContainer, children: historyList.map((history2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            HistoryItem,
            {
              isSelected: currentHistoryUid === history2.uid,
              latestMessage: getLatestMessageContent(history2),
              onSelect: () => fetchAndSetHistory(history2.uid),
              onDelete: (e2) => {
                e2.stopPropagation();
                deleteHistory(history2.uid);
              },
              isDeleteDisabled: currentHistoryUid === history2.uid
            },
            history2.uid
          )) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerActionTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { ...sidebarStyles.historyDrawer.drawer.actionButton, children: t2("common.close") }) }) })
        ] })
      ]
    }
  );
}
const useSidebar = () => {
  const disclosure = useDisclosure();
  const { sendMessage } = useWebSocket();
  const { interrupt } = useInterrupt();
  const { currentHistoryUid, messages: messages2, updateHistoryList } = useChatHistory();
  const { setMode, mode, isElectron: isElectron2 } = useMode();
  const createNewHistory = () => {
    if (currentHistoryUid && messages2.length > 0) {
      const latestMessage = messages2[messages2.length - 1];
      updateHistoryList(currentHistoryUid, latestMessage);
    }
    interrupt();
    sendMessage({
      type: "create-new-history"
    });
  };
  return {
    settingsOpen: disclosure.open,
    onSettingsOpen: disclosure.onOpen,
    onSettingsClose: disclosure.onClose,
    createNewHistory,
    setMode,
    currentMode: mode,
    isElectron: isElectron2
  };
};
const ClipboardIcon = reactExports.forwardRef(function ClipboardIcon2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIndicator, { copied: /* @__PURE__ */ jsxRuntimeExports.jsx(LuCheck, {}), ...props, ref, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuClipboard, {}) });
});
const ClipboardCopyText = reactExports.forwardRef(function ClipboardCopyText22(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIndicator, { copied: "Copied", ...props, ref, children: "Copy" });
});
reactExports.forwardRef(function ClipboardLabel2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ClipboardLabel,
    {
      textStyle: "sm",
      fontWeight: "medium",
      display: "inline-block",
      mb: "1",
      ...props,
      ref
    }
  );
});
const ClipboardButton = reactExports.forwardRef(
  function ClipboardButton2(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$2, { ref, size: "sm", variant: "surface", ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIcon, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardCopyText, {})
    ] }) });
  }
);
reactExports.forwardRef(
  function ClipboardLink2(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button$2,
      {
        unstyled: true,
        variant: "plain",
        size: "xs",
        display: "inline-flex",
        alignItems: "center",
        gap: "2",
        ref,
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LuLink, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardCopyText, {})
        ]
      }
    ) });
  }
);
reactExports.forwardRef(function ClipboardIconButton2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButton, { ref, size: "xs", variant: "subtle", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardIcon, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardCopyText, { srOnly: true })
  ] }) });
});
reactExports.forwardRef(
  function ClipboardInputElement(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardInput, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { ref, ...props }) });
  }
);
const ClipboardRoot = ClipboardRoot$1;
const useGroupDrawer = () => {
  const { t: t2 } = useTranslation();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [inviteUid, setInviteUid] = reactExports.useState("");
  const { sendMessage } = useWebSocket();
  const requestGroupInfo = reactExports.useCallback(() => {
    sendMessage({
      type: "request-group-info"
    });
  }, [sendMessage]);
  const handleInvite = reactExports.useCallback(async () => {
    if (!inviteUid.trim()) {
      toaster.create({
        title: t2("error.enterValidUuid"),
        type: "error",
        duration: 2e3
      });
      return;
    }
    sendMessage({
      type: "add-client-to-group",
      invitee_uid: inviteUid.trim()
    });
    setInviteUid("");
    setTimeout(requestGroupInfo, 100);
  }, [inviteUid, sendMessage, requestGroupInfo, t2]);
  const handleRemove = reactExports.useCallback((targetUid) => {
    sendMessage({
      type: "remove-client-from-group",
      target_uid: targetUid
    });
    setTimeout(requestGroupInfo, 100);
  }, [sendMessage, requestGroupInfo]);
  const handleLeaveGroup = reactExports.useCallback((selfUid) => {
    sendMessage({
      type: "remove-client-from-group",
      target_uid: selfUid
    });
    setTimeout(requestGroupInfo, 100);
  }, [sendMessage, requestGroupInfo]);
  return {
    isOpen,
    setIsOpen,
    inviteUid,
    setInviteUid,
    handleInvite,
    handleRemove,
    handleLeaveGroup,
    requestGroupInfo
  };
};
const GroupContext = reactExports.createContext(null);
function GroupProvider({ children }) {
  const [selfUid, setSelfUid] = reactExports.useState("");
  const [groupMembers, setGroupMembers] = reactExports.useState([]);
  const [isOwner, setIsOwner] = reactExports.useState(false);
  const resetGroupState = () => {
    setGroupMembers([]);
    setIsOwner(false);
  };
  const sortedGroupMembers = reactExports.useMemo(() => {
    if (!groupMembers.includes(selfUid)) return groupMembers;
    return [
      selfUid,
      ...groupMembers.filter((memberId) => memberId !== selfUid)
    ];
  }, [groupMembers, selfUid]);
  return (
    // eslint-disable-next-line react/jsx-no-constructed-context-values
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      GroupContext.Provider,
      {
        value: {
          selfUid,
          groupMembers,
          isOwner,
          setSelfUid,
          setGroupMembers,
          setIsOwner,
          sortedGroupMembers,
          resetGroupState
        },
        children
      }
    )
  );
}
function useGroup() {
  const context = reactExports.useContext(GroupContext);
  if (!context) {
    throw new Error("useGroup must be used within a GroupProvider");
  }
  return context;
}
function GroupDrawer({ children }) {
  const { t: t2 } = useTranslation();
  const { selfUid, sortedGroupMembers, isOwner } = useGroup();
  const {
    isOpen,
    setIsOpen,
    inviteUid,
    setInviteUid,
    handleInvite,
    handleRemove,
    handleLeaveGroup,
    requestGroupInfo
  } = useGroupDrawer();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    DrawerRoot,
    {
      open: isOpen,
      onOpenChange: (e2) => {
        setIsOpen(e2.open);
        if (e2.open) {
          requestGroupInfo();
        }
      },
      placement: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBackdrop, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTrigger, { asChild: true, children }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerContent, { style: sidebarStyles.historyDrawer.drawer.content, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DrawerHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerTitle, { style: sidebarStyles.historyDrawer.drawer.title, children: t2("group.management") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DrawerCloseTrigger,
              {
                style: sidebarStyles.historyDrawer.drawer.closeButton
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.historyDrawer.listContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.section, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...sidebarStyles.groupDrawer.sectionTitle, children: t2("group.yourUuid") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.memberItem, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...sidebarStyles.groupDrawer.memberText, children: selfUid }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardRoot, { value: selfUid, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ClipboardButton,
                  {
                    ...sidebarStyles.groupDrawer.clipboardButton,
                    size: "sm"
                  }
                ) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.section, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...sidebarStyles.groupDrawer.sectionTitle, children: t2("group.inviteMember") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.inviteBox, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1,
                  {
                    value: inviteUid,
                    onChange: (e2) => setInviteUid(e2.target.value),
                    placeholder: t2("group.enterMemberUuid"),
                    ...sidebarStyles.groupDrawer.input
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$2,
                  {
                    onClick: handleInvite,
                    ...sidebarStyles.groupDrawer.button,
                    children: t2("group.invite")
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.section, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...sidebarStyles.groupDrawer.sectionTitle, children: t2("group.members") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.groupDrawer.memberList, children: sortedGroupMembers.map((memberId) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.groupDrawer.memberItem, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...sidebarStyles.groupDrawer.memberText, children: memberId === selfUid ? `${memberId} (${t2("group.you")})` : memberId }),
                (isOwner && memberId !== selfUid || !isOwner && memberId === selfUid) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    "aria-label": memberId === selfUid ? t2("group.leaveGroup") : t2("group.removeMember"),
                    onClick: () => memberId === selfUid ? handleLeaveGroup(selfUid) : handleRemove(memberId),
                    ...sidebarStyles.groupDrawer.removeButton,
                    size: "sm",
                    title: memberId === selfUid ? t2("group.leaveGroup") : t2("group.removeMember"),
                    children: memberId === selfUid ? t2("group.leave") : /* @__PURE__ */ jsxRuntimeExports.jsx(FiX, {})
                  }
                )
              ] }, memberId)) })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerActionTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { ...sidebarStyles.historyDrawer.drawer.actionButton, children: t2("common.close") }) }) })
        ] })
      ]
    }
  );
}
const ToggleButton$1 = reactExports.memo(({ isCollapsed, onToggle }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    ...sidebarStyles.sidebar.toggleButton,
    style: {
      transform: isCollapsed ? "rotate(180deg)" : "rotate(0deg)"
    },
    onClick: onToggle,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiChevronLeft, {})
  }
));
ToggleButton$1.displayName = "ToggleButton";
const ModeMenu = reactExports.memo(({ setMode, currentMode, isElectron: isElectron2 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuRoot, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(MenuTrigger, { as: Button$2, "aria-label": "Mode Menu", title: "Change Mode", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiLayers, {}) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPositioner, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuRadioItemGroup, { value: currentMode, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuRadioItem, { value: "window", onClick: () => setMode("window"), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemIndicator, {}),
      "Live Mode"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      MenuRadioItem,
      {
        value: "pet",
        onClick: () => {
          if (isElectron2) {
            setMode("pet");
          }
        },
        disabled: !isElectron2,
        title: !isElectron2 ? "Pet mode is only available in desktop app" : void 0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemIndicator, {}),
          "Pet Mode"
        ]
      }
    )
  ] }) }) })
] }));
ModeMenu.displayName = "ModeMenu";
const HeaderButtons = reactExports.memo(({ onSettingsOpen, onNewHistory, setMode, currentMode, isElectron: isElectron2 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { display: "flex", gap: 1, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { onClick: onSettingsOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiSettings, {}) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(GroupDrawer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiUsers, {}) }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(HistoryDrawer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiClock, {}) }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { onClick: onNewHistory, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiPlus, {}) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(ModeMenu, { setMode, currentMode, isElectron: isElectron2 })
] }));
HeaderButtons.displayName = "HeaderButtons";
const SidebarContent = reactExports.memo(({
  onSettingsOpen,
  onNewHistory,
  setMode,
  currentMode,
  isElectron: isElectron2
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.sidebar.content, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...sidebarStyles.sidebar.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    HeaderButtons,
    {
      onSettingsOpen,
      onNewHistory,
      setMode,
      currentMode,
      isElectron: isElectron2
    }
  ) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(ChatHistoryPanel, {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx(BottomTab, {})
] }));
SidebarContent.displayName = "SidebarContent";
function Sidebar({ isCollapsed = false, onToggle }) {
  const {
    settingsOpen,
    onSettingsOpen,
    onSettingsClose,
    createNewHistory,
    setMode,
    currentMode,
    isElectron: isElectron2
  } = useSidebar();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...sidebarStyles.sidebar.container(isCollapsed), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton$1, { isCollapsed, onToggle }),
    !isCollapsed && !settingsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SidebarContent,
      {
        onSettingsOpen,
        onNewHistory: createNewHistory,
        setMode,
        currentMode,
        isElectron: isElectron2
      }
    ),
    !isCollapsed && settingsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingUI,
      {
        open: settingsOpen,
        onClose: onSettingsClose,
        onToggle
      }
    )
  ] });
}
function BsMicFill(props) {
  return GenIcon({ "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0z" }, "child": [] }, { "tag": "path", "attr": { "d": "M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5" }, "child": [] }] })(props);
}
function BsMicMuteFill(props) {
  return GenIcon({ "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M13 8c0 .564-.094 1.107-.266 1.613l-.814-.814A4 4 0 0 0 12 8V7a.5.5 0 0 1 1 0zm-5 4c.818 0 1.578-.245 2.212-.667l.718.719a5 5 0 0 1-2.43.923V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 1 0v1a4 4 0 0 0 4 4m3-9v4.879L5.158 2.037A3.001 3.001 0 0 1 11 3" }, "child": [] }, { "tag": "path", "attr": { "d": "M9.486 10.607 5 6.12V8a3 3 0 0 0 4.486 2.607m-7.84-9.253 12 12 .708-.708-12-12z" }, "child": [] }] })(props);
}
function BsPaperclip(props) {
  return GenIcon({ "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M4.5 3a2.5 2.5 0 0 1 5 0v9a1.5 1.5 0 0 1-3 0V5a.5.5 0 0 1 1 0v7a.5.5 0 0 0 1 0V3a1.5 1.5 0 1 0-3 0v9a2.5 2.5 0 0 0 5 0V5a.5.5 0 0 1 1 0v7a3.5 3.5 0 1 1-7 0z" }, "child": [] }] })(props);
}
function IoHandRightSharp(props) {
  return GenIcon({ "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M82.42 209.08c15.06-6.62 32.38 1.31 38.5 17.62L156 312h11.27V80c0-17.6 13.3-32 29.55-32 16.26 0 29.55 14.4 29.55 32v151.75l14.78.25V32c0-17.6 13.3-32 29.55-32 16.3 0 29.55 14.4 29.55 32v199.75L315 232V64c0-17.6 13.3-32 29.55-32 16.26 0 29.55 14.4 29.55 32v183.75l14.78.25V128c0-17.6 13.3-32 29.55-32C434.7 96 448 110.4 448 128v216c0 75.8-37.13 168-169 168-40.8 0-79.42-7-100.66-21a121.41 121.41 0 0 1-33.72-33.31 138 138 0 0 1-16-31.78L66.16 250.77c-6.11-16.31 1.2-35.06 16.26-41.69z" }, "child": [] }] })(props);
}
const InputGroup = reactExports.forwardRef(
  (props, ref) => {
    const {
      startElement,
      startElementProps,
      endElement,
      endElementProps,
      children,
      startOffset = "6px",
      endOffset = "6px",
      ...rest
    } = props;
    const child = reactExports.Children.only(children);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Group, { ref, ...rest, children: [
      startElement && /* @__PURE__ */ jsxRuntimeExports.jsx(InputElement, { pointerEvents: "none", ...startElementProps, children: startElement }),
      reactExports.cloneElement(child, {
        ...startElement && {
          ps: `calc(var(--input-height) - ${startOffset})`
        },
        ...endElement && { pe: `calc(var(--input-height) - ${endOffset})` },
        ...children.props
      }),
      endElement && /* @__PURE__ */ jsxRuntimeExports.jsx(InputElement, { placement: "end", ...endElementProps, children: endElement })
    ] });
  }
);
const footerStyles = {
  footer: {
    container: (isCollapsed) => ({
      bg: isCollapsed ? "transparent" : "gray.800",
      borderTopRadius: isCollapsed ? "none" : "lg",
      transform: isCollapsed ? "translateY(calc(100% - 24px))" : "translateY(0)",
      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
      height: "100%",
      position: "relative",
      overflow: isCollapsed ? "visible" : "hidden",
      pb: "4"
    }),
    toggleButton: {
      height: "24px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      cursor: "pointer",
      color: "whiteAlpha.700",
      _hover: { color: "white" },
      bg: "transparent",
      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)"
    },
    actionButton: {
      borderRadius: "12px",
      width: "50px",
      height: "50px",
      minW: "50px"
    },
    input: {
      bg: "gray.700",
      border: "none",
      height: "80px",
      borderRadius: "12px",
      fontSize: "18px",
      pl: "12",
      pr: "4",
      color: "whiteAlpha.900",
      _placeholder: {
        color: "whiteAlpha.500"
      },
      _focus: {
        border: "none",
        bg: "gray.700"
      },
      resize: "none",
      minHeight: "80px",
      maxHeight: "80px",
      py: "0",
      display: "flex",
      alignItems: "center",
      paddingTop: "28px",
      lineHeight: "1.4"
    },
    attachButton: {
      position: "absolute",
      left: "1",
      top: "50%",
      transform: "translateY(-50%)",
      color: "whiteAlpha.700",
      zIndex: 2,
      _hover: {
        bg: "transparent",
        color: "white"
      }
    }
  },
  aiIndicator: {
    container: {
      bg: "#7C5CFF",
      color: "white",
      width: "110px",
      height: "30px",
      borderRadius: "12px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      boxShadow: "0 2px 6px rgba(0,0,0,0.1)",
      overflow: "hidden"
    },
    text: {
      fontSize: "12px",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis"
    }
  }
};
function AIStateIndicator() {
  const { t: t2 } = useTranslation();
  const { aiState: aiState2 } = useAiState();
  const styles2 = footerStyles.aiIndicator;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...styles2.container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...styles2.text, children: t2(`aiState.${aiState2}`) }) });
}
function useTextInput() {
  const [inputText, setInputText] = reactExports.useState("");
  const [isComposing, setIsComposing] = reactExports.useState(false);
  const wsContext = useWebSocket();
  const { aiState: aiState2 } = useAiState();
  const { interrupt } = useInterrupt();
  const { appendHumanMessage } = useChatHistory();
  const { stopMic, autoStopMic } = useVAD();
  const { captureAllMedia } = useMediaCapture();
  const handleInputChange = (e2) => {
    setInputText(e2.target.value);
  };
  const handleSend = async () => {
    if (!inputText.trim() || !wsContext) return;
    if (aiState2 === "thinking-speaking") {
      interrupt();
    }
    const images = await captureAllMedia();
    appendHumanMessage(inputText.trim());
    wsContext.sendMessage({
      type: "text-input",
      text: inputText.trim(),
      images
    });
    if (autoStopMic) stopMic();
    setInputText("");
  };
  const handleKeyPress = (e2) => {
    if (isComposing) return;
    if (e2.key === "Enter" && !e2.shiftKey) {
      e2.preventDefault();
      handleSend();
    }
  };
  const handleCompositionStart = () => setIsComposing(true);
  const handleCompositionEnd = () => setIsComposing(false);
  return {
    inputText,
    setInputText: handleInputChange,
    handleSend,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd
  };
}
const useFooter = () => {
  const {
    inputText: inputValue,
    setInputText: handleChange,
    handleKeyPress: handleKey,
    handleCompositionStart,
    handleCompositionEnd
  } = useTextInput();
  const { interrupt } = useInterrupt();
  const { startMic, autoStartMicOn } = useVAD();
  const { handleMicToggle, micOn } = useMicToggle();
  const { setAiState, aiState: aiState2 } = useAiState();
  const { sendTriggerSignal } = useTriggerSpeak();
  const { settings: settings2 } = useProactiveSpeak();
  const {
    manualSendEnabled,
    canSendNow,
    pendingImages,
    lockUntilNextMic,
    aggregatedText,
    awaitSegmentsReady,
    pendingNoticeToken
  } = useManualSend();
  const { sendMessage } = useWebSocket();
  const aggregatedTextRef = reactExports.useRef(aggregatedText);
  const noticeTokenRef = reactExports.useRef(0);
  const manualSendInFlightRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    aggregatedTextRef.current = aggregatedText;
  }, [aggregatedText]);
  const handleInputChange = (e2) => {
    handleChange({ target: { value: e2.target.value } });
    setAiState(AiStateEnum.WAITING);
  };
  const handleKeyPress = (e2) => {
    handleKey(e2);
  };
  const handleInterrupt = () => {
    if (aiState2 === AiStateEnum.THINKING_SPEAKING) {
      interrupt();
      if (autoStartMicOn) {
        startMic();
      }
    } else if (settings2.allowButtonTrigger) {
      sendTriggerSignal(-1);
    }
  };
  const handleManualSend = reactExports.useCallback(() => {
    if (!manualSendEnabled || !canSendNow || manualSendInFlightRef.current) {
      return;
    }
    manualSendInFlightRef.current = true;
    toaster.create({
      title: "",
      type: "info",
      duration: 2500
    });
    (async () => {
      try {
        console.debug("[manual-send] manual send triggered, waiting for segments to finish");
        await awaitSegmentsReady();
        const preparedText = aggregatedTextRef.current.trim();
        if (!preparedText.length) {
          console.debug("[manual-send] manual send aborted because combined text is empty");
          toaster.create({
            title: "",
            type: "warning",
            duration: 2500
          });
          return;
        }
        console.debug("[manual-send] sending combined transcript to backend", {
          length: preparedText.length
        });
        toaster.create({
          title: "",
          type: "success",
          duration: 2500
        });
        sendMessage({
          type: "text-input",
          text: preparedText,
          images: pendingImages
        });
        lockUntilNextMic();
      } finally {
        manualSendInFlightRef.current = false;
      }
    })();
  }, [
    manualSendEnabled,
    canSendNow,
    sendMessage,
    pendingImages,
    lockUntilNextMic,
    awaitSegmentsReady
  ]);
  reactExports.useEffect(() => {
    if (!manualSendEnabled || !canSendNow) {
      return;
    }
    if (pendingNoticeToken === noticeTokenRef.current) {
      return;
    }
    noticeTokenRef.current = pendingNoticeToken;
    toaster.create({
      title: "",
      type: "info",
      duration: 4e3
    });
  }, [manualSendEnabled, canSendNow, pendingNoticeToken]);
  return {
    inputValue,
    handleInputChange,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd,
    handleInterrupt,
    handleMicToggle,
    micOn,
    manualSendEnabled,
    canManualSend: canSendNow,
    handleManualSend
  };
};
const ToggleButton = reactExports.memo(({ isCollapsed, onToggle }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    ...footerStyles.footer.toggleButton,
    onClick: onToggle,
    color: "whiteAlpha.500",
    style: {
      transform: isCollapsed ? "rotate(180deg)" : "rotate(0deg)"
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiChevronDown, {})
  }
));
ToggleButton.displayName = "ToggleButton";
const ActionButtons = reactExports.memo(({ micOn, onMicToggle, onInterrupt }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { gap: 2, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton,
    {
      bg: micOn ? "green.500" : "red.500",
      ...footerStyles.footer.actionButton,
      onClick: onMicToggle,
      children: micOn ? /* @__PURE__ */ jsxRuntimeExports.jsx(BsMicFill, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BsMicMuteFill, {})
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton,
    {
      "aria-label": "Raise hand",
      bg: "yellow.500",
      ...footerStyles.footer.actionButton,
      onClick: onInterrupt,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IoHandRightSharp, { size: "24" })
    }
  )
] }));
ActionButtons.displayName = "ActionButtons";
const MessageInput = reactExports.memo(({
  value,
  onChange,
  onKeyDown,
  onCompositionStart,
  onCompositionEnd,
  manualSendEnabled,
  canManualSend,
  onManualSend
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { align: "stretch", flex: 1, gap: 4, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(InputGroup, { flex: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { position: "relative", width: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          "aria-label": "Attach file",
          variant: "ghost",
          ...footerStyles.footer.attachButton,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(BsPaperclip, { size: "24" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Textarea,
        {
          value,
          onChange,
          onKeyDown,
          onCompositionStart,
          onCompositionEnd,
          placeholder: t2("footer.typeYourMessage"),
          ...footerStyles.footer.input
        }
      )
    ] }) }),
    manualSendEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$2,
      {
        width: "140px",
        height: footerStyles.footer.input.height,
        borderRadius: "12px",
        colorScheme: "blue",
        onClick: onManualSend,
        isDisabled: !canManualSend,
        children: t2("footer.finishAnswer", { defaultValue: "" })
      }
    )
  ] });
});
MessageInput.displayName = "MessageInput";
function Footer({ isCollapsed = false, onToggle }) {
  const {
    inputValue,
    handleInputChange,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd,
    handleInterrupt,
    handleMicToggle,
    micOn,
    manualSendEnabled,
    canManualSend,
    handleManualSend
  } = useFooter();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...footerStyles.footer.container(isCollapsed), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton, { isCollapsed, onToggle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { pt: "0", px: "4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { width: "100%", gap: 4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { mb: "1.5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AIStateIndicator, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ActionButtons,
          {
            micOn,
            onMicToggle: handleMicToggle,
            onInterrupt: handleInterrupt
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MessageInput,
        {
          value: inputValue,
          onChange: handleInputChange,
          onKeyDown: handleKeyPress,
          onCompositionStart: handleCompositionStart,
          onCompositionEnd: handleCompositionEnd,
          manualSendEnabled,
          canManualSend,
          onManualSend: handleManualSend
        }
      )
    ] }) })
  ] });
}
const isElectron = window.api !== void 0;
const getAppHeight = () => {
  if (typeof window !== "undefined" && /Mobi|Android/i.test(navigator.userAgent)) {
    return `${window.innerHeight}px`;
  }
  return isElectron ? "calc(100vh - 30px)" : "100vh";
};
const layoutStyles = {
  appContainer: {
    width: "100vw",
    height: getAppHeight(),
    bg: "gray.900",
    color: "white",
    overflow: "hidden",
    position: "relative",
    display: "flex",
    flexDirection: { base: "column", md: "row" },
    mt: isElectron ? "30px" : "0"
  },
  sidebar: {
    position: "relative",
    width: { base: "100%", md: "440px" },
    height: { base: "auto", md: "100%" },
    bg: "gray.800",
    borderRight: "1px solid",
    borderColor: "whiteAlpha.200",
    overflow: "hidden",
    flexShrink: 0,
    transition: "all 0.2s"
  },
  mainContent: {
    flex: 1,
    height: { base: "calc(100% - 120px)", md: "100%" },
    position: "relative",
    display: "flex",
    flexDirection: "column",
    transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    width: "100%",
    overflow: "hidden"
  },
  footer: {
    width: "100%",
    height: { base: "100px", md: "120px" },
    transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    willChange: "transform",
    position: "relative",
    zIndex: 1
  },
  collapsedFooter: {
    height: { base: "20px", md: "24px" },
    transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)"
  },
  windowsTitleBar: {
    position: "fixed",
    top: 0,
    left: 0,
    width: "100vw",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    height: "30px",
    backgroundColor: "gray.800",
    paddingX: "10px",
    zIndex: 1e3,
    css: { "-webkit-app-region": "drag" }
  },
  macTitleBar: {
    position: "fixed",
    top: 0,
    left: 0,
    width: "100vw",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    height: "30px",
    backgroundColor: "gray.800",
    zIndex: 1e3,
    css: {
      "-webkit-app-region": "drag",
      "-webkit-user-select": "none"
    }
  },
  titleBarTitle: {
    fontSize: "sm",
    color: "whiteAlpha.800",
    textAlign: "center"
  },
  titleBarButtons: {
    display: "flex",
    gap: "1"
  },
  titleBarButton: {
    size: "sm",
    variant: "ghost",
    color: "whiteAlpha.800",
    css: { "-webkit-app-region": "no-drag" },
    _hover: { backgroundColor: "whiteAlpha.200" }
  },
  closeButton: {
    size: "sm",
    variant: "ghost",
    color: "whiteAlpha.800",
    css: { "-webkit-app-region": "no-drag" },
    _hover: { backgroundColor: "red.500" }
  }
};
function WebSocketHandler({ children }) {
  const { t: t2 } = useTranslation();
  const [wsState, setWsState] = reactExports.useState("CLOSED");
  const [wsUrl, setWsUrl] = useLocalStorage("wsUrl", defaultWsUrl);
  const [baseUrl, setBaseUrl] = useLocalStorage("baseUrl", defaultBaseUrl);
  const { aiState: aiState2, setAiState, backendSynthComplete, setBackendSynthComplete } = useAiState();
  const { setModelInfo } = useLive2DConfig();
  const { setSubtitleText } = useSubtitle();
  const { clearResponse, setForceNewMessage, appendHumanMessage, appendOrUpdateToolCallMessage } = useChatHistory();
  const { addAudioTask } = useAudioTask();
  const bgUrlContext = useBgUrl();
  const { confUid, setConfName, setConfUid, setConfigFiles } = useConfig();
  const [pendingModelInfo, setPendingModelInfo] = reactExports.useState(void 0);
  const { setSelfUid, setGroupMembers, setIsOwner } = useGroup();
  const { startMic, stopMic, autoStartMicOnConvEnd } = useVAD();
  const autoStartMicOnConvEndRef = reactExports.useRef(autoStartMicOnConvEnd);
  const { interrupt } = useInterrupt();
  const { setBrowserViewData } = useBrowser();
  const { completePendingUtterance } = useManualSend();
  reactExports.useEffect(() => {
    autoStartMicOnConvEndRef.current = autoStartMicOnConvEnd;
  }, [autoStartMicOnConvEnd]);
  reactExports.useEffect(() => {
    if (pendingModelInfo && confUid) {
      setModelInfo(pendingModelInfo);
      setPendingModelInfo(void 0);
    }
  }, [pendingModelInfo, setModelInfo, confUid]);
  const {
    setCurrentHistoryUid,
    setMessages,
    setHistoryList
  } = useChatHistory();
  const handleControlMessage = reactExports.useCallback((controlText) => {
    switch (controlText) {
      case "start-mic":
        console.log("Starting microphone...");
        startMic();
        break;
      case "stop-mic":
        console.log("Stopping microphone...");
        stopMic();
        break;
      case "conversation-chain-start":
        setAiState("thinking-speaking");
        audioTaskQueue.clearQueue();
        clearResponse();
        break;
      case "conversation-chain-end":
        audioTaskQueue.addTask(() => new Promise((resolve2) => {
          setAiState((currentState) => {
            if (currentState === "thinking-speaking") {
              if (autoStartMicOnConvEndRef.current) {
                startMic();
              }
              return "idle";
            }
            return currentState;
          });
          resolve2();
        }));
        break;
      default:
        console.warn("Unknown control command:", controlText);
    }
  }, [setAiState, clearResponse, setForceNewMessage, startMic, stopMic]);
  const handleWebSocketMessage = reactExports.useCallback((message) => {
    console.log("Received message from server:", message);
    switch (message.type) {
      case "control":
        if (message.text) {
          handleControlMessage(message.text);
        }
        break;
      case "set-model-and-conf":
        setAiState("loading");
        if (message.conf_name) {
          setConfName(message.conf_name);
        }
        if (message.conf_uid) {
          setConfUid(message.conf_uid);
          console.log("confUid", message.conf_uid);
        }
        if (message.client_uid) {
          setSelfUid(message.client_uid);
        }
        if (message.model_info) {
          const resolvedBase = baseUrl || defaultBaseUrl;
          if (message.model_info.url) {
            message.model_info.url = resolveStaticUrl(message.model_info.url, resolvedBase);
          }
          if (message.model_info.resourcePath) {
            message.model_info.resourcePath = resolveStaticUrl(message.model_info.resourcePath, resolvedBase);
          }
        }
        setPendingModelInfo(message.model_info);
        setAiState("idle");
        break;
      case "full-text":
        if (message.text) {
          setSubtitleText(message.text);
        }
        break;
      case "config-files":
        if (message.configs) {
          setConfigFiles(message.configs);
        }
        break;
      case "config-switched":
        setAiState("idle");
        setSubtitleText(t2("notification.characterLoaded"));
        toaster.create({
          title: t2("notification.characterSwitched"),
          type: "success",
          duration: 2e3
        });
        wsService.sendMessage({ type: "fetch-history-list" });
        wsService.sendMessage({ type: "create-new-history" });
        break;
      case "background-files":
        if (message.files) {
          bgUrlContext?.setBackgroundFiles(message.files);
        }
        break;
      case "audio":
        if (aiState2 === "interrupted" || aiState2 === "listening") {
          console.log("Audio playback intercepted. Sentence:", message.display_text?.text);
        } else {
          console.log("actions", message.actions);
          addAudioTask({
            audioBase64: message.audio || "",
            volumes: message.volumes || [],
            sliceLength: message.slice_length || 0,
            displayText: message.display_text || null,
            expressions: message.actions?.expressions || null,
            forwarded: message.forwarded || false
          });
        }
        break;
      case "history-data":
        if (message.messages) {
          setMessages(message.messages);
        }
        toaster.create({
          title: t2("notification.historyLoaded"),
          type: "success",
          duration: 2e3
        });
        break;
      case "new-history-created":
        setAiState("idle");
        setSubtitleText(t2("notification.newConversation"));
        if (message.history_uid) {
          setCurrentHistoryUid(message.history_uid);
          setMessages([]);
          const newHistory = {
            uid: message.history_uid,
            latest_message: null,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          setHistoryList((prev2) => [newHistory, ...prev2]);
          toaster.create({
            title: t2("notification.newChatHistory"),
            type: "success",
            duration: 2e3
          });
        }
        break;
      case "history-deleted":
        toaster.create({
          title: message.success ? t2("notification.historyDeleteSuccess") : t2("notification.historyDeleteFail"),
          type: message.success ? "success" : "error",
          duration: 2e3
        });
        break;
      case "history-list":
        if (message.histories) {
          setHistoryList(message.histories);
          if (message.histories.length > 0) {
            setCurrentHistoryUid(message.histories[0].uid);
          }
        }
        break;
      case "user-input-transcription":
        console.log("user-input-transcription: ", message.text);
        if (message.segment_id) {
          completePendingUtterance(message.segment_id, message.text || "");
        }
        if (message.text) {
          appendHumanMessage(message.text);
        }
        break;
      case "error":
        toaster.create({
          title: message.message,
          type: "error",
          duration: 2e3
        });
        break;
      case "group-update":
        console.log("Received group-update:", message.members);
        if (message.members) {
          setGroupMembers(message.members);
        }
        if (message.is_owner !== void 0) {
          setIsOwner(message.is_owner);
        }
        break;
      case "group-operation-result":
        toaster.create({
          title: message.message,
          type: message.success ? "success" : "error",
          duration: 2e3
        });
        break;
      case "backend-synth-complete":
        setBackendSynthComplete(true);
        break;
      case "conversation-chain-end":
        if (!audioTaskQueue.hasTask()) {
          setAiState((currentState) => {
            if (currentState === "thinking-speaking") {
              return "idle";
            }
            return currentState;
          });
        }
        break;
      case "force-new-message":
        setForceNewMessage(true);
        break;
      case "interrupt-signal":
        interrupt(false);
        break;
      case "tool_call_status":
        if (message.tool_id && message.tool_name && message.status) {
          if (message.browser_view) {
            console.log("Browser view data received:", message.browser_view);
            setBrowserViewData(message.browser_view);
          }
          appendOrUpdateToolCallMessage({
            id: message.tool_id,
            type: "tool_call_status",
            role: "ai",
            tool_id: message.tool_id,
            tool_name: message.tool_name,
            name: message.name,
            status: message.status,
            content: message.content || "",
            timestamp: message.timestamp || (/* @__PURE__ */ new Date()).toISOString()
          });
        } else {
          console.warn("Received incomplete tool_call_status message:", message);
        }
        break;
      default:
        console.warn("Unknown message type:", message.type);
    }
  }, [aiState2, addAudioTask, appendHumanMessage, baseUrl, bgUrlContext, setAiState, setConfName, setConfUid, setConfigFiles, setCurrentHistoryUid, setHistoryList, setMessages, setModelInfo, setSubtitleText, startMic, stopMic, setSelfUid, setGroupMembers, setIsOwner, backendSynthComplete, setBackendSynthComplete, clearResponse, handleControlMessage, appendOrUpdateToolCallMessage, interrupt, setBrowserViewData, t2, completePendingUtterance]);
  reactExports.useEffect(() => {
    wsService.connect(wsUrl);
  }, [wsUrl]);
  reactExports.useEffect(() => {
    const stateSubscription = wsService.onStateChange(setWsState);
    const messageSubscription = wsService.onMessage(handleWebSocketMessage);
    return () => {
      stateSubscription.unsubscribe();
      messageSubscription.unsubscribe();
    };
  }, [wsUrl, handleWebSocketMessage]);
  const webSocketContextValue = reactExports.useMemo(() => ({
    sendMessage: wsService.sendMessage.bind(wsService),
    wsState,
    reconnect: () => wsService.connect(wsUrl),
    wsUrl,
    setWsUrl,
    baseUrl,
    setBaseUrl
  }), [wsState, wsUrl, baseUrl]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(WebSocketContext.Provider, { value: webSocketContextValue, children });
}
function TitleBar() {
  const [isMaximized, setIsMaximized] = reactExports.useState(false);
  const [isFullScreen, setIsFullScreen] = reactExports.useState(false);
  const isMac2 = window.electron?.process.platform === "darwin";
  reactExports.useEffect(() => {
    const handleMaximizeChange = (_event, maximized) => {
      setIsMaximized(maximized);
    };
    const handleFullScreenChange = (_event, fullScreen) => {
      setIsFullScreen(fullScreen);
    };
    window.electron?.ipcRenderer.on("window-maximized-change", handleMaximizeChange);
    window.electron?.ipcRenderer.on("window-fullscreen-change", handleFullScreenChange);
    return () => {
      window.electron?.ipcRenderer.removeAllListeners("window-maximized-change");
      window.electron?.ipcRenderer.removeAllListeners("window-fullscreen-change");
    };
  }, []);
  const handleMaximizeClick = () => {
    if (isFullScreen) {
      window.electron?.ipcRenderer.send("window-unfullscreen");
    } else {
      window.electron?.ipcRenderer.send("window-maximize");
    }
  };
  const getButtonLabel = () => {
    if (isFullScreen) return "Exit Full Screen";
    if (isMaximized) return "Restore";
    return "Maximize";
  };
  const getButtonIcon = () => {
    if (isFullScreen) return /* @__PURE__ */ jsxRuntimeExports.jsx(FiChevronsDown, {});
    if (isMaximized) return /* @__PURE__ */ jsxRuntimeExports.jsx(FiMinimize2, {});
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FiMaximize2, {});
  };
  if (isMac2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...layoutStyles.macTitleBar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...layoutStyles.titleBarTitle, children: "Open LLM VTuber" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...layoutStyles.windowsTitleBar, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...layoutStyles.titleBarTitle, children: "Open LLM VTuber" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...layoutStyles.titleBarButtons, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ...layoutStyles.titleBarButton,
          onClick: () => window.electron?.ipcRenderer.send("window-minimize"),
          "aria-label": "Minimize",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiMinus, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ...layoutStyles.titleBarButton,
          onClick: handleMaximizeClick,
          "aria-label": getButtonLabel(),
          children: getButtonIcon()
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ...layoutStyles.closeButton,
          onClick: () => window.electron?.ipcRenderer.send("window-close"),
          "aria-label": "Close",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiX, {})
        }
      )
    ] })
  ] });
}
function useInputSubtitle() {
  const {
    inputText: inputValue,
    setInputText: handleChange,
    handleKeyPress: handleKey,
    handleCompositionStart,
    handleCompositionEnd,
    handleSend
  } = useTextInput();
  const { messages: messages2 } = useChatHistory();
  const { startMic, autoStartMicOn } = useVAD();
  const { handleMicToggle, micOn } = useMicToggle();
  const { aiState: aiState2, setAiState } = useAiState();
  const { interrupt } = useInterrupt();
  const lastAIMessage = messages2.filter((msg) => msg.role === "ai").slice(-1).map((msg) => msg.content)[0];
  const hasAIMessages = messages2.some((msg) => msg.role === "ai");
  const handleInterrupt = () => {
    interrupt();
    if (autoStartMicOn) {
      startMic();
    }
  };
  const handleInputChange = (e2) => {
    handleChange({ target: { value: e2.target.value } });
    setAiState(AiStateEnum.WAITING);
  };
  const handleKeyPress = (e2) => {
    handleKey(e2);
  };
  return {
    inputValue,
    handleInputChange,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd,
    handleInterrupt,
    handleMicToggle,
    lastAIMessage,
    hasAIMessages,
    aiState: aiState2,
    micOn,
    handleSend
  };
}
function useDraggable({ componentId }) {
  const { mode } = useMode();
  const isPet = mode === "pet";
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const positionRef = reactExports.useRef({ x: 0, y: 0 });
  const dragStartRef = reactExports.useRef({ x: 0, y: 0 });
  const elementRef = reactExports.useRef(null);
  const handleMouseEnter = () => {
    if (isPet) {
      window.api?.updateComponentHover(componentId, true);
    }
  };
  const handleMouseLeave = () => {
    if (isPet && !isDragging) {
      window.api?.updateComponentHover(componentId, false);
    }
  };
  const handleMouseDown = (e2) => {
    setIsDragging(true);
    dragStartRef.current = {
      x: e2.clientX - positionRef.current.x,
      y: e2.clientY - positionRef.current.y
    };
    const handleMouseMove = (moveEvent) => {
      if (!elementRef.current) return;
      const newPosition = {
        x: moveEvent.clientX - dragStartRef.current.x,
        y: moveEvent.clientY - dragStartRef.current.y
      };
      positionRef.current = newPosition;
      elementRef.current.style.transform = `translateX(-50%) translate(${positionRef.current.x}px, ${positionRef.current.y}px)`;
    };
    const handleMouseUp = () => {
      setIsDragging(false);
      document.removeEventListener("mousemove", handleMouseMove, true);
      document.removeEventListener("mouseup", handleMouseUp, true);
    };
    document.addEventListener("mousemove", handleMouseMove, true);
    document.addEventListener("mouseup", handleMouseUp, true);
  };
  return {
    elementRef,
    isDragging,
    handleMouseDown,
    handleMouseEnter,
    handleMouseLeave
  };
}
const inputSubtitleStyles = {
  container: {
    display: "flex",
    alignItems: "flex-end",
    justifyContent: "center",
    maxW: "fit-content",
    position: "absolute",
    bottom: "120px",
    left: "50%",
    transform: "translateX(-50%)",
    zIndex: 1e3,
    userSelect: "none",
    willChange: "transform",
    padding: 0
  },
  box: {
    w: "400px",
    rounded: "xl",
    overflow: "hidden",
    boxShadow: "lg",
    bg: "blackAlpha.700",
    backdropFilter: "blur(8px)",
    css: { WebkitUserSelect: "none" }
  },
  messageStack: {
    p: "3",
    gap: 1,
    alignItems: "stretch",
    justify: "flex-end"
  },
  messageText: {
    color: "white",
    fontSize: "sm",
    lineHeight: "1.5",
    transition: "all 0.3s"
  },
  statusBox: {
    bg: "blackAlpha.600",
    p: "3",
    borderTop: "1px",
    borderColor: "whiteAlpha.200"
  },
  statusText: {
    fontSize: "xs",
    color: "whiteAlpha.800",
    transition: "all 0.3s"
  },
  iconButton: {
    size: "xs",
    variant: "ghost",
    color: "whiteAlpha.800",
    _hover: { bg: "whiteAlpha.200" }
  },
  inputBox: {
    bg: "blackAlpha.600",
    borderTop: "1px",
    borderColor: "whiteAlpha.200"
  },
  input: {
    size: "sm",
    bg: "blackAlpha.500",
    color: "white",
    _placeholder: { color: "whiteAlpha.500" },
    borderColor: "whiteAlpha.300",
    _focus: {
      borderColor: "whiteAlpha.500",
      outline: "none"
    },
    flex: "1"
  },
  sendButton: {
    p: "1.5",
    bg: "blackAlpha.500",
    rounded: "lg",
    _hover: { bg: "blackAlpha.600" },
    transition: "colors",
    color: "whiteAlpha.800",
    size: "sm"
  },
  draggableContainer: (isDragging) => ({
    cursor: isDragging ? "grabbing" : "grab",
    transition: isDragging ? "none" : "transform 0.1s ease",
    _active: { cursor: "grabbing" }
  }),
  closeButton: {
    position: "absolute",
    top: 0,
    right: 0,
    size: "2xs",
    minW: "6",
    height: "6",
    padding: 0,
    variant: "ghost",
    color: "whiteAlpha.400",
    bg: "transparent",
    _hover: {
      bg: "blackAlpha.300",
      color: "whiteAlpha.800"
    },
    zIndex: 10
  }
};
function InputSubtitle() {
  const {
    inputValue,
    handleInputChange,
    handleKeyPress,
    handleCompositionStart,
    handleCompositionEnd,
    handleInterrupt,
    handleMicToggle,
    handleSend,
    lastAIMessage,
    hasAIMessages,
    aiState: aiState2,
    micOn
  } = useInputSubtitle();
  const { mode } = useMode();
  const isPet = mode === "pet";
  const {
    elementRef,
    isDragging,
    handleMouseDown,
    handleMouseEnter,
    handleMouseLeave
  } = useDraggable({
    componentId: "input-subtitle"
  });
  const [isVisible, setIsVisible] = reactExports.useState(true);
  const handleClose = reactExports.useCallback(() => {
    if (isPet) {
      window.api?.updateComponentHover("input-subtitle", false);
    }
    setIsVisible(false);
  }, [isPet]);
  const handleOpen = () => {
    setIsVisible(true);
  };
  reactExports.useEffect(() => {
    if (isPet) {
      const cleanup = window.api?.onToggleInputSubtitle(() => {
        if (isVisible) {
          handleClose();
        } else {
          handleOpen();
        }
      });
      return () => cleanup?.();
    }
    return () => {
    };
  }, [handleClose, isPet, isVisible]);
  reactExports.useEffect(() => {
    window.inputSubtitle = {
      open: handleOpen,
      close: handleClose
    };
    return () => {
      delete window.inputSubtitle;
    };
  }, [isPet, handleClose]);
  if (!isVisible) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ref: elementRef,
      ...inputSubtitleStyles.container,
      ...inputSubtitleStyles.draggableContainer(isDragging),
      onMouseDown: handleMouseDown,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...inputSubtitleStyles.box, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            "aria-label": "Close subtitle",
            onClick: handleClose,
            ...inputSubtitleStyles.closeButton,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuX, { size: 12 })
          }
        ),
        hasAIMessages && /* @__PURE__ */ jsxRuntimeExports.jsx(
          VStack,
          {
            minH: lastAIMessage ? "32px" : "0px",
            ...inputSubtitleStyles.messageStack,
            children: lastAIMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...inputSubtitleStyles.messageText, children: lastAIMessage })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...inputSubtitleStyles.statusBox, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { align: "center", justify: "space-between", color: "whiteAlpha.700", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { align: "center", gap: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LuBell, { size: 16 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...inputSubtitleStyles.statusText, children: aiState2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { gap: "2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                "aria-label": "Toggle microphone",
                onClick: handleMicToggle,
                ...inputSubtitleStyles.iconButton,
                children: micOn ? /* @__PURE__ */ jsxRuntimeExports.jsx(LuMic, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(LuMicOff, { size: 16 })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                "aria-label": "Interrupt",
                onClick: handleInterrupt,
                ...inputSubtitleStyles.iconButton,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuHand, { size: 16 })
              }
            )
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...inputSubtitleStyles.inputBox, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", gap: "2", p: "2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$1,
            {
              value: inputValue,
              onChange: handleInputChange,
              onKeyDown: handleKeyPress,
              onCompositionStart: handleCompositionStart,
              onCompositionEnd: handleCompositionEnd,
              placeholder: "Type your message...",
              ...inputSubtitleStyles.input
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$2,
            {
              onClick: handleSend,
              ...inputSubtitleStyles.sendButton,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(LuSend, { size: 16 })
            }
          )
        ] }) })
      ] })
    }
  );
}
const canvasStyles = {
  background: {
    container: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: "auto"
    },
    image: {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      objectFit: "cover",
      zIndex: 1
    },
    video: {
      position: "absolute",
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      objectFit: "cover",
      zIndex: 1,
      transform: "scaleX(-1)"
    }
  },
  subtitle: {
    container: {
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      padding: "15px 30px",
      borderRadius: "12px",
      minWidth: "60%",
      maxWidth: "95%"
    },
    text: {
      color: "white",
      fontSize: "1.5rem",
      textAlign: "center",
      lineHeight: "1.4",
      whiteSpace: "pre-wrap"
    }
  },
  wsStatus: {
    container: {
      position: "relative",
      // top: '20px',
      // left: '20px',
      zIndex: 2,
      padding: "8px 16px",
      borderRadius: "20px",
      fontSize: "14px",
      fontWeight: "medium",
      color: "white",
      transition: "all 0.2s",
      cursor: "pointer",
      userSelect: "none",
      _hover: {
        opacity: 0.8
      }
    }
  }
};
const Background = reactExports.memo(({ children }) => {
  const videoRef = reactExports.useRef(null);
  const {
    backgroundStream,
    isBackgroundStreaming,
    startBackgroundCamera,
    stopBackgroundCamera
  } = useCamera();
  const { useCameraBackground, backgroundUrl } = useBgUrl();
  reactExports.useEffect(() => {
    if (useCameraBackground) {
      startBackgroundCamera();
    } else {
      stopBackgroundCamera();
    }
  }, [useCameraBackground, startBackgroundCamera, stopBackgroundCamera]);
  reactExports.useEffect(() => {
    if (videoRef.current && backgroundStream) {
      videoRef.current.srcObject = backgroundStream;
    }
  }, [backgroundStream]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...canvasStyles.background.container, children: [
    useCameraBackground ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "video",
      {
        ref: videoRef,
        autoPlay: true,
        playsInline: true,
        muted: true,
        style: {
          ...canvasStyles.background.video,
          display: isBackgroundStreaming ? "block" : "none",
          transform: "scaleX(-1)"
        }
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Image$1,
      {
        ...canvasStyles.background.image,
        src: backgroundUrl,
        alt: "background"
      }
    ),
    children
  ] });
});
Background.displayName = "Background";
const useWSStatus = () => {
  const { wsState, reconnect } = useWebSocket();
  const handleClick = reactExports.useCallback(() => {
    if (wsState !== "OPEN" && wsState !== "CONNECTING") {
      reconnect();
    }
  }, [wsState, reconnect]);
  const statusInfo = reactExports.useMemo(() => {
    switch (wsState) {
      case "OPEN":
        return {
          color: "green.500",
          textKey: "wsStatus.connected",
          isDisconnected: false,
          handleClick
        };
      case "CONNECTING":
        return {
          color: "yellow.500",
          textKey: "wsStatus.connecting",
          isDisconnected: false,
          handleClick
        };
      default:
        return {
          color: "red.500",
          textKey: "wsStatus.clickToReconnect",
          isDisconnected: true,
          handleClick
        };
    }
  }, [wsState, handleClick]);
  return statusInfo;
};
const StatusContent = ({ textKey }) => {
  const { t: t2 } = useTranslation();
  return t2(textKey);
};
const MemoizedStatusContent = reactExports.memo(StatusContent);
const WebSocketStatus = reactExports.memo(() => {
  const {
    color,
    textKey,
    handleClick,
    isDisconnected
  } = useWSStatus();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ...canvasStyles.wsStatus.container,
      backgroundColor: color,
      onClick: handleClick,
      cursor: isDisconnected ? "pointer" : "default",
      _hover: {
        opacity: isDisconnected ? 0.8 : 1
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MemoizedStatusContent, { textKey })
    }
  );
});
WebSocketStatus.displayName = "WebSocketStatus";
const useSubtitleDisplay = () => {
  const context = useSubtitle();
  const subtitleText = reactExports.useMemo(() => {
    if (!context) return null;
    return context.subtitleText;
  }, [context?.subtitleText]);
  return {
    subtitleText,
    isLoaded: !!context
  };
};
const SubtitleText = reactExports.memo(({ text }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ...canvasStyles.subtitle.text, children: text }));
SubtitleText.displayName = "SubtitleText";
const Subtitle = reactExports.memo(() => {
  const { subtitleText, isLoaded } = useSubtitleDisplay();
  const { showSubtitle } = useSubtitle();
  if (!isLoaded || !subtitleText || !showSubtitle) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ...canvasStyles.subtitle.container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SubtitleText, { text: subtitleText }) });
});
Subtitle.displayName = "Subtitle";
function AppContent() {
  const [showSidebar, setShowSidebar] = reactExports.useState(true);
  const [isFooterCollapsed, setIsFooterCollapsed] = reactExports.useState(false);
  const { mode } = useMode();
  const isElectron2 = window.api !== void 0;
  const live2dContainerRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const handleResize = () => {
      const vh2 = window.innerHeight * 0.01;
      document.documentElement.style.setProperty("--vh", `${vh2}px`);
    };
    handleResize();
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  document.documentElement.style.overflow = "hidden";
  document.body.style.overflow = "hidden";
  document.documentElement.style.height = "100%";
  document.body.style.height = "100%";
  document.documentElement.style.position = "fixed";
  document.body.style.position = "fixed";
  document.documentElement.style.width = "100%";
  document.body.style.width = "100%";
  const live2dBaseStyle = {
    position: "absolute",
    overflow: "hidden",
    transition: "all 0.3s ease-in-out",
    // Optional transition
    pointerEvents: "auto"
  };
  const getResponsiveLive2DWindowStyle = (sidebarVisible) => ({
    ...live2dBaseStyle,
    top: isElectron2 ? "30px" : "0px",
    height: `calc(100% - ${isElectron2 ? "30px" : "0px"})`,
    zIndex: 5,
    // Ensure it's layered correctly below UI but above background
    left: {
      base: "0px",
      // Column layout (base): Start from left edge
      md: sidebarVisible ? "440px" : "24px"
      // Row layout (md+): Offset by sidebar width
    },
    width: {
      base: "100%",
      // Column layout (base): Full width
      md: `calc(100% - ${sidebarVisible ? "440px" : "24px"})`
      // Row layout (md+): Adjust width based on sidebar
    }
  });
  const live2dPetStyle = {
    ...live2dBaseStyle,
    top: 0,
    // Override position for pet mode
    left: 0,
    width: "100vw",
    // Full viewport
    height: "100vh",
    zIndex: 15
    // Higher zIndex for pet mode overlay
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        ref: live2dContainerRef,
        ...mode === "window" ? getResponsiveLive2DWindowStyle(showSidebar) : live2dPetStyle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Live2D, {})
      }
    ),
    mode === "window" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      isElectron2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TitleBar, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { ...layoutStyles.appContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            ...layoutStyles.sidebar,
            ...!showSidebar && { width: "24px" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Sidebar,
              {
                isCollapsed: !showSidebar,
                onToggle: () => setShowSidebar(!showSidebar)
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...layoutStyles.mainContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Background, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { position: "absolute", top: "20px", left: "20px", zIndex: 10, children: /* @__PURE__ */ jsxRuntimeExports.jsx(WebSocketStatus, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              position: "absolute",
              bottom: isFooterCollapsed ? "39px" : "135px",
              left: "50%",
              transform: "translateX(-50%)",
              zIndex: 10,
              width: "60%",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Subtitle, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              ...layoutStyles.footer,
              zIndex: 10,
              ...isFooterCollapsed && layoutStyles.collapsedFooter,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Footer,
                {
                  isCollapsed: isFooterCollapsed,
                  onToggle: () => setIsFooterCollapsed(!isFooterCollapsed)
                }
              )
            }
          )
        ] })
      ] })
    ] }),
    mode === "pet" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputSubtitle, {})
  ] });
}
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ChakraProvider, { value: defaultSystem, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModeProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppWithGlobalStyles, {}) }) });
}
function AppWithGlobalStyles() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScreenCaptureProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CharacterConfigProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChatHistoryProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AiStateProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProactiveSpeakProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Live2DConfigProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SubtitleProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ManualSendProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(VADProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BgUrlProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WebSocketHandler, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppContent, {})
  ] }) }) }) }) }) }) }) }) }) }) }) }) }) }) });
}
let s_adapter_instance = null;
class LAppAdapter {
  static getInstance() {
    if (s_adapter_instance == null) {
      s_adapter_instance = new LAppAdapter();
    }
    return s_adapter_instance;
  }
  /* gets */
  getMgr() {
    return LAppLive2DManager.getInstance();
  }
  getModel() {
    return this.getMgr().getModel(0);
  }
  getIdManager() {
    return CubismFramework.getIdManager();
  }
  /* motion */
  getMotionGroups() {
    let groups = [];
    for (let i = 0; i < this.getModel()?._modelSetting.getMotionGroupCount(); i++) {
      groups.push(this.getModel()?._modelSetting.getMotionGroupName(i) ?? "");
    }
    return groups;
  }
  getMotionCount(group2) {
    return this.getModel()?._modelSetting.getMotionCount(group2) ?? 0;
  }
  startMotion(group2, no, priority, onFinishedMotionHandler) {
    return this.getModel()?.startMotion(group2, no, priority, onFinishedMotionHandler) ?? InvalidMotionQueueEntryHandleValue;
  }
  /* expression */
  getExpressionCount() {
    return this.getModel()?._expressions.getSize() ?? 0;
  }
  getExpressionName(index) {
    return this.getModel()?._modelSetting?.getExpressionName(index) ?? "";
  }
  setExpression(name2) {
    this.getModel()?.setExpression(name2);
  }
  // @deprecated
  nextChara() {
    this.getMgr().nextScene();
  }
  setChara(ModelDir2, ModelName) {
    const modelPath = (ModelDir2.endsWith("/") ? ModelDir2 : ModelDir2 + "/") + ModelName + "/";
    const modelJsonName = ModelName + ".model3.json";
    this.getMgr().releaseAllModel();
    this.getMgr()._models.pushBack(new LAppModel());
    this.getMgr()._models.at(0)?.loadAssets(modelPath, modelJsonName);
  }
  /* model position manipulation */
  getModelPosition() {
    const model = this.getModel();
    if (model && model._modelMatrix) {
      const matrix = model._modelMatrix.getArray();
      return {
        x: matrix[12],
        y: matrix[13]
      };
    }
    return { x: 0, y: 0 };
  }
  setModelPosition(x2, y2) {
    const model = this.getModel();
    if (model && model._modelMatrix) {
      const matrix = model._modelMatrix.getArray();
      const newMatrix = [...matrix];
      newMatrix[12] = x2;
      newMatrix[13] = y2;
      model._modelMatrix.setMatrix(newMatrix);
    }
  }
  // private _live2DMgr: LAppLive2DManager;
}
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  forEach.call(slice.call(arguments, 1), (source) => {
    if (source) {
      for (const prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
function hasXSS(input) {
  if (typeof input !== "string") return false;
  const xssPatterns = [/<\s*script.*?>/i, /<\s*\/\s*script\s*>/i, /<\s*img.*?on\w+\s*=/i, /<\s*\w+\s*on\w+\s*=.*?>/i, /javascript\s*:/i, /vbscript\s*:/i, /expression\s*\(/i, /eval\s*\(/i, /alert\s*\(/i, /document\.cookie/i, /document\.write\s*\(/i, /window\.location/i, /innerHTML/i];
  return xssPatterns.some((pattern) => pattern.test(input));
}
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const serializeCookie = function(name2, val) {
  let options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    path: "/"
  };
  const opt = options2;
  const value = encodeURIComponent(val);
  let str = `${name2}=${value}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
const cookie = {
  create(name2, value, minutes, domain) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name2, encodeURIComponent(value), cookieOptions);
  },
  read(name2) {
    const nameEQ = `${name2}=`;
    const ca2 = document.cookie.split(";");
    for (let i = 0; i < ca2.length; i++) {
      let c2 = ca2[i];
      while (c2.charAt(0) === " ") c2 = c2.substring(1, c2.length);
      if (c2.indexOf(nameEQ) === 0) return c2.substring(nameEQ.length, c2.length);
    }
    return null;
  },
  remove(name2) {
    this.create(name2, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref2) {
    let {
      lookupCookie
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      return cookie.read(lookupCookie) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref2) {
    let {
      lookupQuerystring
    } = _ref2;
    let found;
    if (typeof window !== "undefined") {
      let {
        search
      } = window.location;
      if (!window.location.search && window.location.hash?.indexOf("?") > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      const query = search.substring(1);
      const params = query.split("&");
      for (let i = 0; i < params.length; i++) {
        const pos = params[i].indexOf("=");
        if (pos > 0) {
          const key = params[i].substring(0, pos);
          if (key === lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = () => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = typeof window !== "undefined" && window.localStorage !== null;
    if (!hasLocalStorageSupport) {
      return false;
    }
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e2) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage$1 = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(lookupLocalStorage, lng);
    }
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = () => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = typeof window !== "undefined" && window.sessionStorage !== null;
    if (!hasSessionStorageSupport) {
      return false;
    }
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e2) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: "sessionStorage",
  lookup(_ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
    }
    return void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup(options2) {
    const found = [];
    if (typeof navigator !== "undefined") {
      const {
        languages,
        userLanguage,
        language
      } = navigator;
      if (languages) {
        for (let i = 0; i < languages.length; i++) {
          found.push(languages[i]);
        }
      }
      if (userLanguage) {
        found.push(userLanguage);
      }
      if (language) {
        found.push(language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref2) {
    let {
      htmlTag: htmlTag2
    } = _ref2;
    let found;
    const internalHtmlTag = htmlTag2 || (typeof document !== "undefined" ? document.documentElement : null);
    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === "function") {
      found = internalHtmlTag.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref2) {
    let {
      lookupFromPathIndex
    } = _ref2;
    if (typeof window === "undefined") return void 0;
    const language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    if (!Array.isArray(language)) return void 0;
    const index = typeof lookupFromPathIndex === "number" ? lookupFromPathIndex : 0;
    return language[index]?.replace("/", "");
  }
};
var subdomain = {
  name: "subdomain",
  lookup(_ref2) {
    let {
      lookupFromSubdomainIndex
    } = _ref2;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === "number" ? lookupFromSubdomainIndex + 1 : 1;
    const language = typeof window !== "undefined" && window.location?.hostname?.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (!language) return void 0;
    return language[internalLookupFromSubdomainIndex];
  }
};
let canCookies = false;
try {
  document.cookie;
  canCookies = true;
} catch (e2) {
}
const order = ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"];
if (!canCookies) order.splice(1, 1);
const getDefaults = () => ({
  order,
  lookupQuerystring: "lng",
  lookupCookie: "i18next",
  lookupLocalStorage: "i18nextLng",
  lookupSessionStorage: "i18nextLng",
  // cache user language
  caches: ["localStorage"],
  excludeCacheFor: ["cimode"],
  // cookieMinutes: 10,
  // cookieDomain: 'myDomain'
  convertDetectedLanguage: (l2) => l2
});
class Browser {
  constructor(services) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options2);
  }
  init() {
    let services = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      languageUtils: {}
    };
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services;
    this.options = defaults(options2, this.options || {}, getDefaults());
    if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
      this.options.convertDetectedLanguage = (l2) => l2.replace("-", "_");
    }
    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
    this.i18nOptions = i18nOptions;
    this.addDetector(cookie$1);
    this.addDetector(querystring);
    this.addDetector(localStorage$1);
    this.addDetector(sessionStorage);
    this.addDetector(navigator$1);
    this.addDetector(htmlTag);
    this.addDetector(path);
    this.addDetector(subdomain);
  }
  addDetector(detector) {
    this.detectors[detector.name] = detector;
    return this;
  }
  detect() {
    let detectionOrder = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.order;
    let detected = [];
    detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        if (lookup && typeof lookup === "string") lookup = [lookup];
        if (lookup) detected = detected.concat(lookup);
      }
    });
    detected = detected.filter((d2) => d2 !== void 0 && d2 !== null && !hasXSS(d2)).map((d2) => this.options.convertDetectedLanguage(d2));
    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected;
    return detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng) {
    let caches = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.caches;
    if (!caches) return;
    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
    caches.forEach((cacheName) => {
      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    });
  }
}
Browser.type = "languageDetector";
const common$1 = {
  save: "Save",
  cancel: "Cancel",
  settings: "Settings",
  close: "Close",
  accept: "Accept"
};
const settings$1 = {
  tabs: {
    general: "General",
    live2d: "Live2D",
    asr: "ASR",
    tts: "TTS",
    agent: "Agent",
    about: "About"
  },
  general: {
    language: "Language",
    useCameraBackground: "Use Camera Background",
    showSubtitle: "Show Subtitle",
    backgroundImage: "Background Image",
    customBgUrlPlaceholder: "Enter image URL",
    customBgUrl: "Or enter a custom background URL",
    characterPreset: "Character Preset",
    wsUrl: "WebSocket URL",
    baseUrl: "Base URL",
    imageCompressionQuality: "Image Compression Quality",
    imageCompressionQualityPlaceholder: "Enter compression quality (0-100)",
    imageCompressionQualityHelp: "JPEG compression quality (0.1-1.0). Default is 0.8 to reduce file size when transmitting images to AI models, as we don't compress images during API transmission which could result in large file sizes.",
    imageMaxWidth: "Image Max Width",
    imageMaxWidthPlaceholder: "Enter maximum width in pixels",
    imageMaxWidthHelp: "Maximum width for image resizing. Images exceeding this width will be proportionally scaled down. Set to 0 for no size limit. This feature exists because some AI models may have limitations when processing very large images. However, most AI models can handle images automatically, so the default is 0 (no restriction) to preserve your original images."
  },
  live2d: {
    pointerInteractive: "Pointer Interactive",
    scrollToResize: "Enable Scroll to Resize"
  },
  asr: {
    autoStopMic: "Auto Stop Mic When AI Start Speaking",
    autoStopMicDesc: "Automatically stops microphone when AI begins speaking to prevent audio feedback",
    autoStartMicOnConvEnd: "Auto Start Mic When Conversation End",
    autoStartMicOnConvEndDesc: "Automatically restarts microphone when AI finishes speaking for seamless conversation",
    autoStartMicOn: "Auto Start Mic When AI Interrupted",
    autoStartMicOnDesc: "Automatically restarts microphone when you interrupt AI for continuous interaction",
    positiveSpeechThreshold: "Speech Prob Threshold",
    positiveSpeechThresholdDesc: "Minimum confidence level (1-100) required to detect speech. Higher values reduce false positives",
    negativeSpeechThreshold: "Negative Speech Threshold",
    negativeSpeechThresholdDesc: "Confidence level (0-100) below which speech detection stops. Lower values make detection less sensitive",
    redemptionFrames: "Redemption Frames",
    redemptionFramesDesc: "Number of consecutive frames (1-100) needed to confirm speech detection. Higher values reduce noise triggers"
  },
  agent: {
    allowProactiveSpeak: "Allow AI to Speak Proactively",
    idleSecondsToSpeak: "Idle seconds allow AI to speak",
    allowButtonTrigger: "Prompt AI to Speak via Raise Hand Button"
  },
  about: {
    title: "Open LLM VTuber Frontend",
    version: "Version",
    projectLinks: "Project Links",
    github: "GitHub",
    documentation: "Documentation",
    license: "License",
    copyright: "Copyright",
    viewLicense: "View License"
  }
};
const footer$1 = {
  typeYourMessage: "Type your message...",
  cameraControl: "Click to start camera",
  cameraStopping: "Click to stop camera",
  screenControl: "Click to start screen capture",
  screenStopping: "Click to stop screen capture",
  finishAnswer: "Finish Response"
};
const sidebar$1 = {
  camera: "Camera",
  screen: "Screen",
  browser: "Browser",
  live: "Live",
  noMessages: "No messages yet. Start a conversation!",
  noBrowserSession: "No active browser session",
  browserSession: "Browser Session"
};
const group$1 = {
  management: "Group Management",
  yourUuid: "Your UUID",
  inviteMember: "Invite Member",
  enterMemberUuid: "Enter member UUID",
  invite: "Invite",
  members: "Members",
  you: "You",
  leaveGroup: "Leave Group",
  removeMember: "Remove Member",
  leave: "Leave"
};
const history$1 = {
  chatHistoryList: "Chat History List",
  noMessages: "No messages"
};
const notification$1 = {
  characterLoaded: "New Character Loaded",
  characterSwitched: "Character switched",
  historyLoaded: "History loaded",
  newConversation: "New Conversation Started",
  newChatHistory: "New chat history created",
  historyDeleteSuccess: "History deleted successfully",
  historyDeleteFail: "Failed to delete history"
};
const error$1 = {
  cameraApiNotSupported: "Camera API is not supported on this device",
  noCameraFound: "No camera found on this device",
  failedStartCamera: "Failed to start camera",
  failedStartBackgroundCamera: "Failed to start background camera",
  failedStartScreenCapture: "Failed to start screen capture",
  failedStartVAD: "Failed to start VAD",
  llmCantHear: "The LLM can't hear you.",
  audioPlayback: "Audio playback error",
  enterValidUuid: "Please enter a valid UUID",
  cannotDeleteCurrentHistory: "Cannot delete current chat history",
  failedCapture: "Failed to capture {{source}} frame",
  failedParseWebSocket: "Failed to parse WebSocket message",
  websocketNotOpen: "WebSocket is not open.",
  vadMisfire: "Voice detected but too brief. Try speaking louder/longer, or adjust settings (lower speech threshold, lower negative threshold, reduce redemption frames)."
};
const aiState$1 = {
  idle: "idle",
  "thinking-speaking": "thinking/speaking",
  interrupted: "interrupted",
  loading: "loading",
  listening: "listening",
  waiting: "waiting"
};
const wsStatus$1 = {
  connected: "Connected",
  connecting: "Connecting",
  clickToReconnect: "Click to Reconnect"
};
const enTranslation = {
  common: common$1,
  settings: settings$1,
  footer: footer$1,
  sidebar: sidebar$1,
  group: group$1,
  history: history$1,
  notification: notification$1,
  error: error$1,
  aiState: aiState$1,
  wsStatus: wsStatus$1
};
const common = {
  save: "",
  cancel: "",
  settings: "",
  close: "",
  accept: ""
};
const settings = {
  tabs: {
    general: "",
    live2d: "Live2D",
    asr: "",
    tts: "",
    agent: "",
    about: ""
  },
  general: {
    language: "",
    useCameraBackground: "",
    showSubtitle: "",
    backgroundImage: "",
    customBgUrlPlaceholder: "URL",
    customBgUrl: "URL",
    characterPreset: "",
    wsUrl: "WebSocket",
    baseUrl: "URL",
    imageCompressionQuality: "",
    imageCompressionQualityHelp: "JPEG(0.1-1.0)0.8AI",
    imageMaxWidth: "",
    imageMaxWidthHelp: "0AIAI0"
  },
  live2d: {
    pointerInteractive: "",
    scrollToResize: ""
  },
  asr: {
    autoStopMic: "AI",
    autoStopMicDesc: "AI",
    autoStartMicOnConvEnd: "",
    autoStartMicOnConvEndDesc: "AI",
    autoStartMicOn: "AI",
    autoStartMicOnDesc: "AI",
    positiveSpeechThreshold: "",
    positiveSpeechThresholdDesc: "(1-100)",
    negativeSpeechThreshold: "",
    negativeSpeechThresholdDesc: "(0-100)",
    redemptionFrames: "",
    redemptionFramesDesc: "(1-100)"
  },
  agent: {
    allowProactiveSpeak: "AI",
    idleSecondsToSpeak: "AI",
    allowButtonTrigger: "AI"
  },
  about: {
    title: "Open LLM VTuber ",
    version: "",
    projectLinks: "",
    github: "GitHub",
    documentation: "",
    copyright: "",
    viewLicense: ""
  }
};
const footer = {
  typeYourMessage: "...",
  cameraControl: "",
  cameraStopping: "",
  screenControl: "",
  screenStopping: "",
  finishAnswer: ""
};
const sidebar = {
  camera: "",
  screen: "",
  browser: "",
  live: "",
  noMessages: "",
  noBrowserSession: "",
  browserSession: ""
};
const group = {
  management: "",
  yourUuid: "UUID",
  inviteMember: "",
  enterMemberUuid: "UUID",
  invite: "",
  members: "",
  you: "",
  leaveGroup: "",
  removeMember: "",
  leave: ""
};
const history = {
  chatHistoryList: "",
  noMessages: ""
};
const notification = {
  characterLoaded: "",
  characterSwitched: "",
  historyLoaded: "",
  newConversation: "",
  newChatHistory: "",
  historyDeleteSuccess: "",
  historyDeleteFail: ""
};
const error = {
  cameraApiNotSupported: "API",
  noCameraFound: "",
  failedStartCamera: "",
  failedStartBackgroundCamera: "",
  failedStartScreenCapture: "",
  failedStartVAD: "",
  llmCantHear: "AI",
  audioPlayback: "",
  enterValidUuid: "UUID",
  cannotDeleteCurrentHistory: "",
  failedCapture: "{{source}}",
  failedParseWebSocket: "WebSocket",
  websocketNotOpen: "WebSocket",
  vadMisfire: ""
};
const aiState = {
  idle: "",
  "thinking-speaking": "/",
  interrupted: "",
  loading: "",
  listening: "",
  waiting: ""
};
const wsStatus = {
  connected: "",
  connecting: "",
  clickToReconnect: ""
};
const zhTranslation = {
  common,
  settings,
  footer,
  sidebar,
  group,
  history,
  notification,
  error,
  aiState,
  wsStatus
};
instance.use(Browser).use(initReactI18next).init({
  // Default language when detection fails
  fallbackLng: "en",
  // Debug mode for development
  debug: false,
  // Namespaces configuration
  defaultNS: "translation",
  ns: ["translation"],
  // Resources containing translations
  resources: {
    en: {
      translation: enTranslation
    },
    zh: {
      translation: zhTranslation
    }
  },
  // Language detection options
  detection: {
    // Order and from where user language should be detected
    order: ["localStorage", "navigator"],
    // Cache user language detection
    caches: ["localStorage"],
    // HTML attribute with which to set language
    htmlTag: document.documentElement
  },
  // Escaping special characters
  interpolation: {
    escapeValue: false
    // React already safes from XSS
  },
  // React config
  react: {
    useSuspense: true
  }
});
instance.on("languageChanged", (lng) => {
  localStorage.setItem("i18nextLng", lng);
  document.documentElement.lang = lng;
});
const originalConsoleWarn = console.warn;
console.warn = (...args) => {
  if (typeof args[0] === "string" && args[0].includes("onnxruntime")) {
    return;
  }
  originalConsoleWarn.apply(console, args);
};
const originalConsoleError = console.error;
const errorMessagesToIgnore = ["Warning: Failed"];
console.error = (...args) => {
  if (typeof args[0] === "string") {
    const shouldIgnore = errorMessagesToIgnore.some((msg) => args[0].startsWith(msg));
    if (shouldIgnore) {
      return;
    }
  }
  originalConsoleError.apply(console, args);
};
if (typeof window !== "undefined") {
  window.getLAppAdapter = () => LAppAdapter.getInstance();
  const loadLive2DCore = () => {
    return new Promise((resolve2, reject2) => {
      const script = document.createElement("script");
      script.src = withBasePath("/libs/live2dcubismcore.js") || "/libs/live2dcubismcore.js";
      script.onload = () => {
        console.log("Live2D Cubism Core loaded successfully.");
        resolve2();
      };
      script.onerror = (error2) => {
        console.error("Failed to load Live2D Cubism Core:", error2);
        reject2(error2);
      };
      document.head.appendChild(script);
    });
  };
  loadLive2DCore().then(() => {
    createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
    );
  }).catch((error2) => {
    console.error("Application failed to start due to script loading error:", error2);
    const rootElement = document.getElementById("root");
    if (rootElement) {
      rootElement.innerHTML = "Error loading required components. Please check the console for details.";
    }
  });
}
